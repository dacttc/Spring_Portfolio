<!doctype html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title th:text="${mapUsername} + '\'s City'">City</title>
    <script src="/js/i18n.js"></script>

    <style>
        /* 반응형 UI 스케일 변수 */
        :root {
            --ui-scale: 1;
            --font-xs: calc(9px * var(--ui-scale));
            --font-sm: calc(11px * var(--ui-scale));
            --font-md: calc(13px * var(--ui-scale));
            --font-lg: calc(16px * var(--ui-scale));
            --font-xl: calc(20px * var(--ui-scale));
            --font-2xl: calc(24px * var(--ui-scale));
            --font-3xl: calc(32px * var(--ui-scale));
            --spacing-xs: calc(4px * var(--ui-scale));
            --spacing-sm: calc(8px * var(--ui-scale));
            --spacing-md: calc(12px * var(--ui-scale));
            --spacing-lg: calc(16px * var(--ui-scale));
            --spacing-xl: calc(24px * var(--ui-scale));
            --btn-size-sm: calc(32px * var(--ui-scale));
            --btn-size-md: calc(40px * var(--ui-scale));
            --btn-size-lg: calc(50px * var(--ui-scale));
            --icon-size-sm: calc(18px * var(--ui-scale));
            --icon-size-md: calc(24px * var(--ui-scale));
            --icon-size-lg: calc(32px * var(--ui-scale));
            --bar-height: calc(40px * var(--ui-scale));
            --toolbar-height: calc(60px * var(--ui-scale));
            --panel-width: calc(300px * var(--ui-scale));
            --border-radius: calc(6px * var(--ui-scale));
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: #f5f5f5;
            font-size: var(--font-md);
            /* 텍스트 선택 및 드래그 금지 */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ===== TOP BAR (Cities Skylines Style - White Theme) ===== */
        #topBar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--bar-height);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.96) 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-md);
            z-index: 1000;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .top-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .menu-btn {
            width: var(--btn-size-sm);
            height: var(--btn-size-sm);
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: var(--border-radius);
            color: #333;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .menu-btn:hover {
            background: linear-gradient(180deg, #f5f5f5, #e8e8e8);
            border-color: rgba(0, 0, 0, 0.2);
        }

        .top-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: var(--spacing-lg);
        }

        .city-name-display {
            background: linear-gradient(180deg, #ffffff, #f5f5f5);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius);
            padding: var(--spacing-xs) var(--spacing-xl);
            color: #333;
            font-size: var(--font-md);
            font-weight: 600;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        }

        .top-right {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .top-btn {
            padding: var(--spacing-xs) var(--spacing-md);
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius);
            color: #555;
            font-size: var(--font-sm);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        }

        .top-btn:hover {
            background: linear-gradient(180deg, #f0f0f0, #e5e5e5);
            color: #333;
            border-color: rgba(0, 0, 0, 0.15);
        }

        .top-btn.login-btn {
            background: linear-gradient(180deg, #4a90d9, #357abd);
            color: white;
            border-color: rgba(0, 0, 0, 0.15);
        }

        .top-btn.login-btn:hover {
            background: linear-gradient(180deg, #357abd, #2868a6);
            color: white;
        }

        /* ===== BGM CONTROLS ===== */
        .bgm-btn {
            width: var(--btn-size-sm);
            height: var(--btn-size-sm);
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: var(--border-radius);
            color: #555;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        }

        .bgm-btn:hover {
            background: linear-gradient(180deg, #f0f0f0, #e0e0e0);
            border-color: rgba(0, 0, 0, 0.2);
        }

        .bgm-btn.playing {
            background: linear-gradient(180deg, #e8f5e9, #c8e6c9);
            border-color: #4caf50;
            color: #2e7d32;
        }

        .bgm-volume-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .bgm-volume-slider {
            width: 0;
            opacity: 0;
            transition: width 0.3s, opacity 0.3s;
            -webkit-appearance: none;
            appearance: none;
            height: calc(4px * var(--ui-scale));
            background: linear-gradient(to right, #4caf50 0%, #ddd 0%);
            border-radius: calc(2px * var(--ui-scale));
            cursor: pointer;
        }

        .bgm-volume-container:hover .bgm-volume-slider,
        .bgm-volume-slider:focus {
            width: calc(80px * var(--ui-scale));
            opacity: 1;
        }

        .bgm-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: calc(12px * var(--ui-scale));
            height: calc(12px * var(--ui-scale));
            background: #4caf50;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .bgm-volume-slider::-moz-range-thumb {
            width: calc(12px * var(--ui-scale));
            height: calc(12px * var(--ui-scale));
            background: #4caf50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        /* ===== BOTTOM BAR (Main Toolbar - White Theme) ===== */
        #bottomBar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: calc(90px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.99) 100%);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.06);
        }

        /* Left section - Game info */
        .bottom-left {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-sm) var(--spacing-lg);
            min-width: calc(200px * var(--ui-scale));
        }

        .game-speed {
            display: flex;
            gap: var(--spacing-xs);
        }

        .speed-btn {
            width: var(--btn-size-sm);
            height: var(--btn-size-sm);
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: calc(5px * var(--ui-scale));
            color: #666;
            font-size: var(--font-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .speed-btn:hover:not(.active) {
            background: linear-gradient(180deg, #f0f0f0, #e0e0e0);
            color: #333;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .speed-btn.active {
            background: linear-gradient(180deg, #4a90c2, #3a7aaa);
            color: #fff;
            border-color: #3a7aaa;
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .date-display {
            background: linear-gradient(180deg, #e8f4ff, #d8ecff);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: calc(5px * var(--ui-scale));
            padding: var(--spacing-xs) var(--spacing-sm);
            color: #2563eb;
            font-size: var(--font-md);
            font-family: 'Consolas', monospace;
        }

        .clock-display {
            background: linear-gradient(180deg, #fef3e2, #fde8c8);
            border: 1px solid rgba(245, 158, 11, 0.25);
            border-radius: calc(5px * var(--ui-scale));
            padding: var(--spacing-xs) var(--spacing-sm);
            color: #d97706;
            font-size: var(--font-md);
            font-family: 'Consolas', monospace;
        }

        /* RCI Demand Bar - 세로 방향 */
        .rci-demand-bar {
            display: flex;
            flex-direction: row;
            gap: var(--spacing-xs);
            background: linear-gradient(180deg, #ffffff, #f8f9fa);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius);
            padding: var(--spacing-sm) var(--spacing-md);
            margin-left: var(--spacing-md);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .rci-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .rci-label {
            font-size: var(--font-xs);
            font-weight: bold;
            text-align: center;
        }

        .rci-item.residential .rci-label { color: #4ade80; }
        .rci-item.commercial .rci-label { color: #60a5fa; }
        .rci-item.industrial .rci-label { color: #fbbf24; }

        /* City Happiness Display */
        .city-happiness {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            background: linear-gradient(180deg, #ffffff, #f8f9fa);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius);
            padding: var(--spacing-sm) var(--spacing-md);
            margin-left: var(--spacing-md);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .happiness-icon {
            font-size: var(--font-xl);
            line-height: 1;
        }

        .happiness-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
        }

        .happiness-label {
            font-size: var(--font-xs);
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .happiness-value {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .happiness-number {
            font-size: var(--font-lg);
            font-weight: bold;
            color: #333;
            min-width: calc(32px * var(--ui-scale));
            font-family: 'Consolas', monospace;
        }

        /* 행복도 색상은 JavaScript에서 동적으로 설정 */

        .happiness-trend {
            font-size: var(--font-sm);
            opacity: 0.8;
        }

        .happiness-trend.up { color: #4ade80; }
        .happiness-trend.down { color: #f87171; }
        .happiness-trend.stable { color: #888; }

        .rci-bar-container {
            width: 14px;
            height: 50px;
            background: #e8e8e8;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .rci-bar-center {
            position: absolute;
            left: 0;
            top: 50%;
            width: 100%;
            height: 1px;
            background: rgba(0, 0, 0, 0.2);
            z-index: 2;
        }

        .rci-bar-positive {
            position: absolute;
            left: 2px;
            bottom: 50%;
            width: calc(100% - 4px);
            background: linear-gradient(0deg, #22c55e, #4ade80);
            border-radius: 2px;
            transition: height 0.3s ease;
            z-index: 1;
        }

        .rci-bar-negative {
            position: absolute;
            left: 2px;
            top: 50%;
            width: calc(100% - 4px);
            background: linear-gradient(180deg, #ef4444, #f87171);
            border-radius: 2px;
            transition: height 0.3s ease;
            z-index: 1;
        }

        .rci-item.commercial .rci-bar-positive {
            background: linear-gradient(0deg, #3b82f6, #60a5fa);
        }

        .rci-item.industrial .rci-bar-positive {
            background: linear-gradient(0deg, #f59e0b, #fbbf24);
        }

        /* Center section - Main tools */
        .bottom-center {
            flex: 1;
            display: flex;
            justify-content: center;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
            padding: calc(5px * var(--ui-scale)) 0;
        }

        .tool-btn {
            width: calc(62px * var(--ui-scale));
            height: calc(62px * var(--ui-scale));
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: calc(12px * var(--ui-scale));
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        .tool-btn:hover:not(.active) {
            background: linear-gradient(180deg, #f5f5f5, #e8e8e8);
            border-color: rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .tool-btn.active {
            background: linear-gradient(180deg, #3b82f6, #2563eb);
            border-color: #1d4ed8;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .tool-btn.active:hover {
            background: linear-gradient(180deg, #4a93f7, #3b7de8);
            transform: translateY(-2px);
        }

        .tool-btn .icon {
            font-size: calc(30px * var(--ui-scale));
        }

        .tool-btn.dirty {
            background: linear-gradient(180deg, #fef3c7, #fde68a);
            border-color: #f59e0b;
        }

        .save-btn.dirty {
            animation: pulse-save 1.5s infinite;
        }

        @keyframes pulse-save {
            0%, 100% { box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3); }
            50% { box-shadow: 0 4px 16px rgba(245, 158, 11, 0.6); }
        }

        .tool-divider {
            width: 2px;
            height: calc(50px * var(--ui-scale));
            background: rgba(0, 0, 0, 0.1);
            margin: 0 var(--spacing-md);
            border-radius: 1px;
        }

        /* Circular demolish button */
        .demolish-btn {
            width: calc(70px * var(--ui-scale));
            height: calc(70px * var(--ui-scale));
            background: linear-gradient(180deg, #dc2626, #991b1b);
            border: 3px solid rgba(255, 100, 100, 0.4);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: var(--spacing-lg);
            flex-shrink: 0;
        }

        .demolish-btn:hover {
            background: linear-gradient(180deg, #ef4444, #b91c1c);
            border-color: rgba(255, 150, 150, 0.6);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.5);
        }

        .demolish-btn.active {
            background: linear-gradient(180deg, #f87171, #dc2626);
            border-color: #fca5a5;
            box-shadow: 0 0 25px rgba(255, 100, 100, 0.7);
        }

        .demolish-btn .icon {
            font-size: var(--icon-size-lg);
        }

        .stats-row {
            display: flex;
            gap: var(--spacing-sm);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-lg);
            background: linear-gradient(180deg, #ffffff, #f8f9fa);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--spacing-sm);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .stat-item .icon {
            font-size: var(--font-2xl);
        }

        .stat-item .value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-family: 'Consolas', monospace;
        }

        .stat-item.money .value { color: #4f8; }
        .stat-item.population .value { color: #8af; }
        .stat-item.happiness .value { color: #fa4; }

        .stat-item .change {
            font-size: var(--font-md);
            margin-left: var(--spacing-xs);
        }

        .stat-item .change.positive { color: #4f8; }
        .stat-item .change.negative { color: #f44; }

        /* Central Money Display (White Theme) */
        .money-display-center {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            background: linear-gradient(180deg, #ecfdf5, #d1fae5);
            border: 2px solid rgba(34, 197, 94, 0.4);
            border-radius: 25px;
            margin-left: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.15s;
        }

        .money-display-center:hover {
            background: linear-gradient(180deg, #d1fae5, #a7f3d0);
            border-color: rgba(34, 197, 94, 0.6);
            transform: scale(1.02);
        }

        .money-display-center .money-icon {
            font-size: 28px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .money-display-center .money-amount {
            font-size: 26px;
            font-weight: 700;
            color: #166534;
            font-family: 'Consolas', 'Segoe UI', monospace;
            letter-spacing: 1px;
        }

        .money-display-center .money-rate {
            font-size: 13px;
            font-weight: 600;
            color: #15803d;
            padding: 3px 8px;
            background: rgba(34, 197, 94, 0.15);
            border-radius: 10px;
            font-family: 'Consolas', monospace;
        }

        .money-display-center .money-rate.negative {
            color: #dc2626;
            background: rgba(239, 68, 68, 0.15);
        }

        /* Population Display (White Theme) */
        .population-display-center {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            background: linear-gradient(180deg, #eff6ff, #dbeafe);
            border: 2px solid rgba(59, 130, 246, 0.4);
            border-radius: 25px;
            margin-left: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.15s;
        }

        .population-display-center:hover {
            background: linear-gradient(180deg, #dbeafe, #bfdbfe);
            border-color: rgba(59, 130, 246, 0.6);
            transform: scale(1.02);
        }

        .population-display-center .pop-icon {
            font-size: 28px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .population-display-center .pop-amount {
            font-size: 26px;
            font-weight: 700;
            color: #1e40af;
            font-family: 'Consolas', 'Segoe UI', monospace;
            letter-spacing: 1px;
        }

        .population-display-center .pop-label {
            font-size: 13px;
            font-weight: 600;
            color: #2563eb;
            padding: 3px 8px;
            background: rgba(59, 130, 246, 0.15);
            border-radius: 10px;
            font-family: 'Consolas', monospace;
        }

        /* Population Panel (White Theme) */
        #populationPanel {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            background: linear-gradient(180deg, #ffffff, #f8fafc);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 16px;
            padding: 0;
            min-width: 380px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 1001;
        }

        #populationPanel.open {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) scale(1);
        }

        .pop-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(180deg, #eff6ff, #dbeafe);
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 14px 14px 0 0;
        }

        .pop-panel-header .panel-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .pop-panel-header .panel-title {
            font-size: 18px;
            font-weight: 700;
            color: #1e40af;
            flex: 1;
        }

        .pop-panel-header .panel-close {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 24px;
            cursor: pointer;
            padding: 0 8px;
            transition: color 0.2s;
        }

        .pop-panel-header .panel-close:hover {
            color: #1f2937;
        }

        .pop-panel-content {
            padding: 16px;
        }

        .pop-stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .pop-stat-card {
            background: rgba(59, 130, 246, 0.08);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            border: 1px solid rgba(59, 130, 246, 0.1);
        }

        .pop-stat-card.full-width {
            grid-column: 1 / -1;
        }

        .pop-stat-card .stat-icon {
            font-size: 32px;
            margin-bottom: 6px;
        }

        .pop-stat-card .stat-label {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .pop-stat-card .stat-value {
            font-size: 22px;
            font-weight: 700;
            color: #1e40af;
            font-family: 'Consolas', monospace;
        }

        .pop-stat-card .stat-percent {
            font-size: 12px;
            color: #3b82f6;
            margin-top: 4px;
        }

        .pop-tier-section {
            margin-top: 16px;
        }

        .pop-tier-section .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 10px;
        }

        .pop-tier-bar {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .pop-tier-bar .tier-icon {
            font-size: 20px;
            width: 36px;
        }

        .pop-tier-bar .tier-label {
            font-size: 13px;
            color: #4b5563;
            width: 70px;
        }

        .pop-tier-bar .tier-bar-bg {
            flex: 1;
            height: 20px;
            background: rgba(0, 0, 0, 0.08);
            border-radius: 10px;
            overflow: hidden;
            margin: 0 10px;
        }

        .pop-tier-bar .tier-bar-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .pop-tier-bar .tier-bar-fill.middle {
            background: linear-gradient(90deg, #4a9eff, #66b3ff);
        }

        .pop-tier-bar .tier-bar-fill.high {
            background: linear-gradient(90deg, #ffc107, #ffca28);
        }

        .pop-tier-bar .tier-value {
            font-size: 14px;
            font-weight: 600;
            color: #1f2937;
            width: 70px;
            text-align: right;
            font-family: 'Consolas', monospace;
        }

        /* 연령별 인구 섹션 - 원형 그래프 */
        .pop-age-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
        }

        .pop-age-section .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 10px;
        }

        .age-pie-container {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .age-pie-chart {
            width: 100px;
            height: 100px;
            position: relative;
            flex-shrink: 0;
        }

        .age-pie-chart svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .age-pie-chart .pie-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .age-pie-chart .pie-center-value {
            font-size: 14px;
            font-weight: 700;
            color: #1f2937;
        }

        .age-pie-chart .pie-center-label {
            font-size: 9px;
            color: #6b7280;
        }

        .age-legend {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
        }

        .age-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .age-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .age-legend-color.children { background: #f472b6; }
        .age-legend-color.youth { background: #60a5fa; }
        .age-legend-color.adults { background: #34d399; }
        .age-legend-color.elderly { background: #a78bfa; }

        .age-legend-label {
            font-size: 11px;
            color: #4b5563;
            width: 36px;
        }

        .age-legend-value {
            font-size: 11px;
            font-weight: 600;
            color: #1f2937;
            font-family: 'Consolas', monospace;
        }

        .age-legend-percent {
            font-size: 10px;
            color: #9ca3af;
            margin-left: auto;
        }

        .age-stats-row {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px dashed rgba(0, 0, 0, 0.1);
        }

        .age-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .age-stat .stat-label {
            font-size: 11px;
            color: #6b7280;
        }

        .age-stat .stat-value {
            font-size: 13px;
            font-weight: 600;
            color: #1f2937;
            font-family: 'Consolas', monospace;
        }

        /* 서비스 커버리지 섹션 */
        .pop-service-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
        }

        .pop-service-section .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 10px;
        }

        .service-coverage-bar {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .service-coverage-bar .service-icon {
            font-size: 16px;
            width: 28px;
        }

        .service-coverage-bar .service-label {
            font-size: 12px;
            color: #4b5563;
            width: 40px;
        }

        .service-coverage-bar .service-bar-bg {
            flex: 1;
            height: 14px;
            background: rgba(0, 0, 0, 0.08);
            border-radius: 7px;
            overflow: hidden;
            margin: 0 8px;
        }

        .service-coverage-bar .service-bar-fill {
            height: 100%;
            border-radius: 7px;
            transition: width 0.3s ease, background 0.3s ease;
            background: linear-gradient(90deg, #f87171, #fbbf24);
        }

        .service-coverage-bar .service-bar-fill.good {
            background: linear-gradient(90deg, #4ade80, #22c55e);
        }

        .service-coverage-bar .service-bar-fill.medium {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
        }

        .service-coverage-bar .service-bar-fill.poor {
            background: linear-gradient(90deg, #f87171, #ef4444);
        }

        .service-coverage-bar .service-value {
            font-size: 12px;
            font-weight: 600;
            color: #1f2937;
            width: 45px;
            text-align: right;
            font-family: 'Consolas', monospace;
        }

        /* ===== SUB MENU (White Theme) ===== */
        #subMenu {
            position: fixed;
            bottom: 146px;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.99) 0%, rgba(248, 250, 252, 0.99) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-bottom: none;
            border-radius: 16px 16px 0 0;
            padding: 20px 25px;
            z-index: 999;
            opacity: 0;
            transition: all 0.25s ease;
            pointer-events: none;
            min-width: 400px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
        }

        #subMenu.open {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .submenu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: calc(10px * var(--ui-scale));
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .submenu-title {
            color: #1f2937;
            font-size: var(--font-md);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .submenu-close {
            width: var(--icon-size-md);
            height: var(--icon-size-md);
            background: rgba(0, 0, 0, 0.06);
            border: none;
            border-radius: var(--spacing-xs);
            color: #6b7280;
            cursor: pointer;
            font-size: var(--font-md);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .submenu-close:hover {
            background: rgba(239, 68, 68, 0.15);
            color: #dc2626;
        }

        .submenu-items {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .submenu-item {
            width: calc(100px * var(--ui-scale));
            height: calc(100px * var(--ui-scale));
            background: linear-gradient(180deg, #ffffff, #f5f5f5);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: calc(12px * var(--ui-scale));
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            transition: all 0.15s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .submenu-item:hover {
            background: linear-gradient(180deg, #f0f0f0, #e8e8e8);
            border-color: rgba(59, 130, 246, 0.5);
            transform: scale(1.05);
        }

        .submenu-item.active {
            background: linear-gradient(180deg, #3b82f6, #2563eb);
            border-color: #1d4ed8;
        }

        .submenu-item .color-box {
            width: calc(40px * var(--ui-scale));
            height: calc(40px * var(--ui-scale));
            border-radius: var(--spacing-sm);
            border: 2px solid rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-2xl);
        }

        .submenu-item .name {
            font-size: var(--font-sm);
            color: #4b5563;
            text-align: center;
            font-weight: 600;
        }

        .submenu-item.active .name {
            color: #fff;
        }

        .submenu-item .cost {
            font-size: var(--font-xs);
            color: #059669;
        }

        /* Zone colors */
        .zone-residential { background: #4ade80 !important; }
        .zone-commercial { background: #60a5fa !important; }
        .zone-industrial { background: #fbbf24 !important; }
        .zone-delete { background: #ef4444 !important; }

        /* Disabled submenu item */
        .submenu-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .submenu-item.disabled:hover {
            transform: none;
            border-color: rgba(0, 0, 0, 0.1);
        }

        /* ===== SUBMENU TOOLTIP (White Theme) ===== */
        .submenu-tooltip {
            position: fixed;
            min-width: calc(220px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.99) 0%, rgba(248, 250, 252, 0.99) 100%);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: calc(10px * var(--ui-scale));
            padding: var(--spacing-md) calc(14px * var(--ui-scale));
            z-index: 10000;
            display: none;
            pointer-events: none;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
        }

        .submenu-tooltip .tooltip-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: calc(10px * var(--ui-scale));
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .submenu-tooltip .tooltip-icon {
            font-size: var(--font-xl);
        }

        .submenu-tooltip .tooltip-name {
            font-size: var(--font-md);
            font-weight: 600;
            color: #1f2937;
        }

        .submenu-tooltip .tooltip-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .submenu-tooltip .tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-sm);
        }

        .submenu-tooltip .tooltip-row .label {
            color: #6b7280;
        }

        .submenu-tooltip .tooltip-row .value {
            color: #1f2937;
            font-weight: 500;
        }

        .submenu-tooltip .tooltip-row.maintenance .value {
            color: #dc2626;
        }

        .submenu-tooltip .tooltip-desc {
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            font-size: var(--font-sm);
            color: #6b7280;
            line-height: 1.5;
        }

        /* ===== DAILY STATS PANEL (White Theme) ===== */
        .daily-stats-panel {
            position: fixed;
            bottom: calc(160px * var(--ui-scale));
            left: calc(20px * var(--ui-scale));
            min-width: calc(220px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.99) 100%);
            border-radius: calc(12px * var(--ui-scale));
            padding: var(--spacing-lg);
            z-index: 1001;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }

        .daily-stats-panel.fire-panel {
            border: 1px solid rgba(239, 68, 68, 0.4);
        }

        .daily-stats-panel.crime-panel {
            border: 1px solid rgba(59, 130, 246, 0.4);
        }

        .daily-stats-panel.medical-panel {
            border: 1px solid rgba(236, 72, 153, 0.4);
        }

        .daily-stats-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            padding-bottom: calc(10px * var(--ui-scale));
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .daily-stats-header .stat-number {
            font-size: var(--font-3xl);
            font-weight: 700;
            color: #1f2937;
            min-width: calc(50px * var(--ui-scale));
            text-align: center;
        }

        .daily-stats-header .stat-title {
            font-size: var(--font-md);
            color: #6b7280;
            line-height: 1.3;
        }

        .daily-stats-rows {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .daily-stats-row {
            display: flex;
            align-items: center;
            gap: calc(10px * var(--ui-scale));
            font-size: var(--font-md);
        }

        .daily-stats-row .row-number {
            font-size: var(--font-md);
            font-weight: 600;
            color: #fff;
            min-width: calc(30px * var(--ui-scale));
        }

        .daily-stats-row .row-label {
            color: #888;
        }

        .daily-stats-footer {
            margin-top: var(--spacing-md);
            padding-top: calc(10px * var(--ui-scale));
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            font-size: var(--font-sm);
            color: #666;
        }

        /* ===== RIGHT PANEL (Info Panel - Collapsible) ===== */
        #infoPanel {
            position: fixed;
            top: calc(50px * var(--ui-scale));
            right: calc(10px * var(--ui-scale));
            width: calc(280px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(25, 30, 38, 0.95) 0%, rgba(18, 22, 28, 0.98) 100%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: calc(10px * var(--ui-scale));
            z-index: 998;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        #infoPanel.collapsed {
            width: calc(180px * var(--ui-scale));
        }

        #infoPanel.collapsed .panel-content {
            display: none;
        }

        #infoPanel.collapsed .panel-header {
            border-bottom: none;
        }

        .panel-header {
            background: linear-gradient(180deg, #3a4550, #2a3540);
            padding: calc(10px * var(--ui-scale)) calc(15px * var(--ui-scale));
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }

        .panel-header:hover {
            background: linear-gradient(180deg, #4a5560, #3a4550);
        }

        .panel-title {
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        .panel-toggle {
            color: #888;
            font-size: var(--font-sm);
            transition: transform 0.3s ease;
        }

        #infoPanel.collapsed .panel-toggle {
            transform: rotate(-90deg);
        }

        .panel-close {
            width: calc(20px * var(--ui-scale));
            height: calc(20px * var(--ui-scale));
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: var(--font-lg);
        }

        .panel-close:hover {
            color: #fff;
        }

        .panel-content {
            padding: calc(15px * var(--ui-scale));
            max-height: calc(500px * var(--ui-scale));
            overflow-y: auto;
        }

        .panel-stat {
            display: flex;
            justify-content: space-between;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .panel-stat:last-child {
            border-bottom: none;
        }

        .panel-stat .label {
            color: #888;
            font-size: var(--font-sm);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .panel-stat .value {
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        .panel-stat .value.good { color: #4f8; }
        .panel-stat .value.warning { color: #fa4; }
        .panel-stat .value.danger { color: #f44; }

        .panel-section {
            margin-top: calc(15px * var(--ui-scale));
            padding-top: calc(15px * var(--ui-scale));
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-section-title {
            font-size: var(--font-sm);
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: calc(10px * var(--ui-scale));
        }

        /* Earnings box */
        .earnings-box {
            background: linear-gradient(135deg, rgba(0, 200, 100, 0.15), rgba(0, 150, 80, 0.1));
            border: 1px solid rgba(0, 200, 100, 0.3);
            border-radius: var(--spacing-sm);
            padding: var(--spacing-md);
            margin-top: calc(10px * var(--ui-scale));
        }

        .earnings-label {
            font-size: var(--font-xs);
            color: #4f8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .earnings-value {
            font-size: var(--font-xl);
            font-weight: 700;
            color: #4f8;
            margin: calc(5px * var(--ui-scale)) 0;
        }

        .collect-btn {
            width: 100%;
            padding: calc(10px * var(--ui-scale));
            background: linear-gradient(180deg, #3a8060, #2a6050);
            border: 1px solid rgba(100, 255, 150, 0.3);
            border-radius: var(--border-radius);
            color: #fff;
            font-weight: 600;
            font-size: var(--font-sm);
            cursor: pointer;
            transition: all 0.2s;
        }

        .collect-btn:hover {
            background: linear-gradient(180deg, #4a9070, #3a7060);
            transform: translateY(-1px);
        }

        /* ===== TOAST ===== */
        #toastRoot {
            position: fixed;
            top: 50%;
            right: calc(20px * var(--ui-scale));
            transform: translateY(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(180deg, rgba(40, 45, 55, 0.98), rgba(30, 35, 45, 0.99));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--spacing-sm);
            padding: var(--spacing-md) var(--spacing-xl);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transform: translateX(100px);
            opacity: 0;
            animation: toastIn 0.3s ease forwards;
        }

        @keyframes toastIn {
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.out {
            animation: toastOut 0.3s ease forwards;
        }

        @keyframes toastOut {
            to {
                transform: translateX(100px);
                opacity: 0;
            }
        }

        .toast .icon {
            width: var(--btn-size-sm);
            height: var(--btn-size-sm);
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-lg);
            font-weight: 700;
        }

        .toast .icon.success {
            background: rgba(100, 255, 150, 0.2);
            color: #4f8;
        }

        .toast .icon.error {
            background: rgba(255, 100, 100, 0.2);
            color: #f66;
        }

        .toast .body .title {
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        .toast .body .desc {
            color: #ffffff;
            font-size: var(--font-sm);
            margin-top: 2px;
        }

        /* ===== HINT ===== */
        #hintContainer {
            position: fixed;
            bottom: calc(156px * var(--ui-scale));
            left: 50%;
            transform: translateX(-50%);
            display: none;  /* 기본적으로 숨김 - 전력 건물 설치 모드에서만 표시 */
            align-items: center;
            gap: var(--spacing-sm);
            z-index: 10;
            transition: bottom 0.25s ease, opacity 0.25s ease;
        }

        #hintContainer.visible {
            display: flex;
        }

        #hint {
            padding: var(--spacing-sm) var(--spacing-xl);
            background: rgba(0, 0, 0, 0.8);
            border-radius: calc(25px * var(--ui-scale));
            color: rgba(255, 255, 255, 0.9);
            font-size: var(--font-lg);
        }

        #btnExitMode {
            display: none;
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 80, 80, 0.9);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        #btnExitMode:hover {
            background: rgba(255, 50, 50, 1);
            transform: scale(1.1);
        }

        #hintContainer.submenu-open {
            bottom: 276px;
            opacity: 0.6;
            pointer-events: none;
        }

        /* ===== COST TOOLTIP ===== */
        #costTooltip {
            position: fixed;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 6px;
            color: #4ade80;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
            display: none;
            white-space: nowrap;
        }
        #costTooltip.insufficient {
            color: #f87171;
        }

        /* 플로팅 금액 표시 (건설 시 차감 금액) */
        .floating-cost {
            position: fixed;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            color: #f87171;
            font-size: 18px;
            font-weight: bold;
            z-index: 1001;
            pointer-events: none;
            white-space: nowrap;
            animation: floatUp 1.2s ease-out forwards;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            50% {
                opacity: 1;
                transform: translateY(-30px) scale(1.1);
            }
            100% {
                opacity: 0;
                transform: translateY(-60px) scale(0.9);
            }
        }

        /* 서비스 효과 이모지 (물결 효과) */
        .service-emoji {
            position: fixed;
            font-size: 28px;
            z-index: 1002;
            pointer-events: none;
            animation: emojiFloat 1.5s ease-out forwards;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            will-change: transform, opacity;
        }

        @keyframes emojiFloat {
            0% {
                opacity: 0;
                transform: translateY(10px) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translateY(0) scale(1.2);
            }
            50% {
                opacity: 1;
                transform: translateY(-20px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0.8);
            }
        }

        /* 도로 끊김 경고 아이콘 */
        .road-disconnect-icon {
            position: fixed;
            font-size: 24px;
            z-index: 1001;
            pointer-events: none;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
            animation: disconnectPulse 2s ease-in-out infinite;
            transform: translate(-50%, -50%);
        }

        @keyframes disconnectPulse {
            0%, 100% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.15);
            }
        }

        /* 그래프 툴팁 (인구/땅값) */
        #graphTooltip {
            position: fixed;
            padding: 8px 14px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            z-index: 1001;
            pointer-events: none;
            display: none;
            white-space: nowrap;
        }
        #graphTooltip .value {
            color: #4ade80;
            font-size: 16px;
        }
        #graphTooltip.landvalue .value {
            color: #fbbf24;
        }

        /* ===== BUILDING INFO POPUP ===== */
        #buildingPopup {
            position: fixed;
            min-width: calc(280px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(45, 50, 58, 0.98) 0%, rgba(35, 40, 48, 0.99) 100%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: calc(12px * var(--ui-scale));
            z-index: 1002;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .popup-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) var(--spacing-lg);
            background: linear-gradient(180deg, rgba(60, 65, 75, 0.9) 0%, rgba(50, 55, 65, 0.9) 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .popup-header .icon {
            font-size: var(--font-2xl);
            margin-right: var(--spacing-sm);
        }

        .popup-header .title {
            flex: 1;
            color: #fff;
            font-size: var(--font-lg);
            font-weight: 600;
        }

        .popup-close {
            width: calc(28px * var(--ui-scale));
            height: calc(28px * var(--ui-scale));
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: #aaa;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .popup-close:hover {
            background: rgba(255, 100, 100, 0.3);
            color: #fff;
        }

        .popup-content {
            padding: var(--spacing-lg);
        }

        .popup-row {
            display: flex;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .popup-row:last-child {
            border-bottom: none;
        }

        .popup-row .label {
            color: #888;
            font-size: var(--font-md);
            min-width: calc(80px * var(--ui-scale));
        }

        .popup-row .value {
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        .popup-row .value.green { color: #4ade80; }
        .popup-row .value.yellow { color: #fbbf24; }
        .popup-row .value.blue { color: #60a5fa; }

        .popup-type {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-md);
            border-radius: calc(20px * var(--ui-scale));
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
        }

        .popup-type.residential {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .popup-type.commercial {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
        }

        .popup-type.industrial {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .popup-happiness {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .popup-happiness .emoji {
            font-size: 28px;
        }

        .popup-happiness .happiness-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .happiness-bar-container {
            width: 80px;
            height: 10px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .happiness-bar-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .happiness-value {
            font-size: 14px;
            font-weight: 700;
            min-width: 32px;
            text-align: center;
        }

        /* 시민 한마디 */
        .citizen-quote {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #60a5fa;
        }

        .citizen-quote .quote-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .citizen-quote .quote-text {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
            font-style: italic;
        }

        .citizen-quote.high {
            border-left-color: #4ade80;
        }

        .citizen-quote.mid {
            border-left-color: #fbbf24;
        }

        .citizen-quote.low {
            border-left-color: #f87171;
        }

        .citizen-quote.shortage {
            border-left-color: #f97316;
            background: rgba(249, 115, 22, 0.15);
        }

        .citizen-quote.positive {
            border-left-color: #22c55e;
            background: rgba(34, 197, 94, 0.15);
        }

        .citizen-quote.negative {
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
        }

        .citizen-quote.abandoned {
            border-left-color: #6b7280;
            background: rgba(107, 114, 128, 0.2);
        }

        .citizen-quote.abandoned .quote-text {
            color: #9ca3af;
        }

        /* ===== LEVEL PROGRESS BAR (Cities Skylines Style) ===== */
        .level-progress-container {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .level-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .level-progress-title {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #aaa;
            font-size: 12px;
        }

        .level-progress-title .icon {
            font-size: 14px;
        }

        .level-progress-value {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            font-family: 'Consolas', monospace;
        }

        .level-progress-bar {
            position: relative;
            height: 24px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            overflow: visible;
            display: flex;
        }

        /* 구역 분할 (레벨 1 | 레벨 2) */
        .level-progress-section {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .level-progress-section.level1 {
            flex: 1;
            background: linear-gradient(180deg, rgba(96, 165, 250, 0.4) 0%, rgba(59, 130, 246, 0.3) 100%);
            border-radius: 6px 0 0 6px;
            border-right: 2px solid rgba(255, 255, 255, 0.3);
        }

        .level-progress-section.level2 {
            flex: 1;
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.2) 0%, rgba(34, 197, 94, 0.15) 100%);
            border-radius: 0 6px 6px 0;
        }

        .level-progress-section.level2.active {
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.5) 0%, rgba(34, 197, 94, 0.4) 100%);
        }

        .level-progress-section .section-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .level-progress-section.level1 .section-label {
            color: rgba(96, 165, 250, 0.8);
        }

        .level-progress-section.level2.active .section-label {
            color: rgba(74, 222, 128, 0.9);
        }

        /* 현재 위치 마커 */
        .level-progress-marker {
            position: absolute;
            top: -8px;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
            transition: left 0.4s ease;
        }

        .level-progress-marker .marker-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(180deg, #60a5fa, #3b82f6);
            border: 2px solid #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
        }

        .level-progress-marker.eligible .marker-icon {
            background: linear-gradient(180deg, #4ade80, #22c55e);
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.5);
        }

        .level-progress-marker .marker-line {
            width: 2px;
            height: 32px;
            background: linear-gradient(180deg, #60a5fa, transparent);
        }

        .level-progress-marker.eligible .marker-line {
            background: linear-gradient(180deg, #4ade80, transparent);
        }

        /* 목표치 표시 */
        .level-threshold-marker {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
        }

        .level-threshold-marker .threshold-line {
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.6);
        }

        .level-threshold-marker .threshold-label {
            position: absolute;
            bottom: -18px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            white-space: nowrap;
        }

        /* 레벨 뱃지 */
        .level-badges {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
        }

        .level-badge {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: #888;
        }

        .level-badge .badge-icon {
            font-size: 12px;
        }

        .level-badge.current {
            color: #60a5fa;
            font-weight: 600;
        }

        .level-badge.next {
            color: #4ade80;
        }

        /* 폐건물 상태 */
        .level-progress-container.abandoned .level-progress-section {
            background: rgba(107, 114, 128, 0.2) !important;
        }

        .level-progress-container.abandoned .level-progress-marker .marker-icon {
            background: linear-gradient(180deg, #6b7280, #4b5563);
            box-shadow: 0 2px 8px rgba(107, 114, 128, 0.5);
        }

        .level-progress-container.abandoned .level-progress-marker .marker-line {
            background: linear-gradient(180deg, #6b7280, transparent);
        }

        /* ===== AGE DISTRIBUTION CHART ===== */
        .age-distribution-section {
            margin-top: calc(12px * var(--ui-scale));
            padding-top: calc(12px * var(--ui-scale));
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .age-distribution-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: calc(10px * var(--ui-scale));
            color: #aaa;
            font-size: var(--font-sm);
        }

        .age-distribution-header .icon {
            font-size: var(--font-lg);
        }

        .age-distribution-content {
            display: flex;
            align-items: center;
            gap: calc(12px * var(--ui-scale));
        }

        .age-chart-labels {
            display: flex;
            flex-direction: column;
            gap: calc(4px * var(--ui-scale));
            min-width: calc(70px * var(--ui-scale));
        }

        .age-label-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--spacing-sm);
        }

        .age-label-name {
            color: #aaa;
            font-size: var(--font-sm);
        }

        .age-label-count {
            min-width: calc(24px * var(--ui-scale));
            height: calc(20px * var(--ui-scale));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-sm);
            font-weight: 600;
            border-radius: calc(4px * var(--ui-scale));
        }

        .age-label-count.children { background: #fbbf24; color: #1a1a1a; }
        .age-label-count.teens { background: #f97316; color: #fff; }
        .age-label-count.young { background: #ef4444; color: #fff; }
        .age-label-count.adult { background: #22c55e; color: #fff; }
        .age-label-count.elderly { background: #9ca3af; color: #1a1a1a; }

        .age-chart-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #ageChartCanvas {
            max-width: calc(100px * var(--ui-scale));
            max-height: calc(100px * var(--ui-scale));
        }

        /* ===== ABANDONED BUILDING STYLES ===== */
        .popup-type.abandoned {
            background: rgba(42, 42, 42, 0.8) !important;
            color: #888 !important;
        }

        .popup-demolish-info {
            margin-top: 12px;
            padding: 14px;
            background: linear-gradient(180deg, rgba(42, 42, 42, 0.9) 0%, rgba(30, 30, 30, 0.95) 100%);
            border: 2px solid rgba(239, 68, 68, 0.6);
            border-radius: 8px;
            text-align: center;
        }

        .demolish-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .demolish-title {
            color: #f87171;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
        }

        .demolish-desc {
            color: #888;
            font-size: 11px;
            line-height: 1.4;
        }

        /* 건물 상태 아이콘 애니메이션 (통합) */
        @keyframes statusIconBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        /* 레거시 호환 */
        @keyframes abandonedIconBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        .building-status-icon {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .abandoned-icon-float {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* ===== CONSTRUCTION POPUP ===== */
        #constructionPopup {
            position: fixed;
            min-width: 260px;
            background: linear-gradient(180deg, rgba(45, 50, 58, 0.98) 0%, rgba(35, 40, 48, 0.99) 100%);
            border: 1px solid rgba(251, 191, 36, 0.4);
            border-radius: 12px;
            z-index: 1002;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(251, 191, 36, 0.2);
            overflow: hidden;
        }

        #constructionPopup .popup-header {
            background: linear-gradient(180deg, rgba(251, 191, 36, 0.3) 0%, rgba(245, 158, 11, 0.2) 100%);
        }

        .construction-progress-container {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 12px;
        }

        .construction-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
            border-radius: 5px;
            transition: width 0.5s ease;
        }

        .construction-time-info {
            margin-top: 12px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .construction-time-info .time-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }

        .construction-time-info .time-label {
            color: #888;
            font-size: 12px;
        }

        .construction-time-info .time-value {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
        }

        .construction-time-info .time-value.highlight {
            color: #fbbf24;
            font-size: 16px;
        }

        .construction-status {
            text-align: center;
            font-size: 13px;
            color: #aaa;
            margin-top: 4px;
        }

        /* ===== PUBLIC BUILDING POPUP ===== */
        #publicBuildingPopup {
            position: fixed;
            min-width: 280px;
            background: linear-gradient(180deg, rgba(45, 50, 58, 0.98) 0%, rgba(35, 40, 48, 0.99) 100%);
            border: 1px solid rgba(239, 68, 68, 0.4);
            border-radius: 12px;
            z-index: 1002;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(239, 68, 68, 0.2);
            overflow: hidden;
        }

        #publicBuildingPopup .popup-header {
            background: linear-gradient(180deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.2) 100%);
        }

        #publicBuildingPopup .popup-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            margin: 12px 0 8px 0;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .firetruck-status {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
        }

        .firetruck-bar-container {
            margin-bottom: 10px;
        }

        .firetruck-bar-bg {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            display: flex;
        }

        .firetruck-bar-dispatched {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f87171);
            transition: width 0.3s ease;
        }

        .firetruck-bar-available {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            transition: width 0.3s ease;
        }

        .firetruck-bar-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 11px;
        }

        .firetruck-bar-labels .dispatched-label {
            color: #f87171;
        }

        .firetruck-bar-labels .available-label {
            color: #4ade80;
        }

        .firetruck-total {
            text-align: center;
            font-size: 12px;
            color: #aaa;
            margin-top: 8px;
        }

        /* ===== WIND TURBINE EXPANSION STYLES ===== */
        .wind-expansion-status {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
        }

        .wind-expansion-visual {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .turbine-slot {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .turbine-slot.main {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: 2px solid #60a5fa;
            cursor: default;
        }

        .turbine-slot.filled {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border: 2px solid #4ade80;
            cursor: default;
        }

        .turbine-slot.empty {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.4);
        }

        .turbine-slot.empty:hover {
            background: rgba(251, 191, 36, 0.2);
            border-color: #fbbf24;
            color: #fbbf24;
        }

        .turbine-slot.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .expand-turbine-btn {
            width: 100%;
            padding: 10px 16px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .expand-turbine-btn:hover {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            transform: translateY(-1px);
        }

        .expand-turbine-btn:disabled {
            background: #4b5563;
            cursor: not-allowed;
            transform: none;
        }

        .expand-turbine-btn .btn-cost {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .expansion-info {
            text-align: center;
            font-size: 11px;
            color: #9ca3af;
            margin-top: 8px;
        }

        /* Solar panel expansion slots */
        .solar-expansion-visual {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .solar-slot {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .solar-slot.main {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: 2px solid #fbbf24;
            cursor: default;
        }

        .solar-slot.filled {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: 2px solid #fbbf24;
            cursor: default;
        }

        .solar-slot.empty {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.4);
        }

        .solar-slot.empty:hover {
            background: rgba(251, 191, 36, 0.2);
            border-color: #fbbf24;
            color: #fbbf24;
        }

        .solar-slot.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .expand-solar-btn {
            width: 100%;
            padding: 10px 16px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .expand-solar-btn:hover {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            transform: translateY(-1px);
        }

        .expand-solar-btn:disabled {
            background: #4b5563;
            cursor: not-allowed;
            transform: none;
        }

        .expand-solar-btn .btn-cost {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .firetruck-total span {
            color: #fff;
            font-weight: 600;
        }

        /* ===== CAMERA SETTINGS PANEL ===== */
        #cameraSettingsPanel {
            position: fixed;
            bottom: calc(80px * var(--ui-scale));
            left: 50%;
            transform: translateX(-50%);
            min-width: calc(320px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(45, 50, 58, 0.98) 0%, rgba(35, 40, 48, 0.99) 100%);
            border: 1px solid rgba(96, 165, 250, 0.4);
            border-radius: calc(12px * var(--ui-scale));
            z-index: 1003;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(96, 165, 250, 0.2);
            overflow: hidden;
        }

        #cameraSettingsPanel .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) var(--spacing-lg);
            background: linear-gradient(180deg, rgba(96, 165, 250, 0.3) 0%, rgba(59, 130, 246, 0.2) 100%);
            border-bottom: 1px solid rgba(96, 165, 250, 0.3);
        }

        #cameraSettingsPanel .panel-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        #cameraSettingsPanel .panel-title .icon {
            font-size: var(--font-lg);
        }

        #cameraSettingsPanel .panel-close {
            width: var(--icon-size-md);
            height: var(--icon-size-md);
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
            border-radius: var(--spacing-xs);
            cursor: pointer;
            font-size: var(--font-md);
            transition: all 0.2s;
        }

        #cameraSettingsPanel .panel-close:hover {
            background: rgba(239, 68, 68, 0.3);
            color: #f87171;
        }

        #cameraSettingsPanel .panel-content {
            padding: var(--spacing-lg);
        }

        .camera-setting-row {
            margin-bottom: var(--spacing-lg);
        }

        .camera-setting-row:last-child {
            margin-bottom: 0;
        }

        .camera-setting-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .camera-setting-label .name {
            color: #aaa;
            font-size: var(--font-sm);
        }

        .camera-setting-label .value {
            color: #60a5fa;
            font-size: var(--font-sm);
            font-weight: 600;
            min-width: calc(40px * var(--ui-scale));
            text-align: right;
        }

        .camera-setting-slider {
            width: 100%;
            height: calc(6px * var(--ui-scale));
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: calc(3px * var(--ui-scale));
            outline: none;
            cursor: pointer;
        }

        .camera-setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: calc(16px * var(--ui-scale));
            height: calc(16px * var(--ui-scale));
            background: linear-gradient(180deg, #60a5fa, #3b82f6);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        .camera-setting-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .camera-setting-slider::-moz-range-thumb {
            width: calc(16px * var(--ui-scale));
            height: calc(16px * var(--ui-scale));
            background: linear-gradient(180deg, #60a5fa, #3b82f6);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .camera-settings-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: var(--spacing-lg) 0;
        }

        .camera-reset-btn {
            width: 100%;
            padding: calc(10px * var(--ui-scale));
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--border-radius);
            color: #aaa;
            font-size: var(--font-sm);
            cursor: pointer;
            transition: all 0.2s;
        }

        .camera-reset-btn:hover {
            background: rgba(96, 165, 250, 0.2);
            border-color: rgba(96, 165, 250, 0.4);
            color: #60a5fa;
        }

        /* ===== LOADING ===== */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a1628 0%, #1a2d4a 50%, #0d2137 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
        }

        #loading.hidden {
            display: none;
        }

        .loading-content {
            text-align: center;
        }

        .loading-logo {
            font-size: calc(2.5rem * var(--ui-scale));
            font-weight: 900;
            background: linear-gradient(135deg, #00d4ff, #00ffcc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: calc(20px * var(--ui-scale));
        }

        .loading-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: calc(1rem * var(--ui-scale));
        }

        .loading-spinner {
            width: calc(40px * var(--ui-scale));
            height: calc(40px * var(--ui-scale));
            border: calc(3px * var(--ui-scale)) solid rgba(0, 212, 255, 0.2);
            border-top-color: #00d4ff;
            border-radius: 50%;
            margin: calc(20px * var(--ui-scale)) auto 0;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== SAVE INDICATOR ===== */
        #saveIndicator {
            position: fixed;
            bottom: calc(120px * var(--ui-scale));
            right: calc(20px * var(--ui-scale));
            padding: calc(10px * var(--ui-scale)) calc(18px * var(--ui-scale));
            border-radius: var(--spacing-sm);
            font-size: var(--font-md);
            font-weight: 600;
            z-index: 100;
            display: none;
        }

        #saveIndicator.saving {
            display: block;
            background: rgba(255, 180, 0, 0.9);
            color: #000;
        }

        #saveIndicator.saved {
            display: block;
            background: rgba(0, 200, 100, 0.9);
            color: #fff;
        }

        /* ===== LEFT SIDEBAR (Zone Stats Buttons) ===== */
        #leftSidebar {
            position: fixed;
            top: 50%;
            left: calc(10px * var(--ui-scale));
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: calc(8px * var(--ui-scale));
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        #leftSidebar.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Zone Mode Hint Panel */
        #zoneModeHint {
            position: fixed;
            bottom: calc(100px * var(--ui-scale));
            left: calc(10px * var(--ui-scale));
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: calc(10px * var(--ui-scale));
            padding: var(--spacing-md) calc(14px * var(--ui-scale));
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            min-width: calc(160px * var(--ui-scale));
        }

        #zoneModeHint.visible {
            opacity: 1;
            visibility: visible;
        }

        #zoneModeHint .hint-title {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: calc(10px * var(--ui-scale));
            padding-bottom: var(--spacing-xs);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #zoneModeHint .hint-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xs);
        }

        #zoneModeHint .hint-item:last-child {
            margin-bottom: 0;
        }

        #zoneModeHint .hint-key {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #fff;
            background: rgba(96, 165, 250, 0.3);
            padding: calc(3px * var(--ui-scale)) var(--spacing-sm);
            border-radius: var(--spacing-xs);
            border: 1px solid rgba(96, 165, 250, 0.5);
        }

        #zoneModeHint .hint-desc {
            font-size: var(--font-sm);
            color: #aaa;
        }

        /* Road mode sidebar (left side) */
        #rightSidebarRoad {
            position: fixed;
            top: 50%;
            left: calc(10px * var(--ui-scale));
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        #rightSidebarRoad.visible {
            opacity: 1;
            visibility: visible;
        }

        /* ===== LEFT SIDEBAR POWER (Wind View) ===== */
        #leftSidebarPower {
            position: fixed;
            top: 50%;
            left: calc(10px * var(--ui-scale));
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        #leftSidebarPower.visible {
            opacity: 1;
            visibility: visible;
        }

        /* 풍량 커서 게이지 */
        #windCursorGauge {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: calc(4px * var(--ui-scale));
            padding: calc(8px * var(--ui-scale));
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid rgba(100, 180, 255, 0.6);
            border-radius: calc(8px * var(--ui-scale));
            box-shadow: 0 4px 12px rgba(0, 100, 200, 0.3);
        }
        #windCursorGauge.visible {
            display: flex;
        }
        #windCursorGauge .gauge-label {
            font-size: var(--font-xs);
            color: rgba(150, 200, 255, 0.9);
            font-weight: 500;
        }
        #windCursorGauge .gauge-container {
            width: calc(80px * var(--ui-scale));
            height: calc(12px * var(--ui-scale));
            background: rgba(0, 30, 60, 0.8);
            border-radius: calc(6px * var(--ui-scale));
            overflow: hidden;
            border: 1px solid rgba(100, 180, 255, 0.3);
        }
        #windCursorGauge .gauge-fill {
            height: 100%;
            background: linear-gradient(90deg, #60a5fa, #3b82f6, #1d4ed8);
            border-radius: calc(6px * var(--ui-scale));
            transition: width 0.1s ease;
        }
        #windCursorGauge .gauge-value {
            font-size: var(--font-sm);
            color: #60a5fa;
            font-weight: 700;
        }

        .sidebar-btn {
            width: var(--btn-size-lg);
            height: var(--btn-size-lg);
            background: linear-gradient(180deg, rgba(30, 35, 42, 0.95) 0%, rgba(20, 25, 32, 0.98) 100%);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: calc(10px * var(--ui-scale));
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: calc(2px * var(--ui-scale));
            transition: all 0.2s;
        }

        .sidebar-btn:hover {
            background: linear-gradient(180deg, rgba(50, 60, 70, 0.95) 0%, rgba(40, 50, 60, 0.98) 100%);
            border-color: rgba(100, 180, 255, 0.5);
            transform: scale(1.05);
        }

        .sidebar-btn.active {
            background: linear-gradient(180deg, #4a80b0, #3a6090);
            border-color: #6af;
            box-shadow: 0 0 15px rgba(100, 170, 255, 0.4);
        }

        .sidebar-btn .icon {
            font-size: var(--font-xl);
        }

        .sidebar-btn .label {
            font-size: var(--font-xs);
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .sidebar-btn.active .label {
            color: #fff;
        }

        /* ===== DATA VIEW LEGEND PANEL ===== */
        #dataViewLegend {
            position: fixed;
            top: calc(70px * var(--ui-scale));
            left: calc(20px * var(--ui-scale));
            width: calc(280px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(240, 245, 240, 0.97) 0%, rgba(230, 235, 230, 0.98) 100%);
            border-radius: var(--spacing-sm);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            font-family: 'Segoe UI', sans-serif;
            color: #333;
        }

        #dataViewLegend.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            background: linear-gradient(180deg, rgba(130, 180, 80, 0.9) 0%, rgba(100, 150, 60, 0.95) 100%);
            border-radius: var(--spacing-sm) var(--spacing-sm) 0 0;
        }

        .legend-header-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .legend-header-icon {
            font-size: var(--font-lg);
        }

        .legend-header-title {
            font-size: calc(15px * var(--ui-scale));
            font-weight: 600;
            color: #fff;
        }

        .legend-close {
            width: var(--icon-size-md);
            height: var(--icon-size-md);
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: var(--spacing-xs);
            color: #fff;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .legend-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .legend-body {
            padding: calc(14px * var(--ui-scale)) var(--spacing-lg);
        }

        .legend-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: calc(14px * var(--ui-scale));
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .legend-stat-label {
            font-size: var(--font-md);
            color: #666;
        }

        .legend-stat-value {
            font-size: var(--font-md);
            font-weight: 600;
            color: #2a5a2a;
        }

        .legend-section-title {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #555;
            margin-bottom: var(--spacing-md);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            margin-bottom: calc(14px * var(--ui-scale));
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xs);
        }

        .legend-item-label {
            font-size: var(--font-sm);
            color: #555;
        }

        .legend-item-toggle {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            font-size: var(--font-sm);
            color: #777;
        }

        .legend-item-toggle input[type="checkbox"] {
            width: calc(14px * var(--ui-scale));
            height: calc(14px * var(--ui-scale));
            cursor: pointer;
            accent-color: #5a9a5a;
        }

        .legend-gradient-bar {
            height: calc(12px * var(--ui-scale));
            border-radius: var(--border-radius);
            position: relative;
            margin-bottom: var(--spacing-xs);
        }

        .legend-gradient-bar.land-value {
            background: linear-gradient(90deg, #3b82f6 0%, #22c55e 50%, #f59e0b 100%);
        }

        .legend-gradient-bar.building-value {
            background: linear-gradient(90deg, #ef4444 0%, #eab308 50%, #22c55e 100%);
        }

        .legend-gradient-bar.population {
            background: linear-gradient(90deg, #94a3b8 0%, #60a5fa 50%, #8b5cf6 100%);
        }

        .legend-gradient-bar.traffic {
            background: linear-gradient(90deg, #22c55e 0%, #eab308 50%, #ef4444 100%);
        }

        .legend-gradient-bar.wind {
            background: linear-gradient(90deg, #e6f0ff 0%, #60a5fa 50%, #1d4ed8 100%);
        }

        .legend-gradient-labels {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: #888;
        }

        /* ===== UTILITY LEGEND PANEL (Power/Water Gauge) ===== */
        #utilityLegend {
            position: fixed;
            top: calc(70px * var(--ui-scale));
            left: calc(20px * var(--ui-scale));
            width: calc(260px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(240, 245, 250, 0.97) 0%, rgba(230, 235, 245, 0.98) 100%);
            border-radius: var(--spacing-sm);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            font-family: 'Segoe UI', sans-serif;
            color: #333;
        }

        #utilityLegend.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        #utilityLegend.power .utility-legend-header {
            background: linear-gradient(180deg, rgba(245, 180, 60, 0.95) 0%, rgba(220, 150, 40, 0.98) 100%);
        }

        #utilityLegend.water .utility-legend-header {
            background: linear-gradient(180deg, rgba(80, 160, 220, 0.95) 0%, rgba(60, 130, 190, 0.98) 100%);
        }

        #utilityLegend.sewage .utility-legend-header {
            background: linear-gradient(180deg, rgba(139, 90, 43, 0.95) 0%, rgba(101, 67, 33, 0.98) 100%);
        }

        /* 하수 원기둥 시각화 */
        .sewage-cylinder-container {
            display: none;
            flex-direction: column;
            align-items: center;
            padding: var(--spacing-md);
            background: rgba(0, 0, 0, 0.05);
            border-radius: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        #utilityLegend.sewage .sewage-cylinder-container {
            display: flex;
        }

        #utilityLegend.sewage .gauge-container {
            display: none;
        }

        .sewage-cylinder-stack {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: calc(2px * var(--ui-scale));
            margin-bottom: var(--spacing-sm);
        }

        .sewage-cylinder {
            width: calc(80px * var(--ui-scale));
            height: calc(16px * var(--ui-scale));
            border-radius: calc(8px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(139, 90, 43, 0.3) 0%, rgba(101, 67, 33, 0.3) 100%);
            border: 1px solid rgba(101, 67, 33, 0.3);
            position: relative;
            overflow: hidden;
        }

        .sewage-cylinder.filled {
            background: linear-gradient(180deg, rgba(180, 130, 70, 0.9) 0%, rgba(139, 90, 43, 0.95) 50%, rgba(101, 67, 33, 1) 100%);
            border-color: rgba(80, 50, 20, 0.6);
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.1);
        }

        .sewage-cylinder.partial {
            background: linear-gradient(90deg,
                rgba(139, 90, 43, 0.9) 0%,
                rgba(139, 90, 43, 0.9) var(--fill-percent, 50%),
                rgba(139, 90, 43, 0.2) var(--fill-percent, 50%),
                rgba(139, 90, 43, 0.2) 100%
            );
        }

        .sewage-cylinder::before {
            content: '';
            position: absolute;
            top: 0;
            left: 10%;
            right: 10%;
            height: 30%;
            background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 100%);
            border-radius: 50%;
        }

        .sewage-cylinder-label {
            font-size: var(--font-sm);
            color: #654321;
            font-weight: 600;
            margin-top: var(--spacing-xs);
        }

        .sewage-cylinder-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px dashed rgba(101, 67, 33, 0.3);
        }

        .sewage-cylinder-info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: calc(2px * var(--ui-scale));
        }

        .sewage-cylinder-info-label {
            font-size: var(--font-xs);
            color: #888;
        }

        .sewage-cylinder-info-value {
            font-size: var(--font-md);
            font-weight: 700;
            color: #654321;
        }

        .utility-legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--spacing-sm) var(--spacing-sm) 0 0;
        }

        .utility-legend-header-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .utility-legend-icon {
            font-size: var(--font-xl);
        }

        .utility-legend-title {
            font-size: calc(15px * var(--ui-scale));
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .utility-legend-body {
            padding: var(--spacing-md) var(--spacing-lg);
        }

        /* 게이지 미터 */
        .gauge-container {
            position: relative;
            margin-bottom: var(--spacing-md);
        }

        .gauge-svg {
            width: 100%;
            height: auto;
        }

        .gauge-value {
            font-size: calc(18px * var(--ui-scale));
            font-weight: 700;
            fill: #374151;
        }

        .gauge-needle {
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            /* viewBox(200x120)에서 피벗(100,100) → 50%, 83.33% */
            transform-origin: 50% 83.33%;
        }

        .gauge-labels {
            display: flex;
            justify-content: space-between;
            padding: 0 calc(12px * var(--ui-scale));
            margin-top: calc(-8px * var(--ui-scale));
        }

        .gauge-label-min,
        .gauge-label-max {
            font-size: var(--font-xs);
            color: #666;
            font-weight: 500;
        }

        /* 사용량 정보 */
        .utility-stats {
            background: rgba(255, 255, 255, 0.6);
            border-radius: var(--spacing-xs);
            padding: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .utility-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(6px * var(--ui-scale)) 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        }

        .utility-stat-row:last-child {
            border-bottom: none;
        }

        .utility-stat-row.highlight {
            background: rgba(34, 197, 94, 0.1);
            margin: calc(4px * var(--ui-scale)) calc(-8px * var(--ui-scale));
            padding: calc(8px * var(--ui-scale));
            border-radius: var(--spacing-xs);
            border-bottom: none;
        }

        .utility-stat-row.highlight.warning {
            background: rgba(234, 179, 8, 0.15);
        }

        .utility-stat-row.highlight.danger {
            background: rgba(239, 68, 68, 0.15);
        }

        .utility-stat-label {
            font-size: var(--font-sm);
            color: #555;
        }

        .utility-stat-value {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #333;
        }

        .utility-stat-row.highlight .utility-stat-value {
            color: #16a34a;
        }

        .utility-stat-row.highlight.warning .utility-stat-value {
            color: #ca8a04;
        }

        .utility-stat-row.highlight.danger .utility-stat-value {
            color: #dc2626;
        }

        /* 상태 표시 */
        .utility-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-sm);
            background: rgba(34, 197, 94, 0.15);
            border-radius: var(--spacing-xs);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .utility-status.warning {
            background: rgba(234, 179, 8, 0.15);
            border-color: rgba(234, 179, 8, 0.3);
        }

        .utility-status.danger {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
        }

        .utility-status-icon {
            font-size: var(--font-md);
        }

        .utility-status-text {
            font-size: var(--font-sm);
            font-weight: 500;
            color: #16a34a;
        }

        .utility-status.warning .utility-status-text {
            color: #ca8a04;
        }

        .utility-status.danger .utility-status-text {
            color: #dc2626;
        }

        /* ===== BUDGET PANEL ===== */
        #budgetPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: calc(500px * var(--ui-scale));
            max-height: 85vh;
            background: linear-gradient(180deg, rgba(25, 30, 40, 0.98) 0%, rgba(18, 22, 30, 0.99) 100%);
            border: 1px solid rgba(100, 180, 255, 0.3);
            border-radius: calc(16px * var(--ui-scale));
            z-index: 2000;
            display: none;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 0 30px rgba(100, 180, 255, 0.15);
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
        }

        #budgetPanel.open {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .budget-panel-header {
            background: linear-gradient(180deg, #3a4a60, #2a3a50);
            padding: calc(14px * var(--ui-scale)) calc(18px * var(--ui-scale));
            display: flex;
            align-items: center;
            gap: calc(10px * var(--ui-scale));
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .budget-panel-header .panel-icon {
            font-size: calc(22px * var(--ui-scale));
        }

        .budget-panel-header .panel-title {
            flex: 1;
            font-size: var(--font-lg);
            font-weight: 600;
            color: #fff;
        }

        .budget-panel-header .panel-close {
            width: calc(28px * var(--ui-scale));
            height: calc(28px * var(--ui-scale));
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: var(--border-radius);
            color: #aaa;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .budget-panel-header .panel-close:hover {
            background: rgba(255, 100, 100, 0.3);
            color: #fff;
        }

        .budget-panel-content {
            padding: var(--spacing-lg) calc(18px * var(--ui-scale));
            max-height: calc(85vh - 60px * var(--ui-scale));
            overflow-y: auto;
        }

        .budget-section {
            margin-bottom: var(--spacing-sm);
        }

        .budget-section-header {
            margin-bottom: calc(10px * var(--ui-scale));
        }

        .budget-section-header .section-title {
            font-size: var(--font-md);
            font-weight: 600;
            color: #8af;
        }

        .budget-bars {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .budget-bar-row {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-xs) calc(10px * var(--ui-scale));
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--border-radius);
        }

        .budget-bar-row .bar-icon {
            font-size: var(--font-lg);
            width: var(--icon-size-md);
            text-align: center;
        }

        .budget-bar-row .bar-label {
            font-size: var(--font-sm);
            color: #bbb;
            width: calc(65px * var(--ui-scale));
        }

        .budget-bar-row .bar-graph {
            flex: 1;
            height: calc(12px * var(--ui-scale));
            background: rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
        }

        .budget-bar-row .bar-fill {
            height: 100%;
            border-radius: var(--border-radius);
            transition: width 0.3s ease;
        }

        .budget-bar-row .bar-fill.income {
            background: linear-gradient(90deg, #22c55e, #4ade80);
        }

        .budget-bar-row .bar-fill.expense {
            background: linear-gradient(90deg, #dc2626, #f87171);
        }

        .budget-bar-row .bar-value {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #4ade80;
            min-width: calc(60px * var(--ui-scale));
            text-align: right;
            font-family: 'Consolas', monospace;
        }

        .budget-bar-row .bar-value.expense {
            color: #f87171;
        }

        .budget-bar-row .bar-count {
            font-size: var(--font-sm);
            color: #888;
            min-width: calc(30px * var(--ui-scale));
            text-align: right;
        }

        .tax-rate-control {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            min-width: calc(80px * var(--ui-scale));
        }

        .tax-slider {
            width: calc(50px * var(--ui-scale));
            height: calc(6px * var(--ui-scale));
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: calc(3px * var(--ui-scale));
            outline: none;
            cursor: pointer;
        }

        .tax-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: calc(14px * var(--ui-scale));
            height: calc(14px * var(--ui-scale));
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .tax-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .tax-slider::-moz-range-thumb {
            width: calc(14px * var(--ui-scale));
            height: calc(14px * var(--ui-scale));
            background: #60a5fa;
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }

        .tax-percent {
            font-size: var(--font-sm);
            color: #60a5fa;
            min-width: calc(28px * var(--ui-scale));
            text-align: right;
        }

        .budget-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.08);
            margin: calc(14px * var(--ui-scale)) 0;
        }

        .budget-summary {
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--spacing-sm);
            padding: var(--spacing-md) calc(14px * var(--ui-scale));
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(5px * var(--ui-scale)) 0;
        }

        .summary-row.total {
            margin-top: var(--spacing-sm);
            padding-top: calc(10px * var(--ui-scale));
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .summary-label {
            font-size: var(--font-md);
            color: #aaa;
        }

        .summary-row.total .summary-label {
            font-weight: 600;
            color: #fff;
        }

        .summary-value {
            font-size: var(--font-md);
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }

        .summary-value.income {
            color: #4ade80;
        }

        .summary-value.expense {
            color: #f87171;
        }

        .summary-row.total .summary-value {
            font-size: var(--font-lg);
        }

        .bond-cards {
            display: flex;
            gap: calc(10px * var(--ui-scale));
            margin-top: calc(10px * var(--ui-scale));
        }

        .bond-card {
            flex: 1;
            background: linear-gradient(180deg, rgba(60, 70, 90, 0.5), rgba(40, 50, 70, 0.5));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: calc(10px * var(--ui-scale));
            padding: var(--spacing-md);
            text-align: center;
            transition: all 0.2s;
        }

        .bond-card:hover {
            border-color: rgba(100, 180, 255, 0.4);
            background: linear-gradient(180deg, rgba(70, 80, 100, 0.6), rgba(50, 60, 80, 0.6));
        }

        .bond-card.issued {
            border-color: rgba(250, 180, 80, 0.5);
            background: linear-gradient(180deg, rgba(100, 80, 50, 0.4), rgba(80, 60, 40, 0.4));
        }

        .bond-name {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #fff;
            margin-bottom: var(--spacing-xs);
        }

        .bond-amount {
            font-size: var(--font-md);
            font-weight: 700;
            color: #4ade80;
            margin-bottom: var(--spacing-xs);
            font-family: 'Consolas', monospace;
        }

        .bond-interest {
            font-size: var(--font-sm);
            color: #fbbf24;
            margin-bottom: var(--spacing-sm);
        }

        .bond-btn {
            width: 100%;
            padding: var(--spacing-xs) calc(10px * var(--ui-scale));
            background: linear-gradient(180deg, #4a6a90, #3a5a80);
            border: 1px solid rgba(100, 180, 255, 0.3);
            border-radius: calc(5px * var(--ui-scale));
            color: #fff;
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }

        .bond-btn:hover {
            background: linear-gradient(180deg, #5a7aa0, #4a6a90);
        }

        .bond-btn.repay {
            background: linear-gradient(180deg, #8a6040, #7a5030);
            border-color: rgba(250, 180, 80, 0.3);
        }

        .bond-btn.repay:hover {
            background: linear-gradient(180deg, #9a7050, #8a6040);
        }

        .bond-debt {
            margin-top: var(--spacing-md);
            padding: calc(10px * var(--ui-scale));
            background: rgba(255, 100, 100, 0.1);
            border: 1px solid rgba(255, 100, 100, 0.2);
            border-radius: var(--border-radius);
            font-size: var(--font-sm);
            color: #f87171;
            text-align: center;
        }

        .bond-debt span {
            font-weight: 700;
        }

        .budget-total {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(14px * var(--ui-scale)) var(--spacing-lg);
            background: linear-gradient(180deg, rgba(50, 120, 80, 0.2), rgba(40, 100, 70, 0.15));
            border: 1px solid rgba(100, 255, 150, 0.2);
            border-radius: calc(10px * var(--ui-scale));
        }

        .total-label {
            font-size: var(--font-md);
            color: #4ade80;
            font-weight: 600;
        }

        .total-value {
            font-size: calc(22px * var(--ui-scale));
            font-weight: 700;
            color: #4ade80;
            font-family: 'Consolas', monospace;
        }

        /* Legacy */
        #ui { display: none; }
        #toolbar { display: none; }
        #hud { display: none; }

        /* ===== COMPASS ===== */
        #compass {
            position: fixed;
            bottom: calc(80px * var(--ui-scale));
            left: calc(20px * var(--ui-scale));
            width: calc(70px * var(--ui-scale));
            height: calc(70px * var(--ui-scale));
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            border: calc(2px * var(--ui-scale)) solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 900;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        #compass-rose {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out;
        }

        .compass-direction {
            position: absolute;
            font-size: calc(12px * var(--ui-scale));
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .compass-direction.north {
            top: calc(6px * var(--ui-scale));
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b6b;
        }

        .compass-direction.south {
            bottom: calc(6px * var(--ui-scale));
            left: 50%;
            transform: translateX(-50%);
            color: #ccc;
        }

        .compass-direction.east {
            right: calc(6px * var(--ui-scale));
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
        }

        .compass-direction.west {
            left: calc(6px * var(--ui-scale));
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
        }

        .compass-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: calc(8px * var(--ui-scale));
            height: calc(8px * var(--ui-scale));
            background: #fff;
            border-radius: 50%;
        }

        .compass-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: calc(2px * var(--ui-scale));
            height: calc(20px * var(--ui-scale));
            transform: translate(-50%, -100%);
            background: linear-gradient(to top, #ff6b6b, #ff4757);
        }

        .compass-needle::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            width: calc(2px * var(--ui-scale));
            height: calc(20px * var(--ui-scale));
            transform: translateX(-50%);
            background: #888;
        }

        /* ===== CITIZEN SNS FEED ===== */
        #citizenSnsFeed {
            position: fixed;
            right: calc(12px * var(--ui-scale));
            top: calc(50px * var(--ui-scale));
            width: calc(280px * var(--ui-scale));
            max-height: calc(400px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(30, 35, 45, 0.95) 0%, rgba(25, 30, 40, 0.98) 100%);
            border-radius: calc(12px * var(--ui-scale));
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 900;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #citizenSnsFeed.collapsed {
            max-height: calc(44px * var(--ui-scale));
        }

        #citizenSnsFeed.hidden {
            transform: translateX(calc(300px * var(--ui-scale)));
            opacity: 0;
            pointer-events: none;
        }

        .sns-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: calc(10px * var(--ui-scale)) calc(12px * var(--ui-scale));
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.3), rgba(139, 92, 246, 0.3));
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .sns-header-left {
            display: flex;
            align-items: center;
            gap: calc(8px * var(--ui-scale));
        }

        .sns-header-icon {
            font-size: calc(18px * var(--ui-scale));
        }

        .sns-header-title {
            font-size: calc(13px * var(--ui-scale));
            font-weight: 600;
            color: #fff;
        }

        .sns-header-badge {
            background: #ef4444;
            color: #fff;
            font-size: calc(10px * var(--ui-scale));
            padding: calc(2px * var(--ui-scale)) calc(6px * var(--ui-scale));
            border-radius: calc(10px * var(--ui-scale));
            font-weight: 600;
            min-width: calc(18px * var(--ui-scale));
            text-align: center;
        }

        .sns-header-toggle {
            font-size: calc(14px * var(--ui-scale));
            color: #888;
            transition: transform 0.3s ease;
        }

        #citizenSnsFeed.collapsed .sns-header-toggle {
            transform: rotate(180deg);
        }

        .sns-feed-content {
            flex: 1;
            overflow-y: auto;
            padding: calc(8px * var(--ui-scale));
            display: flex;
            flex-direction: column;
            gap: calc(8px * var(--ui-scale));
        }

        .sns-feed-content::-webkit-scrollbar {
            width: calc(4px * var(--ui-scale));
        }

        .sns-feed-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .sns-feed-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: calc(2px * var(--ui-scale));
        }

        .sns-post {
            background: rgba(255, 255, 255, 0.05);
            border-radius: calc(10px * var(--ui-scale));
            padding: calc(10px * var(--ui-scale));
            animation: snsPostSlideIn 0.4s ease;
            border-left: 3px solid #3b82f6;
        }

        @keyframes snsPostSlideIn {
            from {
                opacity: 0;
                transform: translateX(calc(20px * var(--ui-scale)));
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .sns-post.positive {
            border-left-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }

        .sns-post.negative {
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        .sns-post.warning {
            border-left-color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .sns-post.info {
            border-left-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .sns-post-header {
            display: flex;
            align-items: center;
            gap: calc(8px * var(--ui-scale));
            margin-bottom: calc(6px * var(--ui-scale));
        }

        .sns-avatar {
            width: calc(28px * var(--ui-scale));
            height: calc(28px * var(--ui-scale));
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(14px * var(--ui-scale));
        }

        .sns-user-info {
            flex: 1;
        }

        .sns-username {
            font-size: calc(11px * var(--ui-scale));
            font-weight: 600;
            color: #fff;
        }

        .sns-location {
            font-size: calc(9px * var(--ui-scale));
            color: #888;
        }

        .sns-post-content {
            font-size: calc(12px * var(--ui-scale));
            color: #ddd;
            line-height: 1.5;
            margin-bottom: calc(6px * var(--ui-scale));
        }

        .sns-post-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: calc(9px * var(--ui-scale));
            color: #666;
        }

        .sns-post-time {
            display: flex;
            align-items: center;
            gap: calc(4px * var(--ui-scale));
        }

        .sns-post-reactions {
            display: flex;
            align-items: center;
            gap: calc(8px * var(--ui-scale));
        }

        .sns-reaction {
            display: flex;
            align-items: center;
            gap: calc(2px * var(--ui-scale));
            cursor: pointer;
            padding: calc(2px * var(--ui-scale)) calc(4px * var(--ui-scale));
            border-radius: calc(4px * var(--ui-scale));
            transition: background 0.2s;
        }

        .sns-reaction:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .sns-empty {
            text-align: center;
            padding: calc(30px * var(--ui-scale));
            color: #666;
            font-size: calc(12px * var(--ui-scale));
        }

        .sns-empty-icon {
            font-size: calc(32px * var(--ui-scale));
            margin-bottom: calc(8px * var(--ui-scale));
        }
    </style>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "three.quarks": "https://esm.sh/three.quarks@0.15.3?external=three"
          }
        }
    </script>

    <!-- 서버 데이터 주입 -->
    <script th:inline="javascript">
        const MAP_CONFIG = {
            username: /*[[${mapUsername}]]*/ '',
            isOwner: /*[[${isOwner}]]*/ false,
            currentUsername: /*[[${currentUsername}]]*/ null,
            cityName: /*[[${cityName}]]*/ null
        };
    </script>
</head>

<body>
<div id="loading">
    <div class="loading-content">
        <div class="loading-logo" data-i18n="app.name">CITY BUILDER</div>
        <div class="loading-text" data-i18n="common.loading">Loading...</div>
        <div class="loading-spinner"></div>
    </div>
</div>

<!-- ===== TOP BAR ===== -->
<div id="topBar">
    <div class="top-left">
        <a href="/" class="menu-btn" title="Home">🏠</a>
    </div>
    <div class="top-center">
        <div class="city-name-display" id="cityNameDisplay">
            <span id="cityNameText" th:text="${mapUsername}">Username</span>'s City
        </div>
    </div>
    <div class="top-right">
        <div class="bgm-volume-container">
            <button class="bgm-btn" id="btnBgm" title="BGM 재생/정지">🔇</button>
            <input type="range" class="bgm-volume-slider" id="bgmVolume" min="0" max="100" value="0">
        </div>
        <a href="/" class="top-btn" data-i18n="common.home">Home</a>
        <a th:if="${currentUsername != null}" href="/mypage" class="top-btn" data-i18n="common.mypage">My Page</a>
        <a th:if="${currentUsername == null}" href="/login" class="top-btn login-btn" data-i18n="common.login">Login</a>
    </div>
</div>

<!-- ===== CITIZEN SNS FEED ===== -->
<div id="citizenSnsFeed">
    <div class="sns-header" id="snsHeader">
        <div class="sns-header-left">
            <span class="sns-header-icon">📱</span>
            <span class="sns-header-title">시민 피드</span>
            <span class="sns-header-badge" id="snsBadge" style="display: none;">0</span>
        </div>
        <span class="sns-header-toggle">▼</span>
    </div>
    <div class="sns-feed-content" id="snsFeedContent">
        <div class="sns-empty">
            <div class="sns-empty-icon">🏙️</div>
            <div>아직 시민들의 이야기가 없습니다</div>
        </div>
    </div>
</div>

<!-- ===== LEFT SIDEBAR (Zone Stats - Only visible in Zone mode) ===== -->
<div id="leftSidebar" th:if="${isOwner}">
    <button class="sidebar-btn" id="btnLandValue" title="땅값 보기">
        <span class="icon">💰</span>
        <span class="label">땅값</span>
    </button>
    <button class="sidebar-btn" id="btnPopulation" title="인구 보기">
        <span class="icon">👥</span>
        <span class="label">인구</span>
    </button>
</div>

<!-- ===== DATA VIEW LEGEND PANEL ===== -->
<div id="dataViewLegend">
    <div class="legend-header">
        <div class="legend-header-left">
            <span class="legend-header-icon" id="legendIcon">💰</span>
            <span class="legend-header-title" id="legendTitle">땅값</span>
        </div>
        <button class="legend-close" id="legendClose">×</button>
    </div>
    <div class="legend-body">
        <!-- 평균 통계 -->
        <div class="legend-stat">
            <span class="legend-stat-label" id="legendStatLabel">평균 땅값</span>
            <span class="legend-stat-value" id="legendStatValue">₩0/칸</span>
        </div>
        <!-- 소방 현황 (소방 모드 전용) -->
        <div id="legendFireStats" style="display: none;">
            <!-- 현재 화재 -->
            <div class="legend-stat">
                <span class="legend-stat-label">🔥 현재 화재</span>
                <span class="legend-stat-value" id="legendActiveFiresValue">0건</span>
            </div>
            <!-- 소방차 현황 -->
            <div class="legend-stat">
                <span class="legend-stat-label">🚒 총 소방차</span>
                <span class="legend-stat-value" id="legendTotalFiretrucksValue">0대</span>
            </div>
            <div class="legend-stat">
                <span class="legend-stat-label" style="padding-left: var(--spacing-md);">출동 중</span>
                <span class="legend-stat-value" id="legendDispatchedFiretrucksValue" style="color: #ef4444;">0대</span>
            </div>
            <div class="legend-stat">
                <span class="legend-stat-label" style="padding-left: var(--spacing-md);">대기 중</span>
                <span class="legend-stat-value" id="legendAvailableFiretrucksValue" style="color: #22c55e;">0대</span>
            </div>
            <!-- 화재 확률 -->
            <div class="legend-stat" id="legendFireChance">
                <span class="legend-stat-label">건물당 화재 확률</span>
                <span class="legend-stat-value" id="legendFireChanceValue">0%</span>
            </div>
        </div>

        <!-- 지도 범례 -->
        <div class="legend-section-title">지도 범례</div>

        <!-- 땅값 범례 (땅값 모드) -->
        <div class="legend-item" id="legendLandValue">
            <div class="legend-item-header">
                <span class="legend-item-label">땅값</span>
                <label class="legend-item-toggle">
                    <span>지형 색상</span>
                    <input type="checkbox" id="legendTerrainColor" checked>
                </label>
            </div>
            <div class="legend-gradient-bar land-value"></div>
            <div class="legend-gradient-labels">
                <span>낮음</span>
                <span>높음</span>
            </div>
        </div>

        <!-- 건물 가치 범례 (땅값 모드) -->
        <div class="legend-item" id="legendBuildingValue">
            <div class="legend-item-header">
                <span class="legend-item-label">건설 부지 가치</span>
                <label class="legend-item-toggle">
                    <span>건물 색상</span>
                    <input type="checkbox" id="legendBuildingColor" checked>
                </label>
            </div>
            <div class="legend-gradient-bar building-value"></div>
            <div class="legend-gradient-labels">
                <span>낮음</span>
                <span>높음</span>
            </div>
        </div>

        <!-- 인구 범례 (인구 모드) -->
        <div class="legend-item" id="legendPopulation" style="display: none;">
            <div class="legend-item-header">
                <span class="legend-item-label">인구 밀도</span>
                <label class="legend-item-toggle">
                    <span>건물 색상</span>
                    <input type="checkbox" id="legendPopColor" checked>
                </label>
            </div>
            <div class="legend-gradient-bar population"></div>
            <div class="legend-gradient-labels">
                <span>낮음</span>
                <span>높음</span>
            </div>
        </div>

        <!-- 교통량 범례 (교통량 모드) -->
        <div class="legend-item" id="legendTraffic" style="display: none;">
            <div class="legend-item-header">
                <span class="legend-item-label">도로 혼잡도</span>
                <label class="legend-item-toggle">
                    <span>도로 색상</span>
                    <input type="checkbox" id="legendTrafficColor" checked>
                </label>
            </div>
            <div class="legend-gradient-bar traffic"></div>
            <div class="legend-gradient-labels">
                <span>원활</span>
                <span>혼잡</span>
            </div>
        </div>

        <!-- 풍량 범례 (풍량 모드) -->
        <div class="legend-item" id="legendWind" style="display: none;">
            <div class="legend-item-header">
                <span class="legend-item-label">풍량</span>
            </div>
            <div class="legend-gradient-bar wind"></div>
            <div class="legend-gradient-labels">
                <span>약함</span>
                <span>강함</span>
            </div>
        </div>
    </div>
</div>

<!-- ===== UTILITY LEGEND PANEL (Power/Water) ===== -->
<div id="utilityLegend">
    <div class="utility-legend-header">
        <div class="utility-legend-header-left">
            <span class="utility-legend-icon" id="utilityLegendIcon">⚡</span>
            <span class="utility-legend-title" id="utilityLegendTitle">전력</span>
        </div>
        <button class="legend-close" id="utilityLegendClose">×</button>
    </div>
    <div class="utility-legend-body">
        <!-- 게이지 미터 -->
        <div class="gauge-container">
            <svg class="gauge-svg" viewBox="0 0 200 120">
                <!-- 게이지 배경 호 -->
                <defs>
                    <linearGradient id="gaugeGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#22c55e"/>
                        <stop offset="50%" style="stop-color:#eab308"/>
                        <stop offset="100%" style="stop-color:#ef4444"/>
                    </linearGradient>
                </defs>
                <!-- 배경 호 (회색) -->
                <path class="gauge-bg" d="M 20 100 A 80 80 0 0 1 180 100"
                      fill="none" stroke="#e5e7eb" stroke-width="16" stroke-linecap="round"/>
                <!-- 게이지 호 (그라데이션) -->
                <path class="gauge-fill" d="M 20 100 A 80 80 0 0 1 180 100"
                      fill="none" stroke="url(#gaugeGradient)" stroke-width="16" stroke-linecap="round"/>
                <!-- 눈금 표시 -->
                <g class="gauge-ticks">
                    <line x1="20" y1="100" x2="28" y2="100" stroke="#888" stroke-width="2"/>
                    <line x1="35" y1="55" x2="42" y2="60" stroke="#888" stroke-width="2"/>
                    <line x1="100" y1="20" x2="100" y2="28" stroke="#888" stroke-width="2"/>
                    <line x1="165" y1="55" x2="158" y2="60" stroke="#888" stroke-width="2"/>
                    <line x1="180" y1="100" x2="172" y2="100" stroke="#888" stroke-width="2"/>
                </g>
                <!-- 수치 표시 (바늘 아래에 배치) -->
                <text x="100" y="85" text-anchor="middle" class="gauge-value" id="gaugeValue">0%</text>
                <!-- 바늘 (맨 위에 배치) -->
                <g class="gauge-needle" id="gaugeNeedle" style="transform: rotate(-90deg);">
                    <polygon points="100,30 94,100 106,100" fill="#374151" stroke="#1f2937" stroke-width="1"/>
                    <circle cx="100" cy="100" r="10" fill="#374151"/>
                    <circle cx="100" cy="100" r="5" fill="#f59e0b"/>
                </g>
            </svg>
            <div class="gauge-labels">
                <span class="gauge-label-min">0</span>
                <span class="gauge-label-max" id="gaugeMaxLabel">100</span>
            </div>
        </div>

        <!-- 하수 원기둥 시각화 (하수 모드 전용) -->
        <div class="sewage-cylinder-container" id="sewageCylinderContainer">
            <div class="sewage-cylinder-stack" id="sewageCylinderStack">
                <!-- JavaScript에서 동적 생성 -->
            </div>
            <div class="sewage-cylinder-label">하수 처리량</div>
            <div class="sewage-cylinder-info">
                <div class="sewage-cylinder-info-item">
                    <span class="sewage-cylinder-info-label">처리 중</span>
                    <span class="sewage-cylinder-info-value" id="sewageCurrentValue">0</span>
                </div>
                <div class="sewage-cylinder-info-item">
                    <span class="sewage-cylinder-info-label">처리 용량</span>
                    <span class="sewage-cylinder-info-value" id="sewageCapacityValue">0</span>
                </div>
            </div>
        </div>

        <!-- 사용량 정보 -->
        <div class="utility-stats">
            <div class="utility-stat-row">
                <span class="utility-stat-label">현재 사용량</span>
                <span class="utility-stat-value" id="utilityCurrentUsage">0</span>
            </div>
            <div class="utility-stat-row">
                <span class="utility-stat-label">총 용량</span>
                <span class="utility-stat-value" id="utilityTotalCapacity">0</span>
            </div>
            <div class="utility-stat-row highlight">
                <span class="utility-stat-label">여유 용량</span>
                <span class="utility-stat-value" id="utilityRemaining">0</span>
            </div>
        </div>

        <!-- 상태 표시 -->
        <div class="utility-status" id="utilityStatus">
            <span class="utility-status-icon">✓</span>
            <span class="utility-status-text">정상 공급 중</span>
        </div>
    </div>
</div>

<!-- ===== ZONE MODE HINT (Only visible in Zone mode) ===== -->
<div id="zoneModeHint" th:if="${isOwner}">
    <div class="hint-title">💡 단축키</div>
    <div class="hint-item">
        <span class="hint-key">Ctrl + 클릭</span>
        <span class="hint-desc">도로 따라 직선 선택</span>
    </div>
    <div class="hint-item">
        <span class="hint-key">드래그</span>
        <span class="hint-desc">영역 칠하기</span>
    </div>
</div>

<!-- ===== RIGHT SIDEBAR (Traffic View - Only visible in Road mode) ===== -->
<div id="rightSidebarRoad" th:if="${isOwner}">
    <button class="sidebar-btn" id="btnTrafficView" title="교통량 보기">
        <span class="icon">🚗</span>
        <span class="label">교통량</span>
    </button>
</div>

<!-- ===== LEFT SIDEBAR POWER (Wind View - Only visible in Power mode) ===== -->
<div id="leftSidebarPower" th:if="${isOwner}">
    <button class="sidebar-btn" id="btnWindView" title="풍량 보기">
        <span class="icon">💨</span>
        <span class="label">풍량</span>
    </button>
</div>

<!-- ===== WIND CURSOR GAUGE ===== -->
<div id="windCursorGauge">
    <span class="gauge-label">💨 풍량</span>
    <div class="gauge-container">
        <div class="gauge-fill" id="windGaugeFill"></div>
    </div>
    <span class="gauge-value" id="windGaugeValue">0%</span>
</div>

<!-- ===== BUILDING INFO POPUP ===== -->
<div id="buildingPopup">
    <div class="popup-header">
        <span class="icon" id="popupIcon">🏠</span>
        <span class="title" id="popupTitle">Building Name</span>
        <button class="popup-close" id="popupClose">×</button>
    </div>
    <div class="popup-content">
        <div class="popup-type residential" id="popupType">
            <span id="popupTypeIcon">🏠</span>
            <span id="popupTypeText">주거</span>
        </div>
        <div class="popup-row" id="popupPopulationRow">
            <span class="label">인구</span>
            <span class="value green" id="popupPopulation">0명</span>
        </div>
        <div class="popup-happiness" id="popupHappiness">
            <span class="emoji" id="happinessEmoji">😊</span>
            <div class="happiness-info">
                <div class="happiness-bar-container" id="happinessBarContainer">
                    <div class="happiness-bar-fill" id="happinessBarFill"></div>
                </div>
                <div class="happiness-value" id="happinessValue">50</div>
            </div>
        </div>
        <div class="citizen-quote" id="citizenQuote">
            <span class="quote-icon">💬</span>
            <span class="quote-text" id="citizenQuoteText">그럭저럭 살만합니다.</span>
        </div>
        <!-- 연령별 분포 (주거 건물만 표시) -->
        <div class="age-distribution-section" id="ageDistributionSection" style="display: none;">
            <div class="age-distribution-header">
                <span class="icon">👥</span>
                <span>연령 분포</span>
            </div>
            <div class="age-distribution-content">
                <div class="age-chart-labels">
                    <div class="age-label-row">
                        <span class="age-label-name">어린이</span>
                        <span class="age-label-count children" id="ageChildren">0</span>
                    </div>
                    <div class="age-label-row">
                        <span class="age-label-name">청소년</span>
                        <span class="age-label-count teens" id="ageTeens">0</span>
                    </div>
                    <div class="age-label-row">
                        <span class="age-label-name">청년</span>
                        <span class="age-label-count young" id="ageYoung">0</span>
                    </div>
                    <div class="age-label-row">
                        <span class="age-label-name">성인</span>
                        <span class="age-label-count adult" id="ageAdult">0</span>
                    </div>
                    <div class="age-label-row">
                        <span class="age-label-name">노인</span>
                        <span class="age-label-count elderly" id="ageElderly">0</span>
                    </div>
                </div>
                <div class="age-chart-container">
                    <canvas id="ageChartCanvas" width="100" height="100"></canvas>
                </div>
            </div>
        </div>
        <!-- 레벨업 진행도 (땅값 통합) -->
        <div class="level-progress-container" id="levelProgressContainer">
            <div class="level-progress-header">
                <div class="level-progress-title">
                    <span class="icon">💰</span>
                    <span>땅값</span>
                </div>
                <div class="level-progress-value" id="levelProgressValue">0 / 50</div>
            </div>
            <div class="level-progress-bar" id="levelProgressBar">
                <div class="level-progress-section level1">
                    <span class="section-label">LV.1</span>
                </div>
                <div class="level-progress-section level2" id="levelSection2">
                    <span class="section-label">LV.2</span>
                </div>
                <!-- 목표치 마커 -->
                <div class="level-threshold-marker">
                    <div class="threshold-line"></div>
                    <span class="threshold-label">목표</span>
                </div>
                <!-- 현재 위치 마커 -->
                <div class="level-progress-marker" id="levelProgressMarker">
                    <div class="marker-icon">🏠</div>
                    <div class="marker-line"></div>
                </div>
            </div>
            <div class="level-badges">
                <div class="level-badge current" id="levelBadgeCurrent">
                    <span class="badge-icon">🏠</span>
                    <span>현재 레벨</span>
                </div>
                <div class="level-badge next" id="levelBadgeNext">
                    <span class="badge-icon">🏢</span>
                    <span>다음 레벨</span>
                </div>
            </div>
        </div>
        <!-- 폐건물 철거 안내 -->
        <div class="popup-demolish-info" id="demolishInfoContainer" style="display: none;">
            <div class="demolish-icon">🏚️</div>
            <div class="demolish-title">철거 필요</div>
            <div class="demolish-desc">이 건물은 복구가 불가능합니다.<br>철거 후 새 건물을 지어주세요.</div>
        </div>
    </div>
</div>

<!-- ===== CONSTRUCTION POPUP ===== -->
<div id="constructionPopup">
    <div class="popup-header">
        <span class="icon">🏗️</span>
        <span class="title" id="constructionTitle">공사 중</span>
        <button class="popup-close" id="constructionPopupClose">×</button>
    </div>
    <div class="popup-content">
        <div class="construction-status" id="constructionStatus">입주민 대기 중...</div>
        <div class="construction-time-info">
            <div class="time-row">
                <span class="time-label">총 소요시간</span>
                <span class="time-value" id="constructionTotalTime">1:00</span>
            </div>
            <div class="time-row">
                <span class="time-label">남은 시간</span>
                <span class="time-value highlight" id="constructionTimeLeft">0:00</span>
            </div>
        </div>
        <div class="construction-progress-container">
            <div class="construction-progress-bar" id="constructionProgress"></div>
        </div>
    </div>
</div>

<!-- ===== PUBLIC BUILDING POPUP ===== -->
<div id="publicBuildingPopup">
    <div class="popup-header">
        <span class="icon" id="publicPopupIcon">🏛️</span>
        <span class="title" id="publicPopupTitle">공공시설</span>
        <button class="popup-close" id="publicPopupClose">×</button>
    </div>
    <div class="popup-content">
        <div class="popup-row">
            <span class="label">시설 종류</span>
            <div class="popup-type" id="publicPopupType">
                <span class="type-icon" id="publicPopupTypeIcon">🚒</span>
                <span class="type-text" id="publicPopupTypeText">소방서</span>
            </div>
        </div>

        <!-- 소방서 전용: 소방차 현황 -->
        <div id="firetruckStatusSection" style="display:none;">
            <div class="popup-section-title">🚒 소방차 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="firetruckBarDispatched"></div>
                        <div class="firetruck-bar-available" id="firetruckBarAvailable"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">출동 중: <span id="firetruckDispatched">0</span></span>
                        <span class="available-label">대기 중: <span id="firetruckAvailable">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    총 보유: <span id="firetruckTotal">0</span> / <span id="firetruckMax">2</span>대
                </div>
            </div>
        </div>

        <!-- 경찰서 전용: 경찰차 및 감옥 현황 -->
        <div id="policeStatusSection" style="display:none;">
            <div class="popup-section-title">🚔 경찰차 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="policeBarDispatched" style="background: linear-gradient(90deg, #3b82f6, #60a5fa);"></div>
                        <div class="firetruck-bar-available" id="policeBarAvailable" style="background: linear-gradient(90deg, #22c55e, #4ade80);"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">출동 중: <span id="policeDispatched">0</span></span>
                        <span class="available-label">대기 중: <span id="policeAvailable">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    총 보유: <span id="policeTotal">0</span> / <span id="policeMax">2</span>대
                </div>
            </div>
            <div class="popup-section-title" style="margin-top: 8px;">⛓️ 감옥 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="prisonBarOccupied" style="background: linear-gradient(90deg, #ef4444, #f87171);"></div>
                        <div class="firetruck-bar-available" id="prisonBarEmpty" style="background: linear-gradient(90deg, #6b7280, #9ca3af);"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">수감 중: <span id="prisonOccupied">0</span></span>
                        <span class="available-label">빈 자리: <span id="prisonEmpty">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    정원: <span id="prisonTotal">0</span> / <span id="prisonMax">5</span>명
                </div>
            </div>
        </div>

        <!-- 병원 전용: 구급차 및 환자 현황 -->
        <div id="hospitalStatusSection" style="display:none;">
            <div class="popup-section-title">🚑 구급차 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="ambulanceBarDispatched" style="background: linear-gradient(90deg, #ec4899, #f472b6);"></div>
                        <div class="firetruck-bar-available" id="ambulanceBarAvailable" style="background: linear-gradient(90deg, #22c55e, #4ade80);"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">출동 중: <span id="ambulanceDispatched">0</span></span>
                        <span class="available-label">대기 중: <span id="ambulanceAvailable">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    총 보유: <span id="ambulanceTotal">0</span> / <span id="ambulanceMax">2</span>대
                </div>
            </div>
            <div class="popup-section-title" style="margin-top: 8px;">🏥 병상 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="patientBarOccupied" style="background: linear-gradient(90deg, #ef4444, #f87171);"></div>
                        <div class="firetruck-bar-available" id="patientBarEmpty" style="background: linear-gradient(90deg, #6b7280, #9ca3af);"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">입원 중: <span id="patientOccupied">0</span></span>
                        <span class="available-label">빈 병상: <span id="patientEmpty">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    정원: <span id="patientTotal">0</span> / <span id="patientMax">8</span>명
                </div>
            </div>
        </div>

        <!-- 하수처리장 전용 -->
        <div id="wastewaterStatusSection" style="display:none;">
            <div class="popup-section-title">🏭 시설 상태</div>
            <div class="firetruck-status">
                <div class="popup-row" style="margin-bottom: 8px;">
                    <span class="label">작동 여부</span>
                    <span class="value" id="wastewaterOperational" style="font-weight: bold;">-</span>
                </div>
                <div class="popup-row">
                    <span class="label">처리 용량</span>
                    <span class="value" id="wastewaterCapacity">-</span>
                </div>
            </div>
        </div>

        <!-- 취수장 전용 -->
        <div id="waterPumpStatusSection" style="display:none;">
            <div class="popup-section-title">🌊 시설 상태</div>
            <div class="firetruck-status">
                <div class="popup-row" style="margin-bottom: 8px;">
                    <span class="label">작동 여부</span>
                    <span class="value" id="waterPumpOperational" style="font-weight: bold;">-</span>
                </div>
                <div class="popup-row">
                    <span class="label">취수량</span>
                    <span class="value" id="waterPumpOutput">-</span>
                </div>
            </div>
        </div>

        <!-- 풍력발전기 전용: 확장 시스템 -->
        <div id="windTurbineExpansionSection" style="display:none;">
            <div class="popup-section-title">⚡ 발전 현황</div>
            <div class="wind-expansion-status">
                <div class="popup-row" style="margin-bottom: 8px;">
                    <span class="label">터빈 수</span>
                    <span class="value"><span id="windTurbineCount">1</span> / <span id="windTurbineMax">6</span>기</span>
                </div>
                <div class="popup-row" style="margin-bottom: 8px;">
                    <span class="label">총 발전량</span>
                    <span class="value" id="windTurbinePower" style="color: #fbbf24;">100 kW</span>
                </div>
                <div class="popup-row" style="margin-bottom: 12px;">
                    <span class="label">유지비</span>
                    <span class="value" id="windTurbineMaintenance" style="color: #f87171;">₩30/h</span>
                </div>
                <div class="wind-expansion-visual" id="windExpansionVisual">
                    <div class="turbine-slot main" title="메인 터빈">💨</div>
                    <div class="turbine-slot empty" data-slot="1" title="확장 슬롯 1">+</div>
                    <div class="turbine-slot empty" data-slot="2" title="확장 슬롯 2">+</div>
                    <div class="turbine-slot empty" data-slot="3" title="확장 슬롯 3">+</div>
                    <div class="turbine-slot empty" data-slot="4" title="확장 슬롯 4">+</div>
                    <div class="turbine-slot empty" data-slot="5" title="확장 슬롯 5">+</div>
                </div>
                <button id="btnExpandWindTurbine" class="expand-turbine-btn">
                    <span class="btn-icon">➕</span>
                    <span class="btn-text">터빈 확장</span>
                    <span class="btn-cost" id="expansionCostText">₩2,000</span>
                </button>
                <div class="expansion-info" id="expansionInfo">
                    확장 시 +80 kW, 유지비 +₩20/h
                </div>
            </div>
        </div>

        <!-- 태양광발전기 전용: 확장 시스템 -->
        <div id="solarPanelExpansionSection" style="display:none;">
            <div class="popup-section-title">☀️ 발전 현황</div>
            <div class="solar-expansion-status">
                <div class="popup-row" style="margin-bottom: 8px;">
                    <span class="label">패널 수</span>
                    <span class="value"><span id="solarPanelCount">1</span> / <span id="solarPanelMax">6</span>기</span>
                </div>
                <div class="popup-row" style="margin-bottom: 8px;">
                    <span class="label">총 발전량</span>
                    <span class="value" id="solarPanelPower" style="color: #fbbf24;">150 kW</span>
                </div>
                <div class="popup-row" style="margin-bottom: 12px;">
                    <span class="label">유지비</span>
                    <span class="value" id="solarPanelMaintenance" style="color: #f87171;">₩40/h</span>
                </div>
                <div class="solar-expansion-visual" id="solarExpansionVisual">
                    <div class="solar-slot main" title="메인 패널">☀️</div>
                    <div class="solar-slot empty" data-slot="1" title="확장 슬롯 1">+</div>
                    <div class="solar-slot empty" data-slot="2" title="확장 슬롯 2">+</div>
                    <div class="solar-slot empty" data-slot="3" title="확장 슬롯 3">+</div>
                    <div class="solar-slot empty" data-slot="4" title="확장 슬롯 4">+</div>
                    <div class="solar-slot empty" data-slot="5" title="확장 슬롯 5">+</div>
                </div>
                <button id="btnExpandSolarPanel" class="expand-solar-btn">
                    <span class="btn-icon">➕</span>
                    <span class="btn-text">패널 확장</span>
                    <span class="btn-cost" id="solarExpansionCostText">₩2,500</span>
                </button>
                <div class="expansion-info" id="solarExpansionInfo">
                    확장 시 +100 kW, 유지비 +₩25/h
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ===== RIGHT INFO PANEL (Collapsible) ===== -->
<div id="infoPanel" class="collapsed">
    <div class="panel-header" onclick="toggleInfoPanel()">
        <span class="panel-title"><span data-i18n="hud.cityStats">📊 City Stats</span></span>
        <span class="panel-toggle" id="panelToggleIcon">▼</span>
    </div>
    <div class="panel-content">
        <div class="panel-stat">
            <span class="label">👥 <span data-i18n="hud.population">Population</span></span>
            <span class="value" id="populationText">0</span>
        </div>
        <div class="panel-stat">
            <span class="label">😊 <span data-i18n="hud.happiness">Happiness</span></span>
            <span class="value" id="happinessText">50%</span>
        </div>
        <div class="panel-stat">
            <span class="label">⚡ <span data-i18n="hud.power">Power</span></span>
            <span class="value" id="powerText">0/0</span>
        </div>
        <div class="panel-stat">
            <span class="label">💧 <span data-i18n="hud.water">Water</span></span>
            <span class="value" id="waterText">0/0</span>
        </div>
        <div class="panel-stat">
            <span class="label">🚗 <span data-i18n="hud.traffic">Traffic</span></span>
            <span class="value" id="trafficText">0%</span>
        </div>
        <div class="panel-stat">
            <span class="label">🚨 <span data-i18n="hud.crime">Crime</span></span>
            <span class="value" id="crimeText">0%</span>
        </div>

        <div th:if="${isOwner}" class="panel-section">
            <div class="panel-section-title" data-i18n="hud.daily">Daily</div>
            <div class="panel-stat">
                <span class="label">⚡ <span data-i18n="hud.ap">AP</span></span>
                <span class="value" id="apText">10/10</span>
            </div>
            <div class="panel-stat">
                <span class="label">📅 <span data-i18n="hud.loginStreak">Streak</span></span>
                <span class="value" id="streakText">0 <span data-i18n="hud.days">days</span></span>
            </div>
        </div>

        <div th:if="${isOwner}" id="offlineEarningsBox" class="earnings-box" style="display:none;">
            <div class="earnings-label" data-i18n="hud.offlineEarnings">Offline Earnings</div>
            <div class="earnings-value"><span id="offlineCurrency">$</span><span id="offlineEarningsText">0</span></div>
            <button id="btnCollectTax" class="collect-btn" data-i18n="hud.collect">Collect</button>
        </div>

        <div th:if="${isOwner}" id="loginRewardBox" class="earnings-box" style="display:none;">
            <div class="earnings-label" data-i18n="hud.loginReward">Login Reward!</div>
            <div class="earnings-value"><span id="rewardCurrency">$</span><span id="loginRewardText">0</span></div>
            <button id="btnClaimReward" class="collect-btn" data-i18n="hud.claim">Claim</button>
        </div>
    </div>
</div>

<!-- ===== SUB MENU (Slide up) ===== -->
<div id="subMenu">
    <div class="submenu-header">
        <span class="submenu-title" id="submenuTitle">🏠 Zones</span>
        <button class="submenu-close" onclick="closeSubMenu()">×</button>
    </div>
    <div class="submenu-items" id="submenuItems">
        <!-- Dynamically populated -->
    </div>
</div>

<!-- ===== SUBMENU TOOLTIP ===== -->
<div id="submenuTooltip" class="submenu-tooltip">
    <div class="tooltip-header">
        <span class="tooltip-icon" id="tooltipIcon">🚒</span>
        <span class="tooltip-name" id="tooltipName">동네 소방서</span>
    </div>
    <div class="tooltip-content">
        <div class="tooltip-row">
            <span class="label">건설비</span>
            <span class="value" id="tooltipCost">₩3,000</span>
        </div>
        <div class="tooltip-row maintenance">
            <span class="label">운영비</span>
            <span class="value" id="tooltipMaintenance">₩50/시간</span>
        </div>
        <div class="tooltip-row power">
            <span class="label">⚡ 전력</span>
            <span class="value" id="tooltipPowerUsage">10 kW</span>
        </div>
        <div class="tooltip-desc" id="tooltipDesc">화재 예방 및 신속한 진압</div>
    </div>
</div>

<!-- ===== DAILY STATS PANELS ===== -->
<!-- 화재 통계 패널 -->
<div id="fireStatsPanel" class="daily-stats-panel fire-panel">
    <div class="daily-stats-header">
        <span class="stat-number" id="statBurnedBuildings">0</span>
        <span class="stat-title">하루에 불에 탄 건물</span>
    </div>
    <div class="daily-stats-rows">
        <div class="daily-stats-row">
            <span class="row-number" id="statExtinguishedFires">0</span>
            <span class="row-number">/</span>
            <span class="row-number" id="statTotalFires">0</span>
            <span class="row-label">하루에 진압한 화재</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statHazmatFires">0</span>
            <span class="row-label">하루에 진압한 위험물 화재</span>
        </div>
    </div>
</div>

<!-- 범죄 통계 패널 -->
<div id="crimeStatsPanel" class="daily-stats-panel crime-panel">
    <div class="daily-stats-header">
        <span class="stat-number" id="statTotalCrimes">0</span>
        <span class="stat-title">하루에 발생한 범죄</span>
    </div>
    <div class="daily-stats-rows">
        <div class="daily-stats-row">
            <span class="row-number" id="statEscapedCriminals">0</span>
            <span class="row-label">잡히지 않은 범죄자</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statArrestedCriminals">0</span>
            <span class="row-label">하루에 체포한 범죄자</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statPrisoners">0</span>
            <span class="row-label">죄수</span>
        </div>
    </div>
</div>

<!-- 의료 통계 패널 -->
<div id="medicalStatsPanel" class="daily-stats-panel medical-panel">
    <div class="daily-stats-header">
        <span class="stat-number" id="statTotalEmergencies">0</span>
        <span class="stat-title">하루에 발생한 응급환자</span>
    </div>
    <div class="daily-stats-rows">
        <div class="daily-stats-row">
            <span class="row-number" id="statDeadPatients">0</span>
            <span class="row-label">사망 환자</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statSavedPatients">0</span>
            <span class="row-label">하루에 구조한 환자</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statHospitalPatients">0</span>
            <span class="row-number">/</span>
            <span class="row-number" id="statHospitalCapacity">0</span>
            <span class="row-label">입원 환자</span>
        </div>
    </div>
</div>

<!-- ===== BOTTOM BAR (Main Toolbar) ===== -->
<div id="bottomBar">
    <!-- Left: Time & Speed Controls -->
    <div class="bottom-left">
        <div class="game-speed">
            <button class="speed-btn active" id="btnSpeed1" title="1x">▶</button>
            <button class="speed-btn" id="btnSpeed2" title="2x">▶▶</button>
            <button class="speed-btn" id="btnSpeed3" title="3x">▶▶▶</button>
        </div>
        <div class="time-display">
            <div class="date-display" id="dateDisplay" data-i18n-template="game.day">Day 1</div>
            <div class="clock-display" id="clockDisplay">06:00</div>
        </div>

        <!-- RCI Demand Bar -->
        <div class="rci-demand-bar">
            <div class="rci-item residential">
                <span class="rci-label">R</span>
                <div class="rci-bar-container">
                    <div class="rci-bar-negative"></div>
                    <div class="rci-bar-center"></div>
                    <div class="rci-bar-positive" id="rciResidential"></div>
                </div>
            </div>
            <div class="rci-item commercial">
                <span class="rci-label">C</span>
                <div class="rci-bar-container">
                    <div class="rci-bar-negative"></div>
                    <div class="rci-bar-center"></div>
                    <div class="rci-bar-positive" id="rciCommercial"></div>
                </div>
            </div>
            <div class="rci-item industrial">
                <span class="rci-label">I</span>
                <div class="rci-bar-container">
                    <div class="rci-bar-negative"></div>
                    <div class="rci-bar-center"></div>
                    <div class="rci-bar-positive" id="rciIndustrial"></div>
                </div>
            </div>
        </div>

        <!-- City Happiness -->
        <div class="city-happiness">
            <span class="happiness-icon" id="cityHappinessIcon">😊</span>
            <div class="happiness-info">
                <span class="happiness-label">행복도</span>
                <div class="happiness-value">
                    <span class="happiness-number high" id="cityHappinessNumber">50</span>
                    <span class="happiness-trend stable" id="cityHappinessTrend">→</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Center: Main Tools (Icons Only) -->
    <div class="bottom-center">
        <button class="tool-btn active" id="btnCam" title="카메라 모드" style="display: none;">
            <span class="icon">📷</span>
        </button>

        <th:block th:if="${isOwner}">
            <button class="tool-btn" id="btnBuild" title="도로/수로">
                <span class="icon">🛣️</span>
            </button>

            <button class="tool-btn" id="btnZones" title="구역 지정">
                <span class="icon">🏘️</span>
            </button>

            <div class="tool-divider"></div>

            <button class="tool-btn" id="btnPower" title="발전소">
                <span class="icon">⚡</span>
            </button>

            <button class="tool-btn" id="btnWater" title="수도">
                <span class="icon">💧</span>
            </button>

            <button class="tool-btn" id="btnSewage" title="하수">
                <span class="icon">🚽</span>
            </button>

            <div class="tool-divider"></div>

            <button class="tool-btn" id="btnPolice" title="경찰서 (₩3,000)">
                <span class="icon">🚔</span>
            </button>

            <button class="tool-btn" id="btnFire" title="소방서 (₩3,000)">
                <span class="icon">🚒</span>
            </button>

            <button class="tool-btn" id="btnSchool" title="학교 (₩4,000)">
                <span class="icon">🏫</span>
            </button>

            <button class="tool-btn" id="btnHospital" title="병원 (₩6,000)">
                <span class="icon">🏥</span>
            </button>

            <button class="tool-btn" id="btnPark" title="공원 (₩1,000)">
                <span class="icon">🌳</span>
            </button>

        </th:block>

        <th:block th:if="${isOwner}">
            <button class="demolish-btn" id="btnDemolish" title="철거 모드">
                <span class="icon">🔨</span>
            </button>
        </th:block>

        <th:block th:if="${isOwner}">
            <button class="tool-btn save-btn" id="btnSave" title="저장 (Ctrl+S)">
                <span class="icon">💾</span>
            </button>
        </th:block>

        <div class="tool-divider"></div>

        <!-- 중앙 자금 표시 (SimCity 스타일) -->
        <div class="money-display-center" id="moneyDisplayBtn" title="시 예산">
            <div class="money-icon">💰</div>
            <div class="money-amount" id="moneyDisplayCenter">49,069</div>
            <div class="money-rate" id="moneyRateCenter">+₩0/h</div>
        </div>

        <!-- 인구 표시 -->
        <div class="population-display-center" id="populationDisplayBtn" title="인구 통계">
            <div class="pop-icon">👥</div>
            <div class="pop-amount" id="popDisplayCenter">0</div>
            <div class="pop-label">명</div>
        </div>
    </div>
</div>

<!-- ===== BUDGET PANEL ===== -->
<div id="budgetPanel">
    <div class="budget-panel-header">
        <span class="panel-icon">📊</span>
        <span class="panel-title">시 예산</span>
        <button class="panel-close" id="btnCloseBudget">×</button>
    </div>
    <div class="budget-panel-content">
        <!-- 수입/지출 그래프 -->
        <div class="budget-section">
            <div class="budget-section-header">
                <span class="section-title">💵 수입</span>
            </div>
            <div class="budget-bars" id="incomeBars">
                <div class="budget-bar-row">
                    <span class="bar-icon">🏠</span>
                    <span class="bar-label">주거 세금</span>
                    <div class="bar-graph">
                        <div class="bar-fill income" id="barResidential" style="width: 60%;"></div>
                    </div>
                    <span class="bar-value" id="valResidential">₩0</span>
                    <div class="tax-rate-control">
                        <input type="range" min="0" max="20" value="10" id="taxResidential" class="tax-slider">
                        <span class="tax-percent" id="taxResidentialPercent">10%</span>
                    </div>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🏪</span>
                    <span class="bar-label">상업 세금</span>
                    <div class="bar-graph">
                        <div class="bar-fill income" id="barCommercial" style="width: 40%;"></div>
                    </div>
                    <span class="bar-value" id="valCommercial">₩0</span>
                    <div class="tax-rate-control">
                        <input type="range" min="0" max="20" value="10" id="taxCommercial" class="tax-slider">
                        <span class="tax-percent" id="taxCommercialPercent">10%</span>
                    </div>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🏭</span>
                    <span class="bar-label">공업 세금</span>
                    <div class="bar-graph">
                        <div class="bar-fill income" id="barIndustrial" style="width: 30%;"></div>
                    </div>
                    <span class="bar-value" id="valIndustrial">₩0</span>
                    <div class="tax-rate-control">
                        <input type="range" min="0" max="20" value="10" id="taxIndustrial" class="tax-slider">
                        <span class="tax-percent" id="taxIndustrialPercent">10%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="budget-divider"></div>

        <div class="budget-section">
            <div class="budget-section-header">
                <span class="section-title">💸 지출</span>
            </div>
            <div class="budget-bars" id="expenseBars">
                <div class="budget-bar-row">
                    <span class="bar-icon">🚒</span>
                    <span class="bar-label">소방서</span>
                    <div class="bar-graph">
                        <div class="bar-fill expense" id="barFireExpense" style="width: 20%;"></div>
                    </div>
                    <span class="bar-value expense" id="valFireExpense">-₩0</span>
                    <span class="bar-count" id="countFire">×0</span>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🚔</span>
                    <span class="bar-label">경찰서</span>
                    <div class="bar-graph">
                        <div class="bar-fill expense" id="barPoliceExpense" style="width: 25%;"></div>
                    </div>
                    <span class="bar-value expense" id="valPoliceExpense">-₩0</span>
                    <span class="bar-count" id="countPolice">×0</span>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🏫</span>
                    <span class="bar-label">학교</span>
                    <div class="bar-graph">
                        <div class="bar-fill expense" id="barSchoolExpense" style="width: 30%;"></div>
                    </div>
                    <span class="bar-value expense" id="valSchoolExpense">-₩0</span>
                    <span class="bar-count" id="countSchool">×0</span>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🌳</span>
                    <span class="bar-label">공원</span>
                    <div class="bar-graph">
                        <div class="bar-fill expense" id="barParkExpense" style="width: 10%;"></div>
                    </div>
                    <span class="bar-value expense" id="valParkExpense">-₩0</span>
                    <span class="bar-count" id="countPark">×0</span>
                </div>
            </div>
        </div>

        <div class="budget-divider"></div>

        <!-- 요약 -->
        <div class="budget-summary">
            <div class="summary-row">
                <span class="summary-label">총 수입</span>
                <span class="summary-value income" id="totalIncome">+₩0/h</span>
            </div>
            <div class="summary-row">
                <span class="summary-label">총 지출</span>
                <span class="summary-value expense" id="totalExpense">-₩0/h</span>
            </div>
            <div class="summary-row total">
                <span class="summary-label">순이익</span>
                <span class="summary-value" id="netProfit">+₩0/h</span>
            </div>
        </div>

        <div class="budget-divider"></div>

        <!-- 채권 -->
        <div class="budget-section">
            <div class="budget-section-header">
                <span class="section-title">💳 채권</span>
            </div>
            <div class="bond-cards">
                <div class="bond-card" id="bondA">
                    <div class="bond-name">채권 A</div>
                    <div class="bond-amount">₩10,000</div>
                    <div class="bond-interest">이자 5%</div>
                    <button class="bond-btn" id="btnBondA">발행</button>
                </div>
                <div class="bond-card" id="bondB">
                    <div class="bond-name">채권 B</div>
                    <div class="bond-amount">₩50,000</div>
                    <div class="bond-interest">이자 7%</div>
                    <button class="bond-btn" id="btnBondB">발행</button>
                </div>
                <div class="bond-card" id="bondC">
                    <div class="bond-name">채권 C</div>
                    <div class="bond-amount">₩100,000</div>
                    <div class="bond-interest">이자 10%</div>
                    <button class="bond-btn" id="btnBondC">발행</button>
                </div>
            </div>
            <div class="bond-debt">
                현재 부채: <span id="totalDebt">₩0</span> (이자: <span id="debtInterest">₩0/h</span>)
            </div>
        </div>

        <div class="budget-divider"></div>

        <!-- 총 자산 -->
        <div class="budget-total">
            <span class="total-label">💵 총 자산</span>
            <span class="total-value" id="totalAssets">₩0</span>
        </div>
    </div>
</div>

<!-- ===== POPULATION PANEL ===== -->
<div id="populationPanel">
    <div class="pop-panel-header">
        <span class="panel-icon">👥</span>
        <span class="panel-title">인구 통계</span>
        <button class="panel-close" id="btnClosePopulation">×</button>
    </div>
    <div class="pop-panel-content">
        <!-- 총 인구 -->
        <div class="pop-stat-grid">
            <div class="pop-stat-card full-width">
                <div class="stat-icon">🏙️</div>
                <div class="stat-label">총 인구</div>
                <div class="stat-value" id="popTotalValue">0</div>
            </div>
            <div class="pop-stat-card">
                <div class="stat-icon">🏠</div>
                <div class="stat-label">주거 건물</div>
                <div class="stat-value" id="popResidentialBuildings">0</div>
            </div>
            <div class="pop-stat-card">
                <div class="stat-icon">📊</div>
                <div class="stat-label">평균 인구/건물</div>
                <div class="stat-value" id="popAvgPerBuilding">0</div>
            </div>
        </div>

        <!-- 계층별 인구 -->
        <div class="pop-tier-section">
            <div class="section-title">계층별 인구 분포</div>
            <div class="pop-tier-bar">
                <span class="tier-icon">🏢</span>
                <span class="tier-label">중산층</span>
                <div class="tier-bar-bg">
                    <div class="tier-bar-fill middle" id="tierBarMiddle" style="width: 0%;"></div>
                </div>
                <span class="tier-value" id="tierValueMiddle">0명</span>
            </div>
            <div class="pop-tier-bar">
                <span class="tier-icon">🏰</span>
                <span class="tier-label">상류층</span>
                <div class="tier-bar-bg">
                    <div class="tier-bar-fill high" id="tierBarHigh" style="width: 0%;"></div>
                </div>
                <span class="tier-value" id="tierValueHigh">0명</span>
            </div>
        </div>

        <!-- 연령별 인구 - 원형 그래프 -->
        <div class="pop-age-section">
            <div class="section-title">연령별 인구 분포</div>
            <div class="age-pie-container">
                <!-- 파이 차트 -->
                <div class="age-pie-chart">
                    <svg viewBox="0 0 100 100">
                        <circle id="pieChildren" cx="50" cy="50" r="40" fill="none" stroke="#f472b6" stroke-width="20" stroke-dasharray="0 251.2" />
                        <circle id="pieYouth" cx="50" cy="50" r="40" fill="none" stroke="#60a5fa" stroke-width="20" stroke-dasharray="0 251.2" stroke-dashoffset="0" />
                        <circle id="pieAdults" cx="50" cy="50" r="40" fill="none" stroke="#34d399" stroke-width="20" stroke-dasharray="0 251.2" stroke-dashoffset="0" />
                        <circle id="pieElderly" cx="50" cy="50" r="40" fill="none" stroke="#a78bfa" stroke-width="20" stroke-dasharray="0 251.2" stroke-dashoffset="0" />
                    </svg>
                    <div class="pie-center">
                        <span class="pie-center-value" id="pieTotalPop">0</span>
                        <span class="pie-center-label">총인구</span>
                    </div>
                </div>
                <!-- 범례 -->
                <div class="age-legend">
                    <div class="age-legend-item">
                        <div class="age-legend-color children"></div>
                        <span class="age-legend-label">👶 어린이</span>
                        <span class="age-legend-value" id="ageLegendChildren">0</span>
                        <span class="age-legend-percent" id="agePctChildren">(0%)</span>
                    </div>
                    <div class="age-legend-item">
                        <div class="age-legend-color youth"></div>
                        <span class="age-legend-label">🧑 청년</span>
                        <span class="age-legend-value" id="ageLegendYouth">0</span>
                        <span class="age-legend-percent" id="agePctYouth">(0%)</span>
                    </div>
                    <div class="age-legend-item">
                        <div class="age-legend-color adults"></div>
                        <span class="age-legend-label">👨 중년</span>
                        <span class="age-legend-value" id="ageLegendAdults">0</span>
                        <span class="age-legend-percent" id="agePctAdults">(0%)</span>
                    </div>
                    <div class="age-legend-item">
                        <div class="age-legend-color elderly"></div>
                        <span class="age-legend-label">👴 노인</span>
                        <span class="age-legend-value" id="ageLegendElderly">0</span>
                        <span class="age-legend-percent" id="agePctElderly">(0%)</span>
                    </div>
                </div>
            </div>
            <div class="age-stats-row">
                <div class="age-stat">
                    <span class="stat-label">출생률</span>
                    <span class="stat-value" id="ageBirthRate">0‰</span>
                </div>
                <div class="age-stat">
                    <span class="stat-label">사망률</span>
                    <span class="stat-value" id="ageDeathRate">0‰</span>
                </div>
                <div class="age-stat">
                    <span class="stat-label">노동인구</span>
                    <span class="stat-value" id="ageWorkforce">0명</span>
                </div>
            </div>
        </div>

        <!-- 서비스 커버리지 -->
        <div class="pop-service-section">
            <div class="section-title">서비스 충족률</div>
            <div class="service-coverage-bar">
                <span class="service-icon">🏫</span>
                <span class="service-label">교육</span>
                <div class="service-bar-bg">
                    <div class="service-bar-fill" id="serviceCoverageSchool" style="width: 0%;"></div>
                </div>
                <span class="service-value" id="serviceCoverageSchoolValue">0%</span>
            </div>
            <div class="service-coverage-bar">
                <span class="service-icon">🏥</span>
                <span class="service-label">의료</span>
                <div class="service-bar-bg">
                    <div class="service-bar-fill" id="serviceCoverageHospital" style="width: 0%;"></div>
                </div>
                <span class="service-value" id="serviceCoverageHospitalValue">0%</span>
            </div>
            <div class="service-coverage-bar">
                <span class="service-icon">🌳</span>
                <span class="service-label">공원</span>
                <div class="service-bar-bg">
                    <div class="service-bar-fill" id="serviceCoveragePark" style="width: 0%;"></div>
                </div>
                <span class="service-value" id="serviceCoverageParkValue">0%</span>
            </div>
        </div>
    </div>
</div>

<!-- Mode Hint with Exit Button -->
<div id="hintContainer">
    <div id="hint">Camera Mode</div>
    <button id="btnExitMode" title="모드 종료 (ESC)">✕</button>
</div>

<!-- Cost Tooltip (follows mouse) -->
<div id="costTooltip"></div>

<!-- Graph Tooltip (population/land value) -->
<div id="graphTooltip">
    <span class="label"></span>
    <span class="value"></span>
</div>

<!-- Camera Settings Panel -->
<div id="cameraSettingsPanel">
    <div class="panel-header">
        <div class="panel-title">
            <span class="icon">📷</span>
            <span>카메라 설정</span>
        </div>
        <button class="panel-close" id="cameraSettingsClose">×</button>
    </div>
    <div class="panel-content">
        <div class="camera-setting-row">
            <div class="camera-setting-label">
                <span class="name">최소 줌</span>
                <span class="value" id="minZoomValue">0.1</span>
            </div>
            <input type="range" class="camera-setting-slider" id="minZoomSlider" min="0.1" max="10" step="0.1" value="0.1">
        </div>
        <div class="camera-setting-row">
            <div class="camera-setting-label">
                <span class="name">최대 줌</span>
                <span class="value" id="maxZoomValue">150</span>
            </div>
            <input type="range" class="camera-setting-slider" id="maxZoomSlider" min="20" max="200" step="5" value="150">
        </div>
        <div class="camera-settings-divider"></div>
        <div class="camera-setting-row">
            <div class="camera-setting-label">
                <span class="name">최소 각도</span>
                <span class="value" id="minAngleValue">0°</span>
            </div>
            <input type="range" class="camera-setting-slider" id="minAngleSlider" min="0" max="45" step="1" value="0">
        </div>
        <div class="camera-setting-row">
            <div class="camera-setting-label">
                <span class="name">최대 각도</span>
                <span class="value" id="maxAngleValue">89°</span>
            </div>
            <input type="range" class="camera-setting-slider" id="maxAngleSlider" min="45" max="89" step="1" value="89">
        </div>
        <div class="camera-settings-divider"></div>
        <button class="camera-reset-btn" id="cameraResetBtn">기본값으로 초기화</button>
    </div>
</div>

<!-- Legacy elements for JS compatibility -->
<div id="toolbar" style="display:none;">
    <button id="btnZoneResidential"></button>
    <button id="btnZoneCommercial"></button>
    <button id="btnZoneIndustrial"></button>
    <button id="btnZoneDelete"></button>
</div>
<div id="hud" style="display:none;"></div>
<div id="ui" style="display:none;"></div>

<div id="saveIndicator"></div>
<div id="toastRoot"></div>

<!-- Compass -->
<div id="compass">
    <div id="compass-rose">
        <span class="compass-direction north">N</span>
        <span class="compass-direction south">S</span>
        <span class="compass-direction east">E</span>
        <span class="compass-direction west">W</span>
        <div class="compass-needle"></div>
        <div class="compass-center"></div>
    </div>
</div>

<canvas id="c"></canvas>

<script type="module">
    const GRID_W = 70;
    const GRID_H = 70;
    const TILE_SIZE = 1;
    const ORIGIN_X = -GRID_W / 2;
    const ORIGIN_Z = -GRID_H / 2;
    const roadCenterOffset = {
        straight: new THREE.Vector3(),
        corner:   new THREE.Vector3(),
        t:        new THREE.Vector3(),
        cross:    new THREE.Vector3(),
    };
    const road4laneCenterOffset = {
        straight: new THREE.Vector3(),
        corner:   new THREE.Vector3(),
        t:        new THREE.Vector3(),
        cross:    new THREE.Vector3(),
        // 2차선 연결용 모델
        straight_side_full: new THREE.Vector3(),
        straight_side_single: new THREE.Vector3(),
        straight_side_single_reversed: new THREE.Vector3(),
        straight_side_corner: new THREE.Vector3(),
        straight_side_corner_reversed: new THREE.Vector3(),
        straight_both_sides: new THREE.Vector3(),
    };

    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // Post-processing imports
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

    // Three.quarks particle system
    import {
        ParticleSystem,
        QuarksLoader,
        BatchedParticleRenderer,
        ConstantValue,
        IntervalValue,
        ConstantColor,
        ColorRange,
        RandomColor,
        Gradient,
        ColorOverLife,
        SizeOverLife,
        RotationOverLife,
        SpeedOverLife,
        FrameOverLife,
        ForceOverLife,
        OrbitOverLife,
        WidthOverLength,
        ApplyForce,
        Rotation3DOverLife,
        SpriteBatch,
        ConeEmitter,
        SphereEmitter,
        PointEmitter,
        DonutEmitter,
        RenderMode,
        PiecewiseBezier,
        Bezier
    } from "three.quarks";

    /* =========================================================
     * 성능 최적화 유틸리티
     * ========================================================= */

    // Throttle: 지정된 간격 내 최대 한 번만 실행
    function throttle(fn, delay) {
        let lastCall = 0;
        return function(...args) {
            const now = performance.now();
            if (now - lastCall >= delay) {
                lastCall = now;
                return fn.apply(this, args);
            }
        };
    }

    // Debounce: 마지막 호출 후 지정된 시간이 지나면 실행
    function debounce(fn, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => fn.apply(this, args), delay);
        };
    }

    // 재사용 가능한 Three.js 객체 (매 프레임/이벤트마다 new 방지)
    const _tempVec3A = new THREE.Vector3();
    const _tempVec3B = new THREE.Vector3();
    const _tempVec3C = new THREE.Vector3();
    const _tempVec3D = new THREE.Vector3();
    const _tempBox3 = new THREE.Box3();
    const _tempMatrix4 = new THREE.Matrix4();

    // 캐시된 렌더러 rect (resize 시에만 업데이트)
    let cachedRendererRect = null;

    /* =========================================================
     * 반응형 UI 스케일 시스템
     * ========================================================= */
    const UI_BASE_WIDTH = 1920;  // 기준 해상도 너비
    const UI_BASE_HEIGHT = 1080; // 기준 해상도 높이
    const UI_MIN_SCALE = 0.6;    // 최소 스케일
    const UI_MAX_SCALE = 1.5;    // 최대 스케일

    function updateUIScale() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        // 너비와 높이 중 작은 비율 사용
        const scaleByWidth = width / UI_BASE_WIDTH;
        const scaleByHeight = height / UI_BASE_HEIGHT;
        let scale = Math.min(scaleByWidth, scaleByHeight);

        // 스케일 범위 제한
        scale = Math.max(UI_MIN_SCALE, Math.min(UI_MAX_SCALE, scale));

        // CSS 변수 업데이트
        document.documentElement.style.setProperty('--ui-scale', scale.toFixed(3));
    }

    // 초기 스케일 설정
    updateUIScale();

    // 창 크기 변경 시 스케일 업데이트 (디바운스 적용)
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateUIScale, 100);
    });

    // 틸트-시프트 쉐이더 (미니어처 효과)
    const TiltShiftShader = {
        uniforms: {
            'tDiffuse': { value: null },
            'blurAmount': { value: 0.0 },     // 블러 강도 (0~1)
            'focusCenter': { value: 0.5 },    // 초점 중심 (0~1, 0.5=화면 중앙)
            'focusRange': { value: 0.3 },     // 초점 범위 (작을수록 좁은 초점)
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float blurAmount;
            uniform float focusCenter;
            uniform float focusRange;
            varying vec2 vUv;

            void main() {
                vec4 color = vec4(0.0);

                // 초점 거리 계산 (상하 가장자리에서 멀어질수록 블러)
                float dist = abs(vUv.y - focusCenter);
                float blur = smoothstep(focusRange * 0.5, focusRange, dist) * blurAmount;

                if (blur > 0.001) {
                    // 가우시안 블러 샘플링 (9 샘플)
                    vec2 texelSize = vec2(1.0 / 1920.0, 1.0 / 1080.0);
                    float kernel[9];
                    kernel[0] = 0.0625; kernel[1] = 0.125; kernel[2] = 0.0625;
                    kernel[3] = 0.125;  kernel[4] = 0.25;  kernel[5] = 0.125;
                    kernel[6] = 0.0625; kernel[7] = 0.125; kernel[8] = 0.0625;

                    int index = 0;
                    for (int y = -1; y <= 1; y++) {
                        for (int x = -1; x <= 1; x++) {
                            vec2 offset = vec2(float(x), float(y)) * texelSize * blur * 8.0;
                            color += texture2D(tDiffuse, vUv + offset) * kernel[index];
                            index++;
                        }
                    }
                } else {
                    color = texture2D(tDiffuse, vUv);
                }

                gl_FragColor = color;
            }
        `
    };

    // 색상 보정 쉐이더 (채도, 밝기, 대비)
    const ColorCorrectionShader = {
        uniforms: {
            'tDiffuse': { value: null },
            'saturation': { value: 1.3 },    // 채도 (1.0 = 기본, >1 = 더 선명)
            'brightness': { value: 0.05 },   // 밝기 추가 (+/-)
            'contrast': { value: 1.1 },      // 대비 (1.0 = 기본)
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float saturation;
            uniform float brightness;
            uniform float contrast;
            varying vec2 vUv;

            void main() {
                vec4 color = texture2D(tDiffuse, vUv);

                // 밝기 조정
                color.rgb += brightness;

                // 대비 조정
                color.rgb = (color.rgb - 0.5) * contrast + 0.5;

                // 채도 조정 (luminance 기반)
                float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                color.rgb = mix(vec3(luminance), color.rgb, saturation);

                // 클램프
                color.rgb = clamp(color.rgb, 0.0, 1.0);

                gl_FragColor = color;
            }
        `
    };

    const loader = new GLTFLoader();

    /* =========================================================
     * DOM REFERENCES
     * ========================================================= */
    const moneyText = document.getElementById("moneyText");
    const costPerMeterText = document.getElementById("costPerMeterText");
    const hudCard = document.querySelector(".hud-card");
    const toastRoot = document.getElementById("toastRoot");
    const loadingEl = document.getElementById("loading");
    const saveIndicator = document.getElementById("saveIndicator");

    const canvas = document.querySelector("#c");
    const btnCam = document.getElementById("btnCam");
    const btnBuild = document.getElementById("btnBuild");
    const btnDemolish = document.getElementById("btnDemolish");
    const hint = document.getElementById("hint");
    const hintContainer = document.getElementById("hintContainer");
    const btnExitMode = document.getElementById("btnExitMode");
    const costTooltip = document.getElementById("costTooltip");
    const graphTooltip = document.getElementById("graphTooltip");

    // New Cities Skylines style buttons
    const btnZones = document.getElementById("btnZones");
    const btnPower = document.getElementById("btnPower");
    const btnWater = document.getElementById("btnWater");
    const btnSewage = document.getElementById("btnSewage");

    // Public facility buttons (individual)
    const btnPolice = document.getElementById("btnPolice");
    const btnFire = document.getElementById("btnFire");
    const btnSchool = document.getElementById("btnSchool");
    const btnHospital = document.getElementById("btnHospital");
    const btnParkBtn = document.getElementById("btnPark");

    // Submenu elements
    const subMenu = document.getElementById("subMenu");
    const submenuTitle = document.getElementById("submenuTitle");
    const submenuItems = document.getElementById("submenuItems");

    // Info panel
    const infoPanel = document.getElementById("infoPanel");

    // Left sidebar (zone stats buttons)
    const leftSidebar = document.getElementById("leftSidebar");
    const btnLandValue = document.getElementById("btnLandValue");
    const btnPopulation = document.getElementById("btnPopulation");

    // Right sidebar (road mode - traffic view)
    const rightSidebarRoad = document.getElementById("rightSidebarRoad");
    const btnTrafficView = document.getElementById("btnTrafficView");

    // Left sidebar (power mode - wind view)
    const leftSidebarPower = document.getElementById("leftSidebarPower");
    const btnWindView = document.getElementById("btnWindView");

    // Building info popup
    const buildingPopup = document.getElementById("buildingPopup");
    const popupIcon = document.getElementById("popupIcon");
    const popupTitle = document.getElementById("popupTitle");
    const popupClose = document.getElementById("popupClose");
    const popupType = document.getElementById("popupType");
    const popupTypeIcon = document.getElementById("popupTypeIcon");
    const popupTypeText = document.getElementById("popupTypeText");
    const popupPopulationRow = document.getElementById("popupPopulationRow");
    const popupPopulation = document.getElementById("popupPopulation");
    const popupHappiness = document.getElementById("popupHappiness");
    const happinessEmoji = document.getElementById("happinessEmoji");
    const happinessBarContainer = document.getElementById("happinessBarContainer");
    const happinessBarFill = document.getElementById("happinessBarFill");
    const happinessValue = document.getElementById("happinessValue");
    const citizenQuote = document.getElementById("citizenQuote");
    const citizenQuoteText = document.getElementById("citizenQuoteText");

    // Construction popup
    const constructionPopup = document.getElementById("constructionPopup");
    const constructionTitle = document.getElementById("constructionTitle");
    const constructionStatus = document.getElementById("constructionStatus");
    const constructionTotalTime = document.getElementById("constructionTotalTime");
    const constructionTimeLeft = document.getElementById("constructionTimeLeft");
    const constructionProgress = document.getElementById("constructionProgress");
    const constructionPopupClose = document.getElementById("constructionPopupClose");

    // Public building popup
    const publicBuildingPopup = document.getElementById("publicBuildingPopup");
    const publicPopupIcon = document.getElementById("publicPopupIcon");
    const publicPopupTitle = document.getElementById("publicPopupTitle");
    const publicPopupClose = document.getElementById("publicPopupClose");
    const publicPopupType = document.getElementById("publicPopupType");
    const publicPopupTypeIcon = document.getElementById("publicPopupTypeIcon");
    const publicPopupTypeText = document.getElementById("publicPopupTypeText");
    const firetruckStatusSection = document.getElementById("firetruckStatusSection");
    const firetruckBarDispatched = document.getElementById("firetruckBarDispatched");
    const firetruckBarAvailable = document.getElementById("firetruckBarAvailable");
    const firetruckDispatched = document.getElementById("firetruckDispatched");
    const firetruckAvailable = document.getElementById("firetruckAvailable");
    const firetruckTotal = document.getElementById("firetruckTotal");
    const firetruckMax = document.getElementById("firetruckMax");

    // 경찰서 현황 요소
    const policeStatusSection = document.getElementById("policeStatusSection");
    const policeBarDispatched = document.getElementById("policeBarDispatched");
    const policeBarAvailable = document.getElementById("policeBarAvailable");
    const policeDispatched = document.getElementById("policeDispatched");
    const policeAvailable = document.getElementById("policeAvailable");
    const policeTotal = document.getElementById("policeTotal");
    const policeMax = document.getElementById("policeMax");
    const prisonBarOccupied = document.getElementById("prisonBarOccupied");
    const prisonBarEmpty = document.getElementById("prisonBarEmpty");
    const prisonOccupied = document.getElementById("prisonOccupied");
    const prisonEmpty = document.getElementById("prisonEmpty");
    const prisonTotal = document.getElementById("prisonTotal");
    const prisonMax = document.getElementById("prisonMax");

    // 병원 현황 요소
    const hospitalStatusSection = document.getElementById("hospitalStatusSection");
    const ambulanceBarDispatched = document.getElementById("ambulanceBarDispatched");
    const ambulanceBarAvailable = document.getElementById("ambulanceBarAvailable");
    const ambulanceDispatched = document.getElementById("ambulanceDispatched");
    const ambulanceAvailable = document.getElementById("ambulanceAvailable");
    const ambulanceTotal = document.getElementById("ambulanceTotal");
    const ambulanceMax = document.getElementById("ambulanceMax");
    const patientBarOccupied = document.getElementById("patientBarOccupied");
    const patientBarEmpty = document.getElementById("patientBarEmpty");
    const patientOccupied = document.getElementById("patientOccupied");
    const patientEmpty = document.getElementById("patientEmpty");
    const patientTotal = document.getElementById("patientTotal");
    const patientMax = document.getElementById("patientMax");

    // 하수처리장 상태 섹션
    const wastewaterStatusSection = document.getElementById("wastewaterStatusSection");
    const wastewaterOperational = document.getElementById("wastewaterOperational");
    const wastewaterCapacity = document.getElementById("wastewaterCapacity");

    // 취수장 상태 섹션
    const waterPumpStatusSection = document.getElementById("waterPumpStatusSection");
    const waterPumpOperational = document.getElementById("waterPumpOperational");
    const waterPumpOutput = document.getElementById("waterPumpOutput");

    // 풍력발전기 확장 섹션
    const windTurbineExpansionSection = document.getElementById("windTurbineExpansionSection");
    const windTurbineCount = document.getElementById("windTurbineCount");
    const windTurbineMax = document.getElementById("windTurbineMax");
    const windTurbinePower = document.getElementById("windTurbinePower");
    const windTurbineMaintenance = document.getElementById("windTurbineMaintenance");
    const windExpansionVisual = document.getElementById("windExpansionVisual");
    const btnExpandWindTurbine = document.getElementById("btnExpandWindTurbine");
    const expansionCostText = document.getElementById("expansionCostText");
    const expansionInfo = document.getElementById("expansionInfo");

    // 태양광발전기 확장 섹션
    const solarPanelExpansionSection = document.getElementById("solarPanelExpansionSection");
    const solarPanelCount = document.getElementById("solarPanelCount");
    const solarPanelMax = document.getElementById("solarPanelMax");
    const solarPanelPower = document.getElementById("solarPanelPower");
    const solarPanelMaintenance = document.getElementById("solarPanelMaintenance");
    const solarExpansionVisual = document.getElementById("solarExpansionVisual");
    const btnExpandSolarPanel = document.getElementById("btnExpandSolarPanel");
    const solarExpansionCostText = document.getElementById("solarExpansionCostText");
    const solarExpansionInfo = document.getElementById("solarExpansionInfo");

    // Bottom bar stats
    const popBottomText = document.getElementById("popBottomText");
    const happyBottomText = document.getElementById("happyBottomText");

    /* =========================================================
     * SUBMENU SYSTEM (Cities Skylines Style)
     * ========================================================= */
    let currentSubmenu = null;

    const SUBMENU_CONFIG = {
        roads: {
            title: '🛣️ 도로/수로',
            items: [
                { id: 'road2lane', icon: '🛤️', color: '#666666', name: '2차로', desc: '기본 도로' },
                { id: 'road4lane', icon: '🛣️', color: '#888888', name: '4차로', desc: '대로' },
                { id: 'water', icon: '🌊', color: '#3b82f6', name: '수로', desc: '수로 설치' },
                { id: 'breakwater', icon: '🧱', color: '#6b7280', name: '방파제', desc: '바다+해변에 설치', size: '2x2' },
            ]
        },
        zones: {
            title: '🏘️ Zones',
            items: [
                { id: 'residential', icon: '🏠', color: '#4ade80', name: 'Residential', desc: 'Housing area' },
                { id: 'commercial', icon: '🏪', color: '#60a5fa', name: 'Commercial', desc: 'Shopping area' },
                { id: 'industrial', icon: '🏭', color: '#fbbf24', name: 'Industrial', desc: 'Factory area' },
                { id: 'delete', icon: '❌', color: '#ef4444', name: 'Delete', desc: 'Remove zone' },
            ]
        },
        buildings: {
            title: '🏛️ Buildings',
            items: [
                { id: 'park', icon: '🌳', cost: 1000, name: 'Park', desc: '+10 Happiness' },
                { id: 'school', icon: '🏫', cost: 4000, name: 'School', desc: 'Education' },
                { id: 'hospital', icon: '🏥', cost: 6000, name: 'Hospital', desc: 'Healthcare' },
            ]
        },
        power: {
            title: '⚡ 전력',
            items: [
                { id: 'powerplant_coal', icon: '🏭', cost: 5000, maintenance: 100, name: '화력 발전소', desc: '석탄을 태워 전기를 생산합니다. 대용량이지만 오염을 유발합니다.', powerOutput: 500, effectRadius: 15, size: '2x2' },
                { id: 'powerplant_wind', icon: '💨', cost: 3000, maintenance: 30, name: '풍력 발전소', desc: '바람으로 전기를 생산합니다. 친환경이지만 소용량입니다.', powerOutput: 100, effectRadius: 8, size: '3x4' },
                { id: 'powerplant_solar', icon: '☀️', cost: 4000, maintenance: 40, name: '태양광 발전소', desc: '태양광으로 전기를 생산합니다. 친환경 중용량 발전소입니다.', powerOutput: 150, effectRadius: 10, size: '3x4' },
            ]
        },
        waterSupply: {
            title: '💧 수도',
            items: [
                { id: 'water_pump_coast', icon: '🌊', cost: 6000, maintenance: 80, name: '해안 취수장', desc: '바닷물을 담수화하여 수도를 공급합니다. 방파제 옆에만 설치 가능합니다.', waterOutput: 600, effectRadius: 15, size: '2x4', requiresBreakwater: true },
            ]
        },
        sewage: {
            title: '🚽 하수',
            items: [
                { id: 'wastewater', icon: '🏭', cost: 8000, maintenance: 100, name: '하수처리장', desc: '도시의 하수를 처리합니다. 방파제 옆에만 설치 가능합니다.', sewageCapacity: 500, effectRadius: 15, size: '2x4', requiresBreakwater: true },
            ]
        },
        services: {
            title: '🚒 Services',
            items: [
                { id: 'police', icon: '🚔', cost: 3000, name: 'Police', desc: 'Crime prevention', size: '2x2' },
                { id: 'fire', icon: '🚒', cost: 3000, name: 'Fire Station', desc: 'Fire prevention', size: '2x2' },
                { id: 'school', icon: '🏫', cost: 4000, name: 'School', desc: 'Education', size: '2x2' },
                { id: 'park', icon: '🌳', cost: 1000, name: 'Park', desc: '+10 Happiness', size: '2x2' },
            ]
        },
        fire: {
            title: '🚒 소방서',
            items: [
                { id: 'fire_small', icon: '🚒', cost: 3000, maintenance: 50, powerUsage: 15, name: '동네 소방서', desc: '화재 예방 및 신속한 진압으로 건물과 시민을 보호합니다.', effectRadius: 8, size: '2x2' },
                { id: 'fire_large', icon: '🏢', cost: 8000, maintenance: 120, powerUsage: 40, name: '대형 소방서', desc: '넓은 범위의 화재에 대응할 수 있는 대형 시설입니다. (미구현)', effectRadius: 15, size: '3x3', disabled: true },
            ]
        },
        police: {
            title: '🚔 경찰서',
            items: [
                { id: 'police_small', icon: '🚔', cost: 3000, maintenance: 60, powerUsage: 12, name: '소형 경찰서', desc: '범죄를 예방하고 치안을 유지하여 시민들의 안전을 보장합니다.', effectRadius: 8, size: '2x2' },
                { id: 'police_large', icon: '🏛️', cost: 8000, maintenance: 150, powerUsage: 35, name: '대형 경찰서', desc: '광범위한 지역의 치안을 담당하는 대형 시설입니다. (미구현)', effectRadius: 15, size: '3x3', disabled: true },
            ]
        },
        school: {
            title: '🏫 학교',
            items: [
                { id: 'school_small', icon: '🏫', cost: 4000, maintenance: 80, powerUsage: 20, name: '초등학교', desc: '시민들에게 교육 서비스를 제공하여 중류층 전환율을 높입니다.', effectRadius: 10, size: '2x2' },
                { id: 'school_large', icon: '🎓', cost: 10000, maintenance: 200, powerUsage: 50, name: '고등학교', desc: '고급 교육을 제공하여 상류층 전환율을 높입니다. (미구현)', effectRadius: 18, size: '3x3', disabled: true },
            ]
        },
        park: {
            title: '🌳 공원',
            items: [
                { id: 'park_small', icon: '🌳', cost: 1000, maintenance: 20, powerUsage: 5, name: '소형 공원', desc: '녹지 공간을 제공하여 시민들의 행복도를 높입니다.', effectRadius: 5, size: '2x2' },
                { id: 'park_large', icon: '🏞️', cost: 5000, maintenance: 50, powerUsage: 15, name: '대형 공원', desc: '넓은 녹지 공간으로 더 많은 시민에게 휴식을 제공합니다. (미구현)', effectRadius: 10, size: '3x3', disabled: true },
            ]
        },
        hospital: {
            title: '🏥 병원',
            items: [
                { id: 'hospital_small', icon: '🏥', cost: 6000, maintenance: 100, powerUsage: 30, name: '동네 병원', desc: '시민들에게 의료 서비스를 제공하여 상류층 전환율을 높이고 행복도를 증가시킵니다.', effectRadius: 12, size: '2x2' },
                { id: 'hospital_large', icon: '🏨', cost: 15000, maintenance: 250, powerUsage: 80, name: '종합병원', desc: '넓은 지역에 고급 의료 서비스를 제공합니다. (미구현)', effectRadius: 20, size: '3x3', disabled: true },
            ]
        }
    };

    // ===== SUBMENU TOOLTIP FUNCTIONS =====
    const submenuTooltip = document.getElementById('submenuTooltip');
    const tooltipIcon = document.getElementById('tooltipIcon');
    const tooltipName = document.getElementById('tooltipName');
    const tooltipCost = document.getElementById('tooltipCost');
    const tooltipMaintenance = document.getElementById('tooltipMaintenance');
    const tooltipPowerUsage = document.getElementById('tooltipPowerUsage');
    const tooltipDesc = document.getElementById('tooltipDesc');

    function showSubmenuTooltip(item, x, y) {
        if (!submenuTooltip) return;

        tooltipIcon.textContent = item.icon || '🏛️';
        tooltipName.textContent = item.name || '';
        tooltipCost.textContent = item.cost ? `${i18n.getCurrency()}${item.cost.toLocaleString()}` : '-';
        tooltipMaintenance.textContent = item.maintenance ? `${i18n.getCurrency()}${item.maintenance}/시간` : '-';
        tooltipPowerUsage.textContent = item.powerUsage ? `${item.powerUsage} kW` : '-';
        tooltipDesc.textContent = item.desc || '';

        submenuTooltip.style.display = 'block';
        updateSubmenuTooltipPosition(x, y);
    }

    function updateSubmenuTooltipPosition(x, y) {
        if (!submenuTooltip) return;

        const tooltipWidth = submenuTooltip.offsetWidth;
        const tooltipHeight = submenuTooltip.offsetHeight;

        // 툴팁을 마우스 위에 표시 (서브메뉴보다 위로)
        let posX = x - tooltipWidth / 2;
        let posY = y - tooltipHeight - 20;

        // 화면 경계 체크
        if (posX < 10) posX = 10;
        if (posX + tooltipWidth > window.innerWidth - 10) {
            posX = window.innerWidth - tooltipWidth - 10;
        }
        if (posY < 10) {
            posY = y + 20;  // 위에 공간 없으면 아래로
        }

        submenuTooltip.style.left = posX + 'px';
        submenuTooltip.style.top = posY + 'px';
    }

    function hideSubmenuTooltip() {
        if (submenuTooltip) {
            submenuTooltip.style.display = 'none';
        }
    }

    function openSubMenu(type) {
        if (currentSubmenu === type && subMenu.classList.contains('open')) {
            closeSubMenu();
            return;
        }

        const config = SUBMENU_CONFIG[type];
        if (!config) return;

        currentSubmenu = type;
        submenuTitle.textContent = config.title;
        submenuItems.innerHTML = '';

        const activeItemId = getActiveSubmenuItemId();
        config.items.forEach(item => {
            const el = document.createElement('div');
            const isActive = item.id === activeItemId;
            el.className = 'submenu-item' + (item.disabled ? ' disabled' : '') + (isActive ? ' active' : '');
            el.dataset.itemId = item.id;  // 아이템 ID 저장
            el.innerHTML = `
                <div class="color-box" style="background: ${item.color || '#666'};">${item.icon}</div>
                <div class="name">${item.name}</div>
                ${item.cost ? `<div class="cost">${i18n.getCurrency()}${item.cost}</div>` : ''}
            `;
            el.addEventListener('click', () => handleSubmenuClick(type, item.id));

            // 서비스 건물 툴팁 (운영비, 설명 포함)
            if (item.maintenance !== undefined || item.effectRadius !== undefined) {
                el.addEventListener('mouseenter', (e) => {
                    showSubmenuTooltip(item, e.clientX, e.clientY);
                });
                el.addEventListener('mousemove', (e) => {
                    updateSubmenuTooltipPosition(e.clientX, e.clientY);
                });
                el.addEventListener('mouseleave', () => {
                    hideSubmenuTooltip();
                });
            }

            submenuItems.appendChild(el);
        });

        // Update button states
        updateToolButtonStates(type);

        subMenu.classList.add('open');
        if (hintContainer) hintContainer.classList.add('submenu-open');

        // 서브메뉴 열릴 때: 먼저 모든 사이드바 숨기고 해당 사이드바만 표시 (라디오 버튼처럼)
        // 모든 사이드바 숨기기
        if (leftSidebar) leftSidebar.classList.remove('visible');
        if (rightSidebarRoad) rightSidebarRoad.classList.remove('visible');

        // 뷰 모드도 해제
        if (type !== 'zones') {
            // 구역 관련 뷰 모드 해제
            if (currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW) {
                setMode(MODE.CAMERA);
            }
        }
        if (type !== 'roads') {
            // 도로 관련 뷰 모드 해제
            if (currentMode === MODE.TRAFFIC_VIEW) {
                setMode(MODE.CAMERA);
            }
        }
        if (type !== 'power') {
            // 전력 관련 뷰 모드 해제
            if (currentMode === MODE.POWER_VIEW) {
                setMode(MODE.CAMERA);
                powerManager.updatePowerVisualization();
            }
        }

        // 해당 서브메뉴 사이드바만 표시
        if (type === 'roads') {
            // 도로/수로 서브메뉴 → 교통량 토글 표시
            if (rightSidebarRoad) rightSidebarRoad.classList.add('visible');
        } else if (type === 'zones') {
            // 구역 서브메뉴 → 땅값/인구 토글 표시
            if (leftSidebar) leftSidebar.classList.add('visible');
        } else if (type === 'power') {
            // 전력 서브메뉴 → 풍량 토글 표시
            if (leftSidebarPower) leftSidebarPower.classList.add('visible');
        }

        // 일일 통계 패널 표시/숨김
        const fireStatsPanel = document.getElementById('fireStatsPanel');
        const crimeStatsPanel = document.getElementById('crimeStatsPanel');
        const medicalStatsPanel = document.getElementById('medicalStatsPanel');

        if (fireStatsPanel) fireStatsPanel.style.display = 'none';
        if (crimeStatsPanel) crimeStatsPanel.style.display = 'none';
        if (medicalStatsPanel) medicalStatsPanel.style.display = 'none';

        if (type === 'fire') {
            if (fireStatsPanel) {
                fireStatsPanel.style.display = 'block';
                updateDailyStatsPanel();
            }
        } else if (type === 'police') {
            if (crimeStatsPanel) {
                crimeStatsPanel.style.display = 'block';
                updateDailyStatsPanel();
            }
        } else if (type === 'hospital') {
            if (medicalStatsPanel) {
                medicalStatsPanel.style.display = 'block';
                updateDailyStatsPanel();
            }
        }
    }

    function closeSubMenu() {
        // 서브메뉴 닫힐 때 현재 모드가 해당 뷰 모드가 아니면 사이드바도 숨김
        if (currentSubmenu === 'roads') {
            const isRoadMode = currentMode === MODE.BUILD || currentMode === MODE.BUILD_4LANE || currentMode === MODE.WATER || currentMode === MODE.TRAFFIC_VIEW;
            if (!isRoadMode && rightSidebarRoad) {
                rightSidebarRoad.classList.remove('visible');
                if (btnTrafficView) btnTrafficView.classList.remove('active');
            }
        } else if (currentSubmenu === 'zones') {
            const isZoneModeActive = isZoneMode() || currentMode === MODE.ZONE_DELETE ||
                                     currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW;
            if (!isZoneModeActive && leftSidebar) {
                leftSidebar.classList.remove('visible');
            }
        } else if (currentSubmenu === 'power') {
            const isPowerModeActive = currentMode === MODE.PLACE_POWER_COAL ||
                                      currentMode === MODE.PLACE_POWER_WIND ||
                                      currentMode === MODE.PLACE_POWER_SOLAR ||
                                      currentMode === MODE.POWER_VIEW ||
                                      currentMode === MODE.WIND_VIEW;
            if (!isPowerModeActive) {
                powerManager.updatePowerVisualization();
                if (leftSidebarPower) {
                    leftSidebarPower.classList.remove('visible');
                    if (btnWindView) btnWindView.classList.remove('active');
                }
            }
        }

        subMenu.classList.remove('open');
        currentSubmenu = null;
        if (hintContainer) hintContainer.classList.remove('submenu-open');

        // 일일 통계 패널 숨기기
        const fireStatsPanel = document.getElementById('fireStatsPanel');
        const crimeStatsPanel = document.getElementById('crimeStatsPanel');
        const medicalStatsPanel = document.getElementById('medicalStatsPanel');
        if (fireStatsPanel) fireStatsPanel.style.display = 'none';
        if (crimeStatsPanel) crimeStatsPanel.style.display = 'none';
        if (medicalStatsPanel) medicalStatsPanel.style.display = 'none';
    }

    // Make closeSubMenu globally accessible for onclick
    window.closeSubMenu = closeSubMenu;

    /**
     * 모든 서비스 관련 패널 숨기기 (토글 비활성화 시 호출)
     */
    function hideAllServicePanels() {
        // 일일 통계 패널 숨기기
        const fireStatsPanel = document.getElementById('fireStatsPanel');
        const crimeStatsPanel = document.getElementById('crimeStatsPanel');
        const medicalStatsPanel = document.getElementById('medicalStatsPanel');
        if (fireStatsPanel) fireStatsPanel.style.display = 'none';
        if (crimeStatsPanel) crimeStatsPanel.style.display = 'none';
        if (medicalStatsPanel) medicalStatsPanel.style.display = 'none';

        // 건물 팝업 숨기기
        if (typeof hidePublicBuildingPopup === 'function') {
            hidePublicBuildingPopup();
        }
        if (typeof hideBuildingPopup === 'function') {
            hideBuildingPopup();
        }

        // 서비스 뷰 범례 숨기기
        if (typeof hideServiceViewLegend === 'function') {
            hideServiceViewLegend();
        }
    }

    function handleSubmenuClick(type, itemId) {
        if (type === 'roads') {
            switch(itemId) {
                case 'road2lane':
                    setMode(MODE.BUILD);
                    break;
                case 'road4lane':
                    setMode(MODE.BUILD_4LANE);
                    break;
                case 'water':
                    setMode(MODE.WATER);
                    break;
                case 'breakwater':
                    setMode(MODE.PLACE_BREAKWATER);
                    break;
            }
        } else if (type === 'zones') {
            switch(itemId) {
                case 'residential':
                    setMode(MODE.ZONE_RESIDENTIAL);
                    break;
                case 'commercial':
                    setMode(MODE.ZONE_COMMERCIAL);
                    break;
                case 'industrial':
                    setMode(MODE.ZONE_INDUSTRIAL);
                    break;
                case 'delete':
                    setMode(MODE.ZONE_DELETE);
                    break;
            }
        } else if (type === 'services') {
            switch(itemId) {
                case 'police':
                    setMode(MODE.PLACE_POLICE);
                    break;
                case 'fire':
                    setMode(MODE.PLACE_FIRE);
                    break;
                case 'school':
                    setMode(MODE.PLACE_SCHOOL);
                    break;
                case 'park':
                    setMode(MODE.PLACE_PARK);
                    break;
            }
        } else if (type === 'fire') {
            switch(itemId) {
                case 'fire_small':
                    setMode(MODE.PLACE_FIRE);
                    break;
                case 'fire_large':
                    toast({
                        title: '미구현',
                        desc: '대형 소방서는 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'police') {
            switch(itemId) {
                case 'police_small':
                    setMode(MODE.PLACE_POLICE);
                    break;
                case 'police_large':
                    toast({
                        title: '미구현',
                        desc: '대형 경찰서는 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'school') {
            switch(itemId) {
                case 'school_small':
                    setMode(MODE.PLACE_SCHOOL);
                    break;
                case 'school_large':
                    toast({
                        title: '미구현',
                        desc: '고등학교는 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'park') {
            switch(itemId) {
                case 'park_small':
                    setMode(MODE.PLACE_PARK);
                    break;
                case 'park_large':
                    toast({
                        title: '미구현',
                        desc: '대형 공원은 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'hospital') {
            switch(itemId) {
                case 'hospital_small':
                    setMode(MODE.PLACE_HOSPITAL);
                    break;
                case 'hospital_large':
                    toast({
                        title: '미구현',
                        desc: '종합병원은 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'power') {
            switch(itemId) {
                case 'powerplant_coal':
                    setMode(MODE.PLACE_POWER_COAL);
                    break;
                case 'powerplant_wind':
                    setMode(MODE.PLACE_POWER_WIND);
                    break;
                case 'powerplant_solar':
                    setMode(MODE.PLACE_POWER_SOLAR);
                    break;
            }
        } else if (type === 'waterSupply') {
            switch(itemId) {
                case 'water_pump_coast':
                    setMode(MODE.PLACE_WATER_PUMP_COAST);
                    break;
            }
        } else if (type === 'sewage') {
            switch(itemId) {
                case 'wastewater':
                    setMode(MODE.PLACE_WASTEWATER);
                    break;
            }
        } else if (type === 'buildings') {
            toast({
                title: i18n.t('toast.comingSoon') || 'Coming Soon',
                desc: i18n.t('toast.comingSoonDesc') || 'This feature will be available soon!',
            });
        }
        // 서브메뉴 닫지 않음 - 사용자가 계속 다른 건물을 선택할 수 있도록

        // 선택된 아이템 활성화 표시 업데이트
        updateSubmenuActiveState();
    }

    // 현재 모드에 해당하는 서브메뉴 아이템 ID 반환
    function getActiveSubmenuItemId() {
        switch(currentMode) {
            // 도로
            case MODE.BUILD: return 'road2lane';
            case MODE.BUILD_4LANE: return 'road4lane';
            case MODE.WATER: return 'water';
            case MODE.PLACE_BREAKWATER: return 'breakwater';
            // 구역
            case MODE.ZONE_RESIDENTIAL: return 'residential';
            case MODE.ZONE_COMMERCIAL: return 'commercial';
            case MODE.ZONE_INDUSTRIAL: return 'industrial';
            case MODE.ZONE_DELETE: return 'delete';
            // 소방서
            case MODE.PLACE_FIRE: return 'fire_small';
            // 경찰서
            case MODE.PLACE_POLICE: return 'police_small';
            // 학교
            case MODE.PLACE_SCHOOL: return 'school_small';
            // 공원
            case MODE.PLACE_PARK: return 'park_small';
            // 병원
            case MODE.PLACE_HOSPITAL: return 'hospital_small';
            // 발전소
            case MODE.PLACE_POWER_COAL: return 'powerplant_coal';
            case MODE.PLACE_POWER_WIND: return 'powerplant_wind';
            case MODE.PLACE_POWER_SOLAR: return 'powerplant_solar';
            // 수도
            case MODE.PLACE_WATER_PUMP_COAST: return 'water_pump_coast';
            // 하수
            case MODE.PLACE_WASTEWATER: return 'wastewater';
            default: return null;
        }
    }

    // 서브메뉴 아이템 활성화 상태 업데이트
    function updateSubmenuActiveState() {
        if (!submenuItems) return;
        const activeItemId = getActiveSubmenuItemId();
        const items = submenuItems.querySelectorAll('.submenu-item');
        items.forEach(item => {
            const itemId = item.dataset.itemId;
            if (itemId === activeItemId) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
    }

    function updateToolButtonStates(activeType) {
        clearToolButtonActive();
        if (activeType === 'roads' && btnBuild) btnBuild.classList.add('active');
        if (activeType === 'zones' && btnZones) btnZones.classList.add('active');
        if (activeType === 'power' && btnPower) btnPower.classList.add('active');
        if (activeType === 'waterSupply' && btnWater) btnWater.classList.add('active');
        if (activeType === 'sewage' && btnSewage) btnSewage.classList.add('active');
        if (activeType === 'fire' && btnFire) btnFire.classList.add('active');
        if (activeType === 'police' && btnPolice) btnPolice.classList.add('active');
        if (activeType === 'school' && btnSchool) btnSchool.classList.add('active');
        if (activeType === 'hospital' && btnHospital) btnHospital.classList.add('active');
        if (activeType === 'park' && btnParkBtn) btnParkBtn.classList.add('active');
    }

    function clearToolButtonActive() {
        btnCam.classList.remove('active');
        if (btnBuild) btnBuild.classList.remove('active');
        if (btnZones) btnZones.classList.remove('active');
        if (btnPower) btnPower.classList.remove('active');
        if (btnWater) btnWater.classList.remove('active');
        if (btnSewage) btnSewage.classList.remove('active');
        if (btnDemolish) btnDemolish.classList.remove('active');
        // Public facility buttons
        if (btnPolice) btnPolice.classList.remove('active');
        if (btnFire) btnFire.classList.remove('active');
        if (btnSchool) btnSchool.classList.remove('active');
        if (btnHospital) btnHospital.classList.remove('active');
        if (btnParkBtn) btnParkBtn.classList.remove('active');
    }

    // Toggle info panel (collapsible)
    function toggleInfoPanel() {
        if (infoPanel) {
            infoPanel.classList.toggle('collapsed');
        }
    }
    window.toggleInfoPanel = toggleInfoPanel;

    /* =========================================================
     * TEST MODE (테스트용 - 돈 무한, DB 저장 비활성화)
     * ========================================================= */
    const TEST_MODE = false;  // DB 연동 활성화
    const UNLIMITED_MONEY = true;  // 테스트용: 자금 무한 (DB 저장은 유지)

    /* =========================================================
     * ECONOMY
     * ========================================================= */
    const economy = {
        money: UNLIMITED_MONEY ? 9999999 : 5000,
        roadCostPerMeter: 25,
    };

    /* =========================================================
     * BUDGET SYSTEM (예산 시스템)
     * ========================================================= */
    const budgetSystem = {
        // 세금율 (0~20%, 기본 10%)
        taxRates: {
            residential: 10,
            commercial: 10,
            industrial: 10
        },
        // 발행된 채권
        issuedBonds: {
            A: false,
            B: false,
            C: false
        },
        // 채권 정보
        bondInfo: {
            A: { amount: 10000, interest: 0.05 },
            B: { amount: 50000, interest: 0.07 },
            C: { amount: 100000, interest: 0.10 }
        },
        // 계산된 값들
        taxIncome: { residential: 0, commercial: 0, industrial: 0, total: 0 },
        operatingCost: { fire: 0, police: 0, school: 0, park: 0, total: 0 },
        buildingCounts: { fire: 0, police: 0, school: 0, park: 0 },
        debtInterest: 0,
        totalDebt: 0,
        netProfit: 0
    };

    // 배치된 공공시설 Map (조기 초기화 - TDZ 방지)
    let placedPublicBuildings = new Map();

    // 예산 패널 DOM 요소
    const budgetPanel = document.getElementById('budgetPanel');
    const btnCloseBudget = document.getElementById('btnCloseBudget');

    // 중앙 자금 표시 DOM 요소 (하단 툴바)
    const moneyDisplayCenter = document.getElementById('moneyDisplayCenter');
    const moneyRateCenter = document.getElementById('moneyRateCenter');

    // 인구 패널 DOM 요소
    const populationPanel = document.getElementById('populationPanel');
    const populationDisplayBtn = document.getElementById('populationDisplayBtn');
    const btnClosePopulation = document.getElementById('btnClosePopulation');
    const popDisplayCenter = document.getElementById('popDisplayCenter');

    // 인구 패널 세부 요소
    const popTotalValue = document.getElementById('popTotalValue');
    const popResidentialBuildings = document.getElementById('popResidentialBuildings');
    const popAvgPerBuilding = document.getElementById('popAvgPerBuilding');
    const tierBarMiddle = document.getElementById('tierBarMiddle');
    const tierBarHigh = document.getElementById('tierBarHigh');
    const tierValueMiddle = document.getElementById('tierValueMiddle');
    const tierValueHigh = document.getElementById('tierValueHigh');

    // 연령별 인구 요소 - 원형 그래프
    const pieChildren = document.getElementById('pieChildren');
    const pieYouth = document.getElementById('pieYouth');
    const pieAdults = document.getElementById('pieAdults');
    const pieElderly = document.getElementById('pieElderly');
    const pieTotalPop = document.getElementById('pieTotalPop');
    const ageLegendChildren = document.getElementById('ageLegendChildren');
    const ageLegendYouth = document.getElementById('ageLegendYouth');
    const ageLegendAdults = document.getElementById('ageLegendAdults');
    const ageLegendElderly = document.getElementById('ageLegendElderly');
    const agePctChildren = document.getElementById('agePctChildren');
    const agePctYouth = document.getElementById('agePctYouth');
    const agePctAdults = document.getElementById('agePctAdults');
    const agePctElderly = document.getElementById('agePctElderly');
    const ageBirthRate = document.getElementById('ageBirthRate');
    const ageDeathRate = document.getElementById('ageDeathRate');
    const ageWorkforce = document.getElementById('ageWorkforce');
    const PIE_CIRCUMFERENCE = 2 * Math.PI * 40;  // 원 둘레 (r=40)

    // 서비스 커버리지 요소
    const serviceCoverageSchool = document.getElementById('serviceCoverageSchool');
    const serviceCoverageSchoolValue = document.getElementById('serviceCoverageSchoolValue');
    const serviceCoverageHospital = document.getElementById('serviceCoverageHospital');
    const serviceCoverageHospitalValue = document.getElementById('serviceCoverageHospitalValue');
    const serviceCoveragePark = document.getElementById('serviceCoveragePark');
    const serviceCoverageParkValue = document.getElementById('serviceCoverageParkValue');

    // 예산 패널 세부 요소
    const barResidential = document.getElementById('barResidential');
    const barCommercial = document.getElementById('barCommercial');
    const barIndustrial = document.getElementById('barIndustrial');
    const valResidential = document.getElementById('valResidential');
    const valCommercial = document.getElementById('valCommercial');
    const valIndustrial = document.getElementById('valIndustrial');
    const taxResidential = document.getElementById('taxResidential');
    const taxCommercial = document.getElementById('taxCommercial');
    const taxIndustrial = document.getElementById('taxIndustrial');
    const taxResidentialPercent = document.getElementById('taxResidentialPercent');
    const taxCommercialPercent = document.getElementById('taxCommercialPercent');
    const taxIndustrialPercent = document.getElementById('taxIndustrialPercent');

    const barFireExpense = document.getElementById('barFireExpense');
    const barPoliceExpense = document.getElementById('barPoliceExpense');
    const barSchoolExpense = document.getElementById('barSchoolExpense');
    const barParkExpense = document.getElementById('barParkExpense');
    const valFireExpense = document.getElementById('valFireExpense');
    const valPoliceExpense = document.getElementById('valPoliceExpense');
    const valSchoolExpense = document.getElementById('valSchoolExpense');
    const valParkExpense = document.getElementById('valParkExpense');
    const countFire = document.getElementById('countFire');
    const countPolice = document.getElementById('countPolice');
    const countSchool = document.getElementById('countSchool');
    const countPark = document.getElementById('countPark');

    const totalIncomeEl = document.getElementById('totalIncome');
    const totalExpenseEl = document.getElementById('totalExpense');
    const netProfitEl = document.getElementById('netProfit');
    const totalDebtEl = document.getElementById('totalDebt');
    const debtInterestEl = document.getElementById('debtInterest');
    const totalAssetsEl = document.getElementById('totalAssets');

    const btnBondA = document.getElementById('btnBondA');
    const btnBondB = document.getElementById('btnBondB');
    const btnBondC = document.getElementById('btnBondC');
    const bondCardA = document.getElementById('bondA');
    const bondCardB = document.getElementById('bondB');
    const bondCardC = document.getElementById('bondC');

    function formatMoney(n) {
        return i18n.formatMoney(Math.max(0, Math.floor(n)));
    }

    function updateCurrencySymbols() {
        const currency = i18n.getCurrency();
        const symbols = document.querySelectorAll('#currencySymbol, #offlineCurrency, #rewardCurrency');
        symbols.forEach(el => { if (el) el.textContent = currency; });
    }

    function renderMoney() {
        if (moneyText) moneyText.textContent = formatMoney(economy.money);
        if (costPerMeterText) costPerMeterText.textContent = formatMoney(economy.roadCostPerMeter);

        // 예산 패널이 열려있으면 총 자산도 업데이트
        if (budgetPanel && budgetPanel.classList.contains('open') && totalAssetsEl) {
            const assets = economy.money - budgetSystem.totalDebt;
            const sign = assets < 0 ? '-' : '';
            totalAssetsEl.textContent = sign + i18n.getCurrency() + formatMoney(Math.abs(assets));
            totalAssetsEl.style.color = assets >= 0 ? '#4ade80' : '#f87171';
        }
    }

    function flashMoney() {
        if (!hudCard) return;
        hudCard.classList.remove("money-flash");
        void hudCard.offsetWidth;
        hudCard.classList.add("money-flash");
    }

    function canSpend(amount) {
        return economy.money >= amount;
    }

    function toast({ title, desc, ms = 2200, success = false }) {
        const el = document.createElement("div");
        el.className = "toast";
        el.innerHTML = `
            <div class="bar ${success ? 'success' : ''}"></div>
            <div class="body">
              <div class="icon ${success ? 'success' : ''}">${success ? '✓' : '!'}</div>
              <div>
                <div class="title">${title}</div>
                <div class="desc">${desc}</div>
              </div>
            </div>
        `;
        toastRoot.appendChild(el);
        setTimeout(() => {
            el.classList.add("out");
            setTimeout(() => el.remove(), 220);
        }, ms);
    }

    function trySpend(amount, reasonText) {
        // 테스트 모드: 항상 성공, 비용 차감 안함
        if (TEST_MODE || UNLIMITED_MONEY) {
            return true;
        }

        if (!canSpend(amount)) {
            toast({
                title: i18n.t('toast.insufficientFunds'),
                desc: i18n.t('toast.insufficientFundsDesc', {
                    item: reasonText,
                    cost: i18n.getCurrency() + formatMoney(amount),
                    current: i18n.getCurrency() + formatMoney(economy.money)
                }),
            });
            return false;
        }
        economy.money -= amount;
        renderMoney();
        flashMoney();
        return true;
    }

    function calcRoadCostByLengthMeters(lengthMeters) {
        return Math.ceil(lengthMeters * economy.roadCostPerMeter);
    }

    // 경로 기반 비용 계산
    function calcPathCost(path) {
        if (!path || path.length === 0) return 0;
        // 각 타일은 1미터로 계산
        return calcRoadCostByLengthMeters(path.length);
    }

    renderMoney();

    // ========== 예산 계산 함수들 ==========

    // 서비스 건물 수 계산
    function countServiceBuildings() {
        const counts = { fire: 0, police: 0, school: 0, park: 0, hospital: 0 };

        if (typeof placedPublicBuildings !== 'undefined') {
            placedPublicBuildings.forEach((building, key) => {
                // ref가 있는 항목은 참조이므로 스킵 (중복 카운트 방지)
                if (building && building.type && !building.ref && counts.hasOwnProperty(building.type)) {
                    counts[building.type]++;
                }
            });
        }

        budgetSystem.buildingCounts = counts;
        return counts;
    }

    // 서비스 운영비 계산
    function calculateOperatingCosts() {
        const counts = countServiceBuildings();
        // PUBLIC_BUILDING_MODELS가 아직 정의되지 않은 경우 기본값 사용
        const models = typeof PUBLIC_BUILDING_MODELS !== 'undefined' ? PUBLIC_BUILDING_MODELS : null;
        const costs = {
            fire: counts.fire * (models?.fire?.maintenanceCost || 50),
            police: counts.police * (models?.police?.maintenanceCost || 60),
            school: counts.school * (models?.school?.maintenanceCost || 80),
            park: counts.park * (models?.park?.maintenanceCost || 20),
            hospital: counts.hospital * (models?.hospital?.maintenanceCost || 100),
            total: 0
        };

        costs.total = costs.fire + costs.police + costs.school + costs.park + costs.hospital;
        budgetSystem.operatingCost = costs;
        return costs;
    }

    // 건물별 세금 계산 (건물 레벨 × 시민 수 × 세금율)
    function calculateTaxIncome() {
        const income = { residential: 0, commercial: 0, industrial: 0, total: 0 };

        // 건물 데이터에서 세금 계산
        if (typeof buildingDataMap !== 'undefined') {
            for (const [key, data] of buildingDataMap.entries()) {
                if (!data || !data.zoneType) continue;

                const level = data.level || 1;
                const citizens = data.population || 0;

                // 기본 세금 (레벨 × 시민 수 × 세금율)
                const baseTax = level * citizens;

                switch (data.zoneType) {
                    case 'residential':
                        income.residential += baseTax * (budgetSystem.taxRates.residential / 100);
                        break;
                    case 'commercial':
                        income.commercial += baseTax * (budgetSystem.taxRates.commercial / 100);
                        break;
                    case 'industrial':
                        income.industrial += baseTax * (budgetSystem.taxRates.industrial / 100);
                        break;
                }
            }
        }

        // 구역 타일 기반 기본 세금 (건물 데이터 없을 경우 보완)
        if (income.residential === 0 && typeof cityStats !== 'undefined') {
            income.residential = (cityStats.residentialTiles || 0) * 10 * (budgetSystem.taxRates.residential / 100);
            income.commercial = (cityStats.commercialTiles || 0) * 15 * (budgetSystem.taxRates.commercial / 100);
            income.industrial = (cityStats.industrialTiles || 0) * 12 * (budgetSystem.taxRates.industrial / 100);
        }

        income.total = income.residential + income.commercial + income.industrial;
        budgetSystem.taxIncome = income;
        return income;
    }

    // 채권 이자 계산
    function calculateDebtInterest() {
        let totalDebt = 0;
        let interestPerHour = 0;

        for (const [bondId, issued] of Object.entries(budgetSystem.issuedBonds)) {
            if (issued) {
                const info = budgetSystem.bondInfo[bondId];
                totalDebt += info.amount;
                interestPerHour += info.amount * info.interest;
            }
        }

        budgetSystem.totalDebt = totalDebt;
        budgetSystem.debtInterest = interestPerHour;
        return { totalDebt, interestPerHour };
    }

    // 순이익 계산
    function calculateNetProfit() {
        const income = calculateTaxIncome();
        const costs = calculateOperatingCosts();
        const debt = calculateDebtInterest();

        const netProfit = income.total - costs.total - debt.interestPerHour;
        budgetSystem.netProfit = netProfit;
        return netProfit;
    }

    // 예산 UI 업데이트 (중앙 자금 표시)
    function updateBudgetDisplay() {
        const netProfit = calculateNetProfit();

        // 중앙 자금 표시 업데이트 (SimCity 스타일)
        if (moneyDisplayCenter) {
            moneyDisplayCenter.textContent = formatMoney(economy.money);
        }
        if (moneyRateCenter) {
            const sign = netProfit >= 0 ? '+' : '';
            moneyRateCenter.textContent = sign + i18n.getCurrency() + formatMoney(Math.abs(netProfit)) + '/h';
            moneyRateCenter.className = 'money-rate' + (netProfit < 0 ? ' negative' : '');
        }
    }

    // 예산 패널 UI 업데이트
    function updateBudgetPanel() {
        const income = budgetSystem.taxIncome;
        const costs = budgetSystem.operatingCost;
        const counts = budgetSystem.buildingCounts;

        // 최대값 계산 (그래프 비율 기준)
        const maxIncome = Math.max(income.residential, income.commercial, income.industrial, 1);
        const maxExpense = Math.max(costs.fire, costs.police, costs.school, costs.park, 1);

        // 수입 바
        if (barResidential) barResidential.style.width = (income.residential / maxIncome * 100) + '%';
        if (barCommercial) barCommercial.style.width = (income.commercial / maxIncome * 100) + '%';
        if (barIndustrial) barIndustrial.style.width = (income.industrial / maxIncome * 100) + '%';

        if (valResidential) valResidential.textContent = i18n.getCurrency() + formatMoney(income.residential);
        if (valCommercial) valCommercial.textContent = i18n.getCurrency() + formatMoney(income.commercial);
        if (valIndustrial) valIndustrial.textContent = i18n.getCurrency() + formatMoney(income.industrial);

        // 지출 바
        if (barFireExpense) barFireExpense.style.width = (costs.fire / maxExpense * 100) + '%';
        if (barPoliceExpense) barPoliceExpense.style.width = (costs.police / maxExpense * 100) + '%';
        if (barSchoolExpense) barSchoolExpense.style.width = (costs.school / maxExpense * 100) + '%';
        if (barParkExpense) barParkExpense.style.width = (costs.park / maxExpense * 100) + '%';

        if (valFireExpense) valFireExpense.textContent = '-' + i18n.getCurrency() + formatMoney(costs.fire);
        if (valPoliceExpense) valPoliceExpense.textContent = '-' + i18n.getCurrency() + formatMoney(costs.police);
        if (valSchoolExpense) valSchoolExpense.textContent = '-' + i18n.getCurrency() + formatMoney(costs.school);
        if (valParkExpense) valParkExpense.textContent = '-' + i18n.getCurrency() + formatMoney(costs.park);

        if (countFire) countFire.textContent = '×' + counts.fire;
        if (countPolice) countPolice.textContent = '×' + counts.police;
        if (countSchool) countSchool.textContent = '×' + counts.school;
        if (countPark) countPark.textContent = '×' + counts.park;

        // 요약
        if (totalIncomeEl) totalIncomeEl.textContent = '+' + i18n.getCurrency() + formatMoney(income.total) + '/h';
        if (totalExpenseEl) totalExpenseEl.textContent = '-' + i18n.getCurrency() + formatMoney(costs.total) + '/h';

        const netProfit = budgetSystem.netProfit;
        if (netProfitEl) {
            const sign = netProfit >= 0 ? '+' : '';
            netProfitEl.textContent = sign + i18n.getCurrency() + formatMoney(Math.abs(netProfit)) + '/h';
            netProfitEl.className = 'summary-value ' + (netProfit >= 0 ? 'income' : 'expense');
        }

        // 채권 정보
        if (totalDebtEl) totalDebtEl.textContent = i18n.getCurrency() + formatMoney(budgetSystem.totalDebt);
        if (debtInterestEl) debtInterestEl.textContent = i18n.getCurrency() + formatMoney(budgetSystem.debtInterest) + '/h';

        // 총 자산 (현재 보유 자금 - 채권 부채)
        if (totalAssetsEl) {
            const assets = economy.money - budgetSystem.totalDebt;
            const sign = assets < 0 ? '-' : '';
            totalAssetsEl.textContent = sign + i18n.getCurrency() + formatMoney(Math.abs(assets));
            totalAssetsEl.style.color = assets >= 0 ? '#4ade80' : '#f87171';
        }

        // 채권 카드 상태 업데이트
        updateBondCards();
    }

    // 채권 카드 상태 업데이트
    function updateBondCards() {
        ['A', 'B', 'C'].forEach(bondId => {
            const card = document.getElementById('bond' + bondId);
            const btn = document.getElementById('btnBond' + bondId);

            if (card && btn) {
                if (budgetSystem.issuedBonds[bondId]) {
                    card.classList.add('issued');
                    btn.textContent = '상환';
                    btn.classList.add('repay');
                } else {
                    card.classList.remove('issued');
                    btn.textContent = '발행';
                    btn.classList.remove('repay');
                }
            }
        });
    }

    // 채권 발행/상환
    function toggleBond(bondId) {
        const info = budgetSystem.bondInfo[bondId];
        if (!info) return;

        if (budgetSystem.issuedBonds[bondId]) {
            // 상환
            if (economy.money >= info.amount) {
                economy.money -= info.amount;
                budgetSystem.issuedBonds[bondId] = false;
                toast({ title: '채권 상환', desc: `채권 ${bondId} (${i18n.getCurrency()}${formatMoney(info.amount)}) 상환 완료`, success: true });
            } else {
                toast({ title: '자금 부족', desc: `상환에 ${i18n.getCurrency()}${formatMoney(info.amount)}이 필요합니다` });
                return;
            }
        } else {
            // 발행
            economy.money += info.amount;
            budgetSystem.issuedBonds[bondId] = true;
            toast({ title: '채권 발행', desc: `채권 ${bondId} 발행 (${i18n.getCurrency()}${formatMoney(info.amount)}, 이자 ${info.interest * 100}%)`, success: true });
        }

        renderMoney();
        calculateNetProfit();
        updateBudgetDisplay();
        updateBudgetPanel();
    }

    // 세금율 변경 핸들러
    function handleTaxRateChange(type, value) {
        budgetSystem.taxRates[type] = parseInt(value);
        calculateNetProfit();
        updateBudgetDisplay();
        updateBudgetPanel();
    }

    // 예산 패널 열기/닫기
    function openBudgetPanel() {
        if (budgetPanel) {
            calculateNetProfit();
            updateBudgetPanel();
            budgetPanel.classList.add('open');
        }
    }

    function closeBudgetPanel() {
        if (budgetPanel) {
            budgetPanel.classList.remove('open');
        }
    }

    // ========== 인구 통계 시스템 ==========

    // 계층별 인구 계산
    function calculatePopulationByTier() {
        const result = {
            total: 0,
            middle: 0,
            high: 0,
            buildingCount: 0
        };

        if (typeof placedBuildings === 'undefined') return result;

        placedBuildings.forEach((building, key) => {
            if (building.ref) return;  // 참조 건물 스킵

            const { instance, x, y } = building;
            const userData = instance?.userData;
            if (!userData) return;

            // 폐건물 제외
            if (userData.isAbandoned) return;

            // 주거 건물만 인구 계산
            const zoneType = userData.zoneType;
            if (!zoneType || !zoneType.includes('residential')) return;

            // 건물 크기 파악
            const size = userData.size || '1x1';
            const buildingKey = getBuildingKey(x, y, size);
            const population = buildingPopulations.get(buildingKey) || 0;

            if (population > 0) {
                result.buildingCount++;
                result.total += population;

                // 계층 파악 (tier)
                const tier = userData.tier || TIER.MIDDLE;
                if (tier === TIER.HIGH) {
                    result.high += population;
                } else {
                    result.middle += population;
                }
            }
        });

        return result;
    }

    // 인구 패널 업데이트
    function updatePopulationPanel() {
        const popData = calculatePopulationByTier();

        // 총 인구
        if (popTotalValue) popTotalValue.textContent = popData.total.toLocaleString();
        if (popResidentialBuildings) popResidentialBuildings.textContent = popData.buildingCount.toLocaleString();

        // 평균 인구/건물
        const avg = popData.buildingCount > 0 ? Math.round(popData.total / popData.buildingCount) : 0;
        if (popAvgPerBuilding) popAvgPerBuilding.textContent = avg.toLocaleString();

        // 계층별 인구
        const maxPop = Math.max(popData.middle, popData.high, 1);

        if (tierBarMiddle) tierBarMiddle.style.width = (popData.middle / maxPop * 100) + '%';
        if (tierBarHigh) tierBarHigh.style.width = (popData.high / maxPop * 100) + '%';
        if (tierValueMiddle) tierValueMiddle.textContent = popData.middle.toLocaleString() + '명';
        if (tierValueHigh) tierValueHigh.textContent = popData.high.toLocaleString() + '명';

        // 연령별 인구 - 원형 그래프 업데이트
        const { ageGroups, birthRate, deathRate } = cityStats;
        const totalAgePop = ageGroups.children + ageGroups.youth + ageGroups.adults + ageGroups.elderly;

        // 파이 차트 업데이트
        if (totalAgePop > 0) {
            const pctChildren = ageGroups.children / totalAgePop;
            const pctYouth = ageGroups.youth / totalAgePop;
            const pctAdults = ageGroups.adults / totalAgePop;
            const pctElderly = ageGroups.elderly / totalAgePop;

            // 각 세그먼트의 stroke-dasharray와 stroke-dashoffset 계산
            let offset = 0;

            if (pieChildren) {
                const length = pctChildren * PIE_CIRCUMFERENCE;
                pieChildren.style.strokeDasharray = `${length} ${PIE_CIRCUMFERENCE}`;
                pieChildren.style.strokeDashoffset = -offset;
                offset += length;
            }
            if (pieYouth) {
                const length = pctYouth * PIE_CIRCUMFERENCE;
                pieYouth.style.strokeDasharray = `${length} ${PIE_CIRCUMFERENCE}`;
                pieYouth.style.strokeDashoffset = -offset;
                offset += length;
            }
            if (pieAdults) {
                const length = pctAdults * PIE_CIRCUMFERENCE;
                pieAdults.style.strokeDasharray = `${length} ${PIE_CIRCUMFERENCE}`;
                pieAdults.style.strokeDashoffset = -offset;
                offset += length;
            }
            if (pieElderly) {
                const length = pctElderly * PIE_CIRCUMFERENCE;
                pieElderly.style.strokeDasharray = `${length} ${PIE_CIRCUMFERENCE}`;
                pieElderly.style.strokeDashoffset = -offset;
            }

            // 퍼센트 표시
            if (agePctChildren) agePctChildren.textContent = `(${Math.round(pctChildren * 100)}%)`;
            if (agePctYouth) agePctYouth.textContent = `(${Math.round(pctYouth * 100)}%)`;
            if (agePctAdults) agePctAdults.textContent = `(${Math.round(pctAdults * 100)}%)`;
            if (agePctElderly) agePctElderly.textContent = `(${Math.round(pctElderly * 100)}%)`;
        } else {
            // 인구 없음 - 빈 파이 차트
            if (pieChildren) pieChildren.style.strokeDasharray = `0 ${PIE_CIRCUMFERENCE}`;
            if (pieYouth) pieYouth.style.strokeDasharray = `0 ${PIE_CIRCUMFERENCE}`;
            if (pieAdults) pieAdults.style.strokeDasharray = `0 ${PIE_CIRCUMFERENCE}`;
            if (pieElderly) pieElderly.style.strokeDasharray = `0 ${PIE_CIRCUMFERENCE}`;
            if (agePctChildren) agePctChildren.textContent = '(0%)';
            if (agePctYouth) agePctYouth.textContent = '(0%)';
            if (agePctAdults) agePctAdults.textContent = '(0%)';
            if (agePctElderly) agePctElderly.textContent = '(0%)';
        }

        // 총 인구 표시
        if (pieTotalPop) pieTotalPop.textContent = totalAgePop.toLocaleString();

        // 범례 값 업데이트
        if (ageLegendChildren) ageLegendChildren.textContent = ageGroups.children.toLocaleString();
        if (ageLegendYouth) ageLegendYouth.textContent = ageGroups.youth.toLocaleString();
        if (ageLegendAdults) ageLegendAdults.textContent = ageGroups.adults.toLocaleString();
        if (ageLegendElderly) ageLegendElderly.textContent = ageGroups.elderly.toLocaleString();

        // 출생률/사망률 (천분율로 표시)
        if (ageBirthRate) ageBirthRate.textContent = (birthRate * 1000).toFixed(1) + '‰';
        if (ageDeathRate) ageDeathRate.textContent = (deathRate * 1000).toFixed(1) + '‰';

        // 노동인구 (청년 + 중년)
        const workforce = getWorkforcePopulation();
        if (ageWorkforce) ageWorkforce.textContent = workforce.toLocaleString() + '명';

        // 서비스 커버리지 업데이트
        updateServiceCoverageDisplay();
    }

    // 서비스 커버리지 표시 업데이트
    function updateServiceCoverageDisplay() {
        const coverage = getAllServiceCoverage();

        // 커버리지에 따른 색상 클래스
        function getCoverageClass(value) {
            if (value >= 80) return 'good';
            if (value >= 50) return 'medium';
            return 'poor';
        }

        // 학교 (교육)
        if (serviceCoverageSchool) {
            serviceCoverageSchool.style.width = Math.min(100, coverage.school) + '%';
            serviceCoverageSchool.className = 'service-bar-fill ' + getCoverageClass(coverage.school);
        }
        if (serviceCoverageSchoolValue) {
            serviceCoverageSchoolValue.textContent = coverage.school + '%';
        }

        // 병원 (의료)
        if (serviceCoverageHospital) {
            serviceCoverageHospital.style.width = Math.min(100, coverage.hospital) + '%';
            serviceCoverageHospital.className = 'service-bar-fill ' + getCoverageClass(coverage.hospital);
        }
        if (serviceCoverageHospitalValue) {
            serviceCoverageHospitalValue.textContent = coverage.hospital + '%';
        }

        // 공원
        if (serviceCoveragePark) {
            serviceCoveragePark.style.width = Math.min(100, coverage.park) + '%';
            serviceCoveragePark.className = 'service-bar-fill ' + getCoverageClass(coverage.park);
        }
        if (serviceCoverageParkValue) {
            serviceCoverageParkValue.textContent = coverage.park + '%';
        }
    }

    // 인구 표시 업데이트 (하단 바)
    function updatePopulationDisplay() {
        if (popDisplayCenter) {
            popDisplayCenter.textContent = cityStats.population.toLocaleString();
        }
    }

    // 인구 패널 열기/닫기
    function openPopulationPanel() {
        if (populationPanel) {
            updatePopulationPanel();
            populationPanel.classList.add('open');
        }
    }

    function closePopulationPanel() {
        if (populationPanel) {
            populationPanel.classList.remove('open');
        }
    }

    // 인구 패널 이벤트 리스너 설정
    function initPopulationEventListeners() {
        // 인구 표시 클릭 시 인구 패널 열기
        if (populationDisplayBtn) {
            populationDisplayBtn.addEventListener('click', () => {
                if (populationPanel && populationPanel.classList.contains('open')) {
                    closePopulationPanel();
                } else {
                    // 예산 패널이 열려있으면 닫기
                    closeBudgetPanel();
                    openPopulationPanel();
                }
            });
        }

        // 닫기 버튼
        if (btnClosePopulation) {
            btnClosePopulation.addEventListener('click', closePopulationPanel);
        }
    }

    // 예산 패널 이벤트 리스너 설정
    function initBudgetEventListeners() {
        // 중앙 자금 표시 클릭 시 예산 패널 열기
        const moneyDisplayContainer = document.querySelector('.money-display-center');
        if (moneyDisplayContainer) {
            moneyDisplayContainer.addEventListener('click', () => {
                if (budgetPanel && budgetPanel.classList.contains('open')) {
                    closeBudgetPanel();
                } else {
                    // 인구 패널이 열려있으면 닫기
                    closePopulationPanel();
                    openBudgetPanel();
                }
            });
        }

        // 닫기 버튼
        if (btnCloseBudget) {
            btnCloseBudget.addEventListener('click', closeBudgetPanel);
        }

        // 세금 슬라이더
        if (taxResidential) {
            taxResidential.addEventListener('input', (e) => {
                if (taxResidentialPercent) taxResidentialPercent.textContent = e.target.value + '%';
                handleTaxRateChange('residential', e.target.value);
            });
        }
        if (taxCommercial) {
            taxCommercial.addEventListener('input', (e) => {
                if (taxCommercialPercent) taxCommercialPercent.textContent = e.target.value + '%';
                handleTaxRateChange('commercial', e.target.value);
            });
        }
        if (taxIndustrial) {
            taxIndustrial.addEventListener('input', (e) => {
                if (taxIndustrialPercent) taxIndustrialPercent.textContent = e.target.value + '%';
                handleTaxRateChange('industrial', e.target.value);
            });
        }

        // 채권 버튼
        if (btnBondA) btnBondA.addEventListener('click', () => toggleBond('A'));
        if (btnBondB) btnBondB.addEventListener('click', () => toggleBond('B'));
        if (btnBondC) btnBondC.addEventListener('click', () => toggleBond('C'));

        // ESC 키로 패널 닫기
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && budgetPanel && budgetPanel.classList.contains('open')) {
                closeBudgetPanel();
            }
        });
    }

    // 초기화 시 예산/인구 UI 업데이트
    setTimeout(() => {
        initBudgetEventListeners();
        initPopulationEventListeners();
        updateBudgetDisplay();
        updatePopulationDisplay();
    }, 100);

    /* =========================================================
     * 텍스트 선택 및 드래그 금지
     * ========================================================= */
    document.addEventListener('dragstart', (e) => e.preventDefault());
    document.addEventListener('selectstart', (e) => {
        // input/textarea는 선택 허용
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        e.preventDefault();
    });

    /* =========================================================
     * CITY STATS
     * ========================================================= */
    const cityStats = {
        population: 0,
        happiness: 50,
        powerCapacity: 0,
        powerUsage: 0,
        waterCapacity: 0,
        waterUsage: 0,
        sewageCapacity: 0,
        sewageUsage: 0,
        crimeRate: 0,
        fireRisk: 0,
        trafficLevel: 0,
        taxPerHour: 0,
        actionPoints: 10,
        consecutiveLoginDays: 0,
        congestionMap: null,
        // RCI 수요 시스템 (-100 ~ +100, 0이 균형)
        residentialDemand: 0,
        commercialDemand: 0,
        industrialDemand: 0,
        // 구역 타일 수
        residentialTiles: 0,
        commercialTiles: 0,
        industrialTiles: 0,
        // 일자리 수
        commercialJobs: 0,
        industrialJobs: 0,
        // 연령별 인구 시스템
        ageGroups: {
            children: 0,   // 0-14세 (어린이)
            youth: 0,      // 15-29세 (청년)
            adults: 0,     // 30-59세 (중년)
            elderly: 0     // 60세+ (노인)
        },
        birthRate: 0,      // 출생률 (시간당)
        deathRate: 0       // 사망률 (시간당)
    };

    // 연령 시스템 상수
    const AGE_SYSTEM = {
        // 연령대별 게임 내 일수 (1게임일 = 실제 1분)
        CHILD_TO_YOUTH: 15,      // 어린이 → 청년 (15일)
        YOUTH_TO_ADULT: 15,      // 청년 → 중년 (15일)
        ADULT_TO_ELDERLY: 30,    // 중년 → 노인 (30일)
        ELDERLY_LIFESPAN: 20,    // 노인 평균 수명 (20일)

        // 기본 출생률/사망률 (인구 1000명당, 게임일당)
        BASE_BIRTH_RATE: 15,     // 기본 출생률
        BASE_DEATH_RATE: 8,      // 기본 사망률

        // 서비스 영향
        SCHOOL_BIRTH_BONUS: 0.2,    // 학교 있으면 출생률 +20%
        HOSPITAL_DEATH_REDUCE: 0.3, // 병원 있으면 사망률 -30%
        PARK_BIRTH_BONUS: 0.1,      // 공원 있으면 출생률 +10%

        // 노동력 계산
        WORKFORCE_RATIO: {
            children: 0,      // 어린이: 노동 불가
            youth: 0.8,       // 청년: 80% 노동
            adults: 1.0,      // 중년: 100% 노동
            elderly: 0.2      // 노인: 20% 노동 (파트타임)
        },

        // 세금 기여율
        TAX_CONTRIBUTION: {
            children: 0,      // 어린이: 세금 없음
            youth: 0.7,       // 청년: 70%
            adults: 1.0,      // 중년: 100%
            elderly: 0.5      // 노인: 50% (연금)
        },

        // 서비스 수요 배율
        SERVICE_DEMAND: {
            school: { children: 1.0, youth: 0.3, adults: 0, elderly: 0 },
            hospital: { children: 0.3, youth: 0.2, adults: 0.3, elderly: 1.0 },
            park: { children: 0.8, youth: 0.5, adults: 0.4, elderly: 0.7 }
        },

        // 초기 인구 분포 (새 건물 입주 시)
        INITIAL_DISTRIBUTION: {
            children: 0.20,   // 20%
            youth: 0.25,      // 25%
            adults: 0.40,     // 40%
            elderly: 0.15     // 15%
        }
    };

    // RCI 이상 비율 (주거 60%, 산업 25%, 상업 15%)
    const RCI_IDEAL_RATIO = {
        residential: 0.60,
        industrial: 0.25,
        commercial: 0.15
    };

    /* =========================================================
     * POWER GRID MANAGER (전력망 시스템)
     * ========================================================= */
    const powerManager = {
        initialized: false,
        powerPlants: new Map(),              // 발전소 목록 (key: "x,y")
        poweredBuildings: new Set(),         // 전기가 공급되는 건물 (key: "x,y")
        unpoweredBuildings: new Set(),       // 전기가 부족한 건물 (key: "x,y")
        buildingPowerOffTime: new Map(),     // 건물별 전기 없는 시간 (key: "x,y", value: timestamp)
        buildingPowerAbandonTime: new Map(), // 건물별 폐건물화 예정 시간 (랜덤, 정규분포)
        powerLineGroup: null,                // 전력선 그룹
        powerIconGroup: null,                // 전력 아이콘 그룹 (전력 모드용)
        unpoweredIconGroup: null,            // 전력 부족 아이콘 그룹 (항상 표시)
        buildingPowerIcons: new Map(),       // 건물별 전력 아이콘
        powerViewOriginalMaterials: new Map(), // 전력 뷰 전환 전 원래 머티리얼 저장
        isPowerViewActive: false,            // 전력 뷰 활성화 상태

        // 상수
        POWER_PER_POPULATION: 0.5,           // 인구 1명당 전력 소비량
        PUBLIC_BUILDING_POWER: 20,           // 공공시설 전력 소비량
        POWER_OFF_ABANDON_MEAN: 60000,       // 전기 없이 폐건물 평균 시간 (60초)
        POWER_OFF_ABANDON_STDDEV: 20000,     // 폐건물화 시간 표준편차 (20초)

        // 초기화
        init() {
            if (this.initialized) return;

            this.powerLineGroup = new THREE.Group();
            this.powerLineGroup.name = 'powerLines';
            this.powerLineGroup.renderOrder = 999;  // 다른 오브젝트 위에 렌더링
            scene.add(this.powerLineGroup);

            this.powerIconGroup = new THREE.Group();
            this.powerIconGroup.name = 'powerIcons';
            this.powerIconGroup.renderOrder = 1000;  // 전력선보다 위에 렌더링
            scene.add(this.powerIconGroup);

            // 전력 부족 아이콘 그룹 (항상 표시)
            this.unpoweredIconGroup = new THREE.Group();
            this.unpoweredIconGroup.name = 'unpoweredIcons';
            scene.add(this.unpoweredIconGroup);

            this.initialized = true;

            // 기존 발전소 스캔 및 등록
            this.scanExistingPowerPlants();

            // 전력 체크 타이머 (10초마다, 최적화)
            setInterval(() => this.checkPowerShortageAbandonment(), 10000);
        },

        // 기존 발전소 스캔 (초기 로드 시)
        scanExistingPowerPlants() {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조 키 스킵
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isPowerPlant) {
                    const powerKey = `${building.x},${building.y}`;
                    if (!this.powerPlants.has(powerKey)) {
                        this.powerPlants.set(powerKey, {
                            x: building.x,
                            y: building.y,
                            type: building.type,
                            output: config.powerOutput || 100,
                            width: config.tileWidth || building.width || 2,
                            depth: config.tileDepth || building.depth || 2
                        });
                        console.log(`기존 발전소 등록: ${powerKey}`);
                    }
                }
            });
        },

        // 발전소 추가
        addPowerPlant(x, y, type, config) {
            const key = `${x},${y}`;
            let output = config.powerOutput || 100;

            // 풍력발전소는 풍량에 비례하여 출력 계산
            if (type === 'powerplant_wind') {
                const windStrength = typeof getWindStrengthAtGrid === 'function'
                    ? getWindStrengthAtGrid(x, y)
                    : 0.5;  // 기본값 50%
                output = Math.round((config.powerOutput || 100) * windStrength);
                console.log(`[WindPower] (${x},${y}) 풍량: ${(windStrength * 100).toFixed(0)}%, 출력: ${output} kW`);
            }

            this.powerPlants.set(key, {
                x, y, type,
                output: output,
                baseOutput: config.powerOutput || 100,  // 기본 출력 저장
                width: config.displayWidth || config.tileWidth || 2,
                depth: config.displayDepth || config.tileDepth || 2
            });
            this.recalculatePowerGrid();
        },

        // 발전소 제거
        removePowerPlant(x, y) {
            const key = `${x},${y}`;
            if (this.powerPlants.has(key)) {
                this.powerPlants.delete(key);
                this.recalculatePowerGrid();
            }
        },

        // 발전소 출력 업데이트 (풍력발전기 확장 등)
        updatePowerPlantOutput(x, y, newOutput) {
            const key = `${x},${y}`;
            const plant = this.powerPlants.get(key);
            if (plant) {
                plant.output = newOutput;
                console.log(`발전소 출력 업데이트: ${key} -> ${newOutput}kW`);
            }
        },

        // 전력 사용량 계산 (인구 기반)
        calculatePowerUsage() {
            let usage = 0;

            // 인구 기반 전력 소비
            usage += Math.ceil(cityStats.population * this.POWER_PER_POPULATION);

            // 공공시설 전력 소비
            placedPublicBuildings.forEach((building, key) => {
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && !config.isPowerPlant) {
                    usage += this.PUBLIC_BUILDING_POWER;
                }
            });

            cityStats.powerUsage = usage;
            return usage;
        },

        // 총 전력 용량 계산
        calculatePowerCapacity() {
            let totalCapacity = 0;
            this.powerPlants.forEach(plant => {
                // 서비스 건물 운영 상태 확인 (발전소는 도로 연결만 체크)
                if (typeof serviceBuildingManager !== 'undefined' &&
                    !serviceBuildingManager.isOperational(plant.x, plant.y)) {
                    return; // 비운영 시설은 용량 계산에서 제외
                }
                totalCapacity += plant.output;
            });
            cityStats.powerCapacity = totalCapacity;
            return totalCapacity;
        },

        // 전력망 재계산 - BFS 거리 기반으로 가까운 건물부터 전력 공급
        recalculatePowerGrid() {
            this.poweredBuildings.clear();
            this.unpoweredBuildings.clear();

            const capacity = this.calculatePowerCapacity();

            // 도로 연결된 모든 건물 수집 (이미 거리순 정렬됨)
            const allConnectedBuildings = this.collectConnectedBuildings();

            if (allConnectedBuildings.length === 0) {
                // 총 전력 사용량 업데이트
                cityStats.powerUsage = 0;
                this.updatePowerVisualization();
                updateStatsDisplay();
                return;
            }

            // 거리순으로 전력 배분 (가까운 건물 우선)
            let remainingCapacity = capacity;
            let totalUsage = 0;

            allConnectedBuildings.forEach(b => {
                const key = `${b.x},${b.y}`;
                const buildingPower = b.powerUsage || 5; // 기본 전력 사용량 5

                if (remainingCapacity >= buildingPower) {
                    // 전력 공급 가능
                    this.poweredBuildings.add(key);
                    this.buildingPowerOffTime.delete(key);
                    this.buildingPowerAbandonTime.delete(key);  // 폐건물화 타이머 초기화
                    remainingCapacity -= buildingPower;
                    totalUsage += buildingPower;
                } else {
                    // 전력 부족 - 공급 불가
                    this.unpoweredBuildings.add(key);
                    // 전력 차단 시작 시간 기록 + 랜덤 폐건물화 시간 설정
                    if (!this.buildingPowerOffTime.has(key)) {
                        this.buildingPowerOffTime.set(key, Date.now());
                        // 정규분포 랜덤 시간 생성 (Box-Muller 변환)
                        const u1 = Math.random();
                        const u2 = Math.random();
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        const randomTime = Math.max(15000, this.POWER_OFF_ABANDON_MEAN + z * this.POWER_OFF_ABANDON_STDDEV);
                        this.buildingPowerAbandonTime.set(key, randomTime);
                    }
                    totalUsage += buildingPower; // 필요 전력량에는 포함
                }
            });

            // 총 전력 사용량 업데이트
            cityStats.powerUsage = totalUsage;

            // 시각화 업데이트
            this.updatePowerVisualization();
            updateStatsDisplay();
        },

        // 도로 연결된 모든 건물 수집 (BFS) - 발전소에서의 거리 포함
        collectConnectedBuildings() {
            const buildings = [];
            const visited = new Set();
            const roadDistances = new Map(); // 도로별 최소 거리

            // 모든 발전소에서 BFS 시작 (거리 0부터)
            this.powerPlants.forEach(plant => {
                // 발전소 인접 도로 찾기 (거리 1)
                for (let dx = -1; dx <= plant.width; dx++) {
                    for (let dy = -1; dy <= plant.depth; dy++) {
                        const nx = plant.x + dx;
                        const ny = plant.y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            if (isRoad(nx, ny) || isBridge(nx, ny)) {
                                const key = `${nx},${ny}`;
                                // 더 가까운 거리로 업데이트
                                if (!roadDistances.has(key) || roadDistances.get(key) > 1) {
                                    roadDistances.set(key, 1);
                                }
                            }
                        }
                    }
                }
            });

            // BFS 큐 초기화 (발전소 인접 도로들)
            const queue = [];
            roadDistances.forEach((dist, key) => {
                const [x, y] = key.split(',').map(Number);
                queue.push({ x, y, distance: dist });
                visited.add(`road_${key}`);
            });

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            // BFS로 도로 따라 이동하며 인접 건물 수집 (거리 계산)
            while (queue.length > 0) {
                const current = queue.shift();

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const roadKey = `road_${nx},${ny}`;
                    const buildingKey = `building_${nx},${ny}`;
                    const newDistance = current.distance + 1;

                    // 도로면 계속 탐색
                    if ((isRoad(nx, ny) || isBridge(nx, ny)) && !visited.has(roadKey)) {
                        visited.add(roadKey);
                        roadDistances.set(`${nx},${ny}`, newDistance);
                        queue.push({ x: nx, y: ny, distance: newDistance });
                    }

                    // 건물이면 수집 (거리 정보 포함) - 민간 건물 + 공공 건물 모두 체크
                    if (!visited.has(buildingKey)) {
                        let building = placedBuildings.get(`${nx},${ny}`);
                        let isPublicBuilding = false;
                        let actualBuildingKey = buildingKey;

                        // 공공 건물도 체크 (참조 타일이면 원본 건물로 해석)
                        if (!building || building.ref) {
                            let publicBuilding = placedPublicBuildings.get(`${nx},${ny}`);

                            // 참조 타일이면 원본 건물 가져오기
                            if (publicBuilding && publicBuilding.ref) {
                                const primaryKey = publicBuilding.ref;
                                publicBuilding = placedPublicBuildings.get(primaryKey);
                                if (publicBuilding) {
                                    actualBuildingKey = `building_${primaryKey}`;
                                }
                            }

                            if (publicBuilding && !publicBuilding.ref) {
                                building = publicBuilding;
                                isPublicBuilding = true;
                            }
                        }

                        // 이미 처리된 건물은 스킵 (참조 해석 후 체크)
                        if (visited.has(actualBuildingKey)) continue;

                        if (building && !building.ref && !building.isAbandoned) {
                            visited.add(actualBuildingKey);
                            // 건물별 전력 사용량 계산
                            const powerUsage = isPublicBuilding ?
                                this.calculatePublicBuildingPowerUsage(building) :
                                this.calculateBuildingPowerUsage(building);
                            buildings.push({
                                x: building.x,  // 원본 건물 좌표 사용
                                y: building.y,
                                building,
                                distance: current.distance, // 발전소로부터의 거리
                                powerUsage,  // 건물별 전력 사용량
                                isPublicBuilding
                            });
                        }
                    }
                }
            }

            // 거리순 정렬 (가까운 건물 우선)
            buildings.sort((a, b) => a.distance - b.distance);

            return buildings;
        },

        // 건물별 전력 사용량 계산
        calculateBuildingPowerUsage(building) {
            if (!building) return 0;

            // 인구 기반 전력 소비
            const population = building.population || 0;
            let usage = Math.ceil(population * this.POWER_PER_POPULATION);

            // 최소 전력 사용량 (건물이 있으면 최소 5 소비)
            if (usage < 5) usage = 5;

            return usage;
        },

        // 공공 건물 전력 사용량 계산
        calculatePublicBuildingPowerUsage(building) {
            if (!building) return 0;

            // 공공 건물별 전력 사용량 설정 (건물 크기에 비례)
            const width = building.width || 2;
            const depth = building.depth || 2;
            const area = width * depth;

            // 기본 전력 사용량: 크기당 10
            return area * 10;
        },

        // 전력 차단으로 인한 폐건물 체크 (랜덤 시간 적용)
        checkPowerShortageAbandonment() {
            const now = Date.now();

            this.buildingPowerOffTime.forEach((startTime, key) => {
                const abandonTime = this.buildingPowerAbandonTime.get(key) || this.POWER_OFF_ABANDON_MEAN;
                const elapsedTime = now - startTime;

                if (elapsedTime >= abandonTime) {
                    // 폐건물로 전환
                    const building = placedBuildings.get(key);
                    if (building && !building.ref && !building.isAbandoned) {
                        this.convertToAbandoned(key, building);
                        // 전력 부족 상태 아이콘 제거 (폐건물 아이콘으로 대체됨)
                        removeBuildingStatus(building.x, building.y, 'NO_POWER');
                    }
                }
            });
        },

        // 건물을 폐건물로 전환 (전력 부족)
        convertToAbandoned(key, building) {
            if (!building || building.isAbandoned) return;

            building.isAbandoned = true;

            // 폐건물 사유 및 시간 저장
            if (building.instance && building.instance.userData) {
                building.instance.userData.isAbandoned = true;
                building.instance.userData.abandonedReason = '전기가 없어서 살 수 없어요...';
                building.instance.userData.abandonedTime = Date.now();
            }

            // 건물 외관 변경 (어둡게)
            if (building.instance) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (!child.userData.originalMaterial) {
                            child.userData.originalMaterial = child.material.clone();
                        }
                        const darkMat = child.material.clone();
                        darkMat.color.multiplyScalar(0.3);
                        child.material = darkMat;
                    }
                });
            }

            // 인구 감소
            if (building.population) {
                cityStats.population -= building.population;
                if (cityStats.population < 0) cityStats.population = 0;
            }

            // 폐건물 목록에 추가
            if (typeof abandonedBuildings !== 'undefined') {
                abandonedBuildings.add(key);
            }

            // 폐건물 상태 아이콘 표시 (통합 시스템)
            addBuildingStatus(building.x, building.y, 'ABANDONED', building);

            // 전력 추적 정리
            this.buildingPowerOffTime.delete(key);
            this.buildingPowerAbandonTime.delete(key);

            console.log(`Building at ${key} became abandoned due to power shortage`);
        },

        // 타일에 전력이 공급되는지 확인
        isPowered(x, y) {
            return this.poweredBuildings.has(`${x},${y}`);
        },

        // 전력선 시각화 업데이트 (트리 구조로 표시)
        updatePowerVisualization() {
            // 기존 전력선 제거
            while (this.powerLineGroup.children.length > 0) {
                const child = this.powerLineGroup.children[0];
                this.powerLineGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            // 기존 전력 모드 아이콘 제거
            while (this.powerIconGroup.children.length > 0) {
                this.powerIconGroup.remove(this.powerIconGroup.children[0]);
            }
            this.buildingPowerIcons.clear();

            // 전력 부족 아이콘 항상 업데이트
            this.updateUnpoweredIcons();

            // 전력 관련 모드가 아니면 전력선/발전소 아이콘만 숨김
            const isPowerRelatedMode = currentMode === MODE.POWER_VIEW ||
                                       currentMode === MODE.PLACE_POWER_COAL ||
                                       currentMode === MODE.PLACE_POWER_WIND ||
                                       currentMode === MODE.PLACE_POWER_SOLAR;
            if (!isPowerRelatedMode) {
                this.powerLineGroup.visible = false;
                this.powerIconGroup.visible = false;
                if (this.isPowerViewActive) {
                    this.restorePowerViewMaterials();
                    this.isPowerViewActive = false;
                }
                return;
            }

            // 전력 뷰 머티리얼 적용
            if (!this.isPowerViewActive) {
                this.applyPowerViewMaterials();
                this.isPowerViewActive = true;
            }

            this.powerLineGroup.visible = true;
            this.powerIconGroup.visible = true;

            // 전력선 트리 구조 생성
            this.createPowerLineTree();

            // 건물 전력 상태 아이콘 표시 (전력 모드용)
            this.updateBuildingPowerIcons();
        },

        // 전력 부족 아이콘 업데이트 (통합 상태 아이콘 시스템 사용)
        // 이전 전력 부족 건물 목록 (상태 변경 감지용)
        _prevUnpoweredBuildings: new Set(),

        updateUnpoweredIcons() {
            // 기존 3D 아이콘 제거 (레거시)
            while (this.unpoweredIconGroup && this.unpoweredIconGroup.children.length > 0) {
                this.unpoweredIconGroup.remove(this.unpoweredIconGroup.children[0]);
            }

            // 새로 전력 공급된 건물에서 상태 제거
            this._prevUnpoweredBuildings.forEach(key => {
                if (!this.unpoweredBuildings.has(key)) {
                    const [x, y] = key.split(',').map(Number);
                    removeBuildingStatus(x, y, 'NO_POWER');
                }
            });

            // 새로 전력 부족한 건물에 상태 추가
            this.unpoweredBuildings.forEach(key => {
                if (!this._prevUnpoweredBuildings.has(key)) {
                    const building = placedBuildings.get(key);
                    if (building && building.instance && !building.ref) {
                        addBuildingStatus(building.x, building.y, 'NO_POWER', building);
                    }
                }
            });

            // 이전 상태 업데이트
            this._prevUnpoweredBuildings = new Set(this.unpoweredBuildings);
        },

        // 전력 부족 아이콘 생성 (항상 표시용)
        createUnpoweredIcon(x, y, buildingInstance) {
            if (!buildingInstance || !this.unpoweredIconGroup) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);

            // ⚡ 아이콘 스프라이트 (빨간색 번개)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // 빨간색 원 배경
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();

            // 흰색 테두리
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // 번개 아이콘
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('⚡', 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(material);

            sprite.position.set(center.x, box.max.y + 0.4, center.z);
            sprite.scale.set(0.5, 0.5, 1);

            this.unpoweredIconGroup.add(sprite);
        },

        // 전력 뷰 머티리얼 적용 (토대는 흰색, 나머지는 회색, 발전소는 초록색)
        applyPowerViewMaterials() {
            this.powerViewOriginalMaterials.clear();

            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const greenMat = new THREE.MeshStandardMaterial({
                color: 0x44ff66,
                transparent: true,
                opacity: 0.85,
                emissive: 0x22aa44,
                emissiveIntensity: 0.3,
            });

            // 토대(잔디) - 흰색
            grassGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.powerViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = whiteMat;
                }
            });

            // 나무 - 흰색
            treeGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.powerViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = whiteMat;
                }
            });

            // 도로, 수로, 다리 - 회색
            const grayGroups = [roadGroup, waterGroup, bridgeGroup];
            grayGroups.forEach(group => {
                group.traverse((child) => {
                    if (child.isMesh && child.material) {
                        this.powerViewOriginalMaterials.set(child.uuid, child.material);
                        child.material = grayMat;
                    }
                });
            });

            // 인스턴스드 메쉬 (도로/구역 인디케이터) - 회색
            const instancedMeshes = [
                typeof roadMesh !== 'undefined' ? roadMesh : null,
                typeof lockedRoadMesh !== 'undefined' ? lockedRoadMesh : null,
                typeof residentialMesh !== 'undefined' ? residentialMesh : null,
                typeof commercialMesh !== 'undefined' ? commercialMesh : null,
                typeof industrialMesh !== 'undefined' ? industrialMesh : null
            ].filter(m => m !== null);

            instancedMeshes.forEach(mesh => {
                if (mesh && mesh.material) {
                    this.powerViewOriginalMaterials.set(mesh.uuid, mesh.material);
                    mesh.material = grayMat;
                }
            });

            // 건물 - 회색
            buildingGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.powerViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = grayMat;
                }
            });

            // 발전소 건물 - 초록색으로 하이라이트
            // 주의: 원본 재질은 위의 buildingGroup.traverse에서 이미 저장됨
            // 여기서 다시 저장하면 이미 회색으로 변경된 재질이 저장되므로 저장하지 않음
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isPowerPlant && building.instance) {
                    building.instance.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // 원본은 이미 저장됨 - 초록색만 적용
                            child.material = greenMat;
                        }
                    });
                    // 풍력발전기 확장 터빈(애드온)도 초록색으로 하이라이트
                    if (building.expansionInstances && building.expansionInstances.length > 0) {
                        building.expansionInstances.forEach(exp => {
                            if (exp.instance) {
                                exp.instance.traverse((child) => {
                                    if (child.isMesh && child.material) {
                                        // 확장 터빈은 scene에 직접 추가되어 있어 buildingGroup에 포함 안됨
                                        // 원본 머티리얼 저장 후 초록색 적용
                                        if (!this.powerViewOriginalMaterials.has(child.uuid)) {
                                            this.powerViewOriginalMaterials.set(child.uuid, child.material);
                                        }
                                        child.material = greenMat;
                                    }
                                });
                            }
                        });
                    }
                }
            });

            // 차량도 회색으로 변경
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                trafficManager.vehicleGroup.traverse((child) => {
                    if (child.isMesh && child.material) {
                        this.powerViewOriginalMaterials.set(child.uuid, child.material);
                        child.material = grayMat;
                    }
                });
            }
        },

        // 전력 뷰 머티리얼 복원
        restorePowerViewMaterials() {
            const restoreMaterial = (child) => {
                if (child.isMesh && this.powerViewOriginalMaterials.has(child.uuid)) {
                    child.material = this.powerViewOriginalMaterials.get(child.uuid);
                }
            };

            grassGroup.traverse(restoreMaterial);
            treeGroup.traverse(restoreMaterial);
            roadGroup.traverse(restoreMaterial);
            waterGroup.traverse(restoreMaterial);
            bridgeGroup.traverse(restoreMaterial);
            buildingGroup.traverse(restoreMaterial);

            // 인스턴스드 메쉬 (도로/구역 인디케이터) 복원
            const instancedMeshes = [
                typeof roadMesh !== 'undefined' ? roadMesh : null,
                typeof lockedRoadMesh !== 'undefined' ? lockedRoadMesh : null,
                typeof residentialMesh !== 'undefined' ? residentialMesh : null,
                typeof commercialMesh !== 'undefined' ? commercialMesh : null,
                typeof industrialMesh !== 'undefined' ? industrialMesh : null
            ].filter(m => m !== null);

            instancedMeshes.forEach(mesh => {
                if (mesh && this.powerViewOriginalMaterials.has(mesh.uuid)) {
                    mesh.material = this.powerViewOriginalMaterials.get(mesh.uuid);
                }
            });

            // 차량 복원
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                trafficManager.vehicleGroup.traverse(restoreMaterial);
            }

            // 풍력발전기 확장 터빈(애드온) 복원 - scene에 직접 추가되어 있어 별도 처리 필요
            placedPublicBuildings.forEach((building) => {
                if (building.ref) return;
                if (building.expansionInstances && building.expansionInstances.length > 0) {
                    building.expansionInstances.forEach(exp => {
                        if (exp.instance) {
                            exp.instance.traverse(restoreMaterial);
                        }
                    });
                }
            });

            this.powerViewOriginalMaterials.clear();
        },

        // 전력선 트리 구조 생성 (발전소에서 모든 전력 소비 건물까지 전선 표시)
        createPowerLineTree() {
            const drawnConnections = new Set();
            const allBuildingConnections = []; // 모든 건물 연결 정보 (전력 공급 여부 포함)

            // 모든 건물 인접 도로 수집 (전력 공급/미공급 모두)
            const allBuildingRoads = new Set();
            const powerPlantRoads = new Set();

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            // 건물에서 인접 도로 찾는 헬퍼 (건물당 하나의 도로 연결만)
            const collectBuildingRoads = (bx, by, width, height, buildingKey, building, isPublic) => {
                let foundConnection = false;
                const isPowered = this.poweredBuildings.has(buildingKey);
                const powerUsage = isPublic ?
                    this.calculatePublicBuildingPowerUsage(building) :
                    this.calculateBuildingPowerUsage(building);

                for (let dx = 0; dx < width && !foundConnection; dx++) {
                    for (let dy = 0; dy < height && !foundConnection; dy++) {
                        const tileX = bx + dx;
                        const tileY = by + dy;

                        for (const dir of directions) {
                            if (foundConnection) break;

                            const rx = tileX + dir.dx;
                            const ry = tileY + dir.dy;

                            // 건물 영역 내부는 스킵
                            if (rx >= bx && rx < bx + width && ry >= by && ry < by + height) continue;

                            if (rx >= 0 && rx < GRID_W && ry >= 0 && ry < GRID_H) {
                                if (isRoad(rx, ry) || isBridge(rx, ry)) {
                                    allBuildingRoads.add(`${rx},${ry}`);
                                    allBuildingConnections.push({
                                        buildingX: bx,
                                        buildingY: by,
                                        tileX: tileX,
                                        tileY: tileY,
                                        roadX: rx,
                                        roadY: ry,
                                        buildingKey,
                                        building,
                                        isPowered,
                                        powerUsage,
                                        width,
                                        height,
                                        isPublic
                                    });
                                    foundConnection = true;
                                }
                            }
                        }
                    }
                }
            };

            // 발전소 인접 도로 수집
            this.powerPlants.forEach((plant, key) => {
                for (let dx = -1; dx <= plant.width; dx++) {
                    for (let dy = -1; dy <= plant.depth; dy++) {
                        const nx = plant.x + dx;
                        const ny = plant.y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            if (isRoad(nx, ny) || isBridge(nx, ny)) {
                                powerPlantRoads.add(`${nx},${ny}`);
                            }
                        }
                    }
                }
            });

            // 일반 건물 (주거/상업/공업) - 모든 건물
            placedBuildings.forEach((building, key) => {
                if (building.ref || building.isAbandoned) return;
                collectBuildingRoads(building.x, building.y, building.width || 1, building.depth || 1, key, building, false);
            });

            // 서비스 건물 (학교, 경찰서, 소방서, 병원, 공원 등) - 모든 건물
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                // 발전소는 제외 (발전소는 전력 생산)
                if (this.powerPlants.has(key)) return;
                collectBuildingRoads(building.x, building.y, building.width || 2, building.depth || 2, key, building, true);
            });

            // 건물이 없으면 전선 없음
            if (allBuildingConnections.length === 0) return;

            // BFS로 발전소에서 모든 도로까지 경로 탐색
            const roadParent = new Map();
            const visited = new Set();
            const queue = [];

            powerPlantRoads.forEach(roadKey => {
                visited.add(roadKey);
                queue.push(roadKey);
            });

            while (queue.length > 0) {
                const current = queue.shift();
                const [cx, cy] = current.split(',').map(Number);

                for (const dir of directions) {
                    const nx = cx + dir.dx;
                    const ny = cy + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const nkey = `${nx},${ny}`;
                    if (visited.has(nkey)) continue;

                    if (isRoad(nx, ny) || isBridge(nx, ny)) {
                        visited.add(nkey);
                        roadParent.set(nkey, current);
                        queue.push(nkey);
                    }
                }
            }

            // 모든 건물에서 발전소까지 경로 역추적하여 필요한 도로 마킹
            const neededRoads = new Set();
            allBuildingConnections.forEach(conn => {
                const roadKey = `${conn.roadX},${conn.roadY}`;
                let trace = roadKey;
                while (trace && !powerPlantRoads.has(trace)) {
                    neededRoads.add(trace);
                    trace = roadParent.get(trace);
                }
                if (trace) {
                    neededRoads.add(trace);
                }
            });

            // 발전소 인접 도로 중 필요한 것만 추가
            powerPlantRoads.forEach(roadKey => {
                for (const dir of directions) {
                    const [x, y] = roadKey.split(',').map(Number);
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;
                    if (neededRoads.has(nkey)) {
                        neededRoads.add(roadKey);
                        break;
                    }
                }
            });

            // 도로 전선 그리기
            const processed4LaneOrigins = new Set();
            neededRoads.forEach(roadKey => {
                const [x, y] = roadKey.split(',').map(Number);

                if (is4LaneRoad(x, y)) {
                    const origin = find4LaneOrigin(x, y);
                    if (origin) {
                        const originKey = `${origin.x},${origin.y}`;
                        if (processed4LaneOrigins.has(originKey)) return;
                        processed4LaneOrigins.add(originKey);
                    }
                }

                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;

                    if (neededRoads.has(nkey) || powerPlantRoads.has(nkey)) {
                        if (is4LaneRoad(x, y) && is4LaneRoad(nx, ny)) {
                            const origin1 = find4LaneOrigin(x, y);
                            const origin2 = find4LaneOrigin(nx, ny);
                            if (origin1 && origin2 && origin1.x === origin2.x && origin1.y === origin2.y) {
                                continue;
                            }
                        }

                        let key1 = roadKey;
                        let key2 = nkey;
                        if (is4LaneRoad(x, y)) {
                            const o = find4LaneOrigin(x, y);
                            if (o) key1 = `4L_${o.x},${o.y}`;
                        }
                        if (is4LaneRoad(nx, ny)) {
                            const o = find4LaneOrigin(nx, ny);
                            if (o) key2 = `4L_${o.x},${o.y}`;
                        }

                        const connKey = [key1, key2].sort().join('_');
                        if (!drawnConnections.has(connKey)) {
                            drawnConnections.add(connKey);
                            this.drawPowerLine(x, y, nx, ny);
                        }
                    }
                }
            });

            // 발전소에서 인접 필요 도로로 연결선 그리기
            this.powerPlants.forEach((plant, key) => {
                const plantCenterX = plant.x + (plant.width - 1) / 2;
                const plantCenterY = plant.y + (plant.depth - 1) / 2;

                let closestRoad = null;
                let closestDist = Infinity;

                neededRoads.forEach(roadKey => {
                    const [rx, ry] = roadKey.split(',').map(Number);
                    let isAdjacent = false;
                    for (let dx = -1; dx <= plant.width; dx++) {
                        for (let dy = -1; dy <= plant.depth; dy++) {
                            if (rx === plant.x + dx && ry === plant.y + dy) {
                                isAdjacent = true;
                                break;
                            }
                        }
                        if (isAdjacent) break;
                    }

                    if (isAdjacent) {
                        const dist = Math.abs(rx - plantCenterX) + Math.abs(ry - plantCenterY);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestRoad = { x: rx, y: ry };
                        }
                    }
                });

                if (closestRoad) {
                    const connKey = `plant_${key}_to_${closestRoad.x},${closestRoad.y}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        this.drawPowerLine(Math.floor(plantCenterX), Math.floor(plantCenterY), closestRoad.x, closestRoad.y);
                    }
                }
            });

            // 모든 건물에서 도로로의 연결선 그리기 + 전력 요구량 원 표시
            allBuildingConnections.forEach(conn => {
                const roadKey = `${conn.roadX},${conn.roadY}`;
                if (neededRoads.has(roadKey) || powerPlantRoads.has(roadKey)) {
                    const connKey = `building_${conn.buildingKey}_to_${roadKey}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        // 건물 중심에서 도로로 연결선
                        const buildingCenterX = conn.buildingX + (conn.width - 1) / 2;
                        const buildingCenterY = conn.buildingY + (conn.height - 1) / 2;
                        this.drawPowerLine(Math.floor(buildingCenterX), Math.floor(buildingCenterY), conn.roadX, conn.roadY);

                        // 전력 요구량 원 표시 (건물 끝점)
                        this.createPowerRequirementCircle(conn);
                    }
                }
            });
        },

        // 전력 소모량 3D 원기둥 생성 (전력선 높이에 납작한 원기둥으로 표현)
        // 반투명 원기둥: 건물의 최대 사용량 (필요량)
        // 불투명 원기둥: 현재 사용량 (공급량)
        createPowerRequirementCircle(conn) {
            const { buildingX, buildingY, width, height, powerUsage, isPowered, building } = conn;

            // 건물 인스턴스 찾기
            let buildingInstance = building?.instance;
            if (!buildingInstance) return;

            // 건물 중심 위치 계산
            const buildingCenterX = buildingX + (width - 1) / 2;
            const buildingCenterY = buildingY + (height - 1) / 2;
            const worldPos = tileToWorldCenter(Math.floor(buildingCenterX), Math.floor(buildingCenterY));

            // 전력선과 동일한 높이
            const cylinderHeight = 0.12;
            const cylinderThickness = 0.04;  // 납작한 원기둥 두께

            // 건물 크기에 비례한 기본 반지름 (1x1 = 0.25, 2x2 = 0.4)
            const buildingSize = Math.max(width, height);
            const maxRadius = 0.15 + (buildingSize - 1) * 0.15;  // 최대 사용량 반지름

            // 전력 공급 비율 (현재 사용량 / 최대 사용량)
            // isPowered면 100%, 아니면 0%
            const supplyRatio = isPowered ? 1.0 : 0.0;
            const currentRadius = maxRadius * supplyRatio;  // 현재 사용량 반지름

            // 1. 반투명 원기둥 (최대 사용량 - 회색)
            const maxGeometry = new THREE.CylinderGeometry(maxRadius, maxRadius, cylinderThickness, 24);
            const maxMaterial = new THREE.MeshBasicMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.35,
                depthTest: false,
                depthWrite: false
            });
            const maxCylinder = new THREE.Mesh(maxGeometry, maxMaterial);
            maxCylinder.position.set(worldPos.x, cylinderHeight, worldPos.z);
            this.powerIconGroup.add(maxCylinder);

            // 2. 불투명 원기둥 (현재 사용량)
            if (currentRadius > 0.01) {
                // 전력 공급됨 - 노란색 불투명
                const currentGeometry = new THREE.CylinderGeometry(currentRadius, currentRadius, cylinderThickness + 0.01, 24);
                const currentMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffcc00,  // 노란색 (전력선과 동일)
                    transparent: false,
                    depthTest: false,
                    depthWrite: false
                });
                const currentCylinder = new THREE.Mesh(currentGeometry, currentMaterial);
                currentCylinder.position.set(worldPos.x, cylinderHeight + 0.005, worldPos.z);
                this.powerIconGroup.add(currentCylinder);
            }
        },

        // 4차선 도로의 월드 중심 좌표 가져오기
        get4LaneWorldCenter(x, y) {
            const origin = find4LaneOrigin(x, y);
            if (!origin) return tileToWorldCenter(x, y);
            // 2x2 영역의 중심
            const c1 = tileToWorldCenter(origin.x, origin.y);
            const c2 = tileToWorldCenter(origin.x + 1, origin.y + 1);
            return { x: (c1.x + c2.x) / 2, z: (c1.z + c2.z) / 2 };
        },

        // 전력선 그리기 - 4차선 도로 지원 (직각 연결)
        drawPowerLine(x1, y1, x2, y2) {
            // 4차선 도로인 경우 중심 좌표 사용
            const is4Lane1 = is4LaneRoad(x1, y1);
            const is4Lane2 = is4LaneRoad(x2, y2);

            const pos1 = is4Lane1 ? this.get4LaneWorldCenter(x1, y1) : tileToWorldCenter(x1, y1);
            const pos2 = is4Lane2 ? this.get4LaneWorldCenter(x2, y2) : tileToWorldCenter(x2, y2);
            const height = 0.12;

            // 4차선 도로는 굵은 선 (0.10), 2차선은 기본 (0.07)
            const lineWidth = (is4Lane1 || is4Lane2) ? 0.10 : 0.07;

            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.95,
                depthTest: false,   // 항상 보이도록 깊이 테스트 비활성화
                depthWrite: false   // 깊이 버퍼에 쓰지 않음
            });

            // 대각선이면 직각으로 꺾어서 연결 (4차선 도로 또는 일반 도로 모두)
            const dx = Math.abs(pos2.x - pos1.x);
            const dz = Math.abs(pos2.z - pos1.z);
            const isDiagonal = dx > 0.01 && dz > 0.01;  // 대각선 판단

            if (isDiagonal) {
                // 직각 연결: 먼저 X방향, 그 다음 Z방향
                const midPos = { x: pos2.x, z: pos1.z };

                // 첫 번째 선 (X방향)
                const curve1 = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(midPos.x, height, midPos.z)
                );
                const tube1 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve1, 1, lineWidth, 6, false),
                    tubeMaterial.clone()
                );
                this.powerLineGroup.add(tube1);

                // 두 번째 선 (Z방향)
                const curve2 = new THREE.LineCurve3(
                    new THREE.Vector3(midPos.x, height, midPos.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube2 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve2, 1, lineWidth, 6, false),
                    tubeMaterial.clone()
                );
                this.powerLineGroup.add(tube2);
            } else {
                // 직선 연결 (같은 X 또는 같은 Z)
                const curve = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube = new THREE.Mesh(
                    new THREE.TubeGeometry(curve, 1, lineWidth, 6, false),
                    tubeMaterial
                );
                this.powerLineGroup.add(tube);
            }
        },

        // 건물 전력 아이콘 업데이트 (발전소만 - 건물 전력 원은 createPowerLineTree에서 생성)
        updateBuildingPowerIcons() {
            // 발전소 아이콘 표시 (출력량 표시)
            this.powerPlants.forEach((plant, key) => {
                const building = placedPublicBuildings.get(key);
                if (building && building.instance) {
                    this.createPowerPlantIcon(plant.x, plant.y, building.instance, plant.output);
                }
            });
        },

        // 전력 아이콘 생성
        createPowerIcon(x, y, buildingInstance, isPowered) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.3;

            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444';
            ctx.fill();

            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('⚡', 32, 28);

            // X 표시
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(18, 42);
            ctx.lineTo(46, 42);
            ctx.stroke();

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.5, 0.5, 1);

            this.powerIconGroup.add(sprite);
            this.buildingPowerIcons.set(`${x},${y}`, sprite);
        },

        // 발전소 아이콘 생성
        createPowerPlantIcon(x, y, buildingInstance, output) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.5;

            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // 배경
            ctx.fillStyle = '#22c55e';
            ctx.beginPath();
            ctx.roundRect(0, 0, 128, 64, 8);
            ctx.fill();

            // 텍스트
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'black';
            ctx.fillText(`⚡${output}`, 64, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.8, 0.4, 1);

            this.powerIconGroup.add(sprite);
        },

        // 전력 뷰 토글
        togglePowerView() {
            if (currentMode === MODE.POWER_VIEW) {
                setMode(MODE.CAMERA);
            } else {
                setMode(MODE.POWER_VIEW);
            }
        }
    };

    // 공공시설 존재 확인 헬퍼
    function hasPublicBuildingAt(x, y) {
        return placedPublicBuildings.has(`${x},${y}`);
    }

    // showPowerEffects 함수 (발전소 설치 시 효과 범위 표시)
    function showPowerEffects(type) {
        // 기존 서비스 효과와 유사하게 처리
        const config = PUBLIC_BUILDING_MODELS[type];
        if (!config) return;

        // 전력 뷰 활성화
        powerManager.updatePowerVisualization();
    }

    /* =========================================================
     * WATER GRID MANAGER (수도망 시스템)
     * ========================================================= */
    const waterManager = {
        initialized: false,
        waterFacilities: new Map(),          // 수도 시설 목록 (key: "x,y")
        wateredBuildings: new Set(),         // 수도가 공급되는 건물 (key: "x,y")
        unwateredBuildings: new Set(),       // 수도가 부족한 건물 (key: "x,y")
        buildingWaterOffTime: new Map(),     // 건물별 수도 없는 시간 (key: "x,y", value: timestamp)
        buildingWaterAbandonTime: new Map(), // 건물별 폐건물화 예정 시간 (랜덤, 정규분포)
        waterPipeGroup: null,                // 수도관 그룹
        waterIconGroup: null,                // 수도 아이콘 그룹 (수도 모드용)
        unwateredIconGroup: null,            // 수도 부족 아이콘 그룹 (항상 표시)
        buildingWaterIcons: new Map(),       // 건물별 수도 아이콘
        waterViewOriginalMaterials: new Map(), // 수도 뷰 전환 전 원래 머티리얼 저장
        isWaterViewActive: false,            // 수도 뷰 활성화 상태

        // 상수
        WATER_PER_POPULATION: 0.3,           // 인구 1명당 수도 소비량
        PUBLIC_BUILDING_WATER: 15,           // 공공시설 수도 소비량
        WATER_OFF_ABANDON_MEAN: 80000,       // 수도 없이 폐건물 평균 시간 (80초)
        WATER_OFF_ABANDON_STDDEV: 25000,     // 폐건물화 시간 표준편차 (25초)

        // 초기화
        init() {
            if (this.initialized) return;

            this.waterPipeGroup = new THREE.Group();
            this.waterPipeGroup.name = 'waterPipes';
            this.waterPipeGroup.renderOrder = 999;  // 다른 오브젝트 위에 렌더링
            scene.add(this.waterPipeGroup);

            this.waterIconGroup = new THREE.Group();
            this.waterIconGroup.name = 'waterIcons';
            this.waterIconGroup.renderOrder = 1000;  // 수도관보다 위에 렌더링
            scene.add(this.waterIconGroup);

            // 수도 부족 아이콘 그룹 (항상 표시)
            this.unwateredIconGroup = new THREE.Group();
            this.unwateredIconGroup.name = 'unwateredIcons';
            scene.add(this.unwateredIconGroup);

            this.initialized = true;

            // 기존 급수시설 스캔 및 등록
            this.scanExistingWaterFacilities();

            // 수도 체크 타이머 (10초마다, 최적화)
            setInterval(() => this.checkWaterShortageAbandonment(), 10000);
        },

        // 기존 급수시설 스캔 (초기 로드 시)
        scanExistingWaterFacilities() {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조 키 스킵
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isWaterFacility) {
                    const waterKey = `${building.x},${building.y}`;
                    if (!this.waterFacilities.has(waterKey)) {
                        // 건물에 저장된 width/depth 우선 사용 (회전된 건물 지원)
                        const width = building.width || config.displayWidth || config.tileWidth || 2;
                        const depth = building.depth || config.displayDepth || config.tileDepth || 2;
                        this.waterFacilities.set(waterKey, {
                            x: building.x,
                            y: building.y,
                            type: building.type,
                            output: config.waterOutput || 100,
                            width: width,
                            depth: depth
                        });
                        console.log(`기존 급수시설 등록: ${waterKey}, size: ${width}x${depth}`);
                    }
                }
            });
        },

        // 수도 시설 추가
        addWaterFacility(x, y, type, config) {
            const key = `${x},${y}`;
            // displayWidth/displayDepth 사용 (실제 배치 크기)
            const width = config.displayWidth || config.tileWidth || 2;
            const depth = config.displayDepth || config.tileDepth || 2;
            this.waterFacilities.set(key, {
                x, y, type,
                output: config.waterOutput || 100,
                width: width,
                depth: depth
            });
            console.log(`수도시설 등록: ${type} at (${x},${y}), size: ${width}x${depth}, output: ${config.waterOutput}`);
            this.recalculateWaterGrid();
        },

        // 수도 시설 제거
        removeWaterFacility(x, y) {
            const key = `${x},${y}`;
            if (this.waterFacilities.has(key)) {
                this.waterFacilities.delete(key);
                this.recalculateWaterGrid();
            }
        },

        // 수도 사용량 계산 (인구 기반)
        calculateWaterUsage() {
            let usage = 0;

            // 인구 기반 수도 소비
            usage += Math.ceil(cityStats.population * this.WATER_PER_POPULATION);

            // 공공시설 수도 소비
            placedPublicBuildings.forEach((building, key) => {
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && !config.isWaterFacility) {
                    usage += this.PUBLIC_BUILDING_WATER;
                }
            });

            cityStats.waterUsage = usage;
            return usage;
        },

        // 총 수도 용량 계산
        calculateWaterCapacity() {
            let totalCapacity = 0;
            this.waterFacilities.forEach(facility => {
                // 서비스 건물 운영 상태 확인 (전력/도로)
                if (typeof serviceBuildingManager !== 'undefined' &&
                    !serviceBuildingManager.isOperational(facility.x, facility.y)) {
                    return; // 비운영 시설은 용량 계산에서 제외
                }
                totalCapacity += facility.output;
            });
            cityStats.waterCapacity = totalCapacity;
            return totalCapacity;
        },

        // 수도망 재계산 - BFS 거리 기반으로 가까운 건물부터 수도 공급
        recalculateWaterGrid() {
            this.wateredBuildings.clear();
            this.unwateredBuildings.clear();

            const capacity = this.calculateWaterCapacity();

            // 도로 연결된 모든 건물 수집 (이미 거리순 정렬됨)
            const allConnectedBuildings = this.collectConnectedBuildings();

            if (allConnectedBuildings.length === 0) {
                // 총 수도 사용량 업데이트
                cityStats.waterUsage = 0;
                this.updateWaterVisualization();
                updateStatsDisplay();
                return;
            }

            // 거리순으로 수도 배분 (가까운 건물 우선)
            let remainingCapacity = capacity;
            let totalUsage = 0;

            allConnectedBuildings.forEach(b => {
                const key = `${b.x},${b.y}`;
                const buildingWater = b.waterUsage || 3; // 기본 수도 사용량 3

                if (remainingCapacity >= buildingWater) {
                    // 수도 공급 가능
                    this.wateredBuildings.add(key);
                    this.buildingWaterOffTime.delete(key);
                    this.buildingWaterAbandonTime.delete(key);  // 폐건물화 타이머 초기화
                    remainingCapacity -= buildingWater;
                    totalUsage += buildingWater;
                } else {
                    // 수도 부족 - 공급 불가
                    this.unwateredBuildings.add(key);
                    // 수도 차단 시작 시간 기록 + 랜덤 폐건물화 시간 설정
                    if (!this.buildingWaterOffTime.has(key)) {
                        this.buildingWaterOffTime.set(key, Date.now());
                        // 정규분포 랜덤 시간 생성 (Box-Muller 변환)
                        const u1 = Math.random();
                        const u2 = Math.random();
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        const randomTime = Math.max(20000, this.WATER_OFF_ABANDON_MEAN + z * this.WATER_OFF_ABANDON_STDDEV);
                        this.buildingWaterAbandonTime.set(key, randomTime);
                    }
                    totalUsage += buildingWater; // 필요 수도량에는 포함
                }
            });

            // 총 수도 사용량 업데이트
            cityStats.waterUsage = totalUsage;

            // 시각화 업데이트
            this.updateWaterVisualization();
            updateStatsDisplay();
        },

        // 도로 연결된 모든 건물 수집 (BFS) - 수도 시설에서의 거리 포함
        collectConnectedBuildings() {
            const buildings = [];
            const visited = new Set();
            const roadDistances = new Map(); // 도로별 최소 거리

            // 모든 수도 시설에서 BFS 시작 (거리 0부터)
            this.waterFacilities.forEach(facility => {
                // 수도 시설 인접 도로 찾기 (거리 1)
                // 시설 영역: (x, y) ~ (x+width-1, y+depth-1)
                // 검사 영역: (x-1, y-1) ~ (x+width, y+depth) - 시설 영역 + 1칸 외곽
                let foundRoads = [];
                for (let dx = -1; dx <= facility.width; dx++) {
                    for (let dy = -1; dy <= facility.depth; dy++) {
                        const nx = facility.x + dx;
                        const ny = facility.y + dy;
                        if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                        // 시설 영역 내부는 스킵 (0 <= dx < width && 0 <= dy < depth)
                        const isInsideFacility = dx >= 0 && dx < facility.width && dy >= 0 && dy < facility.depth;
                        if (isInsideFacility) continue;

                        if (isRoad(nx, ny) || isBridge(nx, ny)) {
                            const key = `${nx},${ny}`;
                            // 더 가까운 거리로 업데이트
                            if (!roadDistances.has(key) || roadDistances.get(key) > 1) {
                                roadDistances.set(key, 1);
                                foundRoads.push(`(${nx},${ny})`);
                            }
                        }
                    }
                }
                if (foundRoads.length > 0) {
                    console.log(`수도시설 (${facility.x},${facility.y}) 인접 도로: ${foundRoads.join(', ')}`);
                } else {
                    console.warn(`수도시설 (${facility.x},${facility.y}) 인접 도로 없음! 물 공급 불가`);
                }
            });

            // BFS 큐 초기화 (수도 시설 인접 도로들)
            const queue = [];
            roadDistances.forEach((dist, key) => {
                const [x, y] = key.split(',').map(Number);
                queue.push({ x, y, distance: dist });
                visited.add(`road_${key}`);
            });

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            // BFS로 도로 따라 이동하며 인접 건물 수집 (거리 계산)
            while (queue.length > 0) {
                const current = queue.shift();

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const roadKey = `road_${nx},${ny}`;
                    const buildingKey = `building_${nx},${ny}`;
                    const newDistance = current.distance + 1;

                    // 도로면 계속 탐색
                    if ((isRoad(nx, ny) || isBridge(nx, ny)) && !visited.has(roadKey)) {
                        visited.add(roadKey);
                        roadDistances.set(`${nx},${ny}`, newDistance);
                        queue.push({ x: nx, y: ny, distance: newDistance });
                    }

                    // 건물이면 수집 (거리 정보 포함) - 민간 건물 + 공공 건물 모두 체크
                    if (!visited.has(buildingKey)) {
                        let building = placedBuildings.get(`${nx},${ny}`);
                        let isPublicBuilding = false;
                        let actualBuildingKey = buildingKey;

                        // 공공 건물도 체크 (참조 타일이면 원본 건물로 해석)
                        if (!building || building.ref) {
                            let publicBuilding = placedPublicBuildings.get(`${nx},${ny}`);

                            // 참조 타일이면 원본 건물 가져오기
                            if (publicBuilding && publicBuilding.ref) {
                                const primaryKey = publicBuilding.ref;
                                publicBuilding = placedPublicBuildings.get(primaryKey);
                                if (publicBuilding) {
                                    actualBuildingKey = `building_${primaryKey}`;
                                }
                            }

                            if (publicBuilding && !publicBuilding.ref) {
                                building = publicBuilding;
                                isPublicBuilding = true;
                            }
                        }

                        // 이미 처리된 건물은 스킵 (참조 해석 후 체크)
                        if (visited.has(actualBuildingKey)) continue;

                        if (building && !building.ref && !building.isAbandoned) {
                            visited.add(actualBuildingKey);
                            // 건물별 수도 사용량 계산
                            const waterUsage = isPublicBuilding ?
                                this.calculatePublicBuildingWaterUsage(building) :
                                this.calculateBuildingWaterUsage(building);
                            buildings.push({
                                x: building.x,  // 원본 건물 좌표 사용
                                y: building.y,
                                building,
                                distance: current.distance, // 수도 시설로부터의 거리
                                waterUsage,  // 건물별 수도 사용량
                                isPublicBuilding
                            });
                        }
                    }
                }
            }

            // 거리순 정렬 (가까운 건물 우선)
            buildings.sort((a, b) => a.distance - b.distance);

            return buildings;
        },

        // 건물별 수도 사용량 계산
        calculateBuildingWaterUsage(building) {
            if (!building) return 0;

            // 인구 기반 수도 소비
            const population = building.population || 0;
            let usage = Math.ceil(population * this.WATER_PER_POPULATION);

            // 최소 수도 사용량 (건물이 있으면 최소 3 소비)
            if (usage < 3) usage = 3;

            return usage;
        },

        // 공공 건물 수도 사용량 계산
        calculatePublicBuildingWaterUsage(building) {
            if (!building) return 0;

            // 공공 건물별 수도 사용량 설정 (건물 크기에 비례)
            const width = building.width || 2;
            const depth = building.depth || 2;
            const area = width * depth;

            // 기본 수도 사용량: 크기당 6
            return area * 6;
        },

        // 수도 차단으로 인한 폐건물 체크 (랜덤 시간 적용)
        checkWaterShortageAbandonment() {
            const now = Date.now();

            this.buildingWaterOffTime.forEach((startTime, key) => {
                const abandonTime = this.buildingWaterAbandonTime.get(key) || this.WATER_OFF_ABANDON_MEAN;
                const elapsedTime = now - startTime;

                if (elapsedTime >= abandonTime) {
                    // 폐건물로 전환
                    const building = placedBuildings.get(key);
                    if (building && !building.ref && !building.isAbandoned) {
                        this.convertToAbandoned(key, building);
                        // 수도 부족 상태 아이콘 제거 (폐건물 아이콘으로 대체됨)
                        removeBuildingStatus(building.x, building.y, 'NO_WATER');
                    }
                }
            });
        },

        // 건물을 폐건물로 전환 (수도 부족)
        convertToAbandoned(key, building) {
            if (!building || building.isAbandoned) return;

            building.isAbandoned = true;

            // 폐건물 사유 및 시간 저장
            if (building.instance && building.instance.userData) {
                building.instance.userData.isAbandoned = true;
                building.instance.userData.abandonedReason = '물이 없어서 살 수 없어요...';
                building.instance.userData.abandonedTime = Date.now();
            }

            // 건물 외관 변경 (어둡게)
            if (building.instance) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (!child.userData.originalMaterial) {
                            child.userData.originalMaterial = child.material.clone();
                        }
                        const darkMat = child.material.clone();
                        darkMat.color.multiplyScalar(0.3);
                        child.material = darkMat;
                    }
                });
            }

            // 인구 감소
            if (building.population) {
                cityStats.population -= building.population;
                if (cityStats.population < 0) cityStats.population = 0;
            }

            // 폐건물 목록에 추가
            if (typeof abandonedBuildings !== 'undefined') {
                abandonedBuildings.add(key);
            }

            // 폐건물 상태 아이콘 표시 (통합 시스템)
            addBuildingStatus(building.x, building.y, 'ABANDONED', building);

            // 수도 추적 정리
            this.buildingWaterOffTime.delete(key);
            this.buildingWaterAbandonTime.delete(key);

            console.log(`Building at ${key} became abandoned due to water shortage`);
        },

        // 타일에 수도가 공급되는지 확인
        isWatered(x, y) {
            return this.wateredBuildings.has(`${x},${y}`);
        },

        // 수도관 시각화 업데이트 (트리 구조로 표시)
        updateWaterVisualization() {
            // 기존 수도관 제거
            while (this.waterPipeGroup.children.length > 0) {
                const child = this.waterPipeGroup.children[0];
                this.waterPipeGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            // 기존 수도 모드 아이콘 제거
            while (this.waterIconGroup.children.length > 0) {
                this.waterIconGroup.remove(this.waterIconGroup.children[0]);
            }
            this.buildingWaterIcons.clear();

            // 수도 부족 아이콘 항상 업데이트
            this.updateUnwateredIcons();

            // 수도 관련 모드가 아니면 수도관/수도 시설 아이콘만 숨김
            const isWaterRelatedMode = currentMode === MODE.WATER_VIEW ||
                                       currentMode === MODE.PLACE_WASTEWATER ||
                                       currentMode === MODE.PLACE_WATER_PUMP_COAST;
            if (!isWaterRelatedMode) {
                this.waterPipeGroup.visible = false;
                this.waterIconGroup.visible = false;
                if (this.isWaterViewActive) {
                    this.restoreWaterViewMaterials();
                    this.isWaterViewActive = false;
                }
                return;
            }

            // 수도 뷰 머티리얼 적용
            if (!this.isWaterViewActive) {
                this.applyWaterViewMaterials();
                this.isWaterViewActive = true;
            }

            this.waterPipeGroup.visible = true;
            this.waterIconGroup.visible = true;

            // 수도관 트리 구조 생성
            this.createWaterPipeTree();

            // 건물 수도 상태 아이콘 표시 (수도 모드용)
            this.updateBuildingWaterIcons();
        },

        // 수도 부족 아이콘 업데이트 (통합 상태 아이콘 시스템 사용)
        _prevUnwateredBuildings: new Set(),

        updateUnwateredIcons() {
            // 기존 3D 아이콘 제거 (레거시)
            while (this.unwateredIconGroup && this.unwateredIconGroup.children.length > 0) {
                this.unwateredIconGroup.remove(this.unwateredIconGroup.children[0]);
            }

            // 새로 수도 공급된 건물에서 상태 제거
            this._prevUnwateredBuildings.forEach(key => {
                if (!this.unwateredBuildings.has(key)) {
                    const [x, y] = key.split(',').map(Number);
                    removeBuildingStatus(x, y, 'NO_WATER');
                }
            });

            // 새로 수도 부족한 건물에 상태 추가
            this.unwateredBuildings.forEach(key => {
                if (!this._prevUnwateredBuildings.has(key)) {
                    const building = placedBuildings.get(key);
                    if (building && building.instance && !building.ref) {
                        addBuildingStatus(building.x, building.y, 'NO_WATER', building);
                    }
                }
            });

            // 이전 상태 업데이트
            this._prevUnwateredBuildings = new Set(this.unwateredBuildings);
        },

        // 수도 뷰 머티리얼 적용 (토대는 흰색, 나머지는 회색)
        applyWaterViewMaterials() {
            this.waterViewOriginalMaterials.clear();

            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });

            // 수도 시설 하이라이트용 초록색 재질
            const greenMat = new THREE.MeshStandardMaterial({
                color: 0x44ff66,
                transparent: true,
                opacity: 0.85,
                emissive: 0x22aa44,
                emissiveIntensity: 0.3,
                roughness: 0.5,
                metalness: 0.0,
            });

            // oceanSewageSystem이 이미 원본 머티리얼을 저장했으면 그것을 사용
            // (수도 뷰 진입 시 oceanSewageSystem.toggleView(true)가 먼저 호출되어
            //  이미 회색으로 변경된 상태일 수 있음)
            const hasOceanSewageOriginals = typeof oceanSewageSystem !== 'undefined' &&
                                            oceanSewageSystem.isViewActive &&
                                            oceanSewageSystem.originalMaterials.size > 0;

            // 원본 머티리얼을 가져오는 헬퍼 함수
            const getOriginalMaterial = (child) => {
                if (hasOceanSewageOriginals && oceanSewageSystem.originalMaterials.has(child.uuid)) {
                    return oceanSewageSystem.originalMaterials.get(child.uuid);
                }
                return child.material;
            };

            // 토대(잔디) - 흰색
            grassGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.waterViewOriginalMaterials.set(child.uuid, getOriginalMaterial(child));
                    child.material = whiteMat;
                }
            });

            // 나무 - 흰색
            treeGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.waterViewOriginalMaterials.set(child.uuid, getOriginalMaterial(child));
                    child.material = whiteMat;
                }
            });

            // 도로, 수로, 다리 - 회색
            const grayGroups = [roadGroup, waterGroup, bridgeGroup];
            grayGroups.forEach(group => {
                group.traverse((child) => {
                    if (child.isMesh && child.material) {
                        this.waterViewOriginalMaterials.set(child.uuid, getOriginalMaterial(child));
                        child.material = grayMat;
                    }
                });
            });

            // 건물 - 회색
            buildingGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.waterViewOriginalMaterials.set(child.uuid, getOriginalMaterial(child));
                    child.material = grayMat;
                }
            });

            // 수도 시설 - 초록색으로 하이라이트
            // 주의: 원본 재질은 위의 buildingGroup.traverse에서 이미 저장됨
            // 여기서 다시 저장하면 이미 회색으로 변경된 재질이 저장되므로 저장하지 않음
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isWaterFacility && building.instance) {
                    building.instance.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // 원본은 이미 저장됨 - 초록색만 적용
                            child.material = greenMat;
                        }
                    });
                }
                // 풍력발전기 확장 터빈(애드온) - scene에 직접 추가되어 있어 별도 처리 필요
                if (building.expansionInstances && building.expansionInstances.length > 0) {
                    building.expansionInstances.forEach(exp => {
                        if (exp.instance) {
                            exp.instance.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    if (!this.waterViewOriginalMaterials.has(child.uuid)) {
                                        this.waterViewOriginalMaterials.set(child.uuid, getOriginalMaterial(child));
                                    }
                                    child.material = grayMat;
                                }
                            });
                        }
                    });
                }
            });

            // 차량도 회색으로 변경
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                trafficManager.vehicleGroup.traverse((child) => {
                    if (child.isMesh && child.material) {
                        this.waterViewOriginalMaterials.set(child.uuid, getOriginalMaterial(child));
                        child.material = grayMat;
                    }
                });
            }
        },

        // 수도 뷰 머티리얼 복원
        restoreWaterViewMaterials() {
            const restoreMaterial = (child) => {
                if (child.isMesh && this.waterViewOriginalMaterials.has(child.uuid)) {
                    child.material = this.waterViewOriginalMaterials.get(child.uuid);
                }
            };

            grassGroup.traverse(restoreMaterial);
            treeGroup.traverse(restoreMaterial);
            roadGroup.traverse(restoreMaterial);
            waterGroup.traverse(restoreMaterial);
            bridgeGroup.traverse(restoreMaterial);
            buildingGroup.traverse(restoreMaterial);

            // 차량 복원
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                trafficManager.vehicleGroup.traverse(restoreMaterial);
            }

            // 풍력발전기 확장 터빈(애드온) 복원 - scene에 직접 추가되어 있어 별도 처리 필요
            placedPublicBuildings.forEach((building) => {
                if (building.ref) return;
                if (building.expansionInstances && building.expansionInstances.length > 0) {
                    building.expansionInstances.forEach(exp => {
                        if (exp.instance) {
                            exp.instance.traverse(restoreMaterial);
                        }
                    });
                }
            });

            this.waterViewOriginalMaterials.clear();
        },

        // 수도관 트리 구조 생성 (모든 건물 연결 - 수도 공급 여부 관계없이)
        createWaterPipeTree() {
            const drawnConnections = new Set();
            const buildingToRoadConnections = [];

            // 1단계: 모든 건물 인접 도로 수집 (수도 공급 여부 관계없이)
            const allBuildingRoads = new Set();
            const waterFacilityRoads = new Set();

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            // 건물에서 인접 도로 찾는 헬퍼 (모든 건물 수집 + 수도 사용량 정보)
            const collectBuildingRoads = (bx, by, width, height, buildingKey, building, isPublic) => {
                let foundConnection = false;
                const isWatered = this.wateredBuildings.has(buildingKey);
                const waterUsage = isPublic ?
                    this.calculatePublicBuildingWaterUsage(building) :
                    this.calculateBuildingWaterUsage(building);

                for (let dx = 0; dx < width && !foundConnection; dx++) {
                    for (let dy = 0; dy < height && !foundConnection; dy++) {
                        const tileX = bx + dx;
                        const tileY = by + dy;

                        for (const dir of directions) {
                            if (foundConnection) break;

                            const rx = tileX + dir.dx;
                            const ry = tileY + dir.dy;

                            if (rx >= bx && rx < bx + width && ry >= by && ry < by + height) continue;

                            if (rx >= 0 && rx < GRID_W && ry >= 0 && ry < GRID_H) {
                                if (isRoad(rx, ry) || isBridge(rx, ry)) {
                                    // 모든 건물의 인접 도로 수집 (수도 공급 여부 관계없이)
                                    allBuildingRoads.add(`${rx},${ry}`);
                                    buildingToRoadConnections.push({
                                        buildingX: bx,
                                        buildingY: by,
                                        tileX: tileX,
                                        tileY: tileY,
                                        roadX: rx,
                                        roadY: ry,
                                        buildingKey,
                                        building,
                                        isWatered,
                                        waterUsage,
                                        width,
                                        height,
                                        isPublic
                                    });
                                    foundConnection = true;
                                }
                            }
                        }
                    }
                }
            };

            // 수도 시설 인접 도로 수집 (시설 영역 외곽만)
            this.waterFacilities.forEach((facility, key) => {
                for (let dx = -1; dx <= facility.width; dx++) {
                    for (let dy = -1; dy <= facility.depth; dy++) {
                        const nx = facility.x + dx;
                        const ny = facility.y + dy;
                        if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                        // 시설 영역 내부는 스킵
                        const isInsideFacility = dx >= 0 && dx < facility.width && dy >= 0 && dy < facility.depth;
                        if (isInsideFacility) continue;

                        if (isRoad(nx, ny) || isBridge(nx, ny)) {
                            waterFacilityRoads.add(`${nx},${ny}`);
                        }
                    }
                }
            });

            // 일반 건물 - 모든 건물 (폐건물 제외)
            placedBuildings.forEach((building, key) => {
                if (building.ref || building.isAbandoned) return;
                collectBuildingRoads(building.x, building.y, building.width || 1, building.depth || 1, key, building, false);
            });

            // 서비스 건물 - 모든 건물 (수도 시설 제외)
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                if (this.waterFacilities.has(key)) return;
                collectBuildingRoads(building.x, building.y, building.width || 2, building.depth || 2, key, building, true);
            });

            // 건물이 없으면 수도관 없음
            if (allBuildingRoads.size === 0) return;

            // 2단계: 수도 시설에서 BFS로 모든 도로까지의 경로 찾기
            const neededRoads = new Set();
            const roadParent = new Map();

            const visited = new Set();
            const queue = [];

            waterFacilityRoads.forEach(roadKey => {
                visited.add(roadKey);
                queue.push(roadKey);
            });

            while (queue.length > 0) {
                const current = queue.shift();
                const [cx, cy] = current.split(',').map(Number);

                for (const dir of directions) {
                    const nx = cx + dir.dx;
                    const ny = cy + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const nkey = `${nx},${ny}`;
                    if (visited.has(nkey)) continue;

                    if (isRoad(nx, ny) || isBridge(nx, ny)) {
                        visited.add(nkey);
                        roadParent.set(nkey, current);
                        queue.push(nkey);
                    }
                }
            }

            // 모든 건물에서 수도 시설까지 경로 역추적 (수도 공급 여부 관계없이)
            allBuildingRoads.forEach(roadKey => {
                let trace = roadKey;
                while (trace && !waterFacilityRoads.has(trace)) {
                    neededRoads.add(trace);
                    trace = roadParent.get(trace);
                }
                if (trace) {
                    neededRoads.add(trace);
                }
            });

            waterFacilityRoads.forEach(roadKey => {
                for (const dir of directions) {
                    const [x, y] = roadKey.split(',').map(Number);
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;
                    if (neededRoads.has(nkey)) {
                        neededRoads.add(roadKey);
                        break;
                    }
                }
            });

            // 3단계: 필요한 도로에 수도관 그리기 (4차선 도로는 원점 기준으로 통합)
            const processed4LaneOrigins = new Set();

            neededRoads.forEach(roadKey => {
                const [x, y] = roadKey.split(',').map(Number);

                // 4차선 도로인 경우 원점만 처리 (중복 방지)
                if (is4LaneRoad(x, y)) {
                    const origin = find4LaneOrigin(x, y);
                    if (origin) {
                        const originKey = `${origin.x},${origin.y}`;
                        if (processed4LaneOrigins.has(originKey)) return;
                        processed4LaneOrigins.add(originKey);
                    }
                }

                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;

                    if (neededRoads.has(nkey) || waterFacilityRoads.has(nkey)) {
                        // 같은 4차선 도로 내부 타일끼리는 연결선 스킵
                        if (is4LaneRoad(x, y) && is4LaneRoad(nx, ny)) {
                            const origin1 = find4LaneOrigin(x, y);
                            const origin2 = find4LaneOrigin(nx, ny);
                            if (origin1 && origin2 && origin1.x === origin2.x && origin1.y === origin2.y) {
                                continue;
                            }
                        }

                        // 4차선 도로는 원점 좌표를 사용하여 연결 키 생성
                        let keyX = x, keyY = y, keyNX = nx, keyNY = ny;
                        if (is4LaneRoad(x, y)) {
                            const origin = find4LaneOrigin(x, y);
                            if (origin) { keyX = origin.x; keyY = origin.y; }
                        }
                        if (is4LaneRoad(nx, ny)) {
                            const origin = find4LaneOrigin(nx, ny);
                            if (origin) { keyNX = origin.x; keyNY = origin.y; }
                        }

                        const connKey = [`${keyX},${keyY}`, `${keyNX},${keyNY}`].sort().join('_');
                        if (!drawnConnections.has(connKey)) {
                            drawnConnections.add(connKey);
                            this.drawWaterPipe(x, y, nx, ny);
                        }
                    }
                }
            });

            // 4단계: 수도 시설에서 인접 필요 도로로 연결선 그리기
            this.waterFacilities.forEach((facility, key) => {
                const facilityCenterX = facility.x + (facility.width - 1) / 2;
                const facilityCenterY = facility.y + (facility.depth - 1) / 2;

                // 시설 인접 도로 중 neededRoads에 포함된 것들 찾기
                const adjacentNeededRoads = [];
                for (let dx = -1; dx <= facility.width; dx++) {
                    for (let dy = -1; dy <= facility.depth; dy++) {
                        // 시설 영역 내부는 스킵
                        const isInsideFacility = dx >= 0 && dx < facility.width && dy >= 0 && dy < facility.depth;
                        if (isInsideFacility) continue;

                        const nx = facility.x + dx;
                        const ny = facility.y + dy;
                        if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                        const roadKey = `${nx},${ny}`;
                        if (neededRoads.has(roadKey) || waterFacilityRoads.has(roadKey)) {
                            adjacentNeededRoads.push({ x: nx, y: ny });
                        }
                    }
                }

                // 가장 가까운 인접 도로와 연결
                if (adjacentNeededRoads.length > 0) {
                    let closestRoad = adjacentNeededRoads[0];
                    let closestDist = Math.abs(closestRoad.x - facilityCenterX) + Math.abs(closestRoad.y - facilityCenterY);

                    for (const road of adjacentNeededRoads) {
                        const dist = Math.abs(road.x - facilityCenterX) + Math.abs(road.y - facilityCenterY);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestRoad = road;
                        }
                    }

                    const connKey = `facility_${key}_to_${closestRoad.x},${closestRoad.y}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        this.drawWaterPipe(Math.floor(facilityCenterX), Math.floor(facilityCenterY), closestRoad.x, closestRoad.y);
                    }
                }
            });

            // 5단계: 모든 건물에서 도로로의 연결선 그리기 + 수도 사용량 원기둥 표시
            buildingToRoadConnections.forEach(conn => {
                const roadKey = `${conn.roadX},${conn.roadY}`;
                if (neededRoads.has(roadKey)) {
                    const connKey = `building_${conn.buildingKey}_to_${roadKey}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        // 건물 중심에서 도로로 연결선
                        const buildingCenterX = conn.buildingX + (conn.width - 1) / 2;
                        const buildingCenterY = conn.buildingY + (conn.height - 1) / 2;
                        this.drawWaterPipe(Math.floor(buildingCenterX), Math.floor(buildingCenterY), conn.roadX, conn.roadY);

                        // 수도 사용량 원기둥 표시
                        this.createWaterUsageCylinder(conn);
                    }
                }
            });
        },

        // 수도 사용량 3D 원기둥 생성 (수도관 높이에 납작한 원기둥으로 표현)
        // 반투명 원기둥: 건물의 최대 사용량 (필요량)
        // 불투명 원기둥: 현재 사용량 (공급량)
        createWaterUsageCylinder(conn) {
            const { buildingX, buildingY, width, height, waterUsage, isWatered, building } = conn;

            // 건물 인스턴스 찾기
            let buildingInstance = building?.instance;
            if (!buildingInstance) return;

            // 건물 중심 위치 계산
            const buildingCenterX = buildingX + (width - 1) / 2;
            const buildingCenterY = buildingY + (height - 1) / 2;
            const worldPos = tileToWorldCenter(Math.floor(buildingCenterX), Math.floor(buildingCenterY));

            // 수도관과 동일한 높이
            const cylinderHeight = 0.10;
            const cylinderThickness = 0.04;  // 납작한 원기둥 두께

            // 건물 크기에 비례한 기본 반지름 (1x1 = 0.15, 2x2 = 0.3)
            const buildingSize = Math.max(width, height);
            const maxRadius = 0.12 + (buildingSize - 1) * 0.12;  // 최대 사용량 반지름

            // 수도 공급 비율 (현재 사용량 / 최대 사용량)
            const supplyRatio = isWatered ? 1.0 : 0.0;
            const currentRadius = maxRadius * supplyRatio;  // 현재 사용량 반지름

            // 1. 반투명 원기둥 (최대 사용량 - 회색)
            const maxGeometry = new THREE.CylinderGeometry(maxRadius, maxRadius, cylinderThickness, 24);
            const maxMaterial = new THREE.MeshBasicMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.35,
                depthTest: false,
                depthWrite: false
            });
            const maxCylinder = new THREE.Mesh(maxGeometry, maxMaterial);
            maxCylinder.position.set(worldPos.x, cylinderHeight, worldPos.z);
            this.waterIconGroup.add(maxCylinder);

            // 2. 불투명 원기둥 (현재 사용량)
            if (currentRadius > 0.01) {
                // 수도 공급됨 - 하늘색 불투명
                const currentGeometry = new THREE.CylinderGeometry(currentRadius, currentRadius, cylinderThickness + 0.01, 24);
                const currentMaterial = new THREE.MeshBasicMaterial({
                    color: 0x87CEEB,  // 하늘색 (수도관과 동일)
                    transparent: false,
                    depthTest: false,
                    depthWrite: false
                });
                const currentCylinder = new THREE.Mesh(currentGeometry, currentMaterial);
                currentCylinder.position.set(worldPos.x, cylinderHeight + 0.005, worldPos.z);
                this.waterIconGroup.add(currentCylinder);
            }
        },

        // 4차선 도로의 월드 중심 좌표 가져오기
        get4LaneWorldCenter(x, y) {
            const origin = find4LaneOrigin(x, y);
            if (!origin) return tileToWorldCenter(x, y);
            // 2x2 영역의 중심
            const c1 = tileToWorldCenter(origin.x, origin.y);
            const c2 = tileToWorldCenter(origin.x + 1, origin.y + 1);
            return { x: (c1.x + c2.x) / 2, z: (c1.z + c2.z) / 2 };
        },

        // 수도관 그리기 - 4차선 도로 지원 (직각 연결)
        drawWaterPipe(x1, y1, x2, y2) {
            // 4차선 도로인 경우 중심 좌표 사용
            const is4Lane1 = is4LaneRoad(x1, y1);
            const is4Lane2 = is4LaneRoad(x2, y2);

            const pos1 = is4Lane1 ? this.get4LaneWorldCenter(x1, y1) : tileToWorldCenter(x1, y1);
            const pos2 = is4Lane2 ? this.get4LaneWorldCenter(x2, y2) : tileToWorldCenter(x2, y2);
            const height = 0.10;

            // 4차선 도로는 굵은 선 (0.10), 2차선은 기본 (0.07)
            const lineWidth = (is4Lane1 || is4Lane2) ? 0.10 : 0.07;

            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,  // 하늘색 (Sky Blue)
                transparent: true,
                opacity: 0.95,
                depthTest: false,   // 항상 보이도록 깊이 테스트 비활성화
                depthWrite: false   // 깊이 버퍼에 쓰지 않음
            });

            // 대각선이면 직각으로 꺾어서 연결 (4차선 도로 또는 일반 도로 모두)
            const dx = Math.abs(pos2.x - pos1.x);
            const dz = Math.abs(pos2.z - pos1.z);
            const isDiagonal = dx > 0.01 && dz > 0.01;  // 대각선 판단

            if (isDiagonal) {
                // 직각 연결: 먼저 X방향, 그 다음 Z방향
                const midPos = { x: pos2.x, z: pos1.z };

                // 첫 번째 선 (X방향)
                const curve1 = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(midPos.x, height, midPos.z)
                );
                const tube1 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve1, 1, lineWidth, 6, false),
                    tubeMaterial.clone()
                );
                this.waterPipeGroup.add(tube1);

                // 두 번째 선 (Z방향)
                const curve2 = new THREE.LineCurve3(
                    new THREE.Vector3(midPos.x, height, midPos.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube2 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve2, 1, lineWidth, 6, false),
                    tubeMaterial.clone()
                );
                this.waterPipeGroup.add(tube2);
            } else {
                // 직선 연결 (같은 X 또는 같은 Z)
                const curve = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube = new THREE.Mesh(
                    new THREE.TubeGeometry(curve, 1, lineWidth, 6, false),
                    tubeMaterial
                );
                this.waterPipeGroup.add(tube);
            }
        },

        // 건물 수도 아이콘 업데이트
        updateBuildingWaterIcons() {
            // 수도 부족 건물에만 아이콘 표시
            this.unwateredBuildings.forEach(key => {
                const building = placedBuildings.get(key);
                if (building && building.instance) {
                    this.createWaterIcon(building.x, building.y, building.instance, false);
                }
            });

            // 수도 시설 아이콘 표시
            this.waterFacilities.forEach((facility, key) => {
                const building = placedPublicBuildings.get(key);
                if (building && building.instance) {
                    this.createWaterFacilityIcon(facility.x, facility.y, building.instance, facility.output);
                }
            });
        },

        // 수도 아이콘 생성
        createWaterIcon(x, y, buildingInstance, isWatered) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.3;

            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444';
            ctx.fill();

            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('💧', 32, 28);

            // X 표시
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(18, 42);
            ctx.lineTo(46, 42);
            ctx.stroke();

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.5, 0.5, 1);

            this.waterIconGroup.add(sprite);
            this.buildingWaterIcons.set(`${x},${y}`, sprite);
        },

        // 수도 시설 아이콘 생성
        createWaterFacilityIcon(x, y, buildingInstance, output) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.5;

            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // 배경 (하늘색)
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.roundRect(0, 0, 128, 64, 8);
            ctx.fill();

            // 텍스트
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'black';
            ctx.fillText(`💧${output}`, 64, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.8, 0.4, 1);

            this.waterIconGroup.add(sprite);
        },

        // 수도 뷰 토글
        toggleWaterView() {
            if (currentMode === MODE.WATER_VIEW) {
                setMode(MODE.CAMERA);
            } else {
                setMode(MODE.WATER_VIEW);
            }
        }
    };

    // showWaterEffects 함수 (수도 시설 설치 시 효과 범위 표시)
    function showWaterEffects(type) {
        const config = PUBLIC_BUILDING_MODELS[type];
        if (!config) return;

        // 수도 뷰 활성화
        waterManager.updateWaterVisualization();
    }

    /* =========================================================
     * SEWAGE GRID MANAGER (하수망 시스템)
     * ========================================================= */
    const sewageManager = {
        initialized: false,
        sewageFacilities: new Map(),          // 하수 처리 시설 목록 (key: "x,y")
        connectedBuildings: new Set(),        // 하수 연결된 건물 (key: "x,y")
        disconnectedBuildings: new Set(),     // 하수 미연결 건물 (key: "x,y")
        sewagePipeGroup: null,                // 하수관 그룹
        sewageIconGroup: null,                // 하수 아이콘 그룹 (하수 모드용)
        isSewageViewActive: false,            // 하수 뷰 활성화 상태
        // 참고: 머티리얼 관리는 oceanSewageSystem이 담당

        // 상수
        SEWAGE_PER_POPULATION: 0.25,          // 인구 1명당 하수 발생량
        PUBLIC_BUILDING_SEWAGE: 10,           // 공공시설 하수 발생량
        PIPE_COLOR: 0x8B4513,                 // 갈색 (하수관 색상)

        // 초기화
        init() {
            if (this.initialized) return;

            this.sewagePipeGroup = new THREE.Group();
            this.sewagePipeGroup.name = 'sewagePipes';
            this.sewagePipeGroup.renderOrder = 999;  // 다른 오브젝트 위에 렌더링
            scene.add(this.sewagePipeGroup);

            this.sewageIconGroup = new THREE.Group();
            this.sewageIconGroup.name = 'sewageIcons';
            this.sewageIconGroup.renderOrder = 1000;  // 하수관보다 위에 렌더링
            scene.add(this.sewageIconGroup);

            this.initialized = true;

            // 기존 하수처리시설 스캔 및 등록
            this.scanExistingSewageFacilities();
        },

        // 기존 하수처리시설 스캔 (초기 로드 시)
        scanExistingSewageFacilities() {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isSewageFacility) {
                    const sewageKey = `${building.x},${building.y}`;
                    if (!this.sewageFacilities.has(sewageKey)) {
                        // 건물에 저장된 width/depth 우선 사용 (회전된 건물 지원)
                        const width = building.width || config.displayWidth || config.tileWidth || 2;
                        const depth = building.depth || config.displayDepth || config.tileDepth || 2;
                        this.sewageFacilities.set(sewageKey, {
                            x: building.x,
                            y: building.y,
                            type: building.type,
                            capacity: config.sewageCapacity || 500,
                            width: width,
                            depth: depth
                        });
                        console.log(`기존 하수처리시설 등록: ${sewageKey}, size: ${width}x${depth}`);
                    }
                }
            });
        },

        // 하수 처리 시설 추가
        addSewageFacility(x, y, type, config) {
            const key = `${x},${y}`;
            const width = config.displayWidth || config.tileWidth || 2;
            const depth = config.displayDepth || config.tileDepth || 2;
            this.sewageFacilities.set(key, {
                x, y, type,
                capacity: config.sewageCapacity || 500,
                width: width,
                depth: depth
            });
            console.log(`하수처리시설 등록: ${type} at (${x},${y}), size: ${width}x${depth}, capacity: ${config.sewageCapacity}`);
            this.recalculateSewageGrid();
        },

        // 하수 처리 시설 제거
        removeSewageFacility(x, y) {
            const key = `${x},${y}`;
            if (this.sewageFacilities.has(key)) {
                this.sewageFacilities.delete(key);
                this.recalculateSewageGrid();
            }
        },

        // 총 하수 발생량 계산
        calculateSewageUsage() {
            let usage = 0;
            usage += Math.ceil(cityStats.population * this.SEWAGE_PER_POPULATION);
            placedPublicBuildings.forEach((building, key) => {
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && !config.isSewageFacility) {
                    usage += this.PUBLIC_BUILDING_SEWAGE;
                }
            });
            cityStats.sewageUsage = usage;
            return usage;
        },

        // 총 하수 처리 용량 계산
        calculateSewageCapacity() {
            let totalCapacity = 0;
            this.sewageFacilities.forEach(facility => {
                // 서비스 건물 운영 상태 확인 (전력/도로)
                if (typeof serviceBuildingManager !== 'undefined' &&
                    !serviceBuildingManager.isOperational(facility.x, facility.y)) {
                    return; // 비운영 시설은 용량 계산에서 제외
                }
                totalCapacity += facility.capacity;
            });
            cityStats.sewageCapacity = totalCapacity;
            return totalCapacity;
        },

        // 하수망 재계산 - BFS 거리 기반
        recalculateSewageGrid() {
            this.connectedBuildings.clear();
            this.disconnectedBuildings.clear();

            const capacity = this.calculateSewageCapacity();
            const allConnectedBuildings = this.collectConnectedBuildings();

            if (allConnectedBuildings.length === 0) {
                cityStats.sewageUsage = 0;
                this.updateSewageVisualization();
                updateStatsDisplay();
                return;
            }

            let remainingCapacity = capacity;
            let totalUsage = 0;

            allConnectedBuildings.forEach(b => {
                const key = `${b.x},${b.y}`;
                const buildingSewage = b.sewageOutput || 2;

                if (remainingCapacity >= buildingSewage) {
                    this.connectedBuildings.add(key);
                    remainingCapacity -= buildingSewage;
                    totalUsage += buildingSewage;
                } else {
                    this.disconnectedBuildings.add(key);
                    totalUsage += buildingSewage;
                }
            });

            cityStats.sewageUsage = totalUsage;
            this.updateSewageVisualization();
            updateStatsDisplay();
        },

        // 도로 연결된 모든 건물 수집 (BFS) - 하수 처리 시설에서의 거리 포함
        collectConnectedBuildings() {
            const buildings = [];
            const visited = new Set();
            const roadDistances = new Map();

            // 모든 하수 처리 시설에서 BFS 시작
            this.sewageFacilities.forEach(facility => {
                let foundRoads = [];
                for (let dx = -1; dx <= facility.width; dx++) {
                    for (let dy = -1; dy <= facility.depth; dy++) {
                        const nx = facility.x + dx;
                        const ny = facility.y + dy;
                        if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                        const isInsideFacility = dx >= 0 && dx < facility.width && dy >= 0 && dy < facility.depth;
                        if (isInsideFacility) continue;

                        if (isRoad(nx, ny) || isBridge(nx, ny)) {
                            const key = `${nx},${ny}`;
                            if (!roadDistances.has(key) || roadDistances.get(key) > 1) {
                                roadDistances.set(key, 1);
                                foundRoads.push(`(${nx},${ny})`);
                            }
                        }
                    }
                }
                if (foundRoads.length > 0) {
                    console.log(`하수처리시설 (${facility.x},${facility.y}) 인접 도로: ${foundRoads.join(', ')}`);
                }
            });

            const queue = [];
            roadDistances.forEach((dist, key) => {
                const [x, y] = key.split(',').map(Number);
                queue.push({ x, y, distance: dist });
                visited.add(`road_${key}`);
            });

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            while (queue.length > 0) {
                const current = queue.shift();

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const roadKey = `road_${nx},${ny}`;
                    const buildingKey = `building_${nx},${ny}`;
                    const newDistance = current.distance + 1;

                    if ((isRoad(nx, ny) || isBridge(nx, ny)) && !visited.has(roadKey)) {
                        visited.add(roadKey);
                        roadDistances.set(`${nx},${ny}`, newDistance);
                        queue.push({ x: nx, y: ny, distance: newDistance });
                    }

                    if (!visited.has(buildingKey)) {
                        const building = placedBuildings.get(`${nx},${ny}`);
                        if (building && !building.ref) {
                            visited.add(buildingKey);
                            buildings.push({
                                x: nx, y: ny,
                                distance: newDistance,
                                sewageOutput: 2
                            });
                        }

                        // 공공 건물 체크 (참조 타일이면 원본 건물로 해석)
                        let publicBuilding = placedPublicBuildings.get(`${nx},${ny}`);
                        let actualBuildingKey = buildingKey;

                        // 참조 타일이면 원본 건물 가져오기
                        if (publicBuilding && publicBuilding.ref) {
                            const primaryKey = publicBuilding.ref;
                            publicBuilding = placedPublicBuildings.get(primaryKey);
                            if (publicBuilding) {
                                actualBuildingKey = `building_${primaryKey}`;
                            }
                        }

                        // 이미 처리된 건물은 스킵
                        if (!visited.has(actualBuildingKey) && publicBuilding && !publicBuilding.ref) {
                            const facilityKey = `${publicBuilding.x},${publicBuilding.y}`;
                            if (!this.sewageFacilities.has(facilityKey)) {
                                visited.add(actualBuildingKey);
                                buildings.push({
                                    x: publicBuilding.x, y: publicBuilding.y,
                                    distance: newDistance,
                                    sewageOutput: this.PUBLIC_BUILDING_SEWAGE
                                });
                            }
                        }
                    }
                }
            }

            buildings.sort((a, b) => a.distance - b.distance);
            return buildings;
        },

        // 하수 시각화 업데이트
        updateSewageVisualization() {
            // 기존 파이프 제거
            while (this.sewagePipeGroup.children.length > 0) {
                const child = this.sewagePipeGroup.children[0];
                this.sewagePipeGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            // 기존 아이콘 제거
            while (this.sewageIconGroup.children.length > 0) {
                const child = this.sewageIconGroup.children[0];
                this.sewageIconGroup.remove(child);
                if (child.material && child.material.map) child.material.map.dispose();
                if (child.material) child.material.dispose();
            }

            if (!this.isSewageViewActive) {
                this.sewagePipeGroup.visible = false;
                this.sewageIconGroup.visible = false;
                return;
            }

            this.sewagePipeGroup.visible = true;
            this.sewageIconGroup.visible = true;

            // 하수관 트리 구조 생성
            this.createSewagePipeTree();

            // 하수 시설 아이콘 표시
            this.updateBuildingSewageIcons();
        },

        // 하수관 트리 구조 생성
        createSewagePipeTree() {
            const drawnConnections = new Set();
            const buildingToRoadConnections = [];

            const connectedBuildingRoads = new Set();
            const sewageFacilityRoads = new Set();

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            const collectBuildingRoads = (bx, by, width, height, isConnected, buildingKey) => {
                let foundConnection = false;
                for (let dx = 0; dx < width && !foundConnection; dx++) {
                    for (let dy = 0; dy < height && !foundConnection; dy++) {
                        const tileX = bx + dx;
                        const tileY = by + dy;
                        for (const dir of directions) {
                            if (foundConnection) break;
                            const rx = tileX + dir.dx;
                            const ry = tileY + dir.dy;
                            if (rx >= bx && rx < bx + width && ry >= by && ry < by + height) continue;
                            if (rx >= 0 && rx < GRID_W && ry >= 0 && ry < GRID_H) {
                                if (isRoad(rx, ry) || isBridge(rx, ry)) {
                                    if (isConnected) {
                                        connectedBuildingRoads.add(`${rx},${ry}`);
                                        buildingToRoadConnections.push({
                                            buildingX: tileX, buildingY: tileY,
                                            roadX: rx, roadY: ry, buildingKey
                                        });
                                    }
                                    foundConnection = true;
                                }
                            }
                        }
                    }
                }
            };

            // 하수 처리 시설 인접 도로 수집
            this.sewageFacilities.forEach((facility, key) => {
                for (let dx = -1; dx <= facility.width; dx++) {
                    for (let dy = -1; dy <= facility.depth; dy++) {
                        const nx = facility.x + dx;
                        const ny = facility.y + dy;
                        if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;
                        const isInsideFacility = dx >= 0 && dx < facility.width && dy >= 0 && dy < facility.depth;
                        if (isInsideFacility) continue;
                        if (isRoad(nx, ny) || isBridge(nx, ny)) {
                            sewageFacilityRoads.add(`${nx},${ny}`);
                        }
                    }
                }
            });

            // 연결된 건물만
            placedBuildings.forEach((building, key) => {
                if (building.ref) return;
                const isConnected = this.connectedBuildings.has(key);
                collectBuildingRoads(building.x, building.y, building.width || 1, building.depth || 1, isConnected, key);
            });

            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                if (this.sewageFacilities.has(key)) return;
                const isConnected = this.connectedBuildings.has(key);
                collectBuildingRoads(building.x, building.y, building.width || 2, building.depth || 2, isConnected, key);
            });

            if (connectedBuildingRoads.size === 0) return;

            // BFS로 경로 찾기
            const neededRoads = new Set();
            const roadParent = new Map();
            const visited = new Set();
            const queue = [];

            sewageFacilityRoads.forEach(roadKey => {
                visited.add(roadKey);
                queue.push(roadKey);
            });

            while (queue.length > 0) {
                const current = queue.shift();
                const [cx, cy] = current.split(',').map(Number);
                for (const dir of directions) {
                    const nx = cx + dir.dx;
                    const ny = cy + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;
                    const nkey = `${nx},${ny}`;
                    if (visited.has(nkey)) continue;
                    if (isRoad(nx, ny) || isBridge(nx, ny)) {
                        visited.add(nkey);
                        roadParent.set(nkey, current);
                        queue.push(nkey);
                    }
                }
            }

            // 연결된 건물에서 하수 처리 시설까지 경로 역추적
            connectedBuildingRoads.forEach(roadKey => {
                let trace = roadKey;
                while (trace && !sewageFacilityRoads.has(trace)) {
                    neededRoads.add(trace);
                    trace = roadParent.get(trace);
                }
                if (trace) neededRoads.add(trace);
            });

            sewageFacilityRoads.forEach(roadKey => {
                for (const dir of directions) {
                    const [x, y] = roadKey.split(',').map(Number);
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;
                    if (neededRoads.has(nkey)) {
                        neededRoads.add(roadKey);
                        break;
                    }
                }
            });

            // 하수관 그리기
            neededRoads.forEach(roadKey => {
                const [x, y] = roadKey.split(',').map(Number);
                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;
                    if (neededRoads.has(nkey) || sewageFacilityRoads.has(nkey)) {
                        const connKey = [`${x},${y}`, nkey].sort().join('_');
                        if (!drawnConnections.has(connKey)) {
                            drawnConnections.add(connKey);
                            this.drawSewagePipe(x, y, nx, ny);
                        }
                    }
                }
            });

            // 하수 처리 시설에서 인접 도로로 연결선
            this.sewageFacilities.forEach((facility, key) => {
                const facilityCenterX = facility.x + (facility.width - 1) / 2;
                const facilityCenterY = facility.y + (facility.depth - 1) / 2;

                const adjacentNeededRoads = [];
                for (let dx = -1; dx <= facility.width; dx++) {
                    for (let dy = -1; dy <= facility.depth; dy++) {
                        const isInsideFacility = dx >= 0 && dx < facility.width && dy >= 0 && dy < facility.depth;
                        if (isInsideFacility) continue;
                        const nx = facility.x + dx;
                        const ny = facility.y + dy;
                        if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;
                        const roadKey = `${nx},${ny}`;
                        if (neededRoads.has(roadKey) || sewageFacilityRoads.has(roadKey)) {
                            adjacentNeededRoads.push({ x: nx, y: ny });
                        }
                    }
                }

                if (adjacentNeededRoads.length > 0) {
                    let closestRoad = adjacentNeededRoads[0];
                    let closestDist = Math.abs(closestRoad.x - facilityCenterX) + Math.abs(closestRoad.y - facilityCenterY);
                    for (const road of adjacentNeededRoads) {
                        const dist = Math.abs(road.x - facilityCenterX) + Math.abs(road.y - facilityCenterY);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestRoad = road;
                        }
                    }
                    const connKey = `facility_${key}_to_${closestRoad.x},${closestRoad.y}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        this.drawSewagePipe(Math.floor(facilityCenterX), Math.floor(facilityCenterY), closestRoad.x, closestRoad.y);
                    }
                }
            });

            // 건물에서 도로로 연결선
            buildingToRoadConnections.forEach(conn => {
                const roadKey = `${conn.roadX},${conn.roadY}`;
                if (neededRoads.has(roadKey)) {
                    const connKey = `building_${conn.buildingKey}_to_${roadKey}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        this.drawSewagePipe(conn.buildingX, conn.buildingY, conn.roadX, conn.roadY);
                    }
                }
            });
        },

        // 하수관 그리기 (갈색)
        drawSewagePipe(x1, y1, x2, y2) {
            const pos1 = tileToWorldCenter(x1, y1);
            const pos2 = tileToWorldCenter(x2, y2);
            const height = 0.08;
            const lineWidth = 0.04;

            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: this.PIPE_COLOR,  // 갈색
                transparent: true,
                opacity: 0.9,
                depthTest: false,   // 항상 보이도록 깊이 테스트 비활성화
                depthWrite: false   // 깊이 버퍼에 쓰지 않음
            });

            const dx = pos2.x - pos1.x;
            const dz = pos2.z - pos1.z;

            if (Math.abs(dx) > 0.01 && Math.abs(dz) > 0.01) {
                // 직각 연결
                const midX = pos1.x + dx;
                const midZ = pos1.z;

                const curve1 = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(midX, height, midZ)
                );
                const tube1 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve1, 1, lineWidth, 6, false),
                    tubeMaterial
                );
                this.sewagePipeGroup.add(tube1);

                const curve2 = new THREE.LineCurve3(
                    new THREE.Vector3(midX, height, midZ),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube2 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve2, 1, lineWidth, 6, false),
                    tubeMaterial
                );
                this.sewagePipeGroup.add(tube2);
            } else {
                const curve = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube = new THREE.Mesh(
                    new THREE.TubeGeometry(curve, 1, lineWidth, 6, false),
                    tubeMaterial
                );
                this.sewagePipeGroup.add(tube);
            }
        },

        // 하수 시설 아이콘 업데이트
        updateBuildingSewageIcons() {
            // 하수 처리 시설 아이콘 표시
            this.sewageFacilities.forEach((facility, key) => {
                const building = placedPublicBuildings.get(key);
                if (building && building.instance) {
                    this.createSewageFacilityIcon(facility.x, facility.y, building.instance, facility.capacity);
                }
            });
        },

        // 하수 처리 시설 아이콘 생성
        createSewageFacilityIcon(x, y, buildingInstance, capacity) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.5;

            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // 배경 (갈색)
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.roundRect(0, 0, 128, 64, 8);
            ctx.fill();

            // 텍스트
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText(`🚽${capacity}`, 64, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.8, 0.4, 1);

            this.sewageIconGroup.add(sprite);
        },

        // 하수 뷰 토글
        // 참고: 머티리얼 관리는 oceanSewageSystem이 담당하므로 여기서는 파이프/아이콘만 관리
        toggleSewageView(show) {
            // 파라미터가 주어지면 해당 값으로 설정, 아니면 토글
            if (typeof show === 'boolean') {
                this.isSewageViewActive = show;
            } else {
                this.isSewageViewActive = !this.isSewageViewActive;
            }

            // 시각화 업데이트 (파이프/아이콘만)
            this.updateSewageVisualization();
        }
    };

    // ===== 바다 하수 방류 시스템 (Ocean Sewage Discharge System) =====
    const oceanSewageSystem = {
        initialized: false,
        sewageGrid: null,                    // 바다 타일별 하수 농도 (0~1)
        sewageVisualGroup: null,             // 하수 시각화 그룹 (데이터 뷰용)
        puddleGroup: null,                   // 오염 웅덩이 그룹 (일반 보기용, 항상 표시)
        sewagePuddles: new Map(),            // 웅덩이 메시 (key: "x,y", value: mesh)
        puddleTexture: null,                 // 공유 그라데이션 텍스처
        dischargePoints: new Map(),          // 방류 지점 (하수처리장 위치)
        contaminatedPumps: new Map(),        // 오염된 취수장 (key: "x,y", value: {startTime, warned})

        // 해류 설정 (맵 오른쪽에서 왼쪽으로 흐름)
        CURRENT_DIRECTION: { x: -1, y: 0.2 },  // 해류 방향 (왼쪽으로, 약간 아래로)
        CURRENT_SPEED: 0.3,                    // 해류 속도 (타일/초)
        DISCHARGE_RATE: 0.15,                  // 방류량 (초당 농도 증가)
        DIFFUSION_RATE: 0.02,                  // 확산 속도
        DECAY_RATE: 0.005,                     // 자연 정화율
        CONTAMINATION_THRESHOLD: 0.3,          // 취수장 오염 임계값
        CONTAMINATION_TIME: 30000,             // 오염 지속 시 폐건물화 시간 (30초)
        UPDATE_INTERVAL: 500,                  // 시뮬레이션 업데이트 간격 (ms)
        PUDDLE_SIZE: 2,                        // 웅덩이 크기 (2x2 타일)

        updateTimer: null,

        // 그라데이션 웅덩이 텍스처 생성
        createPuddleTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // 방사형 그라데이션 (중심 진한 갈색 → 가장자리 투명)
            const gradient = ctx.createRadialGradient(
                size / 2, size / 2, 0,
                size / 2, size / 2, size / 2
            );
            gradient.addColorStop(0, 'rgba(101, 67, 33, 0.85)');    // 중심: 진한 갈색
            gradient.addColorStop(0.3, 'rgba(139, 90, 43, 0.7)');   // 중간: 갈색
            gradient.addColorStop(0.6, 'rgba(160, 120, 60, 0.4)');  // 연한 갈색
            gradient.addColorStop(1, 'rgba(180, 150, 80, 0)');      // 가장자리: 투명

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        },

        init() {
            if (this.initialized) return;

            // 하수 농도 그리드 초기화
            this.sewageGrid = [];
            for (let x = 0; x < GRID_W; x++) {
                this.sewageGrid[x] = [];
                for (let y = 0; y < GRID_H; y++) {
                    this.sewageGrid[x][y] = 0;
                }
            }

            // 데이터 뷰용 시각화 그룹
            this.sewageVisualGroup = new THREE.Group();
            this.sewageVisualGroup.name = 'oceanSewage';
            this.sewageVisualGroup.visible = false;
            scene.add(this.sewageVisualGroup);

            // 일반 보기용 웅덩이 그룹 (항상 표시)
            this.puddleGroup = new THREE.Group();
            this.puddleGroup.name = 'sewagePuddles';
            this.puddleGroup.visible = true;
            scene.add(this.puddleGroup);

            // 그라데이션 텍스처 생성
            this.puddleTexture = this.createPuddleTexture();

            this.initialized = true;

            // 시뮬레이션 시작
            this.startSimulation();

            console.log('Ocean sewage system initialized');
        },

        // 단순 원형 그라데이션 텍스처 생성
        createGradientTexture() {
            const canvas = document.createElement('canvas');
            const size = 256;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // 중심에서 바깥으로 퍼지는 원형 그라데이션
            const center = size / 2;
            const gradient = ctx.createRadialGradient(
                center, center, 0,
                center, center, center
            );

            // 갈색 그라데이션 (중심 → 투명)
            gradient.addColorStop(0, 'rgba(101, 67, 33, 0.8)');     // 진한 갈색
            gradient.addColorStop(0.3, 'rgba(139, 90, 50, 0.5)');
            gradient.addColorStop(0.6, 'rgba(170, 130, 90, 0.25)');
            gradient.addColorStop(1, 'rgba(200, 170, 130, 0)');     // 투명

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        },

        // 오염 이펙트 (단순 원형 그라데이션)
        createPuddleMesh(x, y) {
            // 방류 지점 중심
            const centerX = x - GRID_W / 2 + 0.5;
            const centerZ = y - GRID_H / 2 + 0.5;

            // 그라데이션 텍스처 생성
            const texture = this.createGradientTexture();

            // 원형 평면
            const planeSize = 4;

            const geometry = new THREE.PlaneGeometry(planeSize, planeSize);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 1.0,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(centerX, 0.05, centerZ);
            mesh.renderOrder = 100;

            console.log(`[OceanSewage] Gradient puddle created at grid(${x},${y})`);

            return mesh;
        },

        // 웅덩이 표시/숨김
        updatePuddle(key, point, isOperational) {
            const existingPuddle = this.sewagePuddles.get(key);

            if (isOperational) {
                // 운영 중 → 웅덩이 표시
                if (!existingPuddle) {
                    console.log(`[OceanSewage] Creating puddle for facility at ${key}, discharge at (${point.dischargeX}, ${point.dischargeY})`);
                    const puddleMesh = this.createPuddleMesh(point.dischargeX, point.dischargeY);
                    this.puddleGroup.add(puddleMesh);
                    this.sewagePuddles.set(key, puddleMesh);
                    console.log(`[OceanSewage] Puddle count: ${this.sewagePuddles.size}, Group children: ${this.puddleGroup.children.length}`);
                }
            } else {
                // 비운영 → 웅덩이 제거
                if (existingPuddle) {
                    console.log(`[OceanSewage] Removing puddle for facility at ${key}`);
                    this.puddleGroup.remove(existingPuddle);
                    // 단일 메시 정리 (geometry, material, texture)
                    if (existingPuddle.geometry) existingPuddle.geometry.dispose();
                    if (existingPuddle.material) {
                        if (existingPuddle.material.map) existingPuddle.material.map.dispose();
                        existingPuddle.material.dispose();
                    }
                    this.sewagePuddles.delete(key);
                }
            }
        },

        // 방류 지점 추가 (하수처리장 설치 시)
        addDischargePoint(x, y, facility) {
            const key = `${x},${y}`;

            // 방류 위치 찾기 (하수처리장의 바다 쪽)
            const dischargePos = this.findDischargePosition(x, y, facility);
            if (dischargePos) {
                const point = {
                    x: x,
                    y: y,
                    dischargeX: dischargePos.x,
                    dischargeY: dischargePos.y,
                    capacity: facility.capacity || 500,
                    active: true
                };
                this.dischargePoints.set(key, point);
                console.log(`[OceanSewage] Discharge point added at (${dischargePos.x}, ${dischargePos.y}) for facility at (${x}, ${y})`);

                // 바로 웅덩이 생성 시도 (서비스매니저 초기화 전에는 일단 표시)
                const isOperational = typeof serviceBuildingManager === 'undefined' ||
                    !serviceBuildingManager.initialized ||
                    serviceBuildingManager.isOperational(x, y);
                this.updatePuddle(key, point, isOperational);
            } else {
                console.log(`[OceanSewage] Failed to find discharge position for facility at (${x}, ${y})`);
            }
        },

        // 방류 지점 제거
        removeDischargePoint(x, y) {
            const key = `${x},${y}`;
            this.dischargePoints.delete(key);

            // 웅덩이도 함께 제거
            const puddle = this.sewagePuddles.get(key);
            if (puddle) {
                this.puddleGroup.remove(puddle);
                // 단일 메시 정리 (geometry, material, texture)
                if (puddle.geometry) puddle.geometry.dispose();
                if (puddle.material) {
                    if (puddle.material.map) puddle.material.map.dispose();
                    puddle.material.dispose();
                }
                this.sewagePuddles.delete(key);
            }
        },

        // 방류 위치 찾기 (하수처리장 주변 바다 타일)
        // 하수처리장은 육지에 설치되고 방파제와 인접함
        // 방파제 맞닿은 2타일 기준, 북쪽으로 2칸 뒤 바다에 방류
        findDischargePosition(x, y, facility) {
            // displayWidth/displayDepth 사용 (회전된 건물 고려)
            const width = facility.displayWidth || facility.width || 2;
            const depth = facility.displayDepth || facility.depth || 4;

            console.log(`[OceanSewage] Finding discharge position for facility at (${x},${y}), size: ${width}x${depth}`);

            // 북쪽 방향 확인 (y - 1이 방파제)
            const breakwaterY = y - 1;
            // 방파제 너머 2칸 (y - 3)
            const oceanY = y - 3;

            // 건물 너비 중앙 기준
            const centerX = x + Math.floor(width / 2);

            // 방파제 확인
            if (inBounds(centerX, breakwaterY) && grid[centerX][breakwaterY] === CELL.BREAKWATER) {
                // 방파제 너머 2칸 뒤 바다 확인
                if (inBounds(centerX, oceanY) && isOcean(centerX, oceanY)) {
                    console.log(`[OceanSewage] Found ocean at (${centerX}, ${oceanY}) - 2 tiles beyond breakwater`);
                    return { x: centerX, y: oceanY };
                }
                // 1칸 뒤도 확인
                const oceanY1 = y - 2;
                if (inBounds(centerX, oceanY1) && isOcean(centerX, oceanY1)) {
                    console.log(`[OceanSewage] Found ocean at (${centerX}, ${oceanY1}) - 1 tile beyond breakwater`);
                    return { x: centerX, y: oceanY1 };
                }
            }

            // 남쪽 방향도 확인 (반대편 방파제)
            const southBreakwaterY = y + depth;
            const southOceanY = y + depth + 2;

            if (inBounds(centerX, southBreakwaterY) && grid[centerX][southBreakwaterY] === CELL.BREAKWATER) {
                if (inBounds(centerX, southOceanY) && isOcean(centerX, southOceanY)) {
                    console.log(`[OceanSewage] Found ocean at (${centerX}, ${southOceanY}) - south side, 2 tiles beyond breakwater`);
                    return { x: centerX, y: southOceanY };
                }
            }

            console.log(`[OceanSewage] No ocean tile found around facility at (${x},${y})`);
            return null;
        },

        // 시뮬레이션 시작
        startSimulation() {
            if (this.updateTimer) clearInterval(this.updateTimer);

            this.updateTimer = setInterval(() => {
                this.updateSimulation();
            }, this.UPDATE_INTERVAL);
        },

        // 시뮬레이션 업데이트
        updateSimulation() {
            if (!this.initialized) return;

            const dt = this.UPDATE_INTERVAL / 1000;  // 초 단위

            // 1. 방류 지점에서 하수 방출 (운영 중인 하수처리장만) + 웅덩이 시각화
            this.dischargePoints.forEach((point, key) => {
                if (point.active && inBounds(point.dischargeX, point.dischargeY)) {
                    // 서비스 건물 운영 상태 확인
                    const isOperational = typeof serviceBuildingManager !== 'undefined' &&
                        serviceBuildingManager.isOperational(point.x, point.y);

                    // 웅덩이 시각화 업데이트 (일반 보기 모드용)
                    this.updatePuddle(key, point, isOperational);

                    if (!isOperational) {
                        return; // 비운영 시설은 방류하지 않음
                    }
                    // 처리 용량에 비례한 방류량
                    const discharge = this.DISCHARGE_RATE * dt * (point.capacity / 500);
                    this.sewageGrid[point.dischargeX][point.dischargeY] =
                        Math.min(1, this.sewageGrid[point.dischargeX][point.dischargeY] + discharge);
                }
            });

            // 2. 해류 따라 하수 이동 및 확산
            const newGrid = [];
            for (let x = 0; x < GRID_W; x++) {
                newGrid[x] = [];
                for (let y = 0; y < GRID_H; y++) {
                    newGrid[x][y] = 0;
                }
            }

            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    if (!isOcean(x, y)) continue;

                    const concentration = this.sewageGrid[x][y];
                    if (concentration <= 0.001) continue;

                    // 해류 방향으로 이동
                    const moveX = this.CURRENT_DIRECTION.x * this.CURRENT_SPEED * dt;
                    const moveY = this.CURRENT_DIRECTION.y * this.CURRENT_SPEED * dt;

                    // 현재 위치에 남는 양
                    const remaining = concentration * (1 - this.CURRENT_SPEED * dt - this.DIFFUSION_RATE * 4 * dt);
                    newGrid[x][y] += Math.max(0, remaining);

                    // 해류 방향으로 이동하는 양
                    const flowAmount = concentration * this.CURRENT_SPEED * dt;
                    const targetX = Math.round(x + moveX);
                    const targetY = Math.round(y + moveY);
                    if (inBounds(targetX, targetY) && isOcean(targetX, targetY)) {
                        newGrid[targetX][targetY] += flowAmount;
                    }

                    // 주변으로 확산
                    const diffuseAmount = concentration * this.DIFFUSION_RATE * dt;
                    const dirs = [{dx:-1,dy:0}, {dx:1,dy:0}, {dx:0,dy:-1}, {dx:0,dy:1}];
                    dirs.forEach(dir => {
                        const nx = x + dir.dx;
                        const ny = y + dir.dy;
                        if (inBounds(nx, ny) && isOcean(nx, ny)) {
                            newGrid[nx][ny] += diffuseAmount;
                        }
                    });
                }
            }

            // 3. 자연 정화 (시간에 따라 농도 감소)
            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    newGrid[x][y] = Math.max(0, newGrid[x][y] - this.DECAY_RATE * dt);
                    newGrid[x][y] = Math.min(1, newGrid[x][y]);  // 최대값 제한
                }
            }

            this.sewageGrid = newGrid;

            // 4. 취수장 오염 체크
            this.checkWaterPumpContamination();

            // 5. 시각화 업데이트 (뷰 활성화 시)
            if (this.isViewActive) {
                this.updateVisualization();
            }
        },

        // 취수장 오염 체크
        checkWaterPumpContamination() {
            if (!waterManager.initialized) return;

            waterManager.waterFacilities.forEach((facility, key) => {
                // 취수장 주변 바다 타일의 하수 농도 체크
                const maxContamination = this.getContaminationNearFacility(
                    facility.x, facility.y, facility.width || 2, facility.depth || 4
                );

                if (maxContamination >= this.CONTAMINATION_THRESHOLD) {
                    // 오염됨
                    if (!this.contaminatedPumps.has(key)) {
                        this.contaminatedPumps.set(key, {
                            startTime: Date.now(),
                            warned: false,
                            level: maxContamination
                        });

                        // 시민 불만 메시지 표시
                        this.showContaminationWarning(facility, maxContamination);
                    } else {
                        const data = this.contaminatedPumps.get(key);
                        data.level = maxContamination;

                        // 일정 시간 경과 시 폐건물화
                        if (Date.now() - data.startTime > this.CONTAMINATION_TIME) {
                            this.applyContaminationEffect(facility);
                        }
                    }
                } else {
                    // 오염 해제
                    if (this.contaminatedPumps.has(key)) {
                        this.contaminatedPumps.delete(key);
                        // 수질 정상화 메시지
                        toast({
                            title: '💧 수질 정상화',
                            desc: '취수장 주변 수질이 정상으로 돌아왔습니다.',
                            success: true
                        });
                    }
                }
            });
        },

        // 시설 주변 바다 오염도 확인
        getContaminationNearFacility(x, y, width, depth) {
            let maxContamination = 0;

            for (let dx = -2; dx <= width + 1; dx++) {
                for (let dy = -2; dy <= depth + 1; dy++) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (inBounds(nx, ny) && isOcean(nx, ny)) {
                        maxContamination = Math.max(maxContamination, this.sewageGrid[nx][ny] || 0);
                    }
                }
            }

            return maxContamination;
        },

        // 오염 경고 메시지
        showContaminationWarning(facility, level) {
            const messages = [
                "🤢 똥물 먹기 싫어요!",
                "💩 물에서 이상한 냄새가 나요!",
                "🚱 수돗물이 이상해요!",
                "😱 물이 갈색이에요!"
            ];
            const msg = messages[Math.floor(Math.random() * messages.length)];

            toast({
                title: '💩 수질 오염 경고!',
                desc: `취수장 근처 수질이 오염되었습니다. ${msg}`,
                type: 'warning'
            });

            // 시민 한마디 업데이트
            if (typeof updateCitizenQuote === 'function') {
                updateCitizenQuote(msg, 'warning');
            }
        },

        // 오염 효과 적용 (폐건물화)
        applyContaminationEffect(facility) {
            const data = this.contaminatedPumps.get(`${facility.x},${facility.y}`);
            if (!data || data.effectApplied) return;
            data.effectApplied = true;

            toast({
                title: '🏚️ 수질 오염으로 건물 폐쇄!',
                desc: '오염된 물을 공급받은 건물들이 폐건물이 되었습니다.',
                type: 'error'
            });

            // 해당 취수장에서 물을 공급받는 건물들 폐건물화
            // (간단히 연결된 일부 건물을 폐건물로 변경)
            let abandonedCount = 0;
            const maxAbandon = 5;  // 최대 5개 건물

            waterManager.connectedBuildings.forEach(key => {
                if (abandonedCount >= maxAbandon) return;

                const building = placedBuildings.get(key);
                if (!building || building.ref) return;  // 참조 건물 스킵

                const userData = building.instance?.userData;
                if (!userData || userData.isAbandoned) return;  // 이미 폐건물

                // 30% 확률로 폐건물화
                if (Math.random() < 0.3) {
                    // 폐건물 상태 설정
                    userData.isAbandoned = true;
                    userData.abandonedReason = '💩 오염된 물 공급으로 폐쇄됨';
                    building.isAbandoned = true;
                    building.abandonedReason = userData.abandonedReason;

                    // 폐건물 목록에 추가
                    if (typeof abandonedBuildings !== 'undefined') {
                        abandonedBuildings.add(key);
                    }

                    // 폐건물 색상 적용
                    if (typeof applyAbandonedMaterials === 'function') {
                        applyAbandonedMaterials(building.instance);
                    }

                    // 폐건물 상태 아이콘 표시
                    const [bx, by] = key.split(',').map(Number);
                    if (typeof addBuildingStatus === 'function') {
                        addBuildingStatus(bx, by, 'ABANDONED', building);
                    }

                    abandonedCount++;
                    console.log(`[WaterContamination] Building abandoned at ${key}`);
                }
            });

            if (abandonedCount > 0 && typeof markDirty === 'function') {
                markDirty();
            }
        },

        // 시각화 업데이트
        updateVisualization() {
            // 기존 시각화 제거
            while (this.sewageVisualGroup.children.length > 0) {
                const child = this.sewageVisualGroup.children[0];
                this.sewageVisualGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            // 1. 방류 지점 주변 오염 표시 (작동 중인 하수처리장)
            this.dischargePoints.forEach((point, key) => {
                const isOperational = typeof serviceBuildingManager !== 'undefined' &&
                    serviceBuildingManager.isOperational(point.x, point.y);

                if (isOperational && inBounds(point.dischargeX, point.dischargeY)) {
                    // 방류 지점 주변 2x2 영역에 진한 오염 표시
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const nx = point.dischargeX + dx;
                            const ny = point.dischargeY + dy;
                            if (!inBounds(nx, ny) || !isOcean(nx, ny)) continue;

                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const intensity = Math.max(0.3, 1 - dist * 0.4);

                            const geometry = new THREE.PlaneGeometry(1, 1);
                            const material = new THREE.MeshBasicMaterial({
                                color: 0x8B4513,  // 진한 갈색
                                transparent: true,
                                opacity: intensity * 0.8,
                                side: THREE.DoubleSide,
                                depthWrite: false
                            });

                            const plane = new THREE.Mesh(geometry, material);
                            plane.rotation.x = -Math.PI / 2;
                            plane.position.set(nx - GRID_W / 2 + 0.5, 0.06, ny - GRID_H / 2 + 0.5);
                            this.sewageVisualGroup.add(plane);
                        }
                    }
                }
            });

            // 2. 해류에 의한 확산 오염 표시 (sewageGrid 기반)
            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    const concentration = this.sewageGrid[x][y];
                    if (concentration < 0.05 || !isOcean(x, y)) continue;

                    // 농도에 따른 색상 (투명 → 갈색)
                    const color = this.getConcentrationColor(concentration);
                    const opacity = Math.min(0.7, concentration * 1.0);

                    const geometry = new THREE.PlaneGeometry(1, 1);
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: opacity,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });

                    const plane = new THREE.Mesh(geometry, material);
                    plane.rotation.x = -Math.PI / 2;
                    plane.position.set(x - GRID_W / 2 + 0.5, 0.05, y - GRID_H / 2 + 0.5);

                    this.sewageVisualGroup.add(plane);
                }
            }
        },

        // 농도에 따른 색상 (그라데이션)
        getConcentrationColor(concentration) {
            // 0: 투명 → 0.3: 연한 갈색 → 0.7: 갈색 → 1: 진한 갈색
            if (concentration < 0.3) {
                // 연한 노란색 → 연한 갈색
                const t = concentration / 0.3;
                const r = Math.floor(200 + (139 - 200) * t);
                const g = Math.floor(180 + (90 - 180) * t);
                const b = Math.floor(100 + (43 - 100) * t);
                return (r << 16) | (g << 8) | b;
            } else if (concentration < 0.7) {
                // 연한 갈색 → 갈색
                const t = (concentration - 0.3) / 0.4;
                const r = Math.floor(139 + (101 - 139) * t);
                const g = Math.floor(90 + (67 - 90) * t);
                const b = Math.floor(43 + (33 - 43) * t);
                return (r << 16) | (g << 8) | b;
            } else {
                // 갈색 → 진한 갈색
                const t = (concentration - 0.7) / 0.3;
                const r = Math.floor(101 + (60 - 101) * t);
                const g = Math.floor(67 + (40 - 67) * t);
                const b = Math.floor(33 + (20 - 33) * t);
                return (r << 16) | (g << 8) | b;
            }
        },

        // 뷰 토글
        isViewActive: false,
        originalMaterials: new Map(),        // 원본 머티리얼 저장
        currentArrowGroup: null,             // 해류 방향 화살표 그룹

        toggleView(show) {
            if (!this.initialized) return;

            const newState = typeof show === 'boolean' ? show : !this.isViewActive;

            if (newState === this.isViewActive) return;

            this.isViewActive = newState;
            this.sewageVisualGroup.visible = newState;

            if (newState) {
                // 뷰 활성화
                this.enterSewageDataView();
            } else {
                // 뷰 비활성화
                this.exitSewageDataView();
            }
        },

        // 하수 데이터 뷰 진입
        enterSewageDataView() {
            // 1. 일반 뷰 퍼들 효과 숨기기
            if (this.puddleGroup) {
                this.puddleGroup.visible = false;
            }

            // 2. 모든 오브젝트를 회색/흰색으로 변경 (수도 뷰 스타일)
            this.applyDataViewMaterials(true);

            // 3. 하수처리시설을 초록색으로 하이라이트
            this.highlightWastewaterFacilities(true);

            // 4. 오염된 바다 타일 시각화
            this.updateVisualization();

            // 5. 해류 방향 화살표 표시
            this.showCurrentArrows(true);

            console.log('[OceanSewage] Data view entered');
        },

        // 하수 데이터 뷰 종료
        exitSewageDataView() {
            // 1. 원본 머티리얼 복원
            this.applyDataViewMaterials(false);

            // 2. 하이라이트 제거
            this.highlightWastewaterFacilities(false);

            // 3. 해류 방향 화살표 숨김
            this.showCurrentArrows(false);

            // 4. 시각화 그룹 숨김
            this.sewageVisualGroup.visible = false;

            // 5. 일반 뷰 퍼들 효과 다시 표시
            if (this.puddleGroup) {
                this.puddleGroup.visible = true;
            }

            // 6. 전역 머티리얼 강제 복원 (안전장치)
            if (typeof restoreOriginalMaterials === 'function') {
                restoreOriginalMaterials(true);
            }
            if (typeof restoreAllBuildingOpacity === 'function') {
                restoreAllBuildingOpacity();
            }

            console.log('[OceanSewage] Data view exited');
        },

        // 데이터 뷰 머티리얼 적용 (수도 뷰 스타일)
        applyDataViewMaterials(enable) {
            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });

            // 그룹별 머티리얼 적용 헬퍼
            const applyToGroup = (group, material) => {
                if (!group) return;
                group.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (enable) {
                            if (!this.originalMaterials.has(child.uuid)) {
                                this.originalMaterials.set(child.uuid, child.material);
                            }
                            child.material = material;
                        } else {
                            const original = this.originalMaterials.get(child.uuid);
                            if (original) {
                                child.material = original;
                            }
                        }
                    }
                });
            };

            // 토대(잔디), 나무 - 흰색
            applyToGroup(grassGroup, whiteMat);
            applyToGroup(treeGroup, whiteMat);

            // 도로, 수로, 다리 - 회색
            applyToGroup(roadGroup, grayMat);
            applyToGroup(waterGroup, grayMat);
            applyToGroup(bridgeGroup, grayMat);

            // 민간 건물 - 회색
            applyToGroup(buildingGroup, grayMat);

            // 공공시설 - 회색 (하수처리시설은 나중에 초록색으로 덮어씀)
            placedPublicBuildings.forEach((building) => {
                if (building.ref) return;
                if (building.instance) {
                    applyToGroup(building.instance, grayMat);
                }
                // 풍력발전기 확장 터빈(애드온) - scene에 직접 추가되어 있어 별도 처리 필요
                if (building.expansionInstances && building.expansionInstances.length > 0) {
                    building.expansionInstances.forEach(exp => {
                        if (exp.instance) {
                            applyToGroup(exp.instance, grayMat);
                        }
                    });
                }
            });

            // 차량 - 회색
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                applyToGroup(trafficManager.vehicleGroup, grayMat);
            }

            if (!enable) {
                this.originalMaterials.clear();
            }
        },

        // 하수처리시설 초록색 하이라이트
        highlightWastewaterFacilities(enable) {
            const greenMaterial = new THREE.MeshBasicMaterial({ color: 0x22c55e });

            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                if (building.type !== 'wastewater') return;

                const instance = building.instance;
                if (!instance) return;

                instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (enable) {
                            // 이미 저장된 원본이 없으면 저장
                            if (!this.originalMaterials.has(child.uuid + '_sewage')) {
                                this.originalMaterials.set(child.uuid + '_sewage', child.material);
                            }
                            child.material = greenMaterial.clone();
                        } else {
                            const original = this.originalMaterials.get(child.uuid + '_sewage');
                            if (original) {
                                child.material = original;
                                this.originalMaterials.delete(child.uuid + '_sewage');
                            }
                        }
                    }
                });
            });
        },

        // 해류 방향 화살표 표시
        showCurrentArrows(enable) {
            if (!enable) {
                if (this.currentArrowGroup) {
                    scene.remove(this.currentArrowGroup);
                    this.currentArrowGroup.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    this.currentArrowGroup = null;
                }
                return;
            }

            // 기존 화살표 제거
            if (this.currentArrowGroup) {
                scene.remove(this.currentArrowGroup);
            }

            this.currentArrowGroup = new THREE.Group();
            this.currentArrowGroup.name = 'sewageCurrentArrows';

            // 해류 방향 정규화
            const dir = new THREE.Vector2(this.CURRENT_DIRECTION.x, this.CURRENT_DIRECTION.y).normalize();
            const angle = Math.atan2(dir.y, dir.x);

            // 바다 영역에 화살표 배치 (간격 6타일)
            for (let x = 3; x < GRID_W; x += 6) {
                for (let y = 3; y < GRID_H; y += 6) {
                    if (!isOcean(x, y)) continue;

                    // 화살표 생성
                    const arrowShape = new THREE.Shape();
                    arrowShape.moveTo(0, 0);
                    arrowShape.lineTo(-0.4, 0.2);
                    arrowShape.lineTo(-0.3, 0);
                    arrowShape.lineTo(-0.4, -0.2);
                    arrowShape.lineTo(0, 0);

                    const geometry = new THREE.ShapeGeometry(arrowShape);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x4a90d9,
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide
                    });

                    const arrow = new THREE.Mesh(geometry, material);
                    arrow.rotation.x = -Math.PI / 2;
                    arrow.rotation.z = -angle;
                    arrow.position.set(
                        x - GRID_W / 2 + 0.5,
                        0.1,
                        y - GRID_H / 2 + 0.5
                    );

                    this.currentArrowGroup.add(arrow);
                }
            }

            scene.add(this.currentArrowGroup);
        },

        // 특정 위치의 하수 농도 조회
        getConcentration(x, y) {
            if (!this.initialized || !inBounds(x, y)) return 0;
            return this.sewageGrid[x][y] || 0;
        }
    };

    // ===== 서비스 건물 상태 관리 시스템 (Service Building Status Manager) =====
    const serviceBuildingManager = {
        initialized: false,
        statusMap: new Map(),           // key: "x,y", value: { hasPower, hasRoad, isOperational }
        statusIconGroup: null,          // 상태 아이콘 그룹
        updateInterval: null,
        UPDATE_INTERVAL: 2000,          // 2초마다 체크

        // 서비스 건물 타입 목록 (발전소 제외 - 발전소는 전력 생산하므로)
        SERVICE_TYPES: ['fire', 'police', 'school', 'park', 'hospital', 'wastewater', 'water_pump_coast'],
        // 발전소는 도로만 체크 (전력은 자체 생산)
        POWER_PLANT_TYPES: ['powerplant_coal', 'powerplant_wind'],

        init() {
            if (this.initialized) return;

            this.statusIconGroup = new THREE.Group();
            this.statusIconGroup.name = 'serviceBuildingStatus';
            scene.add(this.statusIconGroup);

            this.initialized = true;

            // 주기적 업데이트 시작
            this.startUpdateLoop();

            console.log('Service building status manager initialized');
        },

        startUpdateLoop() {
            if (this.updateInterval) clearInterval(this.updateInterval);

            this.updateInterval = setInterval(() => {
                this.updateAllBuildingStatus();
            }, this.UPDATE_INTERVAL);

            // 초기 업데이트
            setTimeout(() => this.updateAllBuildingStatus(), 100);
        },

        // 모든 서비스 건물 상태 업데이트
        updateAllBuildingStatus() {
            if (!this.initialized) return;

            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조 건물 스킵

                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (!config) return;

                const isPowerPlant = config.isPowerPlant;
                const isServiceBuilding = this.SERVICE_TYPES.includes(building.type) ||
                                         this.POWER_PLANT_TYPES.includes(building.type);

                if (!isServiceBuilding && !isPowerPlant) return;

                const prevStatus = this.statusMap.get(key) || {};
                const newStatus = this.checkBuildingStatus(building, config, isPowerPlant);

                // 상태 변경 감지
                const statusChanged = prevStatus.hasPower !== newStatus.hasPower ||
                                     prevStatus.hasRoad !== newStatus.hasRoad ||
                                     prevStatus.isOperational !== newStatus.isOperational;

                if (statusChanged) {
                    this.statusMap.set(key, newStatus);
                    this.updateBuildingVisual(building, newStatus);

                    // 상태 변경에 따른 효과 적용
                    this.applyStatusEffect(building, config, newStatus, prevStatus);
                }
            });

            // 삭제된 건물 정리
            this.statusMap.forEach((status, key) => {
                if (!placedPublicBuildings.has(key)) {
                    this.statusMap.delete(key);
                }
            });
        },

        // 개별 건물 상태 체크
        checkBuildingStatus(building, config, isPowerPlant) {
            const key = `${building.x},${building.y}`;

            // 도로 연결 체크
            const hasRoad = this.isBuildingConnectedToRoad(building);

            // 전력 체크 (발전소는 항상 true)
            let hasPower = true;
            if (!isPowerPlant && powerManager.initialized) {
                hasPower = this.isBuildingPowered(building);
            }

            // 작동 여부 (도로 + 전력 모두 필요, 발전소는 도로만)
            const isOperational = isPowerPlant ? hasRoad : (hasRoad && hasPower);

            return { hasPower, hasRoad, isOperational };
        },

        // 건물이 도로에 연결되어 있는지 체크
        isBuildingConnectedToRoad(building) {
            // 건물에 저장된 width/depth 우선 사용 (회전된 건물 지원)
            // config 값은 회전 전 기본값이므로 building 값을 우선함
            const config = typeof PUBLIC_BUILDING_MODELS !== 'undefined' ?
                           PUBLIC_BUILDING_MODELS[building.type] : null;
            const width = building.width || config?.displayWidth || 2;
            const depth = building.depth || config?.displayDepth || 2;
            const directions = [ [0, 1], [0, -1], [1, 0], [-1, 0] ];

            const checkedTiles = [];
            for (let dx = 0; dx < width; dx++) {
                for (let dy = 0; dy < depth; dy++) {
                    const bx = building.x + dx;
                    const by = building.y + dy;

                    for (const [ddx, ddy] of directions) {
                        const nx = bx + ddx;
                        const ny = by + ddy;
                        // 건물 내부 스킵
                        if (nx >= building.x && nx < building.x + width &&
                            ny >= building.y && ny < building.y + depth) continue;

                        const tileKey = `${nx},${ny}`;
                        if (checkedTiles.includes(tileKey)) continue;
                        checkedTiles.push(tileKey);

                        const hasConnectedRoad = typeof connectedRoads !== 'undefined' && connectedRoads.has(tileKey);
                        const hasRoadFn = typeof isRoad === 'function' && isRoad(nx, ny);
                        const hasBridge = typeof isBridge === 'function' && isBridge(nx, ny);

                        if (hasConnectedRoad || hasRoadFn || hasBridge) {
                            return true;
                        }
                    }
                }
            }
            return false;
        },

        // 건물이 전력을 공급받는지 체크
        isBuildingPowered(building) {
            if (!powerManager.initialized) {
                return true;
            }

            // 건물에 저장된 width/depth 우선 사용 (회전된 건물 지원)
            const config = typeof PUBLIC_BUILDING_MODELS !== 'undefined' ?
                           PUBLIC_BUILDING_MODELS[building.type] : null;
            const width = building.width || config?.displayWidth || 2;
            const depth = building.depth || config?.displayDepth || 2;

            // 건물의 모든 타일 중 하나라도 전력 공급받으면 true
            for (let dx = 0; dx < width; dx++) {
                for (let dy = 0; dy < depth; dy++) {
                    const key = `${building.x + dx},${building.y + dy}`;
                    const hasPower = powerManager.poweredBuildings && powerManager.poweredBuildings.has(key);
                    if (hasPower) {
                        return true;
                    }
                }
            }
            return false;
        },

        // 건물 시각적 상태 업데이트 (아이콘 표시)
        updateBuildingVisual(building, status) {
            const key = `${building.x},${building.y}`;

            // 기존 상태 아이콘 제거
            removeBuildingStatus(building.x, building.y, 'SERVICE_NO_POWER');
            removeBuildingStatus(building.x, building.y, 'SERVICE_NO_ROAD');

            if (status.isOperational) {
                // 정상 작동 - 아이콘 없음
                return;
            }

            // 도로 끊김이 더 우선 (도로 없으면 전력 체크도 의미 없음)
            if (!status.hasRoad) {
                addBuildingStatus(building.x, building.y, 'SERVICE_NO_ROAD', building);
            } else if (!status.hasPower) {
                addBuildingStatus(building.x, building.y, 'SERVICE_NO_POWER', building);
            }
        },

        // 상태 변경에 따른 효과 적용
        applyStatusEffect(building, config, newStatus, prevStatus) {
            const key = `${building.x},${building.y}`;

            // 작동 상태 변경 시 유틸리티 재계산
            if (newStatus.isOperational !== prevStatus.isOperational) {
                if (!newStatus.isOperational) {
                    const reason = !newStatus.hasRoad ? '도로 끊김' : '전력 부족';

                    // 비활성화 토스트 (처음 비활성화될 때만)
                    if (prevStatus.isOperational !== undefined) {
                        toast({
                            title: `⚠️ ${config.name || building.type} 작동 중단`,
                            desc: reason === '도로 끊김' ?
                                '도로가 연결되지 않아 서비스가 중단되었습니다.' :
                                '전력이 공급되지 않아 서비스가 중단되었습니다.',
                            type: 'warning'
                        });
                    }
                }

                // 유틸리티 시설 상태 변경 시 해당 시스템 재계산
                if (config.isPowerPlant && typeof powerManager !== 'undefined' && powerManager.initialized) {
                    // 발전소 상태 변경 → 전력망 재계산
                    powerManager.recalculatePowerGrid();
                }
                if (config.isWaterFacility && typeof waterManager !== 'undefined' && waterManager.initialized) {
                    // 취수장 상태 변경 → 수도망 재계산
                    waterManager.recalculateWaterGrid();
                }
                if (config.isSewageFacility && typeof sewageManager !== 'undefined' && sewageManager.initialized) {
                    // 하수처리장 상태 변경 → 하수망 재계산
                    sewageManager.recalculateSewageGrid();
                }
            }
        },

        // 특정 건물이 작동 중인지 확인
        isOperational(x, y) {
            const key = `${x},${y}`;
            const status = this.statusMap.get(key);
            return status ? status.isOperational : true;  // 등록 안된 건물은 기본 작동
        },

        // 특정 타입의 작동 중인 건물 수 반환
        getOperationalCount(buildingType) {
            let count = 0;
            this.statusMap.forEach((status, key) => {
                const building = placedPublicBuildings.get(key);
                if (building && building.type === buildingType && status.isOperational) {
                    count++;
                }
            });
            return count;
        },

        // 모든 작동 중인 서비스 건물 가져오기
        getOperationalBuildings(buildingType = null) {
            const result = [];
            this.statusMap.forEach((status, key) => {
                if (!status.isOperational) return;
                const building = placedPublicBuildings.get(key);
                if (!building || building.ref) return;
                if (buildingType && building.type !== buildingType) return;
                result.push({ key, building, status });
            });
            return result;
        }
    };


    // DOM elements for stats
    const taxPerHourText = document.getElementById("taxPerHourText");
    const populationText = document.getElementById("populationText");
    const happinessText = document.getElementById("happinessText");
    const powerText = document.getElementById("powerText");
    const waterText = document.getElementById("waterText");
    const trafficText = document.getElementById("trafficText");
    const crimeText = document.getElementById("crimeText");
    const apText = document.getElementById("apText");
    const streakText = document.getElementById("streakText");
    const offlineEarningsBox = document.getElementById("offlineEarningsBox");
    const offlineEarningsText = document.getElementById("offlineEarningsText");
    const loginRewardBox = document.getElementById("loginRewardBox");
    const loginRewardText = document.getElementById("loginRewardText");
    const btnCollectTax = document.getElementById("btnCollectTax");
    const btnClaimReward = document.getElementById("btnClaimReward");

    function updateStatsDisplay() {
        // 전력 사용량 업데이트 (인구 기반)
        if (powerManager.initialized) {
            powerManager.calculatePowerUsage();
            powerManager.calculatePowerCapacity();
        }

        // Info panel stats
        if (populationText) populationText.textContent = cityStats.population.toLocaleString();
        if (happinessText) {
            happinessText.textContent = cityStats.happiness + '%';
            happinessText.className = 'value ' + getStatClass(cityStats.happiness, 70, 40);
        }
        if (powerText) {
            powerText.textContent = `${cityStats.powerUsage}/${cityStats.powerCapacity}`;
            powerText.className = 'value ' + (cityStats.powerUsage > cityStats.powerCapacity ? 'danger' : 'good');
        }
        if (waterText) {
            waterText.textContent = `${cityStats.waterUsage}/${cityStats.waterCapacity}`;
            waterText.className = 'value ' + (cityStats.waterUsage > cityStats.waterCapacity ? 'danger' : 'good');
        }
        if (trafficText) {
            trafficText.textContent = cityStats.trafficLevel + '%';
            trafficText.className = 'value ' + getStatClass(100 - cityStats.trafficLevel, 70, 40);
        }
        if (crimeText) {
            crimeText.textContent = cityStats.crimeRate + '%';
            crimeText.className = 'value ' + getStatClass(100 - cityStats.crimeRate, 70, 40);
        }
        if (taxPerHourText) taxPerHourText.textContent = '+' + formatMoney(cityStats.taxPerHour) + '/hr';
        if (apText) apText.textContent = `${cityStats.actionPoints}/10`;
        if (streakText) streakText.textContent = `${cityStats.consecutiveLoginDays} ${i18n.t('hud.days')}`;

        // Bottom bar stats (Cities Skylines style)
        if (popBottomText) popBottomText.textContent = cityStats.population.toLocaleString();
        if (happyBottomText) happyBottomText.textContent = cityStats.happiness + '%';

        // RCI 수요 바 업데이트
        updateRCIDemandBar();
    }

    /* =========================================================
     * RCI DEMAND SYSTEM (수요 시스템)
     * 주거 60% / 산업 25% / 상업 15% 비율 기준
     * ========================================================= */

    // RCI 바 DOM 요소
    const rciResidentialBar = document.getElementById('rciResidential');
    const rciCommercialBar = document.getElementById('rciCommercial');
    const rciIndustrialBar = document.getElementById('rciIndustrial');

    // 구역 타일 수 계산
    function countZoneTiles() {
        let residential = 0, commercial = 0, industrial = 0;

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const cell = grid[x][y];
                if (cell === CELL.ZONE_RESIDENTIAL) residential++;
                else if (cell === CELL.ZONE_COMMERCIAL) commercial++;
                else if (cell === CELL.ZONE_INDUSTRIAL) industrial++;
            }
        }

        cityStats.residentialTiles = residential;
        cityStats.commercialTiles = commercial;
        cityStats.industrialTiles = industrial;

        return { residential, commercial, industrial };
    }

    // RCI 수요 계산
    // 양수 = 수요 있음 (더 지어야 함), 음수 = 과잉 공급
    function calculateRCIDemand() {
        const tiles = countZoneTiles();
        const total = tiles.residential + tiles.commercial + tiles.industrial;

        // 구역이 없으면 모두 수요 있음
        if (total === 0) {
            cityStats.residentialDemand = 50;  // 초기 주거 수요
            cityStats.commercialDemand = 10;   // 약간의 상업 수요
            cityStats.industrialDemand = 30;   // 산업 수요
            return;
        }

        // 현재 비율 계산
        const currentRatio = {
            residential: tiles.residential / total,
            commercial: tiles.commercial / total,
            industrial: tiles.industrial / total
        };

        // 이상 비율과의 차이로 수요 계산
        // 차이 * 200으로 -100 ~ +100 범위로 변환
        // 현재 비율이 이상보다 낮으면 양수(수요), 높으면 음수(과잉)

        // === 주거 수요 ===
        // 주거는 일자리(산업+상업)가 있어야 수요 발생
        const totalJobs = (tiles.commercial * 5) + (tiles.industrial * 8);  // 상업: 5명, 산업: 8명
        const jobDemandFactor = Math.min(totalJobs / Math.max(cityStats.population, 1), 1.5);
        const residentialBase = (RCI_IDEAL_RATIO.residential - currentRatio.residential) * 150;
        cityStats.residentialDemand = Math.max(-100, Math.min(100, residentialBase * jobDemandFactor));

        // === 상업 수요 ===
        // 상업은 인구(소비자)와 산업(물품)이 필요
        const consumerDemand = cityStats.population / Math.max(tiles.commercial * 20, 1);  // 상업 1타일당 20명 소화
        const goodsSupply = tiles.industrial / Math.max(tiles.commercial, 1);  // 산업이 상업에 물품 공급
        const commercialBase = (RCI_IDEAL_RATIO.commercial - currentRatio.commercial) * 150;
        const commercialModifier = Math.min(consumerDemand, 1.5) * Math.min(goodsSupply + 0.5, 1.5);
        cityStats.commercialDemand = Math.max(-100, Math.min(100, commercialBase * commercialModifier));

        // === 산업 수요 ===
        // 산업은 주거(노동력)가 필요, 상업(판매처)이 있으면 보너스
        const laborSupply = cityStats.population / Math.max(tiles.industrial * 15, 1);  // 산업 1타일당 15명 필요
        const salesOutlet = tiles.commercial / Math.max(tiles.industrial * 0.5, 1);  // 상업이 판매처
        const industrialBase = (RCI_IDEAL_RATIO.industrial - currentRatio.industrial) * 150;
        const industrialModifier = Math.min(laborSupply, 1.5) * Math.min(salesOutlet + 0.3, 1.2);
        cityStats.industrialDemand = Math.max(-100, Math.min(100, industrialBase * industrialModifier));

        // 일자리 수 업데이트
        cityStats.commercialJobs = tiles.commercial * 5;
        cityStats.industrialJobs = tiles.industrial * 8;
    }

    // RCI 수요 바 UI 업데이트
    function updateRCIDemandBar() {
        calculateRCIDemand();

        // 각 바 업데이트 (수요를 바 너비로 변환: 0~50% = 절반)
        updateSingleRCIBar(rciResidentialBar, cityStats.residentialDemand, 'residential');
        updateSingleRCIBar(rciCommercialBar, cityStats.commercialDemand, 'commercial');
        updateSingleRCIBar(rciIndustrialBar, cityStats.industrialDemand, 'industrial');
    }

    function updateSingleRCIBar(barElement, demand, type) {
        if (!barElement) return;

        const container = barElement.parentElement;
        const negativeBar = container.querySelector('.rci-bar-negative');

        // 수요 값을 바 높이로 변환 (최대 50% = 절반, 세로 방향)
        const absValue = Math.abs(demand);
        const heightPercent = Math.min(absValue / 2, 50);  // 최대 50%

        if (demand >= 0) {
            // 양수: 녹색 바 (위쪽으로)
            barElement.style.height = heightPercent + '%';
            if (negativeBar) negativeBar.style.height = '0%';
        } else {
            // 음수: 빨간 바 (아래쪽으로)
            barElement.style.height = '0%';
            if (negativeBar) negativeBar.style.height = heightPercent + '%';
        }
    }

    function getStatClass(value, goodThreshold, warningThreshold) {
        if (value >= goodThreshold) return 'good';
        if (value >= warningThreshold) return 'warning';
        return 'danger';
    }

    function showOfflineEarnings(amount) {
        if (offlineEarningsBox && amount > 0) {
            offlineEarningsText.textContent = formatMoney(amount);
            offlineEarningsBox.style.display = 'block';
        }
    }

    function showLoginReward(amount) {
        if (loginRewardBox && amount > 0) {
            loginRewardText.textContent = formatMoney(amount);
            loginRewardBox.style.display = 'block';
        }
    }

    async function collectTax() {
        try {
            // 도시 이름 파라미터 추가
            const cityNameParam = MAP_CONFIG.cityName ? `?cityName=${encodeURIComponent(MAP_CONFIG.cityName)}` : '';
            const response = await fetch(`/api/map/${MAP_CONFIG.username}/collect-tax${cityNameParam}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            if (response.ok) {
                const data = await response.json();
                economy.money = data.money;
                renderMoney();
                flashMoney();
                if (offlineEarningsBox) offlineEarningsBox.style.display = 'none';
                toast({ title: i18n.t('toast.taxCollected'), desc: i18n.t('toast.taxCollectedDesc'), success: true });
            }
        } catch (e) {
            console.error("세금 수집 실패:", e);
        }
    }

    async function claimLoginReward() {
        try {
            // 도시 이름 파라미터 추가
            const cityNameParam = MAP_CONFIG.cityName ? `?cityName=${encodeURIComponent(MAP_CONFIG.cityName)}` : '';
            const response = await fetch(`/api/map/${MAP_CONFIG.username}/claim-reward${cityNameParam}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            if (response.ok) {
                const data = await response.json();
                economy.money = data.money;
                renderMoney();
                flashMoney();
                if (loginRewardBox) loginRewardBox.style.display = 'none';
                toast({ title: i18n.t('toast.rewardClaimed'), desc: i18n.t('toast.rewardClaimedDesc'), success: true });
            }
        } catch (e) {
            console.error("Reward claim failed:", e);
        }
    }

    if (btnCollectTax) btnCollectTax.addEventListener('click', collectTax);
    if (btnClaimReward) btnClaimReward.addEventListener('click', claimLoginReward);

    /* =========================================================
     * TILE MODELS (도로, 수로, 잔디, 다리)
     * ========================================================= */
    const TILE_MODELS = {
        // 기본 잔디 타일
        grass: "/models/tile_for_home_1x1.005.glb",
        // 도로 타일 (2차로)
        road: {
            straight: "/models/roads/DD.glb",
            corner:   "/models/roads/CCC.glb",
            t:        "/models/roads/CCCC.glb",
            cross:    "/models/roads/road_tile_1x1_4.glb",
        },
        // 4차로 도로 타일
        road4lane: {
            straight: "/models/roads/road_tile_2x2_6_L.glb",
            corner:   "/models/roads/road_tile_2x2_4_L.glb",
            t:        "/models/roads/road_tile_2x2_2_L.glb",
            cross:    "/models/roads/road_tile_2x2_5.glb",
            // 2차선 연결용 모델
            straight_side_full: "/models/roads/road_tile_2x2_1_L.glb",   // 한 면 양쪽 연결 (1,2 or 3,4)
            straight_side_single: "/models/roads/road_tile_2x2_3_L.glb", // 한 면 한쪽만 연결
            straight_side_single_reversed: "/models/roads/road_tile_2x2_3 reversal.glb", // 좌상단(1) 연결용 반전 모델
            straight_side_corner: "/models/roads/road_tile_2x2_7_L.glb", // 모서리 양쪽 연결 (3-2, 2-3 대각선)
            straight_side_corner_reversed: "/models/roads/road_tile_2x2_7 reversal.glb", // 1-4 대각선용 좌우반전 모델
            straight_both_sides: "/models/roads/road_tile_2x2_1_L.glb",  // 양쪽 면 모두 연결
        },
        // 수로 타일 (2x2)
        water: "/models/tile_river_2x2_001.glb",
        // 다리 타일 (수로 위 도로)
        bridge: "/models/roads/road_tile_bridge_1x1_3.glb",
        // 해변 타일
        beach: "/models/beach_tile_1x1_7.glb",
        // 바다/물 타일 (가장자리와 중앙 구분)
        ocean: {
            edge: "/models/beach_tile_1x1_007.glb",      // 바다 가장자리 (모래사장)
            middle: "/models/water.glb"                   // 바다 중앙 (2x2 물 타일)
        },
        // 나무 모델
        trees: [
            "/models/trees.010.glb",
            "/models/trees.011.glb"
        ],
    };

    // 하위 호환성을 위한 별칭
    const ROAD_MODELS = TILE_MODELS.road;

    /* =========================================================
     * BUILDING MODELS - 계층별/크기별 분류
     * ========================================================= */
    // 계층 상수: 0=중산층(middle), 1=상류층(high)
    const TIER = { MIDDLE: 0, HIGH: 1 };

    /* =========================================================
     * LAND VALUE SYSTEM - 땅값 시스템
     * ========================================================= */
    // 땅값 범위: -100 ~ 100 (0이 중간)
    // 50 이상이면 상류층 (HIGH), 미만이면 중산층 (MIDDLE)
    const LAND_VALUE_THRESHOLD = 50;

    // 업그레이드 시스템 설정
    const UPGRADE_CHECK_INTERVAL = 5000;  // 5초마다 땅값 체크
    const UPGRADE_MIN_DELAY = 3000;       // 업그레이드 최소 딜레이 (3초)
    const UPGRADE_MAX_DELAY = 15000;      // 업그레이드 최대 딜레이 (15초)
    const pendingUpgrades = new Map();    // 업그레이드 대기 목록
    const upgradeTimers = new Map();      // 업그레이드 딜레이 타이머 (건물 키 -> 타이머ID)
    const upgradeEligibleBuildings = new Map();  // 업그레이드 자격 충족 건물 (키 -> 시간)
    const abandonedBuildings = new Set(); // 폐건물 목록
    let lastUpgradeCheck = 0;             // 마지막 체크 시간
    let lastBottomBarUpdate = 0;          // 하단 바 업데이트 시간

    // 땅값 2D 배열 (GRID_W x GRID_H)
    const landValues = [];

    // 땅값 초기화
    function initLandValues() {
        for (let z = 0; z < GRID_H; z++) {
            landValues[z] = [];
            for (let x = 0; x < GRID_W; x++) {
                landValues[z][x] = 0;
            }
        }
    }

    // 특정 타일의 땅값 조회
    function getLandValue(x, z) {
        if (x < 0 || x >= GRID_W || z < 0 || z >= GRID_H) return 0;
        return landValues[z][x];
    }

    // 서비스 시설로 인한 땅값 버프 계산
    function getServiceBonus(x, z, skipAbandonedCheck = false) {
        // 해당 위치 건물이 폐건물인지 확인 - 폐건물은 버프를 받지 못함
        if (!skipAbandonedCheck) {
            const key = `${x},${z}`;
            if (abandonedBuildings.has(key)) {
                return 0;  // 폐건물은 서비스 보너스 없음
            }
            // buildingDataMap에서도 확인
            if (typeof buildingDataMap !== 'undefined') {
                const buildingData = buildingDataMap.get(key);
                if (buildingData && buildingData.isAbandoned) {
                    return 0;
                }
            }
        }

        let totalBonus = 0;

        // 모든 배치된 공공시설 확인
        if (typeof placedPublicBuildings !== 'undefined') {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조는 스킵

                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (!config) return;

                // 서비스 건물 운영 상태 확인 (비운영 시설은 보너스 미적용)
                if (typeof serviceBuildingManager !== 'undefined' &&
                    !serviceBuildingManager.isOperational(building.x, building.y)) {
                    return; // 비운영 시설은 보너스 없음
                }

                const bx = building.x;
                const by = building.y;
                const bw = building.width || 2;
                const bd = building.depth || 2;

                // 건물 중심 좌표
                const centerX = bx + bw / 2;
                const centerY = by + bd / 2;

                // 타일 중심과의 거리 계산
                const dx = (x + 0.5) - centerX;
                const dy = (z + 0.5) - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 효과 범위 내에 있으면 버프 적용 (거리에 따라 감소)
                if (distance <= config.effectRadius) {
                    const falloff = 1 - (distance / config.effectRadius);
                    totalBonus += config.landValueBonus * falloff;
                }
            });
        }

        return Math.round(totalBonus);
    }

    // 폐건물로 인한 땅값 감소 오라 계산 (행복도에는 영향 없음)
    const ABANDONED_AURA_RADIUS = 4;  // 폐건물 효과 범위 (4칸)
    const ABANDONED_LAND_VALUE_PENALTY = -50;  // 최대 땅값 감소

    function getAbandonedPenalty(x, z) {
        let totalPenalty = 0;

        // 모든 폐건물 확인
        abandonedBuildings.forEach(key => {
            const [bx, by] = key.split(',').map(Number);

            // 자기 자신은 제외
            if (bx === x && by === z) return;

            // 거리 계산
            const dx = x - bx;
            const dy = z - by;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // 효과 범위 내에 있으면 페널티 적용 (거리에 따라 감소)
            if (distance <= ABANDONED_AURA_RADIUS && distance > 0) {
                const falloff = 1 - (distance / ABANDONED_AURA_RADIUS);
                totalPenalty += ABANDONED_LAND_VALUE_PENALTY * falloff;
            }
        });

        return Math.round(totalPenalty);
    }

    // 총 땅값 계산 (기본 + 서비스 보너스 - 폐건물 페널티)
    function getTotalLandValue(x, z) {
        const baseLandValue = getLandValue(x, z);
        const serviceBonus = getServiceBonus(x, z);
        const abandonedPenalty = getAbandonedPenalty(x, z);
        return Math.max(0, baseLandValue + serviceBonus + abandonedPenalty);
    }

    // 땅값에 따른 계층 결정 (서비스 보너스 + 폐건물 페널티 포함)
    function getTierByLandValue(x, z) {
        const totalLandValue = getTotalLandValue(x, z);
        return totalLandValue >= LAND_VALUE_THRESHOLD ? TIER.HIGH : TIER.MIDDLE;
    }

    // 초기화 호출
    initLandValues();

    /* =========================================================
     * BUILDING UPGRADE SYSTEM - 건물 업그레이드 시스템
     * ========================================================= */

    // 모든 건물의 땅값 체크 (주기적으로 호출)
    function checkBuildingLandValues() {
        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData) continue;

            // 총 땅값 계산 (서비스 보너스 + 폐건물 페널티 포함)
            const totalLandValue = getTotalLandValue(x, y);
            userData.currentLandValue = totalLandValue;

            // 레벨 1 → 레벨 2 업그레이드 체크
            if (userData.level === 1 && !userData.isAbandoned) {
                if (totalLandValue >= LAND_VALUE_THRESHOLD) {
                    checkUpgradeEligibility(building, key);
                } else {
                    // 땅값 조건 미달 시 업그레이드 타이머 취소
                    cancelUpgradeTimer(key);
                }
            }

            // 레벨 2 → 폐건물 체크
            if (userData.level === 2 && !userData.isAbandoned) {
                if (totalLandValue < LAND_VALUE_THRESHOLD) {
                    userData.abandonedReason = '땅값이 하락해서 더 이상 살 수 없어요...';
                    markBuildingAbandoned(building, key);
                }
            }

            // 폐건물은 복구 불가 - 철거해야 함
            // (복구 로직 제거됨)
        }
    }

    // 업그레이드 가능 여부 확인 (랜덤 딜레이 적용)
    function checkUpgradeEligibility(building, key) {
        const { x, y, width, instance } = building;
        const userData = instance.userData;
        const zoneType = userData.zoneType;

        // 이미 2x2거나 레벨2면 스킵
        if (width === 2 || userData.level === 2) return;

        // 이미 업그레이드 대기 중이면 스킵
        if (upgradeTimers.has(key)) return;

        // 2x2 합체 가능 여부 확인
        const mergeResult = check2x2MergeEligibility(x, y, zoneType);

        if (mergeResult.canMerge) {
            // 랜덤 딜레이 계산 (3~15초)
            const delay = UPGRADE_MIN_DELAY + Math.random() * (UPGRADE_MAX_DELAY - UPGRADE_MIN_DELAY);

            // 업그레이드 자격 충족 표시 (땅값 조건 만족)
            upgradeEligibleBuildings.set(key, Date.now());

            // 딜레이 후 업그레이드 실행
            const timerId = setTimeout(() => {
                upgradeTimers.delete(key);
                upgradeEligibleBuildings.delete(key);

                // 건물이 아직 존재하고 조건이 여전히 만족하는지 확인
                const currentBuilding = placedBuildings.get(key);
                if (!currentBuilding) return;

                const currentUserData = currentBuilding.instance?.userData;
                if (!currentUserData || currentUserData.isAbandoned) return;
                if (currentUserData.level !== 1) return;

                // 땅값 재확인
                const totalLandValue = getTotalLandValue(x, y);
                if (totalLandValue < LAND_VALUE_THRESHOLD) return;

                // 2x2 합체 가능 여부 재확인
                const currentMergeResult = check2x2MergeEligibility(x, y, zoneType);
                if (currentMergeResult.canMerge) {
                    queueMergeUpgrade(currentMergeResult);
                }
            }, delay);

            upgradeTimers.set(key, timerId);
            console.log(`[Upgrade] Building at ${key} scheduled for upgrade in ${(delay/1000).toFixed(1)}s`);
        }
    }

    // 업그레이드 타이머 취소 (건물 제거 시 호출)
    function cancelUpgradeTimer(key) {
        if (upgradeTimers.has(key)) {
            clearTimeout(upgradeTimers.get(key));
            upgradeTimers.delete(key);
            upgradeEligibleBuildings.delete(key);
        }
    }

    // 2x2로 합체 가능한지 확인 (땅값만 만족하면 확장 가능, 옆 건물/공사 여부 무관)
    function check2x2MergeEligibility(startX, startY, zoneType) {
        // 4가지 2x2 배치 시도 (현재 타일이 각 모서리인 경우)
        const configs = [
            { x: startX, y: startY },         // 좌상단
            { x: startX - 1, y: startY },     // 우상단
            { x: startX, y: startY - 1 },     // 좌하단
            { x: startX - 1, y: startY - 1 }  // 우하단
        ];

        // 구역 문자열을 셀 타입으로 변환
        let zoneCellType = CELL.ZONE_RESIDENTIAL;
        if (zoneType === 'commercial') zoneCellType = CELL.ZONE_COMMERCIAL;
        else if (zoneType === 'industrial') zoneCellType = CELL.ZONE_INDUSTRIAL;

        for (const config of configs) {
            const x = config.x;
            const y = config.y;

            // 범위 체크
            if (x < 0 || y < 0 || x + 1 >= GRID_W || y + 1 >= GRID_H) continue;

            // 도로 방향 찾기 (canPlace2x2Building과 유사한 로직)
            const roadCounts = { top: 0, bottom: 0, left: 0, right: 0 };

            // 위쪽 (y - 1)
            if (inBounds(x, y - 1) && isRoad(x, y - 1)) roadCounts.top++;
            if (inBounds(x + 1, y - 1) && isRoad(x + 1, y - 1)) roadCounts.top++;
            // 아래쪽 (y + 2)
            if (inBounds(x, y + 2) && isRoad(x, y + 2)) roadCounts.bottom++;
            if (inBounds(x + 1, y + 2) && isRoad(x + 1, y + 2)) roadCounts.bottom++;
            // 왼쪽 (x - 1)
            if (inBounds(x - 1, y) && isRoad(x - 1, y)) roadCounts.left++;
            if (inBounds(x - 1, y + 1) && isRoad(x - 1, y + 1)) roadCounts.left++;
            // 오른쪽 (x + 2)
            if (inBounds(x + 2, y) && isRoad(x + 2, y)) roadCounts.right++;
            if (inBounds(x + 2, y + 1) && isRoad(x + 2, y + 1)) roadCounts.right++;

            // 도로가 있는 방향 (가장 많은 도로 우선)
            const directions = Object.entries(roadCounts)
                .filter(([_, count]) => count > 0)
                .sort((a, b) => b[1] - a[1])
                .map(([dir]) => dir);

            if (directions.length === 0) continue;

            // 모든 4타일 검사 (앞/뒤 구분 없음 - 땅값만 확인)
            const allTiles = [
                { x: x, y: y },
                { x: x + 1, y: y },
                { x: x, y: y + 1 },
                { x: x + 1, y: y + 1 }
            ];

            let isValid = true;
            const buildings = [];
            let hasOriginBuilding = false;  // 현재 건물이 포함되어 있는지

            for (const tile of allTiles) {
                const cellValue = grid[tile.x][tile.y];
                const bld = findBuildingAt(tile.x, tile.y);
                const isConstruction = constructionSites.has(`${tile.x},${tile.y}`);

                // 땅값 확인 (모든 타일)
                const landValue = getTotalLandValue(tile.x, tile.y);
                if (landValue < LAND_VALUE_THRESHOLD) { isValid = false; break; }

                if (bld) {
                    // 건물이 있으면 조건 확인 (2x2 건물은 불가)
                    if (bld.width !== 1) { isValid = false; break; }
                    const ud = bld.instance?.userData;
                    // 폐건물은 불가, 같은 구역이어야 함
                    if (ud && ud.isAbandoned) { isValid = false; break; }
                    if (ud && ud.zoneType && ud.zoneType !== zoneType) { isValid = false; break; }

                    buildings.push({ x: tile.x, y: tile.y, building: bld });
                    if (tile.x === startX && tile.y === startY) hasOriginBuilding = true;
                } else if (isConstruction) {
                    // 공사 중인 타일도 허용 (공사 취소 후 합체)
                    // buildings에는 추가하지 않음
                } else {
                    // 건물이 없으면 빈 공간 또는 같은 구역이어야 함
                    const isEmptyOrSameZone = (cellValue === CELL.EMPTY || cellValue === zoneCellType);
                    // 다른 타입의 구역, 도로, 수로 등은 불가
                    const isBlocker = (cellValue === CELL.ROAD || cellValue === CELL.LOCKED_ROAD ||
                                      cellValue === CELL.ROAD_4LANE || cellValue === CELL.LOCKED_ROAD_4LANE ||
                                      cellValue === CELL.WATER || cellValue === CELL.BRIDGE);
                    const isOtherZone = (cellValue === CELL.ZONE_RESIDENTIAL ||
                                        cellValue === CELL.ZONE_COMMERCIAL ||
                                        cellValue === CELL.ZONE_INDUSTRIAL) &&
                                        cellValue !== zoneCellType;

                    if (isBlocker || isOtherZone) {
                        isValid = false; break;
                    }
                    // 빈 공간/같은 구역은 허용
                }
            }
            if (!isValid) continue;

            // 최소 1개의 건물(현재 건물)이 있으면 합체 가능
            if (buildings.length >= 1 && hasOriginBuilding) {
                return { canMerge: true, startX: x, startY: y, buildings, zoneType };
            }
        }

        return { canMerge: false };
    }

    // 구역 문자열을 셀 타입으로 변환
    function getCellTypeForZone(zoneType) {
        if (zoneType === 'residential') return CELL.ZONE_RESIDENTIAL;
        if (zoneType === 'commercial') return CELL.ZONE_COMMERCIAL;
        if (zoneType === 'industrial') return CELL.ZONE_INDUSTRIAL;
        return CELL.ZONE_RESIDENTIAL;
    }

    // 2x2 합체 업그레이드 큐잉
    function queueMergeUpgrade(mergeResult) {
        const { startX, startY, buildings, zoneType } = mergeResult;
        const upgradeKey = `merge_${startX},${startY}`;

        if (pendingUpgrades.has(upgradeKey)) return;

        // 레벨 2 2x2 건물 모델 선택
        const cellType = getCellTypeForZone(zoneType);
        const buildingNames = getBuildingsForZone(cellType, TIER.HIGH, "2x2");
        if (buildingNames.length === 0) return;

        const idx = (startX * 7 + startY * 13) % buildingNames.length;
        const prefabName = buildingNames[idx];
        const buildingPrefab = buildingPrefabs[prefabName];
        if (!buildingPrefab) return;

        pendingUpgrades.set(upgradeKey, { type: 'merge', startX, startY, buildings });

        // 기존 건물 제거 (2x2 합체용이므로 재건축 스킵)
        for (const b of buildings) {
            removeBuildingAt(b.x, b.y, true);  // skipRebuild = true
        }

        // 기존 공사 시스템 사용
        queueConstruction(startX, startY, cellType, 2, 2, buildingPrefab, prefabName);

        console.log(`Merge upgrade queued at (${startX}, ${startY}) for ${zoneType}`);
    }

    // 건물을 폐건물로 표시 (영구적 - 철거만 가능)
    function markBuildingAbandoned(building, key) {
        const { instance, x, y } = building;
        const userData = instance.userData;

        if (userData.isAbandoned) return;

        userData.isAbandoned = true;
        building.isAbandoned = true;
        // 폐건물 이유를 buildingEntry에도 동기화
        building.abandonedReason = userData.abandonedReason || null;
        abandonedBuildings.add(key);

        // 단색 어두운 회색 적용
        applyAbandonedMaterials(instance);

        // 폐건물 아이콘 표시
        showAbandonedIcon(building, x, y);

        console.log(`Building at ${key} is now abandoned (reason: ${userData.abandonedReason || 'unknown'})`);
    }

    // ========================================
    // 통합 건물 상태 아이콘 시스템
    // 우선순위: 폐건물 > 도로 끊김 > 전력 부족 > 물 부족
    // 건물당 하나의 아이콘만 표시 (가장 높은 우선순위)
    // ========================================
    const BUILDING_STATUS = {
        // 치명적 문제 (우선순위 1-4)
        ABANDONED: { priority: 1, icon: '🏚️', className: 'status-abandoned', message: '폐건물이 되었어요...' },
        SERVICE_NO_ROAD: { priority: 2, icon: '🚫', className: 'status-no-road', message: '도로가 끊겨서 운영할 수 없어요!' },
        NO_ROAD: { priority: 2.5, icon: '🚫', className: 'status-no-road', message: '도로가 없어서 갈 수가 없어요!' },
        SERVICE_NO_POWER: { priority: 2.8, icon: '⚡', className: 'status-no-power', message: '전기가 없어서 운영이 중단됐어요!' },
        NO_POWER: { priority: 3, icon: '⚡', className: 'status-no-power', message: '전기가 없어요! 발전소가 필요해요!' },
        NO_WATER: { priority: 4, icon: '💧', className: 'status-no-water', message: '수도가 안 나와요! 취수장이 필요해요!' },
        // 서비스 요구사항 (우선순위 5-10)
        NEED_FIRE: { priority: 5, icon: '🚒', className: 'status-need-service', message: '화재가 걱정돼요... 소방서가 필요해요!' },
        NEED_POLICE: { priority: 6, icon: '🚔', className: 'status-need-service', message: '치안이 불안해요... 경찰서가 필요해요!' },
        NEED_HOSPITAL: { priority: 7, icon: '🏥', className: 'status-need-service', message: '아플 때 갈 곳이 없어요... 병원이 필요해요!' },
        NEED_SCHOOL: { priority: 8, icon: '🏫', className: 'status-need-service', message: '아이들 교육이 걱정돼요... 학교가 필요해요!' },
        NEED_PARK: { priority: 9, icon: '🌳', className: 'status-need-service', message: '쉴 곳이 없어요... 공원이 필요해요!' },
        LOW_HAPPINESS: { priority: 10, icon: '😢', className: 'status-low-happiness', message: '여기 살기 힘들어요...' }
    };

    // 건물별 상태 저장 (key -> Set of status types)
    const buildingStatuses = new Map();
    // 건물별 표시중인 아이콘 (key -> { element, building, currentStatus })
    const buildingStatusIcons = new Map();

    // 건물 상태 추가
    function addBuildingStatus(x, y, statusType, building = null) {
        const key = `${x},${y}`;
        if (!buildingStatuses.has(key)) {
            buildingStatuses.set(key, new Set());
        }
        buildingStatuses.get(key).add(statusType);

        // 건물 참조 저장 (없으면 placedBuildings/placedPublicBuildings에서 찾기)
        if (!building) {
            building = placedBuildings.get(key) || placedPublicBuildings.get(key);
        }
        // ref 참조인 경우 원본 건물 찾기
        if (building && building.ref) {
            building = placedBuildings.get(building.ref) || placedPublicBuildings.get(building.ref);
        }

        updateBuildingStatusIcon(key, building);
    }

    // 건물 상태 제거
    function removeBuildingStatus(x, y, statusType) {
        const key = `${x},${y}`;
        const statuses = buildingStatuses.get(key);
        if (statuses) {
            statuses.delete(statusType);
            if (statuses.size === 0) {
                buildingStatuses.delete(key);
            }
        }

        // 건물 참조 찾기 (placedBuildings + placedPublicBuildings)
        let building = placedBuildings.get(key) || placedPublicBuildings.get(key);
        // ref 참조인 경우 원본 건물 찾기
        if (building && building.ref) {
            building = placedBuildings.get(building.ref) || placedPublicBuildings.get(building.ref);
        }
        updateBuildingStatusIcon(key, building);
    }

    // 건물의 최우선 상태 가져오기
    function getHighestPriorityStatus(key) {
        const statuses = buildingStatuses.get(key);
        if (!statuses || statuses.size === 0) return null;

        let highest = null;
        let highestPriority = Infinity;

        statuses.forEach(statusType => {
            const statusConfig = BUILDING_STATUS[statusType];
            if (statusConfig && statusConfig.priority < highestPriority) {
                highestPriority = statusConfig.priority;
                highest = statusType;
            }
        });

        return highest;
    }

    // 건물 상태 아이콘 업데이트 (우선순위에 따라 하나만 표시)
    function updateBuildingStatusIcon(key, building) {
        const highestStatus = getHighestPriorityStatus(key);
        const existingIcon = buildingStatusIcons.get(key);

        // 상태 없음 → 아이콘 제거
        if (!highestStatus) {
            if (existingIcon) {
                existingIcon.element.remove();
                buildingStatusIcons.delete(key);
            }
            return;
        }

        // 같은 상태면 유지
        if (existingIcon && existingIcon.currentStatus === highestStatus) {
            return;
        }

        // 기존 아이콘 제거
        if (existingIcon) {
            existingIcon.element.remove();
        }

        // 새 아이콘 생성
        if (!building) {
            building = placedBuildings.get(key) || placedPublicBuildings.get(key);
        }
        // ref 참조인 경우 원본 건물 찾기
        if (building && building.ref) {
            building = placedBuildings.get(building.ref) || placedPublicBuildings.get(building.ref);
        }
        if (!building || !building.instance) return;

        const statusConfig = BUILDING_STATUS[highestStatus];
        // 컨테이너: 위치 지정 (translate3d)
        const iconEl = document.createElement('div');
        iconEl.className = 'building-status-icon-container';
        iconEl.style.cssText = `
            position: fixed;
            left: 0;
            top: 0;
            pointer-events: none;
            z-index: 50;
            will-change: transform;
            transform: translate3d(0, 0, 0);
        `;
        // 내부 아이콘: 바운스 애니메이션 (translateY)
        const iconSpan = document.createElement('span');
        iconSpan.className = `building-status-icon ${statusConfig.className}`;
        iconSpan.textContent = statusConfig.icon;
        iconSpan.style.cssText = `
            display: block;
            font-size: calc(24px * var(--ui-scale, 1));
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            animation: statusIconBounce 2s ease-in-out infinite;
        `;
        iconEl.appendChild(iconSpan);
        document.body.appendChild(iconEl);

        buildingStatusIcons.set(key, {
            element: iconEl,
            building: building,
            currentStatus: highestStatus
        });
    }

    // 모든 상태 아이콘 위치 업데이트 (animate 루프)
    const _iconBox = new THREE.Box3();
    const _iconCenter = new THREE.Vector3();
    const _iconTop = new THREE.Vector3();
    const _iconScreenPos = new THREE.Vector3();

    // 상태 아이콘 표시 최대 거리
    const STATUS_ICON_MAX_DISTANCE = 25;

    function updateAllStatusIcons() {
        buildingStatusIcons.forEach((iconData, key) => {
            const { element, building } = iconData;
            if (!building || !building.instance) {
                element.remove();
                buildingStatusIcons.delete(key);
                buildingStatuses.delete(key);
                return;
            }

            // 건물 상단 위치 계산 - 바운딩 박스 사용
            _iconBox.setFromObject(building.instance);
            _iconBox.getCenter(_iconCenter);

            // 건물 상단 중앙에 아이콘 위치
            _iconTop.set(_iconCenter.x, _iconBox.max.y + 0.5, _iconCenter.z);

            // 카메라와의 거리 계산
            const distanceToCamera = camera.position.distanceTo(_iconCenter);

            // 일정 거리 이상이면 숨김
            if (distanceToCamera > STATUS_ICON_MAX_DISTANCE) {
                element.style.display = 'none';
                return;
            }

            // 3D → 2D 화면 좌표 변환
            _iconScreenPos.copy(_iconTop).project(camera);

            // 카메라 뒤에 있으면 숨김
            if (_iconScreenPos.z > 1) {
                element.style.display = 'none';
                return;
            }

            const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
            // UI 스케일에 맞게 아이콘 오프셋 계산 (아이콘 크기: 24px * ui-scale)
            const uiScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--ui-scale')) || 1;
            const iconOffset = 12 * uiScale;
            const screenX = (_iconScreenPos.x * 0.5 + 0.5) * rect.width + rect.left - iconOffset;
            const screenY = (-_iconScreenPos.y * 0.5 + 0.5) * rect.height + rect.top - iconOffset;

            element.style.display = 'block';
            // GPU 가속 transform 사용 (left/top 대신)
            element.style.transform = `translate3d(${screenX}px, ${screenY}px, 0)`;
        });
    }

    // ========================================
    // 하위 호환성을 위한 래퍼 함수들
    // ========================================

    // 폐건물 아이콘 (레거시 호환)
    const abandonedIcons = buildingStatusIcons;  // 참조 유지 (레거시 코드용)

    function showAbandonedIcon(building, x, y) {
        addBuildingStatus(x, y, 'ABANDONED', building);
    }

    function removeAbandonedIcon(x, y) {
        removeBuildingStatus(x, y, 'ABANDONED');
    }

    // 건물의 모든 상태 제거 (철거 시 호출)
    function clearAllBuildingStatuses(x, y) {
        const key = `${x},${y}`;

        // 모든 상태 제거
        buildingStatuses.delete(key);

        // 아이콘 요소 제거
        const iconData = buildingStatusIcons.get(key);
        if (iconData) {
            iconData.element.remove();
            buildingStatusIcons.delete(key);
        }
    }

    // 레거시 함수명 유지
    function updateAbandonedIcons() {
        updateAllStatusIcons();
    }

    // 건물의 서비스 요구사항 체크 (서비스 범위 내에 있는지)
    function checkBuildingServiceNeeds(x, y, building) {
        const needs = [];
        if (!building || building.ref || building.isAbandoned) return needs;

        // 서비스 건물 타입별 효과 범위
        const SERVICE_TYPES = {
            fire: { types: ['fire'], radius: 8, status: 'NEED_FIRE' },
            police: { types: ['police'], radius: 8, status: 'NEED_POLICE' },
            hospital: { types: ['hospital'], radius: 12, status: 'NEED_HOSPITAL' },
            school: { types: ['school'], radius: 10, status: 'NEED_SCHOOL' },
            park: { types: ['park'], radius: 5, status: 'NEED_PARK' }
        };

        // 각 서비스 타입별로 범위 내 서비스 건물이 있는지 체크
        for (const [service, config] of Object.entries(SERVICE_TYPES)) {
            let hasService = false;

            placedPublicBuildings.forEach((pb, key) => {
                if (pb.ref) return;
                if (!config.types.includes(pb.type)) return;

                // 서비스 건물이 운영 중인지 확인
                if (typeof serviceBuildingManager !== 'undefined' &&
                    !serviceBuildingManager.isOperational(pb.x, pb.y)) {
                    return;
                }

                // 거리 계산
                const pbWidth = pb.width || 2;
                const pbDepth = pb.depth || 2;
                const pbCenterX = pb.x + pbWidth / 2;
                const pbCenterY = pb.y + pbDepth / 2;

                const bWidth = building.width || 1;
                const bDepth = building.depth || 1;
                const bCenterX = x + bWidth / 2;
                const bCenterY = y + bDepth / 2;

                const distance = Math.sqrt(
                    Math.pow(pbCenterX - bCenterX, 2) +
                    Math.pow(pbCenterY - bCenterY, 2)
                );

                // 서비스 건물의 효과 범위 사용
                const pbConfig = PUBLIC_BUILDING_MODELS[pb.type];
                const effectRadius = pbConfig?.effectRadius || config.radius;

                if (distance <= effectRadius) {
                    hasService = true;
                }
            });

            if (!hasService) {
                needs.push(config.status);
            }
        }

        return needs;
    }

    // 건물 요구사항 업데이트 (비활성화됨 - 서비스 요구사항 메시지 제거)
    function updateBuildingRequirements() {
        // 서비스 요구사항 체크 비활성화
        // 기존 서비스 요구사항 아이콘만 제거
        placedBuildings.forEach((building, key) => {
            if (building.ref || building.isAbandoned) return;

            // 기존 서비스 요구사항 상태 제거
            ['NEED_FIRE', 'NEED_POLICE', 'NEED_HOSPITAL', 'NEED_SCHOOL', 'NEED_PARK', 'LOW_HAPPINESS'].forEach(status => {
                const statuses = buildingStatuses.get(key);
                if (statuses) statuses.delete(status);
            });

            updateBuildingStatusIcon(key, building);
        });
    }

    // 서비스 요구사항 업데이트 비활성화
    // setInterval(updateBuildingRequirements, 30000);

    // 건물 클릭 시 요구사항 메시지 가져오기
    function getBuildingRequirementMessage(x, y) {
        const key = `${x},${y}`;
        const highestStatus = getHighestPriorityStatus(key);
        if (highestStatus && BUILDING_STATUS[highestStatus]) {
            return BUILDING_STATUS[highestStatus].message;
        }
        return null;
    }

    // 폐건물 회색 적용
    const ABANDONED_GRAY = 0x4a4a4a;  // 어두운 회색

    function applyAbandonedMaterials(instance) {
        instance.traverse((child) => {
            if (child.isMesh && child.material) {
                const materials = Array.isArray(child.material) ? child.material : [child.material];

                materials.forEach((mat) => {
                    // 회색으로 변경
                    if (mat.color) {
                        mat.color.setHex(ABANDONED_GRAY);
                    }
                    mat.transparent = false;
                    mat.opacity = 1.0;
                });
            }
        });
    }

    // 폐건물은 복구 불가능 - 철거만 가능
    // (복구 함수 제거됨)

    // 새로운 건물 모델 구조: zone -> tier -> size -> models[]
    const CIVIL_BUILDING_MODELS = {
        residential: {
            [TIER.MIDDLE]: {
                "1x1": [
                    "Group%2012", "Group%2013", "Group%2014", "Group%2015",
                    "Group%2034", "Group%2035", "Group%2036", "Group%2042",
                    "Group%2044", "Group%2045", "Group%2047", "Group%2048",
                    "Group%2049", "Group%2050"
                ],
                "2x2": []  // 중산층 주거는 2x2 없음
            },
            [TIER.HIGH]: {
                "1x1": [
                    "tile_for_home_1x1.006",
                    "tile_for_home_1x1.006%20(1)",
                    "tile_for_home_1x1.006%20(2)",
                    "tile_for_home_1x1.006%20(3)",
                    "tile_for_home_1x1.006%20(4)",
                    "tile_for_home_1x1.006%20(5)"
                ],
                "2x2": [
                    "tile_for_home_1x1.006%20(6)",
                    "tile_for_home_1x1.006%20(7)",
                    "tile_for_home_1x1.006%20(8)",
                    "tile_for_home_1x1.006%20(9)",
                    "tile_for_home_2x2.002",
                    "tile_for_home_2x2.002%20(1)",
                    "tile_for_home_2x2.002%20(2)",
                    "tile_for_home_2x2.002%20(3)",
                    "tile_for_home_2x2.002%20(4)",
                    "tile_for_home_2x2.002%20(5)",
                    "tile_for_home_2x2.002%20(6)",
                    "tile_for_home_2x2.002%20(7)",
                    "tile_for_home_2x2.002%20(8)",
                    "tile_for_home_2x2.002%20(9)"
                ]
            }
        },
        commercial: {
            [TIER.MIDDLE]: {
                "1x1": [
                    "tile_for_home_1x1.006%20(1)%20bookstore",
                    "tile_for_home_1x1.006%20(2)%20gym",
                    "tile_for_home_1x1.006%20(3)%20furniture",
                    "tile_for_home_1x1.006%20(4)%20skateboard",
                    "tile_for_home_1x1.006%20(5)%20guitar",
                    "tile_for_home_1x1.006%20(6)%20shoes",
                    "tile_for_home_1x1.006%20(7)%20hairshop",
                    "tile_for_home_1x1.006%20(8)%20tool",
                    "tile_for_home_1x1.006%20(9)%20glasses",
                    "tile_for_home_1x1.006%20(10)%20whiskey",
                    "tile_for_home_1x1.006%20(11)hamburer",
                    "tile_for_home_1x1.006%20(12)%20store",
                    "tile_for_home_1x1.006%20(13)%20icecream",
                    "tile_for_home_1x1.006%20(14)%20muffin",
                    "tile_for_home_1x1.006%20(15)%20donet",
                    "tile_for_home_1x1.006%20(16)",
                    "tile_for_home_1x1.006%20(17)%20bubbletea",
                    "tile_for_home_1x1.006%20(18)%20coke",
                    "tile_for_home_1x1.006%20speaker",
                    "tile_for_home_1x1.006%20(8)%20supermarket",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(1)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(2)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(3)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(4)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(5)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(6)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(7)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(9)"
                ],
                "2x2": ["Group%2024", "Group%2029"]
            },
            [TIER.HIGH]: {
                "1x1": [],  // 상류층 상업은 1x1 없음
                "2x2": [
                    "business%20centers.009",
                    "tile_for_home_2x2.005",
                    "tile_for_home_2x2.005%20(1)",
                    "tile_for_home_2x2.005%20(2)",
                    "tile_for_home_2x2.005%20(3)",
                    "tile_for_home_2x2.005%20(4)",
                    "tile_for_home_2x2.005%20(5)",
                    "tile_for_home_2x2.005%20(6)",
                    "tile_for_home_2x2.005%20(8)"
                ]
            }
        },
        industrial: {
            [TIER.MIDDLE]: { "1x1": [], "2x2": [] },
            [TIER.HIGH]: { "1x1": [], "2x2": [] }
        }
    };

    // 건물 표시 이름 매핑 (prefabName -> 한글 이름)
    // prefabName 형식: {zoneType}_{tier}_{size}_{modelName}
    const BUILDING_DISPLAY_NAMES = {
        // 상업 중산층 1x1
        "commercial_1_1x1_tile_for_home_1x1.006%20(1)%20bookstore": "책벌레 서점",
        "commercial_1_1x1_tile_for_home_1x1.006%20(2)%20gym": "머슬파워 짐",
        "commercial_1_1x1_tile_for_home_1x1.006%20(3)%20furniture": "편안한 가구나라",
        "commercial_1_1x1_tile_for_home_1x1.006%20(4)%20skateboard": "익스트림 보드샵",
        "commercial_1_1x1_tile_for_home_1x1.006%20(5)%20guitar": "록스타 기타",
        "commercial_1_1x1_tile_for_home_1x1.006%20(6)%20shoes": "황금신발 구두방",
        "commercial_1_1x1_tile_for_home_1x1.006%20(7)%20hairshop": "가위손 미용실",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20tool": "뚝딱뚝딱 공구상",
        "commercial_1_1x1_tile_for_home_1x1.006%20(9)%20glasses": "맑은눈 안경점",
        "commercial_1_1x1_tile_for_home_1x1.006%20(10)%20whiskey": "한잔의 여유",
        "commercial_1_1x1_tile_for_home_1x1.006%20(11)hamburer": "왕햄버거",
        "commercial_1_1x1_tile_for_home_1x1.006%20(12)%20store": "24시 행복마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(13)%20icecream": "달콤 아이스",
        "commercial_1_1x1_tile_for_home_1x1.006%20(14)%20muffin": "구름머핀",
        "commercial_1_1x1_tile_for_home_1x1.006%20(15)%20donet": "동글동글 도넛",
        "commercial_1_1x1_tile_for_home_1x1.006%20(16)": "이것저것 잡화점",
        "commercial_1_1x1_tile_for_home_1x1.006%20(17)%20bubbletea": "타피오카 천국",
        "commercial_1_1x1_tile_for_home_1x1.006%20(18)%20coke": "톡톡 음료가게",
        "commercial_1_1x1_tile_for_home_1x1.006%20speaker": "쿵쿵 오디오",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket": "엄마손 슈퍼",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(1)": "싱싱 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(2)": "알뜰 식료품",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(3)": "착한가격 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(4)": "우리동네 가게",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(5)": "쪼꼬미 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(6)": "럭키세븐 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(7)": "매일매일 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(9)": "싱싱프레시",
    };

    // 상업 건물 영단어 → 한글 업종명 매핑
    const COMMERCIAL_TYPE_NAMES = {
        bookstore: { type: '서점', prefixes: ['책벌레', '지식의', '문학', '동네', '행복한'] },
        gym: { type: '헬스장', prefixes: ['머슬파워', '파워', '근육맨', '건강한', '철인'] },
        furniture: { type: '가구점', prefixes: ['편안한', '꿈의', '행복', '우리집', '좋은'] },
        skateboard: { type: '보드샵', prefixes: ['익스트림', '스피드', '자유', '쿨', '슬라이드'] },
        guitar: { type: '기타샵', prefixes: ['록스타', '멜로디', '음악의', '하모니', '기타천국'] },
        shoes: { type: '신발가게', prefixes: ['황금신발', '편한', '발이좋아', '걸음마', '스텝'] },
        hairshop: { type: '미용실', prefixes: ['가위손', '예쁜손', '헤어', '스타일', '멋쟁이'] },
        tool: { type: '공구상', prefixes: ['뚝딱뚝딱', '만능', '철물', '든든한', '장인'] },
        glasses: { type: '안경점', prefixes: ['맑은눈', '선명한', '눈이편한', '시력', '클리어'] },
        whiskey: { type: '주점', prefixes: ['한잔의여유', '달빛', '황금잔', '밤하늘', '술한잔'] },
        hamburer: { type: '버거집', prefixes: ['왕', '빅', '맛있는', '황금', '불맛'] },
        hamburger: { type: '버거집', prefixes: ['왕', '빅', '맛있는', '황금', '불맛'] },
        store: { type: '마트', prefixes: ['24시', '행복', '알뜰', '동네', '싱싱'] },
        icecream: { type: '아이스크림', prefixes: ['달콤', '시원한', '행복', '무지개', '솜사탕'] },
        muffin: { type: '머핀', prefixes: ['구름', '달콤한', '행복', '황금', '맛있는'] },
        donet: { type: '도넛', prefixes: ['동글동글', '달콤', '행복', '황금', '맛있는'] },
        donut: { type: '도넛', prefixes: ['동글동글', '달콤', '행복', '황금', '맛있는'] },
        bubbletea: { type: '버블티', prefixes: ['타피오카', '쫀득', '달콤', '행복', '무지개'] },
        coke: { type: '음료', prefixes: ['톡톡', '시원한', '청량', '행복', '상쾌한'] },
        speaker: { type: '오디오', prefixes: ['쿵쿵', '하이파이', '음악의', '멜로디', '사운드'] },
        supermarket: { type: '슈퍼', prefixes: ['엄마손', '싱싱', '알뜰', '착한가격', '동네'] },
        cafe: { type: '카페', prefixes: ['향기로운', '커피향', '달콤한', '행복한', '아늑한'] },
        restaurant: { type: '식당', prefixes: ['맛있는', '행복한', '엄마손', '정성', '황금'] },
        pharmacy: { type: '약국', prefixes: ['건강한', '튼튼', '행복', '우리동네', '24시'] },
        bakery: { type: '빵집', prefixes: ['갓구운', '달콤한', '행복', '황금빛', '맛있는'] },
        flower: { type: '꽃집', prefixes: ['향기로운', '아름다운', '행복한', '사랑의', '봄날'] },
        pet: { type: '펫샵', prefixes: ['사랑스런', '행복한', '동물친구', '멍멍', '냥냥'] },
        laundry: { type: '세탁소', prefixes: ['깨끗한', '뽀송', '새하얀', '향기나는', '빨래'] },
        centers: { type: '센터', prefixes: ['비즈니스', '글로벌', '시티', '프라임', '스카이'] }
    };

    // prefabName에서 마지막 영단어(업종) 추출
    function extractCommercialType(prefabName) {
        if (!prefabName) return null;

        // URL 디코딩 (%20 → 공백)
        const decoded = decodeURIComponent(prefabName);

        // 마지막 영단어 추출 (숫자, 괄호, 점 제외)
        // 예: "commercial_1_1x1_tile_for_home_1x1.006 (8) supermarket (1)" → "supermarket"
        const words = decoded.split(/[\s._()]+/).filter(w => w && !/^\d+$/.test(w));

        // 뒤에서부터 영단어 찾기
        for (let i = words.length - 1; i >= 0; i--) {
            const word = words[i].toLowerCase();
            if (COMMERCIAL_TYPE_NAMES[word]) {
                return word;
            }
        }
        return null;
    }

    // 상업 건물 이름 생성 (모델명 기반)
    function generateCommercialName(prefabName) {
        const commercialType = extractCommercialType(prefabName);

        if (commercialType && COMMERCIAL_TYPE_NAMES[commercialType]) {
            const config = COMMERCIAL_TYPE_NAMES[commercialType];
            const prefix = config.prefixes[Math.floor(Math.random() * config.prefixes.length)];
            return `${prefix} ${config.type}`;
        }

        // 타입을 찾을 수 없으면 기본 이름
        return null;
    }

    // 건물 표시 이름 가져오기
    function getBuildingDisplayName(prefabName) {
        if (!prefabName) return null;

        // 먼저 매핑된 이름이 있는지 확인
        if (BUILDING_DISPLAY_NAMES[prefabName]) {
            return BUILDING_DISPLAY_NAMES[prefabName];
        }

        // 매핑된 이름이 없으면 prefabName에서 기본 이름 생성
        // prefabName 형식: {zoneType}_{tier}_{size}_{modelName}
        const parts = prefabName.split('_');
        if (parts.length >= 3) {
            const zoneType = parts[0];  // residential, commercial, industrial
            const tier = parseInt(parts[1]);  // 1: MIDDLE, 2: HIGH
            const size = parts[2];  // 1x1, 2x2

            // 상업 건물: 모델명에서 업종 추출하여 이름 생성
            if (zoneType === 'commercial') {
                // 상류층 상업 (2x2) - 오피스/타워 (상점 스타일 아님)
                if (tier === 2) {
                    const officePrefixes = ['스카이', '센트럴', '글로벌', '파크', '시티', '테크', '프라임', '랜드마크', '코어', '원', '메트로', '그랜드'];
                    const officeSuffixes = ['타워', '오피스', '빌딩', '플라자', '센터', '스퀘어'];
                    const prefix = officePrefixes[Math.floor(Math.random() * officePrefixes.length)];
                    const suffix = officeSuffixes[Math.floor(Math.random() * officeSuffixes.length)];
                    return `${prefix} ${suffix}`;
                }

                // 중산층 상업 (1x1) - 상점 스타일
                const commercialName = generateCommercialName(prefabName);
                if (commercialName) return commercialName;
            }

            // 상류층(tier=2) 주거 건물
            if (tier === 2 && zoneType === 'residential') {
                return '아파트';
            }

            // 중산층(tier=1) 주거 건물
            if (tier === 1 && zoneType === 'residential') {
                const villaNames = ['해피 빌라', '그린 빌라', '썬샤인 빌라', '블루 빌라', '행복 주택'];
                return villaNames[Math.floor(Math.random() * villaNames.length)];
            }
        }

        return null;
    }

    // 기본 경로 생성 함수
    function getCivilBuildingPath(zoneType, tier, size, modelName) {
        const zoneFolder = zoneType === 'residential' ? 'resident' : 'commerical';
        const tierFolder = tier === TIER.HIGH ? 'high' : 'middle';
        return `/models/civil%20buildlings/${zoneFolder}%20${tierFolder}/${size}/${modelName}.glb`;
    }

    // 기존 호환용 (공업구역 등)
    const BUILDING_MODELS = {
        residential: [],
        commercial: [],
        industrial: [],
    };

    // 건물 프리팹 저장소 { name: { prefab, width, depth, height } }
    const buildingPrefabs = {};

    // 건물 그룹 (씬에 배치된 건물들)
    const buildingGroup = new THREE.Group();

    // 건물 위치 추적 Map: "x,y" -> { instance, tiles: ["x,y", ...] }
    const placedBuildings = new Map();
    let savedBuildingsData = null;  // DB에서 로드된 건물 데이터

    // === 건물 순회 최적화: Array 캐시 ===
    // Map.forEach보다 Array iteration이 더 빠름
    let placedBuildingsArrayCache = [];
    let placedBuildingsArrayDirty = true;

    // 건물 배열 캐시 가져오기 (참조 건물 제외, 실제 건물만)
    function getPlacedBuildingsArray() {
        if (placedBuildingsArrayDirty) {
            placedBuildingsArrayCache = [];
            placedBuildings.forEach((building, key) => {
                if (!building.ref) {  // 참조가 아닌 실제 건물만
                    placedBuildingsArrayCache.push({ building, key });
                }
            });
            placedBuildingsArrayDirty = false;
        }
        return placedBuildingsArrayCache;
    }

    // 캐시 무효화
    function invalidateBuildingsCache() {
        placedBuildingsArrayDirty = true;
    }

    // 건물 데이터 추출 (저장용 - 3D 객체 제외)
    function extractBuildingsData() {
        const data = {
            civilBuildings: [],
            publicBuildings: [],
            constructionSites: [],  // 공사중인 현장
            road4LaneOrigins: [],   // 4차로 도로 원점
            trees: []               // 나무 데이터
        };

        // 4차로 도로 원점 저장
        if (typeof road4laneOrigins !== 'undefined') {
            road4laneOrigins.forEach((originData, key) => {
                const [x, y] = key.split(',').map(Number);
                data.road4LaneOrigins.push({
                    x, y,
                    variant: originData.variant,
                    rotY: originData.rotY
                });
            });
        }

        // 민간 건물
        let totalBuildings = 0;
        let refBuildings = 0;
        let savedBuildings = 0;
        let skippedNoCoords = 0;

        console.log(`[Save Debug] placedBuildings size: ${placedBuildings.size}`);

        placedBuildings.forEach((building, key) => {
            totalBuildings++;
            if (building.ref) {
                refBuildings++;
                return;  // 참조 건물 스킵
            }

            // 필수 속성 확인
            if (typeof building.x === 'undefined' || typeof building.y === 'undefined') {
                console.warn(`[Save] 건물 ${key}에 좌표 정보 없음, 스킵`, building);
                skippedNoCoords++;
                return;
            }

            // 인구 데이터 가져오기 (주거 건물만)
            const size = building.width === 2 ? '2x2' : '1x1';
            const popKey = getBuildingKey(building.x, building.y, size);
            const population = buildingPopulations.get(popKey) || 0;

            // 건물 prefab 이름 (건물 복원용)
            const prefabName = building.prefabName || null;
            // 건물 표시 이름 (한글)
            const displayName = building.displayName || getBuildingDisplayName(prefabName);

            // 폐건물 이유 가져오기 (폐건물인 경우만)
            const abandonedReason = (building.isAbandoned && building.instance?.userData?.abandonedReason)
                ? building.instance.userData.abandonedReason
                : null;

            data.civilBuildings.push({
                key,
                x: building.x,
                y: building.y,
                width: building.width,
                depth: building.depth,
                zoneType: building.zoneType,
                level: building.level || 1,
                tier: building.tier || TIER.MIDDLE,
                isAbandoned: building.isAbandoned || false,
                abandonedReason: abandonedReason,  // 폐건물 이유 저장
                population: population,  // 인구 저장
                prefabName: prefabName,  // 건물 모델 이름 저장
                displayName: displayName // 건물 표시 이름 저장
            });
            savedBuildings++;
        });

        console.log(`[Save] placedBuildings 총: ${totalBuildings}개 (참조: ${refBuildings}개, 좌표없음: ${skippedNoCoords}개, 저장됨: ${savedBuildings}개)`);

        // 공공시설
        if (typeof placedPublicBuildings !== 'undefined') {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조 스킵
                // 회전값 추출 (instance가 있는 경우)
                const rotation = building.instance ? building.instance.rotation.y : 0;

                // 확장 터빈/패널 데이터 추출 (풍력/태양광 발전소)
                let expansions = null;
                if ((building.type === 'powerplant_wind' || building.type === 'powerplant_solar') &&
                    building.expansionInstances && building.expansionInstances.length > 0) {
                    expansions = building.expansionInstances.map((exp, idx) => ({
                        x: exp.x,
                        y: exp.y,
                        width: exp.width || 3,
                        depth: exp.depth || 1,
                        slotNum: idx + 1
                    }));
                }

                data.publicBuildings.push({
                    key,
                    type: building.type,
                    x: building.x,
                    y: building.y,
                    width: building.width,
                    depth: building.depth,
                    rotation: rotation,
                    roadSide: building.roadSide || 'bottom',  // 도로 방향 저장
                    expansions: expansions  // 확장 터빈 데이터 추가
                });
            });
        }

        // 공사중인 현장 (3D 객체 제외하고 저장)
        if (typeof constructionSites !== 'undefined') {
            constructionSites.forEach((site, key) => {
                data.constructionSites.push({
                    key,
                    x: site.x,
                    y: site.y,
                    width: site.width,
                    depth: site.depth,
                    zoneType: site.zoneType,
                    state: site.state,
                    zoneStr: site.zoneStr,
                    size: site.size
                });
            });
        }

        // 나무 데이터 저장
        if (typeof placedTrees !== 'undefined') {
            placedTrees.forEach((treeData, key) => {
                const [x, y] = key.split(',').map(Number);
                data.trees.push({
                    x,
                    y,
                    modelIndex: treeData.modelIndex,
                    offsetX: treeData.offsetX,
                    offsetZ: treeData.offsetZ
                });
            });
        }

        // 저장 디버그 로그
        console.log(`[Save] 민간건물: ${data.civilBuildings.length}개, 공공시설: ${data.publicBuildings.length}개, 공사현장: ${data.constructionSites.length}개, 4차로: ${data.road4LaneOrigins.length}개, 나무: ${data.trees.length}개`);

        return data;
    }

    // 저장된 건물 데이터에서 특정 위치의 건물 정보 찾기
    function findSavedBuildingData(x, y) {
        if (!savedBuildingsData) return null;
        return savedBuildingsData.find(b => {
            // 건물이 차지하는 모든 타일 확인
            for (let dx = 0; dx < b.width; dx++) {
                for (let dy = 0; dy < b.depth; dy++) {
                    if (b.x + dx === x && b.y + dy === y) return true;
                }
            }
            return false;
        });
    }

    // 공사중인 현장 복원
    function restoreConstructionSites(sites) {
        if (!sites || sites.length === 0) return;

        for (const site of sites) {
            const { x, y, width, depth, zoneType, zoneStr, size } = site;

            // 해당 위치가 구역 타일인지 확인
            if (x >= 0 && x < GRID_W && y >= 0 && y < GRID_H) {
                const cellType = grid[x][y];
                if (cellType !== CELL.ZONE_RESIDENTIAL &&
                    cellType !== CELL.ZONE_COMMERCIAL &&
                    cellType !== CELL.ZONE_INDUSTRIAL) {
                    console.log(`Skipping construction at (${x},${y}) - not a zone cell`);
                    continue;
                }

                // 이미 건물이 있으면 스킵
                if (findBuildingAt(x, y)) {
                    console.log(`Skipping construction at (${x},${y}) - building already exists`);
                    continue;
                }

                // 해당 티어와 사이즈의 건물 목록 가져오기
                const tier = width === 2 ? TIER.HIGH : TIER.MIDDLE;
                const buildingSize = size || (width === 2 ? "2x2" : "1x1");
                let buildingNames = getBuildingsForZone(cellType, tier, buildingSize);
                if (buildingNames.length === 0) {
                    const otherTier = tier === TIER.HIGH ? TIER.MIDDLE : TIER.HIGH;
                    buildingNames = getBuildingsForZone(cellType, otherTier, buildingSize);
                }

                if (buildingNames.length === 0) {
                    console.warn(`No building found for construction at (${x},${y})`);
                    continue;
                }

                // 랜덤 건물 선택
                const buildingName = buildingNames[Math.floor(Math.random() * buildingNames.length)];
                const building = buildingPrefabs[buildingName];

                if (building) {
                    // 공사 대기열에 추가 (새로 시작)
                    queueConstruction(x, y, cellType, width || 1, depth || 1, building, buildingName);
                }
            }
        }
    }

    // 건물 모델 로드 및 크기 측정 (targetSize: "1x1" 또는 "2x2")
    async function loadBuildingPrefab(path, name, targetSize = "1x1", explicitWidth = null, explicitDepth = null) {
        return new Promise((resolve, reject) => {
            loader.load(path, (gltf) => {
                const prefab = gltf.scene;
                prefab.updateMatrixWorld(true);

                // 바운딩 박스로 크기 측정
                const box = new THREE.Box3().setFromObject(prefab);
                const size = new THREE.Vector3();
                box.getSize(size);

                // 명시적 크기가 있으면 사용, 없으면 targetSize에서 파싱
                const tileWidth = explicitWidth || (targetSize === "2x2" ? 2 : 1);
                const tileDepth = explicitDepth || (targetSize === "2x2" ? 2 : 1);
                const maxTileSizeX = TILE_SIZE * tileWidth;
                const maxTileSizeZ = TILE_SIZE * tileDepth;

                // X와 Z를 각각 독립적으로 스케일링하여 타일을 완전히 채움 (틈새 방지)
                const scaleX = maxTileSizeX / size.x;
                const scaleZ = maxTileSizeZ / size.z;
                const scaleY = Math.min(scaleX, scaleZ);  // Y는 비율 유지
                const scale = scaleY;  // 저장용

                prefab.scale.set(scaleX, scaleY, scaleZ);
                prefab.updateMatrixWorld(true);

                // 스케일 적용 후 크기 재측정
                const scaledBox = new THREE.Box3().setFromObject(prefab);
                const scaledSize = new THREE.Vector3();
                scaledBox.getSize(scaledSize);

                // 바운딩 박스 중심 계산 (XZ 평면에서 원점 오프셋)
                const center = new THREE.Vector3();
                scaledBox.getCenter(center);

                // 그림자 설정 및 머티리얼을 조명 반응형으로 강제 교체
                prefab.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // 모든 material을 MeshLambertMaterial로 강제 교체 (조명 반응)
                        const convertMaterial = (mat) => {
                            return new THREE.MeshLambertMaterial({
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                                map: mat.map || null,
                                transparent: mat.transparent || false,
                                opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                            });
                        };

                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(m => convertMaterial(m));
                        } else {
                            child.material = convertMaterial(child.material);
                        }
                    }
                });

                buildingPrefabs[name] = {
                    prefab,
                    width: tileWidth,
                    depth: tileDepth,
                    height: scaledSize.y,
                    minY: scaledBox.min.y,
                    centerOffsetX: center.x,  // 중심 오프셋 저장
                    centerOffsetZ: center.z,
                    scale: scale,
                    size: targetSize,  // "1x1" 또는 "2x2"
                    animations: gltf.animations || [],  // GLB 애니메이션 저장
                };

                console.log(`Building loaded: ${name}, size: ${tileWidth}x${tileDepth} tiles`);
                resolve();
            }, undefined, reject);
        });
    }

    // 모든 건물 모델 로드 (새 구조)
    async function loadAllBuildingModels() {
        const loadPromises = [];
        let totalModels = 0;

        // 새 civil building 모델 로드
        for (const [zoneType, tiers] of Object.entries(CIVIL_BUILDING_MODELS)) {
            for (const [tier, sizes] of Object.entries(tiers)) {
                for (const [size, models] of Object.entries(sizes)) {
                    for (const modelName of models) {
                        const path = getCivilBuildingPath(zoneType, parseInt(tier), size, modelName);
                        const uniqueName = `${zoneType}_${tier}_${size}_${modelName}`;
                        totalModels++;
                        console.log(`Loading: ${uniqueName} from ${path}`);
                        loadPromises.push(
                            loadBuildingPrefab(path, uniqueName, size)
                                .catch(err => console.warn(`Failed to load ${uniqueName} from ${path}:`, err))
                        );
                    }
                }
            }
        }

        console.log(`Attempting to load ${totalModels} civil building models...`);
        await Promise.all(loadPromises);

        // 빈틈 채움용 1x1 기본 건물 생성 (각 구역별) - 폴백용
        createFillerBuilding('Filler_Residential', 0x8fbc8f, 1.2);  // 연두색
        createFillerBuilding('Filler_Commercial', 0x6495ed, 1.5);   // 파란색
        createFillerBuilding('Filler_Industrial', 0xdaa520, 1.0);   // 갈색

        // 공공시설 모델 로드 (학교, 경찰서, 소방서, 공원)
        await loadPublicBuildingModels();

        console.log('All building models loaded:', Object.keys(buildingPrefabs).length, 'models');
        console.log('Loaded prefabs:', Object.keys(buildingPrefabs));
    }

    // 공공시설 프리팹 저장소 (별도 관리)
    const publicBuildingPrefabs = {};

    // 공공시설 모델 정보 (효과 범위 및 땅값 보너스 포함)
    const PUBLIC_BUILDING_MODELS = {
        school: {
            path: '/models/school/Group 7.glb',
            size: '2x2',
            tileWidth: 2,   // 명시적 타일 크기
            tileDepth: 2,
            cost: 4000,
            name: '학교',
            icon: '🏫',
            description: '시민들에게 교육 서비스를 제공하여 중류층 전환율을 높입니다.',
            maintenanceCost: 80,   // 시간당 운영비
            powerUsage: 20,        // 전력 소모량 (kW)
            effectRadius: 10,      // 효과 범위 (타일)
            landValueBonus: 150,   // 중심부 땅값 상승
            effectColor: 0x44cc66  // 초록색 (이로운 효과)
        },
        police: {
            path: '/models/PoliceStations/Group 5.glb',
            size: '1x1',
            tileWidth: 1,
            tileDepth: 1,
            cost: 3000,
            name: '경찰서',
            icon: '🚔',
            description: '범죄를 예방하고 치안을 유지하여 시민들의 안전을 보장합니다.',
            maintenanceCost: 60,   // 시간당 운영비
            powerUsage: 12,        // 전력 소모량 (kW)
            effectRadius: 8,
            landValueBonus: 100,
            effectColor: 0x44cc66  // 초록색 (이로운 효과)
        },
        fire: {
            path: '/models/FireStation/Group 6.glb',
            size: '1x1',
            tileWidth: 1,
            tileDepth: 1,
            cost: 3000,
            name: '소방서',
            icon: '🚒',
            description: '화재 예방 및 신속한 진압으로 건물과 시민을 보호합니다.',
            maintenanceCost: 50,   // 시간당 운영비
            powerUsage: 15,        // 전력 소모량 (kW)
            effectRadius: 8,
            landValueBonus: 100,
            effectColor: 0x44cc66  // 초록색 (이로운 효과)
        },
        park: {
            paths: [
                '/models/Park/2x2/Group.glb',
                '/models/Park/2x2/Group 1.glb',
                '/models/Park/2x2/Group 2.glb',
                '/models/Park/2x2/Group 3.glb',
                '/models/Park/2x2/Group 4.glb',
            ],
            size: '2x2',
            tileWidth: 2,
            tileDepth: 2,
            cost: 1000,
            name: '공원',
            icon: '🌳',
            description: '녹지 공간을 제공하여 시민들의 행복도를 높입니다.',
            maintenanceCost: 20,   // 시간당 운영비
            powerUsage: 5,         // 전력 소모량 (kW) - 조명 등
            effectRadius: 5,
            landValueBonus: 80,
            effectColor: 0x44cc66  // 초록색 (이로운 효과)
        },
        hospital: {
            path: '/models/Hospital/Hospital 2x2.glb',
            size: '2x2',
            tileWidth: 2,
            tileDepth: 2,
            cost: 6000,
            name: '병원',
            icon: '🏥',
            description: '시민들에게 의료 서비스를 제공하여 상류층 전환율을 높이고 행복도를 증가시킵니다.',
            maintenanceCost: 100,   // 시간당 운영비
            powerUsage: 30,         // 전력 소모량 (kW)
            effectRadius: 12,       // 효과 범위 (타일)
            landValueBonus: 200,    // 중심부 땅값 상승
            effectColor: 0x44cc66   // 초록색 (이로운 효과)
        },
        // 발전소 (전력 공급)
        powerplant_coal: {
            path: '/models/school/Group 7.glb',  // 임시 2x2 모델 (학교 모델 사용)
            size: '2x2',
            tileWidth: 2,
            tileDepth: 2,
            cost: 5000,
            name: '화력 발전소',
            icon: '🏭',
            description: '석탄을 태워 전기를 생산합니다. 대용량이지만 오염을 유발합니다.',
            maintenanceCost: 100,
            powerOutput: 500,       // 전력 생산량
            effectRadius: 15,       // 전력 공급 범위
            landValueBonus: -50,    // 오염으로 땅값 하락
            effectColor: 0xffcc00,  // 노란색 (전력)
            isPowerPlant: true
        },
        powerplant_wind: {
            path: '/models/turbin1.glb',
            size: '3x4',
            tileWidth: 4,           // 모델 스케일 (가로)
            tileDepth: 4,           // 모델 스케일 (세로)
            displayWidth: 3,        // 실제 배치 크기 (짧은 면)
            displayDepth: 4,        // 실제 배치 크기 (긴 면)
            cost: 3000,
            name: '풍력 발전소',
            icon: '💨',
            description: '바람으로 전기를 생산합니다. 친환경이지만 소용량입니다.',
            maintenanceCost: 30,
            powerOutput: 100,
            effectRadius: 8,
            landValueBonus: 20,     // 친환경으로 땅값 소폭 상승
            effectColor: 0xffcc00,
            isPowerPlant: true,
            rotationY: Math.PI / 2 * 3, // 270도 회전
            modelOffsetX: 0,
            modelOffsetZ: 0 ,
            shortSideFacesRoad: true,  // 짧은 면(3칸)이 항상 도로를 향하도록
            // 확장 시스템
            expandable: true,           // 확장 가능 여부
            maxExpansions: 5,           // 최대 확장 개수
            expansionSize: { width: 3, depth: 1 },  // 확장 터빈 크기 (3x1)
            expansionCost: 2000,        // 확장당 비용
            expansionPowerOutput: 80,   // 확장당 추가 전력
            expansionMaintenanceCost: 20 // 확장당 추가 유지비
        },
        // 태양광 발전소 (3x4) - 풍력 발전소와 동일한 배치 방식
        powerplant_solar: {
            path: '/models/solar_panel2.glb',
            size: '3x4',
            tileWidth: 4,           // 모델 스케일 (가로) - 풍력과 동일하게 4x4 정사각
            tileDepth: 3.3,           // 모델 스케일 (세로) - 풍력과 동일하게 4x4 정사각
            displayWidth: 3,        // 실제 배치 크기 (짧은 면)
            displayDepth: 4,        // 실제 배치 크기 (긴 면)
            cost: 4000,
            name: '태양광 발전소',
            icon: '☀️',
            description: '태양광으로 전기를 생산합니다. 친환경 중용량 발전소입니다.',
            maintenanceCost: 40,
            powerOutput: 150,
            effectRadius: 10,
            landValueBonus: 30,     // 친환경으로 땅값 상승
            effectColor: 0xffaa00,
            isPowerPlant: true,
            rotationY: Math.PI / 2 * 3, // 270도 회전 - 풍력과 동일
            modelOffsetX: 0,
            modelOffsetZ: 0,
            shortSideFacesRoad: true,  // 짧은 면(3칸)이 항상 도로를 향하도록 - 풍력과 동일
            // 확장 시스템
            expandable: true,           // 확장 가능 여부
            maxExpansions: 5,           // 최대 확장 개수
            expansionSize: { width: 3, depth: 1 },  // 확장 패널 크기 (3x1)
            expansionCost: 2500,        // 확장당 비용
            expansionPowerOutput: 100,  // 확장당 추가 전력
            expansionMaintenanceCost: 25, // 확장당 추가 유지비
            expansionModelPath: '/models/solarpanel_addon.glb'
        },
        // 방파제 인접 수도 시설 (2x3) - 모델은 3x2로 로드 후 270도 회전
        wastewater: {
            path: '/models/wasted_water.glb',
            size: '2x3',
            tileWidth: 6.66,           // 로드 시 3x2로 스케일링
            tileDepth: 2.22,
            displayWidth: 2,        // 실제 배치 크기
            displayDepth: 4,
            cost: 8000,
            name: '하수처리장',
            icon: '🏭',
            description: '도시의 하수를 처리합니다. 방파제 옆 해안가에만 설치할 수 있습니다.',
            maintenanceCost: 100,
            powerUsage: 40,         // 전력 소모량 (kW) - 펌프/처리시설
            waterOutput: 0,
            sewageCapacity: 500,    // 하수 처리 용량
            effectRadius: 0,
            landValueBonus: -50,    // 땅값 하락 (혐오시설)
            effectColor: 0x8B4513,  // 갈색 (하수)
            isWaterFacility: false,
            isSewageFacility: true, // 하수 처리 시설
            requiresBreakwater: true,  // 방파제 인접 필수
            rotationY: Math.PI/2*3, // 180도 회전 보정 (시계방향)
            modelOffsetZ: -1.3,       // 모델 오프셋 (방파제 쪽으로 1.5칸)
            modelOffsetX: 0.12         // 좌우 오프셋
        },
        water_pump_coast: {
            path: '/models/water_pump.glb',
            size: '2x3',
            tileWidth: 6.66,           // 로드 시 3x2로 스케일링
            tileDepth: 2.22,
            displayWidth: 2,        // 실제 배치 크기
            displayDepth: 4,
            cost: 6000,
            name: '해안 취수장',
            icon: '🌊',
            description: '바닷물을 담수화하여 수도를 공급합니다. 방파제 옆 해안가에만 설치할 수 있습니다.',
            maintenanceCost: 80,
            powerUsage: 35,         // 전력 소모량 (kW) - 담수화 펌프
            waterOutput: 600,       // 대용량 수도 생산
            effectRadius: 15,
            landValueBonus: 20,
            effectColor: 0x87CEEB,  // 하늘색 (수도)
            isWaterFacility: true,
            requiresBreakwater: true,  // 방파제 인접 필수
            rotationY: Math.PI/2*3, // 180도 회전 보정 (시계방향)
            modelOffsetZ: -1.3,
            modelOffsetX: 0.12         // 좌우 오프셋
        }
    };

    // 공공시설 모델 로드
    async function loadPublicBuildingModels() {
        const loadPromises = [];

        for (const [type, config] of Object.entries(PUBLIC_BUILDING_MODELS)) {
            // 명시적 타일 크기 사용
            const tileW = config.tileWidth || (config.size === '2x2' ? 2 : 1);
            const tileD = config.tileDepth || (config.size === '2x2' ? 2 : 1);

            if (config.paths) {
                // 여러 모델이 있는 경우 (공원)
                config.paths.forEach((path, index) => {
                    const prefabName = `public_${type}_${index}`;
                    loadPromises.push(
                        loadBuildingPrefab(path, prefabName, config.size, tileW, tileD)
                            .then(() => {
                                if (!publicBuildingPrefabs[type]) {
                                    publicBuildingPrefabs[type] = [];
                                }
                                publicBuildingPrefabs[type].push(prefabName);
                            })
                            .catch(err => console.warn(`Failed to load ${prefabName}:`, err))
                    );
                });
            } else {
                // 단일 모델
                const prefabName = `public_${type}`;
                loadPromises.push(
                    loadBuildingPrefab(config.path, prefabName, config.size, tileW, tileD)
                        .then(() => {
                            publicBuildingPrefabs[type] = [prefabName];
                            // 모델 자체에 회전/스케일 적용
                            if (buildingPrefabs[prefabName]) {
                                const prefabData = buildingPrefabs[prefabName];

                                // 스케일 적용
                                if (config.scale) {
                                    prefabData.prefab.scale.multiplyScalar(config.scale);
                                }

                                // 회전 적용 (rotationY 속성이 있으면)
                                if (config.rotationY) {
                                    prefabData.prefab.rotation.y = config.rotationY;
                                }

                                prefabData.prefab.updateMatrixWorld(true);
                                // 변환 후 바운딩 박스 재계산
                                const box = new THREE.Box3().setFromObject(prefabData.prefab);
                                const center = new THREE.Vector3();
                                box.getCenter(center);
                                prefabData.centerOffsetX = center.x;
                                prefabData.centerOffsetZ = center.z;
                                prefabData.minY = box.min.y;
                                // displayWidth/displayDepth가 있으면 사용 (회전된 실제 배치 크기)
                                if (config.displayWidth && config.displayDepth) {
                                    prefabData.width = config.displayWidth;
                                    prefabData.depth = config.displayDepth;
                                }
                            }
                        })
                        .catch(err => console.warn(`Failed to load ${prefabName}:`, err))
                );
            }
        }

        await Promise.all(loadPromises);
    }

    // 공공시설 랜덤 프리팹 선택
    function getRandomPublicPrefab(type) {
        const prefabs = publicBuildingPrefabs[type];
        if (!prefabs || prefabs.length === 0) return null;
        const prefabName = prefabs[Math.floor(Math.random() * prefabs.length)];
        return buildingPrefabs[prefabName];
    }

    // 공공시설 첫 번째 프리팹 가져오기 (미리보기용)
    function getFirstPublicPrefab(type) {
        const prefabs = publicBuildingPrefabs[type];
        if (!prefabs || prefabs.length === 0) return null;
        return buildingPrefabs[prefabs[0]];
    }

    /* =========================================================
     * BUILDING PLACEMENT PREVIEW
     * 설치 모드에서 마우스 위치에 미리보기 건물 표시
     * ========================================================= */
    const buildingPreviewGroup = new THREE.Group();
    buildingPreviewGroup.visible = false;
    let currentPreviewBuilding = null;
    let currentPreviewType = null;

    // 부드러운 프리뷰 이동을 위한 변수
    const previewTargetPos = new THREE.Vector3();
    const previewCurrentPos = new THREE.Vector3();
    let previewInitialized = false;
    const PREVIEW_LERP_SPEED = 0.25;  // 보간 속도 (0~1, 높을수록 빠름)

    // 미리보기용 흰색 반투명 머티리얼
    const previewMaterialWhite = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,
    });

    // 배치 가능 시 초록색, 불가능 시 빨간색
    const previewMaterialValid = new THREE.MeshStandardMaterial({
        color: 0x44ff66,
        transparent: true,
        opacity: 0.6,
    });

    const previewMaterialInvalid = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        transparent: true,
        opacity: 0.6,
    });

    // 풍력발전기 확장 프리뷰 그룹
    const expansionPreviewGroup = new THREE.Group();
    expansionPreviewGroup.visible = false;
    let expansionPreviewMeshes = [];

    // 확장 프리뷰 표시
    function showExpansionPreview(building, slotNum) {
        if (!building) return;

        const config = PUBLIC_BUILDING_MODELS['powerplant_wind'];
        const expSize = config.expansionSize || { width: 3, depth: 1 };
        const roadSide = building.roadSide || 'bottom';
        const x = building.x;
        const y = building.y;

        console.log('[확장 프리뷰] roadSide:', roadSide, 'building:', { x, y, width: building.width, depth: building.depth, roadSide: building.roadSide });

        // 도로 방향에 따라 메인 건물의 깊이(확장 방향) 결정
        const isVerticalRoad = (roadSide === 'left' || roadSide === 'right');
        const mainLength = isVerticalRoad ? (building.width || 4) : (building.depth || 4);

        // 기존 확장 개수 (slotNum - 1까지는 이미 확장됨)
        const existingExpansions = building.expansions || 0;

        // 기존 프리뷰 메쉬 제거
        expansionPreviewMeshes.forEach(mesh => {
            expansionPreviewGroup.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
        });
        expansionPreviewMeshes = [];

        // slotNum번째 확장 위치 계산
        const prevExpansionDepth = (slotNum - 1) * expSize.depth;
        let expX = x, expY = y;

        // 터빈이 바라보는 방향의 반대쪽(뒤쪽)으로 확장
        switch (roadSide) {
            case 'bottom':  // 도로가 아래 → 터빈이 남쪽을 봄 → 북쪽(뒤)으로 확장
                expY = y - expSize.depth - prevExpansionDepth;
                break;
            case 'top':     // 도로가 위 → 터빈이 북쪽을 봄 → 남쪽(뒤)으로 확장
                expY = y + mainLength + prevExpansionDepth;
                break;
            case 'left':    // 도로가 왼쪽 → 터빈이 서쪽을 봄 → 동쪽(뒤)으로 확장
                expX = x + mainLength + prevExpansionDepth;
                break;
            case 'right':   // 도로가 오른쪽 → 터빈이 동쪽을 봄 → 서쪽(뒤)으로 확장
                expX = x - expSize.depth - prevExpansionDepth;
                break;
        }

        const width = isVerticalRoad ? expSize.depth : expSize.width;
        const depth = isVerticalRoad ? expSize.width : expSize.depth;

        // 공간 확인
        let canExpand = true;
        for (let dx = 0; dx < width && canExpand; dx++) {
            for (let dy = 0; dy < depth && canExpand; dy++) {
                const checkX = expX + dx;
                const checkY = expY + dy;
                if (!inBounds(checkX, checkY)) {
                    canExpand = false;
                    break;
                }
                const cell = grid[checkY]?.[checkX];
                if (!cell || cell.type !== 'grass') {
                    canExpand = false;
                    break;
                }
            }
        }

        // 프리뷰 박스 생성
        const material = canExpand ? previewMaterialValid.clone() : previewMaterialInvalid.clone();
        const geometry = new THREE.BoxGeometry(width * TILE_SIZE, 0.3, depth * TILE_SIZE);
        const mesh = new THREE.Mesh(geometry, material);

        const worldX = ORIGIN_X + expX + width / 2;
        const worldZ = ORIGIN_Z + expY + depth / 2;
        mesh.position.set(worldX, 0.2, worldZ);

        expansionPreviewGroup.add(mesh);
        expansionPreviewMeshes.push(mesh);
        expansionPreviewGroup.visible = true;
    }

    // 확장 프리뷰 숨기기
    function hideExpansionPreview() {
        expansionPreviewGroup.visible = false;
    }

    // 미리보기 건물 업데이트
    function updateBuildingPreview(type, gx, gy) {
        // 타입이 변경되면 미리보기 건물 재생성
        if (type !== currentPreviewType) {
            // 기존 미리보기 제거
            while (buildingPreviewGroup.children.length > 0) {
                buildingPreviewGroup.remove(buildingPreviewGroup.children[0]);
            }

            const prefabData = getFirstPublicPrefab(type);
            if (!prefabData || !prefabData.prefab) {
                buildingPreviewGroup.visible = false;
                currentPreviewBuilding = null;
                currentPreviewType = null;
                return;
            }

            // 프리팹 복제
            currentPreviewBuilding = prefabData.prefab.clone();
            currentPreviewBuilding.userData.prefabData = prefabData;

            // 프리뷰 모델 위치/회전 리셋 (그룹에서 제어하므로)
            currentPreviewBuilding.position.set(0, 0, 0);
            currentPreviewBuilding.rotation.set(0, 0, 0);

            // 흰색 머티리얼 적용
            currentPreviewBuilding.traverse((child) => {
                if (child.isMesh) {
                    child.material = previewMaterialWhite.clone();
                    child.castShadow = false;
                    child.receiveShadow = false;
                }
            });

            buildingPreviewGroup.add(currentPreviewBuilding);
            currentPreviewType = type;
        }

        if (!currentPreviewBuilding) return;

        const prefabData = currentPreviewBuilding.userData.prefabData;
        // displayWidth/displayDepth 우선 사용 (하수처리장, 취수장 등 회전된 건물)
        const modelConfig = PUBLIC_BUILDING_MODELS[type];
        const originalWidth = modelConfig?.displayWidth || prefabData.width || 2;
        const originalDepth = modelConfig?.displayDepth || prefabData.depth || 2;
        let width = originalWidth;
        let depth = originalDepth;
        let swapPositionOffset = { x: 0, z: 0 };

        // shortSideFacesRoad: 도로를 바라봤을 때 오른쪽 코너에 앵커 배치
        let shortSideRotation = 0;
        let anchorOffset = { x: width / 2, z: depth / 2 };  // 기본값: 중심

        if (modelConfig?.shortSideFacesRoad && width !== depth) {
            const swappedRoad = detectRoadSideWithCount(gx, gy, depth, width);
            const originalRoad = detectRoadSideWithCount(gx, gy, width, depth);

            if (swappedRoad.side === 'vertical' && swappedRoad.hasRoad) {
                // 세로 도로 (좌/우) - footprint 90도 회전
                [width, depth] = [depth, width];

                if (swappedRoad.direction === 'left') {
                    // 도로가 왼쪽: 서쪽을 바라봄 (뒤로=+X, 왼쪽=-Z, 오른쪽=+Z)
                    anchorOffset = { x: 0 + 0.5, z: 0 - 0.5 + 1 };
                    shortSideRotation = Math.PI / 2;
                } else {
                    // 도로가 오른쪽: 동쪽을 바라봄 (뒤로=-X, 왼쪽=+Z, 오른쪽=-Z)
                    anchorOffset = { x: width - 0.5, z: depth + 0.5 - 1 };
                    shortSideRotation = -Math.PI / 2;
                }
            } else if (originalRoad.hasRoad) {
                // 가로 도로 (상/하) - footprint 유지, 180도 추가 회전
                if (originalRoad.direction === 'top') {
                    // 도로가 위쪽: 북쪽을 바라봄 (뒤로=+Z, 왼쪽=-X)
                    anchorOffset = { x: width - 0.5, z: 0 + 0.5 };
                    shortSideRotation = 0;  // 180 + 180 = 0
                } else {
                    // 도로가 아래쪽: 남쪽을 바라봄 (뒤로=-Z, 왼쪽=+X)
                    anchorOffset = { x: 0 + 0.5, z: depth - 0.5 };
                    shortSideRotation = Math.PI;  // 0 + 180
                }
            }
        }

        // 목표 위치 설정
        const worldX = ORIGIN_X + gx + anchorOffset.x;
        const worldZ = ORIGIN_Z + gy + anchorOffset.z;

        // 모델 오프셋 적용
        const modelOffsetX = modelConfig?.modelOffsetX || 0;
        const modelOffsetZ = modelConfig?.modelOffsetZ || 0;

        // 센터 오프셋 (앵커 배치일 때는 적용하지 않음)
        const useAnchor = modelConfig?.shortSideFacesRoad && width !== depth;
        const centerOffsetX = useAnchor ? 0 : (prefabData.centerOffsetX || 0);
        const centerOffsetZ = useAnchor ? 0 : (prefabData.centerOffsetZ || 0);

        previewTargetPos.set(
            worldX - centerOffsetX + modelOffsetX,
            -(prefabData.minY || 0),
            worldZ - centerOffsetZ + modelOffsetZ
        );

        // 첫 번째 위치 설정 시 즉시 이동
        if (!previewInitialized) {
            previewCurrentPos.copy(previewTargetPos);
            buildingPreviewGroup.position.copy(previewCurrentPos);
            previewInitialized = true;
        }

        // 도로 방향으로 자동 회전
        if (modelConfig?.shortSideFacesRoad) {
            // shortSideFacesRoad: 모델 기본 회전 + 도로 방향 회전
            const baseRotation = modelConfig?.rotationY || 0;
            buildingPreviewGroup.rotation.y = baseRotation + shortSideRotation;
        } else if (modelConfig?.requiresBreakwater) {
            // 방파제 인접 시설: 모델 기본 회전 적용 (실제 설치와 동일)
            buildingPreviewGroup.rotation.y = modelConfig?.rotationY || 0;
        } else {
            const roadDirection = findNearestRoadDirection(gx, gy, width, depth);
            buildingPreviewGroup.rotation.y = roadDirection;
        }

        // 배치 가능 여부 확인하고 색상 변경
        const canPlace = canPlacePublicBuilding(gx, gy, type);
        const targetMaterial = canPlace ? previewMaterialValid : previewMaterialInvalid;

        currentPreviewBuilding.traverse((child) => {
            if (child.isMesh) {
                child.material = targetMaterial.clone();
            }
        });

        buildingPreviewGroup.visible = true;
    }

    // 미리보기 숨기기
    function hideBuildingPreview() {
        buildingPreviewGroup.visible = false;
        previewInitialized = false;  // 다음 표시 시 즉시 이동하도록 초기화
    }

    // ===== 방파제 프리뷰 시스템 =====
    const breakwaterPreviewGroup = new THREE.Group();
    breakwaterPreviewGroup.visible = false;
    let breakwaterPreviewInitialized = false;
    let lastBreakwaterX = -1;
    let lastBreakwaterY = -1;

    // 방파제 프리뷰 생성 (한 번만)
    function createBreakwaterPreview() {
        // 기존 프리뷰 제거
        while (breakwaterPreviewGroup.children.length > 0) {
            breakwaterPreviewGroup.remove(breakwaterPreviewGroup.children[0]);
        }

        // 2x2 프리뷰 박스
        const previewGeometry = new THREE.BoxGeometry(2, 0.3, 2);
        const previewMesh = new THREE.Mesh(previewGeometry, previewMaterialValid.clone());
        previewMesh.position.set(0, 0.15, 0);
        breakwaterPreviewGroup.add(previewMesh);
    }
    createBreakwaterPreview();
    // breakwaterPreviewGroup은 scene 초기화 후 추가됨 (아래 scene.add 섹션 참조)

    // 방파제 프리뷰 업데이트 (2x2 격자로 스냅)
    function updateBreakwaterPreview(gx, gy) {
        // 2x2 격자로 스냅
        const snapped = snapToBreakwaterGrid(gx, gy);
        lastBreakwaterX = snapped.x;
        lastBreakwaterY = snapped.y;

        const canPlace = canPlaceBreakwater(snapped.x, snapped.y);

        // 색상 업데이트
        const targetMaterial = canPlace ? previewMaterialValid : previewMaterialInvalid;
        breakwaterPreviewGroup.children.forEach(child => {
            if (child.isMesh) {
                child.material = targetMaterial.clone();
            }
        });

        // 위치 설정 (2x2 중심: snapped.x+1, snapped.y+1 지점)
        const worldX = (ORIGIN_X + snapped.x + 1) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + snapped.y + 1) * TILE_SIZE;
        breakwaterPreviewGroup.position.set(worldX, -0.15, worldZ);  // 높이 오프셋 적용

        breakwaterPreviewGroup.visible = true;
        breakwaterPreviewInitialized = true;
    }

    // 방파제 프리뷰 숨기기
    function hideBreakwaterPreview() {
        breakwaterPreviewGroup.visible = false;
        breakwaterPreviewInitialized = false;
        lastBreakwaterX = -1;
        lastBreakwaterY = -1;
    }

    // 프리뷰 부드러운 이동 업데이트 (매 프레임 호출)
    function updateBuildingPreviewPosition() {
        if (!buildingPreviewGroup.visible || !previewInitialized) return;

        // 현재 위치를 목표 위치로 부드럽게 보간
        previewCurrentPos.lerp(previewTargetPos, PREVIEW_LERP_SPEED);
        buildingPreviewGroup.position.copy(previewCurrentPos);
    }

    // 배치 가능 여부 확인 (비용 제외) - 이유 반환 버전
    function canPlacePublicBuildingWithReason(gx, gy, type) {
        const prefabData = getFirstPublicPrefab(type);
        if (!prefabData) return { canPlace: false, reason: '건물 데이터를 찾을 수 없습니다.' };

        const modelDef = PUBLIC_BUILDING_MODELS[type];
        // displayWidth/displayDepth 우선 사용 (하수처리장, 취수장 등 회전된 건물)
        let width = modelDef?.displayWidth || prefabData.width || 2;
        let depth = modelDef?.displayDepth || prefabData.depth || 2;

        // shortSideFacesRoad: 짧은 면이 항상 도로를 향하도록 (동서남북 모두)
        if (modelDef?.shortSideFacesRoad && width !== depth) {
            // 두 방향 모두에서 도로 감지 (각 footprint 기준)
            const originalRoad = detectRoadSideWithCount(gx, gy, width, depth);
            const swappedRoad = detectRoadSideWithCount(gx, gy, depth, width);

            // 원본(3x4): 짧은면(3)이 상/하 향함 - horizontal 도로에 적합
            // 스왑(4x3): 짧은면(3)이 좌/우 향함 - vertical 도로에 적합

            // 어느 방향이 짧은 면을 도로에 향하게 하는지 결정
            const originalShortFacesRoad = originalRoad.side === 'horizontal' && originalRoad.hasRoad;
            const swappedShortFacesRoad = swappedRoad.side === 'vertical' && swappedRoad.hasRoad;

            if (!originalShortFacesRoad && !swappedShortFacesRoad) {
                // 짧은 면이 도로를 향하지 않으면 일반 도로 인접 확인
                const originalAdjacent = isBuildingAdjacentToRoad(gx, gy, width, depth);
                const swappedAdjacent = isBuildingAdjacentToRoad(gx, gy, depth, width);
                if (!originalAdjacent && !swappedAdjacent) {
                    return { canPlace: false, reason: '도로에 인접해야 합니다.' };
                }
            } else if (swappedShortFacesRoad) {
                // 스왑하면 짧은 면이 도로를 향함
                [width, depth] = [depth, width];
            }
            // originalShortFacesRoad이면 원본 유지
        }

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const cx = gx + dx;
                const cy = gy + dy;
                if (cx < 0 || cx >= GRID_W || cy < 0 || cy >= GRID_H) {
                    return { canPlace: false, reason: '맵 경계를 벗어납니다.' };
                }
                const cell = grid[cx][cy];

                // 셀 타입별 상세 이유
                if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD ||
                    cell === CELL.ROAD_4LANE || cell === CELL.LOCKED_ROAD_4LANE) {
                    return { canPlace: false, reason: '도로 위에는 건설할 수 없습니다.' };
                }
                if (cell === CELL.WATER) {
                    return { canPlace: false, reason: '수로 위에는 건설할 수 없습니다.' };
                }
                if (cell === CELL.BRIDGE) {
                    return { canPlace: false, reason: '다리 위에는 건설할 수 없습니다.' };
                }
                if (cell === CELL.SEA || cell === CELL.BEACH) {
                    return { canPlace: false, reason: '바다/해변에는 건설할 수 없습니다.' };
                }
                if (cell === CELL.BREAKWATER) {
                    return { canPlace: false, reason: '방파제 위에는 건설할 수 없습니다.' };
                }
                if (cell !== CELL.EMPTY && cell !== CELL.ZONE_RESIDENTIAL &&
                    cell !== CELL.ZONE_COMMERCIAL && cell !== CELL.ZONE_INDUSTRIAL) {
                    return { canPlace: false, reason: '이 지형에는 건설할 수 없습니다.' };
                }

                // 이미 배치된 공공시설 확인 (참조 타일 포함)
                const key = `${cx},${cy}`;
                if (placedPublicBuildings.has(key)) {
                    return { canPlace: false, reason: '이미 공공시설이 있습니다.' };
                }

                // 확장 터빈/패널 위에는 건설 불가
                if (findExpansionTurbineAt && findExpansionTurbineAt(cx, cy)) {
                    return { canPlace: false, reason: '확장 터빈 위에는 건설할 수 없습니다.' };
                }
                if (findExpansionSolarAt && findExpansionSolarAt(cx, cy)) {
                    return { canPlace: false, reason: '확장 패널 위에는 건설할 수 없습니다.' };
                }
            }
        }

        // 방파제 인접 필수 건물 체크 (2x4 건물의 2 너비 면이 방파제에 인접해야 함)
        if (modelDef && modelDef.requiresBreakwater) {
            const hasBreakwaterAdjacent = checkBreakwaterAdjacent(gx, gy, width, depth);
            if (!hasBreakwaterAdjacent) {
                return { canPlace: false, reason: '방파제에 인접해야 합니다.' };
            }
        } else if (!modelDef?.shortSideFacesRoad) {
            // shortSideFacesRoad 건물은 위에서 이미 도로 인접 확인됨
            if (!isBuildingAdjacentToRoad(gx, gy, width, depth)) {
                return { canPlace: false, reason: '도로에 인접해야 합니다.' };
            }
        }

        return { canPlace: true, reason: null };
    }

    // 배치 가능 여부 확인 (비용 제외) - 간단한 boolean 반환
    function canPlacePublicBuilding(gx, gy, type) {
        return canPlacePublicBuildingWithReason(gx, gy, type).canPlace;
    }

    // 건물 영역이 도로에 인접해 있는지 확인 (width x depth 크기)
    function isBuildingAdjacentToRoad(gx, gy, width, depth) {
        // 건물의 모든 외곽 타일 체크
        for (let dx = 0; dx < width; dx++) {
            // 위쪽
            if (gy > 0 && isRoad(gx + dx, gy - 1)) return true;
            // 아래쪽
            if (gy + depth < GRID_H && isRoad(gx + dx, gy + depth)) return true;
        }
        for (let dy = 0; dy < depth; dy++) {
            // 왼쪽
            if (gx > 0 && isRoad(gx - 1, gy + dy)) return true;
            // 오른쪽
            if (gx + width < GRID_W && isRoad(gx + width, gy + dy)) return true;
        }
        return false;
    }

    // 방파제 인접 여부 확인 (2x4 건물의 2칸 너비 면만 방파제와 인접해야 함)
    function checkBreakwaterAdjacent(gx, gy, width, depth) {
        // 2칸 너비 면(상/하)만 방파제 인접 허용 (4칸 깊이 면은 불허)
        const directions = [
            { side: 'top', check: () => {
                // 상단 (y-1)에 방파제가 있는지 - width 너비만큼 체크
                for (let dx = 0; dx < width; dx++) {
                    const nx = gx + dx;
                    const ny = gy - 1;
                    if (ny >= 0 && grid[nx] && grid[nx][ny] === CELL.BREAKWATER) {
                        return true;
                    }
                }
                return false;
            }},
            { side: 'bottom', check: () => {
                // 하단 (y+depth)에 방파제가 있는지 - width 너비만큼 체크
                for (let dx = 0; dx < width; dx++) {
                    const nx = gx + dx;
                    const ny = gy + depth;
                    if (ny < GRID_H && grid[nx] && grid[nx][ny] === CELL.BREAKWATER) {
                        return true;
                    }
                }
                return false;
            }}
            // 좌/우 방향은 체크하지 않음 (4칸 깊이 면은 방파제 인접 불허)
        ];

        // 상단 또는 하단이 방파제에 인접하면 true
        for (const dir of directions) {
            if (dir.check()) {
                return true;
            }
        }

        return false;
    }

    /* =========================================================
     * SERVICE EFFECT VISUALIZATION
     * 서비스 시설 설치 모드에서 땅값 상승 효과 범위 표시
     * 원형으로 중심에서 멀어질수록 옅어지는 효과
     * ========================================================= */
    const serviceEffectGroup = new THREE.Group();
    serviceEffectGroup.visible = false;

    // 원형 효과 메시 생성 (단색 원)
    function createCircularEffectMesh(centerX, centerY, radius, color, opacity = 0.5, buildingWidth = 2, buildingDepth = 2) {
        const maxRadius = radius * TILE_SIZE;

        // 단일 원형 메시 생성
        const geometry = new THREE.CircleGeometry(maxRadius, 64);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: opacity,
            side: THREE.DoubleSide,
            depthWrite: false,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;  // 바닥에 눕히기

        // 건물 크기에 따라 중심 계산
        mesh.position.set(
            ORIGIN_X + centerX + buildingWidth / 2,
            0.05,  // 약간 띄우기
            ORIGIN_Z + centerY + buildingDepth / 2
        );

        return mesh;
    }

    // 건물 타입에서 크기 파싱 (예: '1x1' -> {width: 1, depth: 1})
    function parseBuildingSize(sizeStr) {
        if (!sizeStr) return { width: 2, depth: 2 };
        const parts = sizeStr.split('x');
        return {
            width: parseInt(parts[0]) || 2,
            depth: parseInt(parts[1]) || 2
        };
    }

    // 서비스 타입별 효과 표시
    function showServiceEffects(serviceType) {
        // 기존 효과 제거
        clearServiceEffects();

        const config = PUBLIC_BUILDING_MODELS[serviceType];
        if (!config) return;

        const effectColor = config.effectColor;
        const effectRadius = config.effectRadius;

        // 해당 타입의 모든 배치된 시설 효과 표시
        placedPublicBuildings.forEach((building, key) => {
            if (building.ref) return;  // 참조는 스킵
            if (building.type !== serviceType) return;

            // 저장된 건물 크기 사용
            const bWidth = building.width || 2;
            const bDepth = building.depth || 2;

            const mesh = createCircularEffectMesh(
                building.x,
                building.y,
                effectRadius,
                effectColor,
                0.4,
                bWidth,
                bDepth
            );
            mesh.userData.isServiceEffect = true;
            serviceEffectGroup.add(mesh);
        });

        serviceEffectGroup.visible = true;
    }

    // 미리보기 위치에 효과 표시 (설치 전 미리보기)
    function showPreviewEffect(serviceType, gx, gy) {
        const config = PUBLIC_BUILDING_MODELS[serviceType];
        if (!config) return;

        // 건물 크기 파싱
        const size = parseBuildingSize(config.size);

        // 미리보기 효과 메시 생성 (더 투명하게)
        const mesh = createCircularEffectMesh(
            gx,
            gy,
            config.effectRadius,
            config.effectColor,
            0.25,  // 미리보기는 더 투명
            size.width,
            size.depth
        );
        mesh.userData.isPreviewEffect = true;
        serviceEffectGroup.add(mesh);
    }

    // 미리보기 효과만 제거
    function clearPreviewEffect() {
        for (let i = serviceEffectGroup.children.length - 1; i >= 0; i--) {
            const child = serviceEffectGroup.children[i];
            if (child.userData.isPreviewEffect) {
                serviceEffectGroup.remove(child);
                // 그룹인 경우 내부 메시들도 정리
                if (child.isGroup) {
                    child.traverse((obj) => {
                        if (obj.isMesh) {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        }
                    });
                } else {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
            }
        }
    }

    // 모든 효과 제거
    function clearServiceEffects() {
        while (serviceEffectGroup.children.length > 0) {
            const child = serviceEffectGroup.children[0];
            serviceEffectGroup.remove(child);
            // 그룹인 경우 내부 메시들도 정리
            if (child.isGroup) {
                child.traverse((obj) => {
                    if (obj.isMesh) {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    }
                });
            } else {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }
        }
        serviceEffectGroup.visible = false;
    }

    // 서비스 효과 업데이트 (미리보기 포함)
    function updateServiceEffectVisualization(serviceType, previewX, previewY) {
        // 기존 효과 제거
        clearServiceEffects();

        const config = PUBLIC_BUILDING_MODELS[serviceType];
        if (!config) return;

        const effectColor = config.effectColor;
        const effectRadius = config.effectRadius;
        const size = parseBuildingSize(config.size);

        // 해당 타입의 모든 배치된 시설 효과 표시
        placedPublicBuildings.forEach((building, key) => {
            if (building.ref) return;
            if (building.type !== serviceType) return;

            // 저장된 건물 크기 사용
            const bWidth = building.width || size.width;
            const bDepth = building.depth || size.depth;

            const mesh = createCircularEffectMesh(
                building.x,
                building.y,
                effectRadius,
                effectColor,
                0.4,
                bWidth,
                bDepth
            );
            mesh.userData.isServiceEffect = true;
            serviceEffectGroup.add(mesh);
        });

        // 미리보기 위치에도 효과 표시
        if (previewX !== undefined && previewY !== undefined) {
            const previewMesh = createCircularEffectMesh(
                previewX,
                previewY,
                effectRadius,
                effectColor,
                0.25,
                size.width,
                size.depth
            );
            previewMesh.userData.isPreviewEffect = true;
            serviceEffectGroup.add(previewMesh);
        }

        serviceEffectGroup.visible = true;
    }

    // 1x1 채움용 건물 생성
    function createFillerBuilding(name, color, height) {
        const geometry = new THREE.BoxGeometry(TILE_SIZE * 0.8, height, TILE_SIZE * 0.8);
        const material = new THREE.MeshStandardMaterial({ color: color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        const prefab = new THREE.Group();
        prefab.add(mesh);
        mesh.position.y = height / 2;

        buildingPrefabs[name] = {
            prefab,
            width: 1,
            depth: 1,
            height: height,
            minY: 0,
            centerOffsetX: 0,
            centerOffsetZ: 0,
            scale: 1,
        };

        console.log(`Filler building created: ${name}, size: 1x1 tiles`);
    }

    // 타일 프리팹 저장소
    const tilePrefabs = {
        grass: null,
        bridge: null,
        beach: null,  // 해변 타일
        road: { straight: null, corner: null, t: null, cross: null },
        road4lane: { straight: null, corner: null, t: null, cross: null, straight_side_full: null, straight_side_single: null, straight_side_single_reversed: null, straight_side_corner: null, straight_side_corner_reversed: null, straight_both_sides: null },
        water: null,  // 수로 타일 (2x2)
        ocean: { edge: null, middle: null },  // 바다 타일 (가장자리/중앙)
        trees: [],  // 나무 프리팹 배열 (trees.010, trees.011)
    };

    // 하위 호환성
    const roadPrefabs = tilePrefabs.road;
    const road4lanePrefabs = tilePrefabs.road4lane;

    // 4차선 도로 원점 추적 (2x2 타일의 좌하단 원점)
    // key: "x,y" (원점 좌표), value: { variant: 'straight'|'corner'|'t'|'cross', rotY: number }
    const road4laneOrigins = new Map();

    const tileMinY = {
        grass: 0,
        bridge: 0,
        beach: 0,  // 해변 타일
        road: { straight: 0, corner: 0, t: 0, cross: 0 },
        road4lane: { straight: 0, corner: 0, t: 0, cross: 0, straight_side_full: 0, straight_side_single: 0, straight_side_single_reversed: 0, straight_side_corner: 0, straight_side_corner_reversed: 0, straight_both_sides: 0 },
        water: 0,  // 수로 타일 (2x2)
        ocean: { edge: 0, middle: 0 },
    };
    const roadMinY = tileMinY.road;

    // 일반 타일 로드 함수
    async function loadTilePrefab(category, key, url) {
        return new Promise((resolve, reject) => {
            loader.load(url, (gltf) => {
                const prefab = gltf.scene;
                prefab.scale.set(1, 1, 1);
                prefab.updateMatrixWorld(true);

                prefab.traverse((child) => {
                    // Light 오브젝트 찾기 (디버그)
                    if (child.name.toLowerCase().includes('light') || child.isLight) {
                        console.log(`[${category}/${key}] Found light object:`, child.name, child.type);
                    }

                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // 모든 material을 MeshLambertMaterial로 강제 교체 (조명 반응)
                        const convertMaterial = (mat) => {
                            return new THREE.MeshLambertMaterial({
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                                map: mat.map || null,
                                transparent: mat.transparent || false,
                                opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                            });
                        };

                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(m => convertMaterial(m));
                        } else {
                            child.material = convertMaterial(child.material);
                        }
                    }
                });

                const box0 = new THREE.Box3().setFromObject(prefab);
                const size0 = new THREE.Vector3();
                box0.getSize(size0);

                // 4차선 도로는 2x2 타일에 맞게 스케일, 나머지는 1x1 타일
                const targetSize = (category === 'road4lane') ? TILE_SIZE * 2 : TILE_SIZE;
                const s = targetSize / Math.max(size0.x, size0.z);
                prefab.scale.setScalar(s);
                prefab.updateMatrixWorld(true);

                const box = new THREE.Box3().setFromObject(prefab);

                if (key) {
                    tilePrefabs[category][key] = prefab;
                    tileMinY[category][key] = box.min.y;
                    // 도로 센터 오프셋 계산
                    if (roadCenterOffset[key]) {
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        roadCenterOffset[key].set(center.x, 0, center.z);
                    }
                    // 4차선 도로 센터 오프셋 계산
                    if (road4laneCenterOffset[key]) {
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        road4laneCenterOffset[key].set(center.x, 0, center.z);
                    }
                } else {
                    tilePrefabs[category] = prefab;
                    tileMinY[category] = box.min.y;
                }

                resolve();
            }, undefined, (err) => {
                console.warn(`Failed to load tile: ${category}/${key || 'base'}`, err);
                resolve(); // 실패해도 계속 진행
            });
        });
    }

    // 수로 2x2 모델 오프셋
    let waterCenterOffset = new THREE.Vector3();
    let waterMinY = 0;

    // 수로 2x2 모델 로드 함수
    async function loadWater2x2Model() {
        return new Promise((resolve) => {
            loader.load(TILE_MODELS.water, (gltf) => {
                const prefab = gltf.scene;
                prefab.scale.set(1, 1, 1);
                prefab.updateMatrixWorld(true);

                prefab.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // MeshLambertMaterial로 변환
                        const convertMaterial = (mat) => {
                            return new THREE.MeshLambertMaterial({
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                                map: mat.map || null,
                                transparent: mat.transparent || false,
                                opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                            });
                        };
                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(m => convertMaterial(m));
                        } else {
                            child.material = convertMaterial(child.material);
                        }
                    }
                });

                const box0 = new THREE.Box3().setFromObject(prefab);
                const size0 = new THREE.Vector3();
                box0.getSize(size0);

                // 2x2 타일에 맞게 스케일
                const targetSize = TILE_SIZE * 2;
                const s = targetSize / Math.max(size0.x, size0.z);
                prefab.scale.setScalar(s);
                prefab.updateMatrixWorld(true);

                const box = new THREE.Box3().setFromObject(prefab);
                const center = new THREE.Vector3();
                box.getCenter(center);

                waterCenterOffset.set(center.x, 0, center.z);
                waterMinY = box.min.y;
                tilePrefabs.water = prefab;
                tileMinY.water = box.min.y;

                console.log('[Water] 2x2 model loaded, centerOffset:', waterCenterOffset, 'minY:', waterMinY);
                resolve();
            }, undefined, (err) => {
                console.warn('Failed to load water 2x2 model:', err);
                resolve();
            });
        });
    }

    // 도로 전용 로드 함수 (하위 호환)
    async function loadRoadPrefabFitToTile(key, url) {
        return loadTilePrefab('road', key, url);
    }

    // 모든 타일 모델 로딩
    await Promise.all([
        // 잔디 타일
        loadTilePrefab('grass', null, TILE_MODELS.grass),
        // 다리 타일
        loadTilePrefab('bridge', null, TILE_MODELS.bridge),
        // 도로 타일 (2차로)
        loadTilePrefab('road', 'straight', TILE_MODELS.road.straight),
        loadTilePrefab('road', 'corner', TILE_MODELS.road.corner),
        loadTilePrefab('road', 't', TILE_MODELS.road.t),
        loadTilePrefab('road', 'cross', TILE_MODELS.road.cross),
        // 4차로 도로 타일
        loadTilePrefab('road4lane', 'straight', TILE_MODELS.road4lane.straight),
        loadTilePrefab('road4lane', 'corner', TILE_MODELS.road4lane.corner),
        loadTilePrefab('road4lane', 't', TILE_MODELS.road4lane.t),
        loadTilePrefab('road4lane', 'cross', TILE_MODELS.road4lane.cross),
        // 4차선 2차선 연결용 모델
        loadTilePrefab('road4lane', 'straight_side_full', TILE_MODELS.road4lane.straight_side_full),
        loadTilePrefab('road4lane', 'straight_side_single', TILE_MODELS.road4lane.straight_side_single),
        loadTilePrefab('road4lane', 'straight_side_single_reversed', TILE_MODELS.road4lane.straight_side_single_reversed),
        loadTilePrefab('road4lane', 'straight_side_corner', TILE_MODELS.road4lane.straight_side_corner),
        loadTilePrefab('road4lane', 'straight_side_corner_reversed', TILE_MODELS.road4lane.straight_side_corner_reversed),
        loadTilePrefab('road4lane', 'straight_both_sides', TILE_MODELS.road4lane.straight_both_sides),
        // 수로 타일 (2x2) - 별도 로드
        loadWater2x2Model(),
        // 해변/바다 타일
        loadTilePrefab('beach', null, TILE_MODELS.beach),
        loadTilePrefab('ocean', 'edge', TILE_MODELS.ocean.edge),
        loadTilePrefab('ocean', 'middle', TILE_MODELS.ocean.middle),
    ]);

    // 나무 모델 로딩 (별도 처리 - 배열에 저장)
    async function loadTreePrefabs() {
        const treePromises = TILE_MODELS.trees.map((url, index) => {
            return new Promise((resolve) => {
                loader.load(url, (gltf) => {
                    const prefab = gltf.scene;
                    // 나무 스케일 조정 (타일 크기에 맞게)
                    prefab.scale.setScalar(0.8);  // 나무 크기 조정
                    prefab.updateMatrixWorld(true);

                    prefab.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            // Lambert 재질로 변환
                            const convertMaterial = (mat) => {
                                return new THREE.MeshLambertMaterial({
                                    color: mat.color ? mat.color.clone() : new THREE.Color(0x228B22),
                                    map: mat.map || null,
                                    transparent: mat.transparent || false,
                                    opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                    side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                                });
                            };
                            if (Array.isArray(child.material)) {
                                child.material = child.material.map(m => convertMaterial(m));
                            } else {
                                child.material = convertMaterial(child.material);
                            }
                        }
                    });

                    tilePrefabs.trees[index] = prefab;
                    console.log(`[Trees] Loaded tree model ${index}: ${url}`);
                    resolve();
                }, undefined, (err) => {
                    console.warn(`[Trees] Failed to load tree: ${url}`, err);
                    resolve();
                });
            });
        });
        await Promise.all(treePromises);
        console.log(`[Trees] All tree models loaded: ${tilePrefabs.trees.filter(t => t).length}/${TILE_MODELS.trees.length}`);
    }

    // 나무 모델 로딩 실행
    await loadTreePrefabs();

    /* =========================================================
     * DIRECTION & ROAD VARIANTS
     * ========================================================= */
    const DIR = {
        N: { dx: 0, dy: -1, bit: 1 },
        E: { dx: 1, dy: 0,  bit: 2 },
        S: { dx: 0, dy: 1,  bit: 4 },
        W: { dx: -1,dy: 0,  bit: 8 },
    };

    function inBounds(x, y) {
        return x >= 0 && y >= 0 && x < GRID_W && y < GRID_H;
    }

    function isAnyRoad(x, y) {
        if (!inBounds(x, y)) return false;
        return isRoad(x, y);
    }

    function getRoadMask(x, y) {
        if (!isAnyRoad(x, y)) return 0;
        let m = 0;
        if (isAnyRoad(x + DIR.N.dx, y + DIR.N.dy)) m |= DIR.N.bit;
        if (isAnyRoad(x + DIR.E.dx, y + DIR.E.dy)) m |= DIR.E.bit;
        if (isAnyRoad(x + DIR.S.dx, y + DIR.S.dy)) m |= DIR.S.bit;
        if (isAnyRoad(x + DIR.W.dx, y + DIR.W.dy)) m |= DIR.W.bit;
        return m;
    }

    function pickRoadVariant(mask) {
        const count =
            ((mask & 1) ? 1 : 0) +
            ((mask & 2) ? 1 : 0) +
            ((mask & 4) ? 1 : 0) +
            ((mask & 8) ? 1 : 0);

        if (count <= 1) {
            const rot = (mask === 2 || mask === 8) ? Math.PI : Math.PI / 2;
            return { key: "straight", rotY: rot };
        }
        if (count === 4) return { key: "cross", rotY: 0 };
        if (count === 3) {
            // T자: 180도 회전 적용
            if (!(mask & 4)) return { key: "t", rotY: Math.PI };      // 남쪽 없음
            if (!(mask & 2)) return { key: "t", rotY: -Math.PI / 2 }; // 동쪽 없음
            if (!(mask & 1)) return { key: "t", rotY: 0 };            // 북쪽 없음
            if (!(mask & 8)) return { key: "t", rotY: Math.PI / 2 };  // 서쪽 없음
        }
        if (count === 2) {
            if (mask === 10) return { key: "straight", rotY: 0 };
            if (mask === 5) return { key: "straight", rotY: Math.PI / 2 };
            // 커브: N=1, E=2, S=4, W=8
            if (mask === 3)  return { key:"corner", rotY: 0 };           // N+E
            if (mask === 6)  return { key:"corner", rotY: -Math.PI/2 };  // S+E
            if (mask === 12) return { key:"corner", rotY: Math.PI };     // S+W
            if (mask === 9)  return { key:"corner", rotY: Math.PI/2 };   // N+W
        }
        return { key: "straight", rotY: 0 };
    }

    // 수로용 변형 선택 (직선 90도 추가 회전, 커브 반대)
    function pickWaterVariant(mask) {
        const count =
            ((mask & 1) ? 1 : 0) +
            ((mask & 2) ? 1 : 0) +
            ((mask & 4) ? 1 : 0) +
            ((mask & 8) ? 1 : 0);

        if (count <= 1) {
            // 수로 직선: 90도 추가 회전
            const rot = (mask === 2 || mask === 8) ? Math.PI / 2 : 0;
            return { key: "straight", rotY: rot };
        }
        if (count === 4) return { key: "cross", rotY: 0 };
        if (count === 3) {
            // 수로 T자: 180도 회전 적용
            if (!(mask & 4)) return { key: "t", rotY: Math.PI / 2 };   // 남쪽 없음
            if (!(mask & 2)) return { key: "t", rotY: Math.PI };       // 동쪽 없음
            if (!(mask & 1)) return { key: "t", rotY: -Math.PI / 2 };  // 북쪽 없음
            if (!(mask & 8)) return { key: "t", rotY: 0 };             // 서쪽 없음
        }
        if (count === 2) {
            // 수로 직선: 90도 추가 회전
            if (mask === 10) return { key: "straight", rotY: Math.PI / 2 };
            if (mask === 5) return { key: "straight", rotY: 0 };
            // 수로 커브 (원본)
            if (mask === 9)  return { key:"corner", rotY: Math.PI };
            if (mask === 12) return { key:"corner", rotY: -Math.PI/2 };
            if (mask === 6)  return { key:"corner", rotY: 0 };
            if (mask === 3)  return { key:"corner", rotY: Math.PI/2 };
        }
        return { key: "straight", rotY: Math.PI / 2 };
    }

    /* =========================================================
     * THREE.JS SETUP
     * ========================================================= */
    const scene = new THREE.Scene();

    // ===== SKYBOX SYSTEM (낮/일출일몰/밤 3단계 블렌딩) =====
    const cubeTextureLoader = new THREE.CubeTextureLoader();
    const skyboxPath = '/textures/ExtractedSkybox/';

    // 낮 스카이박스 (SunlessCirruscover4k)
    const daySkybox = cubeTextureLoader.load([
        skyboxPath + 'SunlessCirruscover4k_px.png',
        skyboxPath + 'SunlessCirruscover4k_nx.png',
        skyboxPath + 'SunlessCirruscover4k_py.png',
        skyboxPath + 'SunlessCirruscover4k_ny.png',
        skyboxPath + 'SunlessCirruscover4k_pz.png',
        skyboxPath + 'SunlessCirruscover4k_nz.png',
    ]);

    // 일출/일몰 스카이박스 (CloudedSunGlow4k)
    const sunsetSkybox = cubeTextureLoader.load([
        skyboxPath + 'CloudedSunGlow4k_px.png',
        skyboxPath + 'CloudedSunGlow4k_nx.png',
        skyboxPath + 'CloudedSunGlow4k_py.png',
        skyboxPath + 'CloudedSunGlow4k_ny.png',
        skyboxPath + 'CloudedSunGlow4k_pz.png',
        skyboxPath + 'CloudedSunGlow4k_nz.png',
    ]);

    // 밤 스카이박스 (CoriolisNight4k)
    const nightSkybox = cubeTextureLoader.load([
        skyboxPath + 'CoriolisNight4k_px.png',
        skyboxPath + 'CoriolisNight4k_nx.png',
        skyboxPath + 'CoriolisNight4k_py.png',
        skyboxPath + 'CoriolisNight4k_ny.png',
        skyboxPath + 'CoriolisNight4k_pz.png',
        skyboxPath + 'CoriolisNight4k_nz.png',
    ]);

    // 커스텀 스카이박스 셰이더 (3개 큐브맵 블렌딩: 낮 ↔ 일출/일몰 ↔ 밤)
    const skyboxBlendShader = {
        uniforms: {
            tCubeDay: { value: daySkybox },
            tCubeSunset: { value: sunsetSkybox },
            tCubeNight: { value: nightSkybox },
            tBlendDaySunset: { value: 0.0 },  // 0 = 낮, 1 = 일출/일몰
            tBlendSunsetNight: { value: 0.0 } // 0 = 일출/일몰, 1 = 밤
        },
        vertexShader: `
            varying vec3 vWorldDirection;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldDirection = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                gl_Position.z = gl_Position.w;
            }
        `,
        fragmentShader: `
            uniform samplerCube tCubeDay;
            uniform samplerCube tCubeSunset;
            uniform samplerCube tCubeNight;
            uniform float tBlendDaySunset;
            uniform float tBlendSunsetNight;
            varying vec3 vWorldDirection;

            void main() {
                vec3 direction = normalize(vWorldDirection);

                vec4 dayColor = textureCube(tCubeDay, direction);
                vec4 sunsetColor = textureCube(tCubeSunset, direction);
                vec4 nightColor = textureCube(tCubeNight, direction);

                // 3단계 블렌딩: 낮 → 일몰 → 밤
                // tBlendDaySunset: 낮(0) ↔ 일출/일몰(1)
                // tBlendSunsetNight: 일출/일몰(0) ↔ 밤(1)
                vec4 daySunsetMix = mix(dayColor, sunsetColor, tBlendDaySunset);
                vec4 finalColor = mix(daySunsetMix, nightColor, tBlendSunsetNight);

                gl_FragColor = finalColor;
            }
        `
    };

    // 스카이박스 메쉬 생성
    const skyboxGeometry = new THREE.BoxGeometry(10000, 10000, 10000);
    const skyboxMaterial = new THREE.ShaderMaterial({
        uniforms: skyboxBlendShader.uniforms,
        vertexShader: skyboxBlendShader.vertexShader,
        fragmentShader: skyboxBlendShader.fragmentShader,
        side: THREE.BackSide,
        depthWrite: false
    });
    const skyboxMesh = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
    scene.add(skyboxMesh);

    // 초기 환경맵 설정 (건물/차량 반사용)
    scene.environment = daySkybox;

    // 스카이박스 블렌드 상태
    let skyboxBlendDaySunset = 0;     // 0 = 낮, 1 = 일몰
    let skyboxBlendSunsetNight = 0;   // 0 = 일몰, 1 = 밤
    let targetBlendDaySunset = 0;
    let targetBlendSunsetNight = 0;

    // Three.quarks 파티클 렌더러 초기화
    const batchRenderer = new BatchedParticleRenderer();
    scene.add(batchRenderer);

    // 파티클 애니메이션용 Clock
    const particleClock = new THREE.Clock();

    // GLB 모델 애니메이션용 (풍력 발전소 등)
    const animationClock = new THREE.Clock();
    const activeAnimationMixers = [];  // AnimationMixer 배열
    const windTurbinePropellers = [];  // 풍력발전기 프로펠러 수동 회전용

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // Tone Mapping - 화사한 룩
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;  // 더 밝게

    // 그림자 렌더링 활성화 (향상된 설정)
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // 부드러운 그림자

    // 원근 투영 카메라 설정 (Perspective)
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE.PerspectiveCamera(65, aspect, 0.1, 500);
    // 초기 위치
    const CAMERA_START = { x: 50, y: 50, z: 50 };
    const CAMERA_END = { x: 25, y: 25, z: 25 };
    camera.position.set(CAMERA_START.x, CAMERA_START.y, CAMERA_START.z);
    camera.updateProjectionMatrix();

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 0.1;   // 최소 거리 (가까이)
    controls.maxDistance = 150;   // 최대 거리 (멀리)
    controls.enableZoom = false;  // 기본 줌 비활성화, 커스텀 줌 사용
    controls.enablePan = false;   // 기본 팬 비활성화, 커스텀 팬 사용
    controls.panSpeed = 0.8;
    controls.rotateSpeed = 0.5;
    controls.target.set(0, 0, 0);
    controls.enabled = false; // 애니메이션 중 컨트롤 비활성화

    // 카메라 각도 제한 (minPolarAngle은 updateCameraPolarAngle에서 동적으로 조절)
    controls.minPolarAngle = 10 * Math.PI / 180;  // 초기 최소 각도 (10도 - 동적 조절됨)
    controls.maxPolarAngle = 89 * Math.PI / 180; // 최대 각도 (89도)

    // 마우스 버튼 설정: 좌클릭=회전, 우클릭=커스텀 팬
    controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: null  // 커스텀 핸들링
    };
    // 터치 제스처 설정
    controls.touches = {
        ONE: THREE.TOUCH.ROTATE,
        TWO: THREE.TOUCH.DOLLY_PAN
    };
    controls.update();

    // ===== 커스텀 카메라 이동 (지면 기준) - 우클릭 =====
    let isRightDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    const panSensitivity = 0.002;  // 감도 낮춤
    let isPanEnabled = true;  // 건설 모드에서 비활성화용

    renderer.domElement.addEventListener('mousedown', (e) => {
        if (e.button === 2 && !cameraIntroActive && isPanEnabled) {  // 우클릭
            isRightDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
    });

    // 카메라 패닝용 재사용 벡터 (매 이벤트마다 new 방지)
    const _panCameraDir = new THREE.Vector3();
    const _panForward = new THREE.Vector3();
    const _panRight = new THREE.Vector3();
    const _panOffset = new THREE.Vector3();
    const _panUpVec = new THREE.Vector3(0, 1, 0);

    renderer.domElement.addEventListener('mousemove', (e) => {
        if (!isRightDragging || !controls.enabled || !isPanEnabled) return;

        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;

        // 카메라의 수평 방향 벡터 계산 (Y축 회전만 고려) - 재사용 벡터
        camera.getWorldDirection(_panCameraDir);

        // 지면에 투영된 전방 벡터 (Y=0) - 재사용 벡터
        _panForward.set(_panCameraDir.x, 0, _panCameraDir.z).normalize();
        // 오른쪽 벡터 (전방과 Y축의 외적) - 재사용 벡터
        _panRight.crossVectors(_panUpVec, _panForward).normalize();

        // 현재 카메라 거리에 따른 이동 속도 조절 (멀수록 빠르게)
        const cameraDistance = camera.position.distanceTo(controls.target);
        const zoomFactor = cameraDistance / 20;  // 거리 기준 속도 조절
        const speedFactor = zoomFactor * panSensitivity * 10;

        // 마우스 드래그 방향과 같은 방향으로 이동 (반전)
        const moveX = deltaX * speedFactor;
        const moveZ = deltaY * speedFactor;

        // 지면 기준으로 이동 (오른쪽/왼쪽 + 전방/후방) - 재사용 벡터
        _panOffset.set(0, 0, 0);
        _panOffset.addScaledVector(_panRight, moveX);
        _panOffset.addScaledVector(_panForward, moveZ);

        camera.position.add(_panOffset);
        controls.target.add(_panOffset);
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
        if (e.button === 2) {
            isRightDragging = false;
        }
    });

    renderer.domElement.addEventListener('mouseleave', () => {
        isRightDragging = false;
    });

    // 우클릭 컨텍스트 메뉴 방지
    renderer.domElement.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });

    // ===== 그래픽 품질 설정 =====
    const GRAPHICS_SETTINGS = {
        bloomEnabled: true,         // Bloom 효과 활성화 (false시 GPU 부하 감소)
        bloomResolutionScale: 0.35, // Bloom 해상도 (0.5→0.35 최적화)
        tiltShiftEnabled: true,     // 틸트-시프트 미니어처 효과
        shadowMapEnabled: true,     // 그림자 (renderer.shadowMap)
    };

    // 그래픽 품질 토글 함수 (개발자 패널/설정에서 호출)
    window.toggleBloom = function(enabled) {
        GRAPHICS_SETTINGS.bloomEnabled = enabled;
        bloomPass.enabled = enabled;
        console.log(`[Graphics] Bloom: ${enabled ? 'ON' : 'OFF'}`);
    };

    window.toggleTiltShift = function(enabled) {
        GRAPHICS_SETTINGS.tiltShiftEnabled = enabled;
        tiltShiftPass.enabled = enabled;
        console.log(`[Graphics] TiltShift: ${enabled ? 'ON' : 'OFF'}`);
    };

    // ===== POST-PROCESSING 설정 =====
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // Bloom 효과 (빛 번짐) - 야간 조명/네온 효과용
    // 해상도를 더 낮춰 성능 최적화 (0.5→0.35)
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(
            Math.floor(window.innerWidth * GRAPHICS_SETTINGS.bloomResolutionScale),
            Math.floor(window.innerHeight * GRAPHICS_SETTINGS.bloomResolutionScale)
        ),
        0.25,   // strength - 블룸 강도 (0.3→0.25 최적화)
        0.3,    // radius - 블룸 반경 (0.4→0.3 최적화)
        0.9     // threshold - 밝기 임계값 (0.85→0.9 더 밝은 부분만)
    );
    bloomPass.enabled = GRAPHICS_SETTINGS.bloomEnabled;
    composer.addPass(bloomPass);

    // 색상 보정 패스 (채도, 밝기, 대비 향상)
    const colorCorrectionPass = new ShaderPass(ColorCorrectionShader);
    composer.addPass(colorCorrectionPass);

    // 틸트-시프트 패스 (미니어처 효과)
    const tiltShiftPass = new ShaderPass(TiltShiftShader);
    tiltShiftPass.enabled = GRAPHICS_SETTINGS.tiltShiftEnabled;
    composer.addPass(tiltShiftPass);

    // Output Pass (최종 출력)
    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // 블룸 설정을 시간대별로 조절하기 위한 변수
    let currentBloomStrength = 0.25;
    let targetBloomStrength = 0.25;

    // ===== 안개 효과 (대기 원근감) =====
    // 낮: 연한 하늘색 안개, 밤: 짙은 파란 안개
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.008);  // 지수 안개

    // 커스텀 부드러운 휠 줌 (원근 카메라용 - 카메라 거리 조절)
    let targetCameraDistance = camera.position.distanceTo(controls.target);
    renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();

        // 원근 카메라 줌 (카메라 거리 조절)
        const zoomSpeed = 3;  // 줌 속도
        const delta = e.deltaY > 0 ? 1 : -1;  // 스크롤 방향 (위로=확대=가까이)
        const MIN_ZOOM_DISTANCE = 0.1;  // 최소 거리 하드 리밋
        targetCameraDistance = Math.max(
            MIN_ZOOM_DISTANCE,
            Math.min(controls.maxDistance, targetCameraDistance + delta * zoomSpeed)
        );
    }, { passive: false });

    // 부드러운 줌 애니메이션 (원근 카메라용)
    function updateSmoothZoom() {
        const currentDistance = camera.position.distanceTo(controls.target);
        const diff = targetCameraDistance - currentDistance;
        if (Math.abs(diff) > 0.01) {
            // 카메라를 타겟 방향으로 이동
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            const newDistance = currentDistance + diff * 0.1;  // 보간 속도
            camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
        }

        // 틸트-시프트 효과 업데이트 (가까울수록 강해짐)
        const zoomLevel = 1 - (currentDistance - controls.minDistance) / (controls.maxDistance - controls.minDistance);
        updateTiltShiftEffect(zoomLevel);

        // 카메라 각도 제한 업데이트 (줌인 시 수직 방지)
        updateCameraPolarAngle(currentDistance);
    }

    // 나침반 회전 업데이트 (카메라 방위각 기반)
    const compassRose = document.getElementById('compass-rose');
    function updateCompass() {
        if (!compassRose || !controls) return;
        // OrbitControls의 방위각 (azimuthal angle) 가져오기
        const azimuth = controls.getAzimuthalAngle();
        // 라디안을 도(degree)로 변환하여 회전 적용
        // 카메라가 북쪽을 향할 때 나침반 N이 위를 향하도록
        const rotationDeg = azimuth * (180 / Math.PI);
        compassRose.style.transform = `rotate(${rotationDeg}deg)`;
    }

    // 카메라 거리에 따른 동적 polar angle 제한 (최대 줌인 시 수직 방지)
    function updateCameraPolarAngle(cameraDistance) {
        const MIN_DISTANCE_FOR_ANGLE = 0.5;   // 이 거리 이하에서 각도 제한 시작
        const MAX_DISTANCE_FOR_ANGLE = 10.0;  // 이 거리 이상에서 각도 제한 없음
        const MIN_POLAR_CLOSE = 60 * Math.PI / 180;  // 가까울 때 최소 polar angle (60도)
        const MIN_POLAR_FAR = 10 * Math.PI / 180;    // 멀 때 최소 polar angle (10도)

        if (cameraDistance <= MAX_DISTANCE_FOR_ANGLE) {
            // 10에서 0.5로 갈수록 최소 각도가 10도에서 60도로 증가
            const t = Math.max(0, Math.min(1, (MAX_DISTANCE_FOR_ANGLE - cameraDistance) / (MAX_DISTANCE_FOR_ANGLE - MIN_DISTANCE_FOR_ANGLE)));
            const dynamicMinPolar = MIN_POLAR_FAR + t * (MIN_POLAR_CLOSE - MIN_POLAR_FAR);
            controls.minPolarAngle = dynamicMinPolar;
        } else {
            controls.minPolarAngle = MIN_POLAR_FAR;
        }
    }

    // 틸트-시프트 (미니어처) 효과 업데이트
    // 줌 레벨이 높을수록(가까울수록) 블러가 진해짐
    function updateTiltShiftEffect(zoomLevel) {
        const BLUR_THRESHOLD = 0.3;  // 이 줌 레벨 이하일 때만 블러 적용
        const MAX_BLUR = 0.35;       // 최대 블러 강도

        let blurStrength = 0;
        let focusRange = 0.5;

        if (zoomLevel <= BLUR_THRESHOLD) {
            // 줌아웃할수록 블러 강해짐 (미니어처 효과)
            const normalized = 1 - (zoomLevel / BLUR_THRESHOLD);  // 0~1 (0.3에서 0, 0에서 1)
            blurStrength = normalized * MAX_BLUR;
            focusRange = 0.5 - normalized * 0.2;  // 멀어질수록 초점 범위 좁아짐
            tiltShiftPass.uniforms.focusCenter.value = 0.5;  // 중앙 초점
        } else {
            // 줌인하면 블러 없음
            blurStrength = 0;
            focusRange = 0.5;
            tiltShiftPass.uniforms.focusCenter.value = 0.5;
        }

        tiltShiftPass.uniforms.blurAmount.value = blurStrength;
        tiltShiftPass.uniforms.focusRange.value = focusRange;
    }

    // 카메라 줌인 애니메이션
    let cameraIntroActive = false;
    let cameraIntroStart = 0;
    let cameraRestoredFromSave = false;  // 저장된 카메라 상태가 복원되었는지 여부
    const CAMERA_INTRO_DURATION = 2000; // 2초

    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    function startCameraIntro() {
        cameraIntroActive = true;
        cameraIntroStart = performance.now();
    }

    function updateCameraIntro() {
        if (!cameraIntroActive) return;

        const elapsed = performance.now() - cameraIntroStart;
        const progress = Math.min(elapsed / CAMERA_INTRO_DURATION, 1);
        const eased = easeOutCubic(progress);

        // 위치 애니메이션 (원근 카메라)
        camera.position.x = CAMERA_START.x + (CAMERA_END.x - CAMERA_START.x) * eased;
        camera.position.y = CAMERA_START.y + (CAMERA_END.y - CAMERA_START.y) * eased;
        camera.position.z = CAMERA_START.z + (CAMERA_END.z - CAMERA_START.z) * eased;

        if (progress >= 1) {
            cameraIntroActive = false;
            controls.enabled = true; // 애니메이션 끝나면 컨트롤 활성화
            // 카메라 거리를 현재 거리로 동기화
            targetCameraDistance = camera.position.distanceTo(controls.target);
        }
    }

    // 카메라 이동 제한 함수 (맵 범위 내, 땅 위)
    function clampCameraPosition() {
        // 맵 범위 계산 (여유 공간 포함)
        const mapPadding = 5;  // 맵 가장자리 여유
        const halfW = (GRID_W * TILE_SIZE) / 2 + mapPadding;
        const halfH = (GRID_H * TILE_SIZE) / 2 + mapPadding;

        // 카메라 타겟 위치 제한 (맵 범위 내)
        controls.target.x = Math.max(-halfW, Math.min(halfW, controls.target.x));
        controls.target.z = Math.max(-halfH, Math.min(halfH, controls.target.z));
        controls.target.y = Math.max(0, controls.target.y);  // 땅 아래로 못 감

        // 카메라 위치도 땅 아래로 못 가게 (최소 높이 1)
        if (camera.position.y < 1) {
            camera.position.y = 1;
        }

        // 카메라가 맵 범위를 너무 벗어나지 않도록 제한
        const maxCameraDistance = halfW * 2;
        camera.position.x = Math.max(-maxCameraDistance, Math.min(maxCameraDistance, camera.position.x));
        camera.position.z = Math.max(-maxCameraDistance, Math.min(maxCameraDistance, camera.position.z));
    }

    // 조명 시스템 (낮/밤 전환 지원) - 대비감 강화
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);  // 약하게 (그림자 대비 강화)
    scene.add(hemiLight);

    const dir = new THREE.DirectionalLight(0xffffff, 2.5);  // 더 밝게 (그림자 강조)
    dir.position.set(25, 40, 25);  // 낮은 각도로 (그림자 더 길게)

    // 그림자 설정 - 선명한 그림자
    dir.castShadow = true;
    dir.shadow.mapSize.width = 4096;
    dir.shadow.mapSize.height = 4096;
    dir.shadow.camera.near = 0.5;
    dir.shadow.camera.far = 150;
    dir.shadow.camera.left = -60;
    dir.shadow.camera.right = 60;
    dir.shadow.camera.top = 60;
    dir.shadow.camera.bottom = -60;
    dir.shadow.bias = -0.0003;
    dir.shadow.normalBias = 0.005;
    dir.shadow.radius = 1;  // 그림자 선명도 (1=선명)

    scene.add(dir);

    // 밤하늘 ambient light (달빛 효과)
    const nightAmbient = new THREE.AmbientLight(0x4466aa, 0.4);
    scene.add(nightAmbient);

    /* =========================================================
     * TIME CYCLE SYSTEM (12분 = 1일)
     * ========================================================= */
    const TIME_CONFIG = {
        dayDurationMs: 12 * 60 * 1000,  // 12분 = 1일 (720,000ms)
        startHour: 6,                    // 시작 시간 (오전 6시)
    };

    const timeState = {
        gameTime: 6 * 3600,  // 현재 게임 시간 (초 단위, 6:00 AM 시작)
        gameDay: 1,          // 현재 게임 일수
        speed: 1,            // 게임 속도 (0=정지, 1=보통, 2=빠름, 4=매우빠름)
        lastUpdate: Date.now(),
    };

    // 가로등 조명 배열 (밤에 켜짐)
    const streetLights = [];

    // UI 요소
    const clockDisplay = document.getElementById('clockDisplay');
    const dateDisplay = document.getElementById('dateDisplay');
    const btnSpeed1 = document.getElementById('btnSpeed1');
    const btnSpeed2 = document.getElementById('btnSpeed2');
    const btnSpeed3 = document.getElementById('btnSpeed3');
    const btnDayNight = document.getElementById('btnDayNight');

    // 시간을 HH:MM 형식으로 변환
    function formatGameTime(seconds) {
        const hours = Math.floor(seconds / 3600) % 24;
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    }

    // 게임 속도 설정
    function setGameSpeed(speed) {
        timeState.speed = speed;
        timeState.lastUpdate = Date.now();

        // 버튼 상태 업데이트
        if (btnSpeed1) btnSpeed1.classList.toggle('active', speed === 1);
        if (btnSpeed2) btnSpeed2.classList.toggle('active', speed === 2);
        if (btnSpeed3) btnSpeed3.classList.toggle('active', speed === 3);
    }

    // 속도 버튼 이벤트
    if (btnSpeed1) btnSpeed1.addEventListener('click', () => setGameSpeed(1));
    if (btnSpeed2) btnSpeed2.addEventListener('click', () => setGameSpeed(2));
    if (btnSpeed3) btnSpeed3.addEventListener('click', () => setGameSpeed(3));
    if (btnDayNight) btnDayNight.addEventListener('click', toggleDayNight);

    // ===== BGM 시스템 =====
    const btnBgm = document.getElementById('btnBgm');
    const bgmVolumeSlider = document.getElementById('bgmVolume');
    const bgmAudio = new Audio(encodeURI('/mp3/SimCity Soundtrack (Full) [5GCoc893Vt8].mp3'));
    bgmAudio.loop = true;
    bgmAudio.volume = 0;  // 기본 음소거
    let isBgmPlaying = false;

    function toggleBgm() {
        if (isBgmPlaying) {
            bgmAudio.pause();
            isBgmPlaying = false;
            btnBgm.textContent = '🔇';
            btnBgm.classList.remove('playing');
        } else {
            bgmAudio.play().then(() => {
                isBgmPlaying = true;
                btnBgm.textContent = '🔊';
                btnBgm.classList.add('playing');
            }).catch(err => {
                console.warn('BGM 재생 실패:', err);
                toast({ title: 'BGM 오류', desc: '재생 실패 - 페이지를 클릭 후 다시 시도하세요' });
            });
        }
    }

    function setBgmVolume(value) {
        const volume = value / 100;
        bgmAudio.volume = volume;
        // 볼륨 슬라이더 그라데이션 업데이트
        if (bgmVolumeSlider) {
            bgmVolumeSlider.style.background = `linear-gradient(to right, #4caf50 ${value}%, #ddd ${value}%)`;
        }
        // 볼륨에 따라 아이콘 변경
        if (isBgmPlaying) {
            if (volume === 0) {
                btnBgm.textContent = '🔇';
            } else if (volume < 0.5) {
                btnBgm.textContent = '🔉';
            } else {
                btnBgm.textContent = '🔊';
            }
        }
    }

    if (btnBgm) {
        btnBgm.addEventListener('click', toggleBgm);
    }

    if (bgmVolumeSlider) {
        bgmVolumeSlider.addEventListener('input', (e) => setBgmVolume(e.target.value));
        // 초기 그라데이션 설정
        setBgmVolume(bgmVolumeSlider.value);
    }

    // 스페이스바로 BGM 토글
    document.addEventListener('keydown', (e) => {
        // input, textarea에서는 스페이스바 기본 동작 유지
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (e.code === 'Space' || e.key === ' ') {
            e.preventDefault();  // 페이지 스크롤 방지
            toggleBgm();
        }
    });

    // BGM 자동 재생 (첫 사용자 상호작용 후)
    let bgmAutoPlayAttempted = false;
    function tryAutoPlayBgm() {
        if (bgmAutoPlayAttempted || isBgmPlaying) return;
        bgmAutoPlayAttempted = true;

        bgmAudio.play().then(() => {
            isBgmPlaying = true;
            if (btnBgm) {
                btnBgm.textContent = '🔊';
                btnBgm.classList.add('playing');
            }
            console.log('[BGM] Auto-play started');
        }).catch(err => {
            console.warn('[BGM] Auto-play failed:', err);
            bgmAutoPlayAttempted = false;  // 다음 상호작용에서 재시도
        });
    }

    // 첫 사용자 상호작용 시 BGM 자동 재생
    const autoPlayEvents = ['click', 'keydown', 'touchstart'];
    function onFirstInteraction() {
        tryAutoPlayBgm();
        // 한 번만 실행 후 이벤트 리스너 제거
        autoPlayEvents.forEach(evt => {
            document.removeEventListener(evt, onFirstInteraction);
        });
    }
    autoPlayEvents.forEach(evt => {
        document.addEventListener(evt, onFirstInteraction, { once: false });
    });

    // 키프레임 기반 환경 설정 (부드러운 보간)
    // nightAmbientIntensity: 달빛 강도 (밤에 높음, 낮에 낮음)
    // bloomStrength: 0으로 설정 - bloom 대신 실제 PointLight/SpotLight 사용
    const ENV_KEYFRAMES = [
        { hour: 0,  background: 0x2a3545, hemiIntensity: 0.65, hemiSkyColor: 0x6a7590, hemiGroundColor: 0x3a4555, dirIntensity: 0.55, dirColor: 0x99aacc, sunAngle: -20, exposure: 1.15, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x3a4555, fogDensity: 0.006, nightAmbientIntensity: 0.85 },
        { hour: 5,  background: 0x3a4555, hemiIntensity: 0.60, hemiSkyColor: 0x6a7590, hemiGroundColor: 0x3a4555, dirIntensity: 0.50, dirColor: 0x99aacc, sunAngle: -15, exposure: 1.1, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x3a4555, fogDensity: 0.006, nightAmbientIntensity: 0.75 },
        { hour: 6,  background: 0xffa070, hemiIntensity: 0.5, hemiSkyColor: 0xffccaa, hemiGroundColor: 0x665544, dirIntensity: 0.8, dirColor: 0xff8844, sunAngle: 5, exposure: 0.95, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0xffa080, fogDensity: 0.006, nightAmbientIntensity: 0.25 },
        { hour: 8,  background: 0x87ceeb, hemiIntensity: 0.85, hemiSkyColor: 0xaaddff, hemiGroundColor: 0x667755, dirIntensity: 1.8, dirColor: 0xfffaf0, sunAngle: 35, exposure: 1.2, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x87ceeb, fogDensity: 0.004, nightAmbientIntensity: 0.05 },
        { hour: 12, background: 0x9ed8f8, hemiIntensity: 1.0, hemiSkyColor: 0xaaddff, hemiGroundColor: 0x778866, dirIntensity: 2.2, dirColor: 0xffffff, sunAngle: 80, exposure: 1.3, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x9ed8f8, fogDensity: 0.003, nightAmbientIntensity: 0.05 },
        { hour: 16, background: 0x87ceeb, hemiIntensity: 0.85, hemiSkyColor: 0xaaddff, hemiGroundColor: 0x667755, dirIntensity: 1.8, dirColor: 0xfff8e0, sunAngle: 40, exposure: 1.2, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x87ceeb, fogDensity: 0.004, nightAmbientIntensity: 0.05 },
        { hour: 18, background: 0xff9966, hemiIntensity: 0.6, hemiSkyColor: 0xffaa77, hemiGroundColor: 0x554433, dirIntensity: 1.2, dirColor: 0xff6622, sunAngle: 10, exposure: 1.05, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0xcc6644, fogDensity: 0.008, nightAmbientIntensity: 0.15 },
        { hour: 20, background: 0x665566, hemiIntensity: 0.45, hemiSkyColor: 0x665577, hemiGroundColor: 0x554455, dirIntensity: 0.35, dirColor: 0x886688, sunAngle: -10, exposure: 0.95, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x554455, fogDensity: 0.009, nightAmbientIntensity: 0.55 },
        { hour: 22, background: 0x2a3545, hemiIntensity: 0.65, hemiSkyColor: 0x6a7590, hemiGroundColor: 0x3a4555, dirIntensity: 0.55, dirColor: 0x99aacc, sunAngle: -20, exposure: 1.15, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x3a4555, fogDensity: 0.006, nightAmbientIntensity: 0.85 },
        { hour: 24, background: 0x2a3545, hemiIntensity: 0.65, hemiSkyColor: 0x6a7590, hemiGroundColor: 0x3a4555, dirIntensity: 0.55, dirColor: 0x99aacc, sunAngle: -20, exposure: 1.15, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x3a4555, fogDensity: 0.006, nightAmbientIntensity: 0.85 },
    ];

    // 색상 보간 함수
    function lerpColor(color1, color2, t) {
        const c1 = new THREE.Color(color1);
        const c2 = new THREE.Color(color2);
        return c1.lerp(c2, Math.max(0, Math.min(1, t))).getHex();
    }

    // 숫자 보간 함수
    function lerpValue(v1, v2, t) {
        return v1 + (v2 - v1) * t;
    }

    // 키프레임 기반 환경 설정 (부드러운 RGB 보간)
    function getTimeOfDayConfig(hour) {
        // 현재 시간에 해당하는 키프레임 구간 찾기
        let prev = ENV_KEYFRAMES[ENV_KEYFRAMES.length - 2];
        let next = ENV_KEYFRAMES[0];

        for (let i = 0; i < ENV_KEYFRAMES.length - 1; i++) {
            if (hour >= ENV_KEYFRAMES[i].hour && hour < ENV_KEYFRAMES[i + 1].hour) {
                prev = ENV_KEYFRAMES[i];
                next = ENV_KEYFRAMES[i + 1];
                break;
            }
        }

        // 보간 비율 계산
        const duration = next.hour - prev.hour;
        const t = duration > 0 ? (hour - prev.hour) / duration : 0;

        // 모든 값 부드럽게 보간
        return {
            background: lerpColor(prev.background, next.background, t),
            hemiIntensity: lerpValue(prev.hemiIntensity, next.hemiIntensity, t),
            hemiSkyColor: lerpColor(prev.hemiSkyColor, next.hemiSkyColor, t),
            hemiGroundColor: lerpColor(prev.hemiGroundColor, next.hemiGroundColor, t),
            dirIntensity: lerpValue(prev.dirIntensity, next.dirIntensity, t),
            dirColor: lerpColor(prev.dirColor, next.dirColor, t),
            sunAngle: lerpValue(prev.sunAngle, next.sunAngle, t),
            exposure: lerpValue(prev.exposure, next.exposure, t),
            bloomStrength: lerpValue(prev.bloomStrength, next.bloomStrength, t),
            bloomThreshold: lerpValue(prev.bloomThreshold, next.bloomThreshold, t),
            fogColor: lerpColor(prev.fogColor, next.fogColor, t),
            fogDensity: lerpValue(prev.fogDensity, next.fogDensity, t),
            nightAmbientIntensity: lerpValue(prev.nightAmbientIntensity, next.nightAmbientIntensity, t),
        };
    }

    // 환경 업데이트 (시네마틱)
    function updateEnvironment() {
        const hour = (timeState.gameTime / 3600) % 24;
        const config = getTimeOfDayConfig(hour);
        const isNight = hour >= 20 || hour < 5;
        const isStreetLightTime = hour >= 18 || hour < 6;  // 가로등은 18시부터 켜짐

        // ===== SKYBOX 3단계 블렌딩 (낮 ↔ 일출/일몰 ↔ 밤) =====
        // MegaSun(낮), FluffballDay(일출/일몰), CosmicCoolCloud(밤)
        // tBlendDaySunset: 낮(0) ↔ 일출/일몰(1)
        // tBlendSunsetNight: 일출/일몰(0) ↔ 밤(1)

        if (hour >= 7 && hour < 17) {
            // 낮 (07:00 ~ 17:00)
            targetBlendDaySunset = 0;
            targetBlendSunsetNight = 0;
        } else if (hour >= 17 && hour < 18.5) {
            // 낮 → 일몰 전환 (17:00 ~ 18:30)
            targetBlendDaySunset = (hour - 17) / 1.5;  // 0 → 1
            targetBlendSunsetNight = 0;
        } else if (hour >= 18.5 && hour < 20) {
            // 일몰 → 밤 전환 (18:30 ~ 20:00)
            targetBlendDaySunset = 1;
            targetBlendSunsetNight = (hour - 18.5) / 1.5;  // 0 → 1
        } else if (hour >= 20 || hour < 5) {
            // 밤 (20:00 ~ 05:00)
            targetBlendDaySunset = 1;
            targetBlendSunsetNight = 1;
        } else if (hour >= 5 && hour < 6) {
            // 밤 → 일출 전환 (05:00 ~ 06:00)
            targetBlendDaySunset = 1;
            targetBlendSunsetNight = 1 - (hour - 5);  // 1 → 0
        } else {
            // 일출 → 낮 전환 (06:00 ~ 07:00)
            targetBlendDaySunset = 1 - (hour - 6);  // 1 → 0
            targetBlendSunsetNight = 0;
        }

        // 부드러운 블렌드 전환
        skyboxBlendDaySunset += (targetBlendDaySunset - skyboxBlendDaySunset) * 0.02;
        skyboxBlendSunsetNight += (targetBlendSunsetNight - skyboxBlendSunsetNight) * 0.02;

        // 스카이박스 셰이더 블렌드 값 업데이트 (항상 업데이트)
        skyboxMaterial.uniforms.tBlendDaySunset.value = skyboxBlendDaySunset;
        skyboxMaterial.uniforms.tBlendSunsetNight.value = skyboxBlendSunsetNight;

        // Zone 모드가 아닐 때만 스카이박스 표시
        if (!isZoneModeActive) {
            skyboxMesh.visible = true;
        }

        // 환경맵도 현재 상태에 따라 전환 (항상 업데이트)
        if (skyboxBlendSunsetNight > 0.5) {
            scene.environment = nightSkybox;
        } else if (skyboxBlendDaySunset > 0.5) {
            scene.environment = sunsetSkybox;
        } else {
            scene.environment = daySkybox;
        }

        // 태양 위치 계산 (DirectionalLight용)
        const sunAngleRad = THREE.MathUtils.degToRad(config.sunAngle);
        const azimuthRad = THREE.MathUtils.degToRad((hour - 6) * 15);
        const sunDistance = 50;

        // 주변광 (하늘/지면 색상 포함)
        hemiLight.intensity = config.hemiIntensity;
        if (config.hemiSkyColor) hemiLight.color.setHex(config.hemiSkyColor);
        if (config.hemiGroundColor) hemiLight.groundColor.setHex(config.hemiGroundColor);

        // 태양광 (Directional Light)
        dir.intensity = config.dirIntensity;
        dir.color.setHex(config.dirColor);

        // 태양 위치 계산
        dir.position.set(
            Math.cos(azimuthRad) * Math.cos(sunAngleRad) * sunDistance,
            Math.sin(sunAngleRad) * sunDistance,
            Math.sin(azimuthRad) * Math.cos(sunAngleRad) * sunDistance
        );

        // 밤 ambient (달빛 효과 - 부드러운 보간)
        nightAmbient.intensity = config.nightAmbientIntensity;

        // Tone Mapping Exposure (밝기 조절)
        if (config.exposure !== undefined) {
            renderer.toneMappingExposure = config.exposure;
        }

        // Bloom 설정 (부드러운 전환)
        if (config.bloomStrength !== undefined) {
            targetBloomStrength = config.bloomStrength;
        }
        if (config.bloomThreshold !== undefined) {
            bloomPass.threshold = config.bloomThreshold;
        }
        // 부드러운 블룸 전환
        currentBloomStrength += (targetBloomStrength - currentBloomStrength) * 0.05;
        bloomPass.strength = currentBloomStrength;

        // 안개 설정
        if (config.fogColor !== undefined) {
            scene.fog.color.setHex(config.fogColor);
        }
        if (config.fogDensity !== undefined) {
            scene.fog.density = config.fogDensity;
        }

        // 야간 건물 발광 업데이트
        updateBuildingEmissive(isNight);

        // 가로등 조명 업데이트 (18시부터)
        updateStreetLights(isStreetLightTime);

        // 시간대별 오브젝트 색감 적용 (수치 모드 및 배치 모드가 아닐 때만)
        if (!isZoneModeActive && !isPlacementModeActive) {
            updateSceneColorTint(hour, isNight);
        }

        // UI 업데이트
        if (clockDisplay) clockDisplay.textContent = formatGameTime(timeState.gameTime);
        if (dateDisplay) dateDisplay.textContent = i18n.t('game.day', { day: timeState.gameDay });

        // 밤/낮 버튼 아이콘 업데이트
        if (btnDayNight) {
            const isNight = hour >= 20 || hour < 6;
            const icon = btnDayNight.querySelector('.icon');
            const label = btnDayNight.querySelector('.label');
            if (icon) icon.textContent = isNight ? '☀️' : '🌙';
            if (label) label.textContent = isNight ? i18n.t('toolbar.day') : i18n.t('toolbar.night');
        }
    }

    // 가로등 조명 시스템 (최적화: 거리 기반 활성화 + 풀링)
    let lastStreetLightState = null;
    let streetLightsInitialized = false;
    const _slWorldPos = new THREE.Vector3();
    const _slCameraPos = new THREE.Vector3();

    // 최적화 설정
    const STREET_LIGHT_MAX_ACTIVE = 80;      // 최대 활성 라이트 수
    const STREET_LIGHT_RANGE = 30;           // 활성화 거리
    const STREET_LIGHT_UPDATE_INTERVAL = 500; // 업데이트 간격 (ms) - 최적화
    const STREET_LIGHT_CAMERA_THRESHOLD = 4;  // 카메라 이동 감지 임계값

    let lastStreetLightUpdate = 0;
    let lastStreetLightCameraPos = new THREE.Vector3();
    const streetLightPool = [];
    const activeStreetLightMap = new Map();  // index -> poolItem

    function initStreetLightPool() {
        if (streetLightsInitialized) return;
        streetLightsInitialized = true;

        // 풀 생성 (제한된 수의 PointLight)
        for (let i = 0; i < STREET_LIGHT_MAX_ACTIVE; i++) {
            const light = new THREE.PointLight(0xffffaa, 1, 6);
            light.castShadow = false;
            light.visible = false;
            scene.add(light);
            streetLightPool.push({ light, inUse: false, assignedIndex: -1 });
        }
        console.log(`[StreetLight] Pool initialized: ${STREET_LIGHT_MAX_ACTIVE} lights`);
    }

    function getStreetLightFromPool() {
        for (const item of streetLightPool) {
            if (!item.inUse) {
                item.inUse = true;
                return item;
            }
        }
        return null;
    }

    function returnStreetLightToPool(poolItem) {
        if (poolItem) {
            poolItem.inUse = false;
            poolItem.light.visible = false;
            poolItem.assignedIndex = -1;
        }
    }

    function updateStreetLights(isStreetLightTime) {
        if (streetLights.length === 0) return;

        // 풀 초기화
        if (!streetLightsInitialized) {
            initStreetLightPool();
            lastStreetLightCameraPos.copy(camera.position);
        }

        // 낮/밤 전환
        if (lastStreetLightState !== isStreetLightTime) {
            lastStreetLightState = isStreetLightTime;
            if (!isStreetLightTime) {
                // 낮: 모든 라이트 끄기
                activeStreetLightMap.forEach(poolItem => returnStreetLightToPool(poolItem));
                activeStreetLightMap.clear();
                return;
            }
            lastStreetLightUpdate = 0;  // 강제 업데이트
        }

        if (!isStreetLightTime) return;

        // 업데이트 필요 여부 체크
        const now = performance.now();
        const cameraMoved = camera.position.distanceToSquared(lastStreetLightCameraPos) > STREET_LIGHT_CAMERA_THRESHOLD;
        if (!cameraMoved && (now - lastStreetLightUpdate) < STREET_LIGHT_UPDATE_INTERVAL) return;

        lastStreetLightUpdate = now;
        lastStreetLightCameraPos.copy(camera.position);

        // 카메라 근처 가로등 찾기
        const maxDistSq = STREET_LIGHT_RANGE * STREET_LIGHT_RANGE;
        const nearbyLights = [];

        for (let i = 0; i < streetLights.length; i++) {
            const item = streetLights[i];
            if (!item.mesh) continue;
            item.mesh.getWorldPosition(_slWorldPos);
            const distSq = _slWorldPos.distanceToSquared(camera.position);
            if (distSq < maxDistSq) {
                nearbyLights.push({ index: i, distSq, worldPos: _slWorldPos.clone() });
            }
        }

        // 거리순 정렬
        nearbyLights.sort((a, b) => a.distSq - b.distSq);

        // 범위 밖 라이트 비활성화
        const toRemove = [];
        activeStreetLightMap.forEach((poolItem, idx) => {
            if (!nearbyLights.some(n => n.index === idx)) {
                toRemove.push(idx);
            }
        });
        toRemove.forEach(idx => {
            returnStreetLightToPool(activeStreetLightMap.get(idx));
            activeStreetLightMap.delete(idx);
        });

        // 가까운 라이트 활성화
        const maxLights = Math.min(nearbyLights.length, STREET_LIGHT_MAX_ACTIVE);
        for (let i = 0; i < maxLights; i++) {
            const { index, worldPos } = nearbyLights[i];

            if (!activeStreetLightMap.has(index)) {
                const poolItem = getStreetLightFromPool();
                if (poolItem) {
                    poolItem.light.position.copy(worldPos);
                    poolItem.light.position.y += 0.5;
                    poolItem.light.visible = true;
                    poolItem.assignedIndex = index;
                    activeStreetLightMap.set(index, poolItem);
                }
            } else {
                // 위치 업데이트 (도로가 이동했을 수 있음)
                const poolItem = activeStreetLightMap.get(index);
                poolItem.light.position.copy(worldPos);
                poolItem.light.position.y += 0.5;
            }
        }
    }

    // 야간 건물 발광 효과 - 비활성화 (성능 최적화)
    function updateBuildingEmissive(isNight) {
        // 발광 효과 비활성화
    }

    // 시간대별 오브젝트 색감 적용
    let lastColorTintHour = -1;
    const originalObjectColors = new Map();

    function updateSceneColorTint(hour, isNight) {
        // 1시간 단위로만 업데이트 (성능 최적화)
        const hourInt = Math.floor(hour);
        if (hourInt === lastColorTintHour) return;
        lastColorTintHour = hourInt;

        // 시간대별 색조 계산
        let tintColor;
        let tintIntensity;

        if (hour >= 5 && hour < 7) {
            // 일출 - 따뜻한 주황빛
            tintColor = new THREE.Color(0xffddaa);
            tintIntensity = 0.15;
        } else if (hour >= 7 && hour < 17) {
            // 낮 - 자연색
            tintColor = new THREE.Color(0xffffff);
            tintIntensity = 0;
        } else if (hour >= 17 && hour < 20) {
            // 일몰 - 주황/빨간빛
            const t = (hour - 17) / 3;
            tintColor = new THREE.Color().lerpColors(
                new THREE.Color(0xffffff),
                new THREE.Color(0xff8866),
                t
            );
            tintIntensity = t * 0.2;
        } else if (hour >= 20 && hour < 22) {
            // 박명 - 일몰에서 밤으로 부드러운 전환
            const t = (hour - 20) / 2;
            tintColor = new THREE.Color().lerpColors(
                new THREE.Color(0xff8866),
                new THREE.Color(0x6688aa),
                t
            );
            tintIntensity = 0.2 + t * 0.15;
        } else {
            // 밤 - 파란빛
            tintColor = new THREE.Color(0x6688aa);
            tintIntensity = 0.35;
        }

        // 초원, 수로, 건물, 차량에 색조 적용 (지연 참조)
        const getGroups = () => {
            const result = [];
            if (typeof grassGroup !== 'undefined' && grassGroup) result.push(grassGroup);
            if (typeof waterGroup !== 'undefined' && waterGroup) result.push(waterGroup);
            if (typeof buildingGroup !== 'undefined' && buildingGroup) result.push(buildingGroup);
            // 차량 그룹도 포함
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                result.push(trafficManager.vehicleGroup);
            }
            return result;
        };

        const groups = getGroups();
        groups.forEach(group => {
            group.traverse((child) => {
                if (child.isMesh && child.material) {
                    // 폐건물인지 확인 - 폐건물은 색상 변경 안함
                    let parentObj = child;
                    while (parentObj.parent && !parentObj.userData?.isAbandoned) {
                        parentObj = parentObj.parent;
                    }
                    if (parentObj.userData?.isAbandoned) return;

                    const materials = Array.isArray(child.material) ? child.material : [child.material];

                    materials.forEach(mat => {
                        // color 속성이 있는 모든 머티리얼에 적용 (타입 체크 완화)
                        if (!mat.color || typeof mat.color.lerp !== 'function') return;

                        // 원본 색상 저장
                        if (!originalObjectColors.has(mat.uuid)) {
                            originalObjectColors.set(mat.uuid, mat.color.clone());
                        }

                        // 색조 적용
                        if (tintIntensity > 0) {
                            const original = originalObjectColors.get(mat.uuid);
                            mat.color.copy(original).lerp(tintColor, tintIntensity);
                        } else {
                            const original = originalObjectColors.get(mat.uuid);
                            if (original) mat.color.copy(original);
                        }
                    });
                }
            });
        });
    }

    // 시간 진행
    function updateGameTime() {
        const now = Date.now();
        const deltaMs = now - timeState.lastUpdate;
        timeState.lastUpdate = now;

        if (timeState.speed === 0) return;

        // 실제 시간 -> 게임 시간 변환
        // 12분(720초) = 24시간(86400초)
        // 1 실제초 = 120 게임초
        const gameSecondsPerRealMs = 86400 / TIME_CONFIG.dayDurationMs;
        const deltaGameSeconds = deltaMs * gameSecondsPerRealMs * timeState.speed;

        timeState.gameTime += deltaGameSeconds;

        // 하루가 지났으면
        if (timeState.gameTime >= 86400) {
            timeState.gameTime -= 86400;
            timeState.gameDay++;
            // 연령 시스템 업데이트 (매일)
            updateAgeSystem();
        }

        updateEnvironment();
    }

    // ===== 연령 시스템 업데이트 =====
    function updateAgeSystem() {
        if (cityStats.population === 0) return;

        const { ageGroups } = cityStats;
        const totalPop = ageGroups.children + ageGroups.youth + ageGroups.adults + ageGroups.elderly;

        // 총 인구가 0이면 초기화
        if (totalPop === 0 && cityStats.population > 0) {
            initializeAgeDistribution();
            return;
        }

        // 1. 자연 노화 (연령대 전환)
        processAging();

        // 2. 출생 처리
        processBirths();

        // 3. 사망 처리
        processDeaths();

        // 4. 총 인구와 동기화
        syncPopulationWithAgeGroups();

        console.log(`[Age] Day ${timeState.gameDay}: 어린이=${ageGroups.children}, 청년=${ageGroups.youth}, 중년=${ageGroups.adults}, 노인=${ageGroups.elderly}`);
    }

    // 연령 분포 초기화 (처음 인구가 생겼을 때)
    function initializeAgeDistribution() {
        const pop = cityStats.population;
        const dist = AGE_SYSTEM.INITIAL_DISTRIBUTION;

        cityStats.ageGroups.children = Math.round(pop * dist.children);
        cityStats.ageGroups.youth = Math.round(pop * dist.youth);
        cityStats.ageGroups.adults = Math.round(pop * dist.adults);
        cityStats.ageGroups.elderly = Math.round(pop * dist.elderly);

        // 반올림 오차 보정
        const total = cityStats.ageGroups.children + cityStats.ageGroups.youth +
                      cityStats.ageGroups.adults + cityStats.ageGroups.elderly;
        cityStats.ageGroups.adults += (pop - total);

        console.log(`[Age] Initialized: ${JSON.stringify(cityStats.ageGroups)}`);
    }

    // 자연 노화 처리 (확률 기반)
    function processAging() {
        const { ageGroups } = cityStats;

        // 노화 확률 (게임일당 전환율)
        const childToYouthRate = 1 / AGE_SYSTEM.CHILD_TO_YOUTH;
        const youthToAdultRate = 1 / AGE_SYSTEM.YOUTH_TO_ADULT;
        const adultToElderlyRate = 1 / AGE_SYSTEM.ADULT_TO_ELDERLY;

        // 어린이 → 청년
        const childrenToAge = Math.floor(ageGroups.children * childToYouthRate);
        if (childrenToAge > 0) {
            ageGroups.children -= childrenToAge;
            ageGroups.youth += childrenToAge;
        }

        // 청년 → 중년
        const youthToAge = Math.floor(ageGroups.youth * youthToAdultRate);
        if (youthToAge > 0) {
            ageGroups.youth -= youthToAge;
            ageGroups.adults += youthToAge;
        }

        // 중년 → 노인
        const adultsToAge = Math.floor(ageGroups.adults * adultToElderlyRate);
        if (adultsToAge > 0) {
            ageGroups.adults -= adultsToAge;
            ageGroups.elderly += adultsToAge;
        }
    }

    // 출생 처리
    function processBirths() {
        const { ageGroups } = cityStats;
        const totalPop = ageGroups.children + ageGroups.youth + ageGroups.adults + ageGroups.elderly;
        if (totalPop === 0) return;

        // 기본 출생률 계산
        let birthRate = AGE_SYSTEM.BASE_BIRTH_RATE / 1000;

        // 서비스 보너스
        let schoolCount = 0, parkCount = 0;
        placedPublicBuildings.forEach(b => {
            if (!b.ref) {
                if (b.type === 'school') schoolCount++;
                if (b.type === 'park') parkCount++;
            }
        });

        if (schoolCount > 0) birthRate *= (1 + AGE_SYSTEM.SCHOOL_BIRTH_BONUS);
        if (parkCount > 0) birthRate *= (1 + AGE_SYSTEM.PARK_BIRTH_BONUS);

        // 행복도 보너스
        if (cityStats.happiness > 70) birthRate *= 1.2;
        else if (cityStats.happiness < 30) birthRate *= 0.5;

        // 출산 가능 인구 (청년 + 중년의 일부)
        const fertilePop = ageGroups.youth * 0.5 + ageGroups.adults * 0.3;

        // 출생 수 계산
        const births = Math.floor(fertilePop * birthRate);
        if (births > 0) {
            ageGroups.children += births;
            cityStats.birthRate = births;
        }
    }

    // 사망 처리
    function processDeaths() {
        const { ageGroups } = cityStats;

        // 기본 사망률
        let deathRate = AGE_SYSTEM.BASE_DEATH_RATE / 1000;

        // 병원 보너스
        let hospitalCount = 0;
        placedPublicBuildings.forEach(b => {
            if (!b.ref && b.type === 'hospital') hospitalCount++;
        });

        if (hospitalCount > 0) deathRate *= (1 - AGE_SYSTEM.HOSPITAL_DEATH_REDUCE);

        // 노인 사망 (자연사)
        const elderlyDeathRate = 1 / AGE_SYSTEM.ELDERLY_LIFESPAN;
        const elderlyDeaths = Math.floor(ageGroups.elderly * elderlyDeathRate);

        // 기타 연령 사망 (낮은 확률)
        const otherDeaths = Math.floor(
            (ageGroups.children * 0.001 + ageGroups.youth * 0.002 + ageGroups.adults * 0.005) * deathRate
        );

        const totalDeaths = elderlyDeaths + otherDeaths;

        if (elderlyDeaths > 0) ageGroups.elderly = Math.max(0, ageGroups.elderly - elderlyDeaths);
        if (otherDeaths > 0) {
            // 다른 연령대에서 분산 감소
            const ratio = otherDeaths / (ageGroups.children + ageGroups.youth + ageGroups.adults || 1);
            ageGroups.children = Math.max(0, ageGroups.children - Math.floor(ageGroups.children * ratio * 0.1));
            ageGroups.youth = Math.max(0, ageGroups.youth - Math.floor(ageGroups.youth * ratio * 0.2));
            ageGroups.adults = Math.max(0, ageGroups.adults - Math.floor(ageGroups.adults * ratio * 0.7));
        }

        cityStats.deathRate = totalDeaths;
    }

    // 총 인구와 연령 그룹 동기화
    function syncPopulationWithAgeGroups() {
        const { ageGroups } = cityStats;
        const ageTotal = ageGroups.children + ageGroups.youth + ageGroups.adults + ageGroups.elderly;

        // 건물 인구와 연령 인구 차이 조정
        const diff = cityStats.population - ageTotal;

        if (diff > 0) {
            // 인구가 늘었으면 (새 건물 입주) - 초기 분포로 추가
            const dist = AGE_SYSTEM.INITIAL_DISTRIBUTION;
            ageGroups.children += Math.round(diff * dist.children);
            ageGroups.youth += Math.round(diff * dist.youth);
            ageGroups.adults += Math.round(diff * dist.adults);
            ageGroups.elderly += Math.round(diff * dist.elderly);
        } else if (diff < 0) {
            // 인구가 줄었으면 (건물 철거 등) - 비율대로 감소
            const absDiff = Math.abs(diff);
            const ratio = absDiff / ageTotal;
            ageGroups.children = Math.max(0, Math.round(ageGroups.children * (1 - ratio)));
            ageGroups.youth = Math.max(0, Math.round(ageGroups.youth * (1 - ratio)));
            ageGroups.adults = Math.max(0, Math.round(ageGroups.adults * (1 - ratio)));
            ageGroups.elderly = Math.max(0, Math.round(ageGroups.elderly * (1 - ratio)));
        }
    }

    // 노동 인구 계산
    function getWorkforcePopulation() {
        const { ageGroups } = cityStats;
        const { WORKFORCE_RATIO } = AGE_SYSTEM;

        return Math.floor(
            ageGroups.children * WORKFORCE_RATIO.children +
            ageGroups.youth * WORKFORCE_RATIO.youth +
            ageGroups.adults * WORKFORCE_RATIO.adults +
            ageGroups.elderly * WORKFORCE_RATIO.elderly
        );
    }

    // 세금 기여 인구 계산
    function getTaxablePopulation() {
        const { ageGroups } = cityStats;
        const { TAX_CONTRIBUTION } = AGE_SYSTEM;

        return Math.floor(
            ageGroups.children * TAX_CONTRIBUTION.children +
            ageGroups.youth * TAX_CONTRIBUTION.youth +
            ageGroups.adults * TAX_CONTRIBUTION.adults +
            ageGroups.elderly * TAX_CONTRIBUTION.elderly
        );
    }

    // 서비스 수요 계산 (연령 기반)
    function getServiceDemand(serviceType) {
        const { ageGroups } = cityStats;
        const demandRatio = AGE_SYSTEM.SERVICE_DEMAND[serviceType];
        if (!demandRatio) return 0;

        return Math.floor(
            ageGroups.children * demandRatio.children +
            ageGroups.youth * demandRatio.youth +
            ageGroups.adults * demandRatio.adults +
            ageGroups.elderly * demandRatio.elderly
        );
    }

    // 서비스 커버리지 계산 (해당 서비스가 얼마나 수요를 충족하는지)
    function getServiceCoverage(serviceType) {
        const demand = getServiceDemand(serviceType);
        if (demand === 0) return 100;

        // 해당 서비스 건물 수 계산
        let serviceCount = 0;
        let capacityPerBuilding = 0;

        placedPublicBuildings.forEach((b) => {
            if (!b.ref && b.type === serviceType) serviceCount++;
        });

        // 서비스별 용량
        switch (serviceType) {
            case 'school':
                capacityPerBuilding = 200;  // 학교당 200명 수용
                break;
            case 'hospital':
                capacityPerBuilding = 150;  // 병원당 150명 수용
                break;
            case 'park':
                capacityPerBuilding = 100;  // 공원당 100명 수용
                break;
            default:
                capacityPerBuilding = 100;
        }

        const totalCapacity = serviceCount * capacityPerBuilding;
        return Math.min(100, Math.round((totalCapacity / demand) * 100));
    }

    // 모든 서비스 커버리지 요약
    function getAllServiceCoverage() {
        return {
            school: getServiceCoverage('school'),
            hospital: getServiceCoverage('hospital'),
            park: getServiceCoverage('park')
        };
    }

    // 시간 점프 (낮/밤 전환)
    function toggleDayNight() {
        const hour = (timeState.gameTime / 3600) % 24;
        if (hour >= 6 && hour < 20) {
            // 낮이면 -> 밤 (21시)
            timeState.gameTime = 21 * 3600;
        } else {
            // 밤이면 -> 낮 (9시)
            timeState.gameTime = 9 * 3600;
        }
        updateEnvironment();
    }

    // 전역 함수로 등록
    window.toggleDayNight = toggleDayNight;
    window.setGameSpeed = setGameSpeed;

    // 초기 환경 설정은 INIT 섹션에서 호출

    /* =========================================================
     * GRID DATA
     * ========================================================= */
    const CELL = {
        EMPTY: 0,           // 빈 땅 (잔디)
        ROAD: 1,            // 도로
        LOCKED_ROAD: 2,     // 잠긴 도로
        // 주거 건물 (시민 자동 생성) - 서버에서만 사용
        RESIDENTIAL_LOW: 3,
        RESIDENTIAL_MID: 4,
        RESIDENTIAL_HIGH: 5,
        // 상업/공업 건물 (시민 자동 생성) - 서버에서만 사용
        COMMERCIAL_BUILDING: 6,
        INDUSTRIAL_BUILDING: 7,
        // 구역 지정 (플레이어가 지정)
        ZONE_RESIDENTIAL: 8,  // 주거구역 (초록)
        ZONE_COMMERCIAL: 9,   // 상업구역 (파랑)
        ZONE_INDUSTRIAL: 10,  // 공업구역 (노랑)
        // 수로 시스템
        WATER: 11,            // 수로
        BRIDGE: 12,           // 다리 (수로 위 도로)
        // 4차로 도로 시스템
        ROAD_4LANE: 13,       // 4차로 도로
        LOCKED_ROAD_4LANE: 14, // 잠긴 4차로 도로
        // 지형 타일 (마스터 편집기용)
        BEACH: 15,            // 해변 타일
        OCEAN: 16,            // 바다/물 타일
        BREAKWATER: 17,       // 방파제 (2x2, 바다+해변 위에 설치)
    };

    // 구역 색상 정의
    const ZONE_COLORS = {
        [CELL.ZONE_RESIDENTIAL]: 0x4ade80,  // 초록
        [CELL.ZONE_COMMERCIAL]: 0x60a5fa,   // 파랑
        [CELL.ZONE_INDUSTRIAL]: 0xfbbf24,   // 노랑
    };

    const ZONE_NAMES = {
        [CELL.ZONE_RESIDENTIAL]: '주거구역',
        [CELL.ZONE_COMMERCIAL]: '상업구역',
        [CELL.ZONE_INDUSTRIAL]: '공업구역',
    };

    // ===== 공사 시스템 =====
    const CONSTRUCTION_STATE = {
        WAITING_VEHICLE: 'waiting_vehicle',  // 차량 대기 중
        UNDER_CONSTRUCTION: 'under_construction',  // 공사 중
        COMPLETED: 'completed'  // 완료
    };

    // 공사 현장 맵 (key: "x,y", value: constructionData)
    const constructionSites = new Map();

    // 공사 소요 시간 (1분 - 테스트용)
    const CONSTRUCTION_DURATION = 60000;

    // ===== 입주 시스템 =====
    // 건물 레벨별 수용 인원 (차량 1대 = 가족 1가구)
    const BUILDING_CAPACITY = {
        // 1x1 건물
        "1x1_low": 2,      // 저층 주거: 2가구
        "1x1_mid": 3,      // 중층 주거: 3가구
        "1x1_high": 4,     // 고층 주거: 4가구
        // 2x2 건물
        "2x2_low": 6,      // 저층 아파트: 6가구
        "2x2_mid": 10,     // 중층 아파트: 10가구
        "2x2_high": 16,    // 고층 아파트: 16가구
    };

    // 입주 대기 맵 (key: "x,y", value: { capacity, movedIn, buildingX, buildingY, size, tier })
    const pendingMoveIns = new Map();
    let lastMoveInSpawnTime = 0;

    // ===== 행복도 시스템 =====
    // 행복도 3단계: 0-33 = 하(low), 34-66 = 중(mid), 67-100 = 상(high)
    const HAPPINESS_THRESHOLDS = {
        LOW: 33,    // 0-33
        MID: 66,    // 34-66
        HIGH: 100   // 67-100
    };

    // 낮은 행복도 지속 시간 추적 (폐건물 전환용)
    const buildingLowHappinessTime = new Map();  // key: "x,y", value: { startTime, abandonTime }
    const ABANDON_HAPPINESS_THRESHOLD = 20;  // 행복도 20 이하일 때만 폐건물 가능
    const MIN_ABANDON_TIME = 30000;  // 최소 30초
    const MAX_ABANDON_TIME = 90000;  // 최대 90초 (랜덤 편차)

    // 시민 한마디 (행복도 & 건물 타입별)
    const CITIZEN_QUOTES = {
        residential: {
            low: [
                "여기서 벗어날 거에요!",
                "이런 곳에서 못 살겠어요...",
                "매일 걱정뿐이에요.",
                "이사 갈 곳을 찾고 있어요."
            ],
            mid: [
                "그럭저럭 살만합니다.",
                "나쁘지 않은 동네예요.",
                "평범한 일상이에요.",
                "조금만 더 좋아지면..."
            ],
            high: [
                "살기 정말 좋은 곳이에요!",
                "이 동네 최고예요!",
                "매일이 행복해요!",
                "이사 올 때 잘한 선택이었어요."
            ],
            // RCI 부족 상황 멘트
            noJobs: [
                "일자리가 없어요!",
                "직장을 구할 수가 없어요.",
                "일할 곳이 부족해요.",
                "취업이 너무 어려워요."
            ]
        },
        commercial: {
            low: [
                "손님이 없어요...",
                "폐업을 고민 중이에요.",
                "장사가 안 돼요.",
                "임대료도 못 내겠어요."
            ],
            mid: [
                "그럭저럭 장사하고 있어요.",
                "손님이 좀 있어요.",
                "먹고 살만해요.",
                "조금만 더 번창하면..."
            ],
            high: [
                "장사가 아주 잘됩니다!",
                "손님이 끊이질 않아요!",
                "확장을 고려 중이에요!",
                "매출이 최고예요!"
            ],
            // RCI 부족 상황 멘트
            noWorkers: [
                "일할 사람이 없어요!",
                "직원을 구할 수가 없어요.",
                "인력이 부족해요.",
                "알바생도 못 구해요."
            ],
            noSupply: [
                "납품받을 물건이 없어요!",
                "공급이 부족해요.",
                "공장에서 물건이 안 와요.",
                "재고가 바닥이에요."
            ]
        },
        industrial: {
            low: [
                "주문이 없어요...",
                "공장 가동률이 바닥이에요.",
                "직원들 월급도 걱정이에요.",
                "이러다 문 닫겠어요."
            ],
            mid: [
                "생산량이 적당해요.",
                "그럭저럭 돌아가요.",
                "직원들 괜찮아요.",
                "안정적으로 운영 중이에요."
            ],
            high: [
                "주문이 밀려요!",
                "풀가동 중이에요!",
                "직원 더 뽑아야겠어요!",
                "사업이 번창하고 있어요!"
            ],
            // RCI 부족 상황 멘트
            noWorkers: [
                "일할 사람이 없어요!",
                "직원을 구할 수가 없어요.",
                "인력이 부족해요.",
                "생산라인 가동이 어려워요."
            ],
            noShops: [
                "납품할 매장이 없어요!",
                "물건을 팔 곳이 없어요.",
                "상점이 부족해요.",
                "재고가 쌓여가요."
            ]
        }
    };

    // ===== 행복도 효과 원인 시스템 =====
    // 효과 타입 정의
    const HAPPINESS_EFFECT_TYPES = {
        // 서비스 시설 버프 (긍정)
        POLICE: 'police',       // 경찰서
        FIRE: 'fire',           // 소방서
        SCHOOL: 'school',       // 학교
        PARK: 'park',           // 공원
        HOSPITAL: 'hospital',   // 병원
        // RCI 부족 너프 (부정)
        NO_JOBS: 'noJobs',           // 일자리 부족
        NO_WORKERS: 'noWorkers',     // 일할 사람 부족
        NO_SUPPLY: 'noSupply',       // 물건 공급 부족
        NO_SHOPS: 'noShops',         // 납품 매장 부족
        // 기타
        LOW_LAND_VALUE: 'lowLandValue',  // 낮은 땅값
        NONE: 'none'                      // 효과 없음
    };

    // 효과 타입별 시민 멘트
    const EFFECT_QUOTES = {
        // 서비스 시설 버프 멘트
        police: [
            "경찰서가 옆에 있어 든든해요!",
            "치안이 좋아서 안심이에요.",
            "밤에도 안전하게 다닐 수 있어요!",
            "범죄 걱정이 없어요."
        ],
        fire: [
            "소방서가 가까워서 안심이에요!",
            "화재 걱정이 없어요.",
            "소방관 아저씨들 덕분에 안전해요!",
            "비상시 빠른 대응이 가능해요."
        ],
        school: [
            "좋은 학교가 근처에 있어요!",
            "아이들 교육 걱정이 없어요.",
            "교육 환경이 훌륭해요!",
            "학군이 좋아서 만족해요."
        ],
        park: [
            "공원에서 산책하기 좋아요!",
            "녹지가 많아서 쾌적해요.",
            "공원 덕분에 여유로워요!",
            "자연과 가까워서 행복해요."
        ],
        hospital: [
            "병원이 가까워서 안심이에요!",
            "의료 시설이 잘 갖춰져 있어요.",
            "건강 관리하기 좋은 동네예요!",
            "응급 상황에도 걱정 없어요."
        ],
        // RCI 부족 너프 멘트
        noJobs: [
            "일자리가 부족해요!",
            "직장을 구하기 어려워요.",
            "취업이 너무 힘들어요.",
            "일할 곳이 없어요."
        ],
        noWorkers: [
            "일할 사람이 없어요!",
            "직원을 구할 수가 없어요.",
            "인력이 부족해요.",
            "사람을 못 구하겠어요."
        ],
        noSupply: [
            "물건 공급이 부족해요!",
            "납품받을 물건이 없어요.",
            "공장에서 물건이 안 와요.",
            "재고가 바닥이에요."
        ],
        noShops: [
            "납품할 매장이 부족해요!",
            "물건을 팔 곳이 없어요.",
            "상점이 부족해요.",
            "생산품이 쌓여가요."
        ],
        // 기타
        lowLandValue: [
            "이 지역은 좀 낙후됐어요.",
            "주변 환경이 별로예요.",
            "개발이 필요한 지역이에요.",
            "인프라가 부족해요."
        ]
    };

    // 건물별 현재 적용 중인 주요 효과 (가장 최근 또는 가장 큰 효과)
    const buildingHappinessEffect = new Map();  // key: "x,y", value: { type: string, value: number, isPositive: boolean }

    // ===== RCI 부족 시스템 =====
    // 부족 영향을 받는 건물 목록 (랜덤 선정)
    const rciShortageAffectedBuildings = {
        residential: new Set(),  // 주민 부족 → 상업/산업 영향
        commercial: new Set(),   // 상업 부족 → 주거/산업 영향
        industrial: new Set()    // 산업 부족 → 주거/상업 영향
    };

    // 부족 상황 저장 (건물별로 어떤 부족의 영향을 받는지)
    const buildingShortageEffect = new Map();  // key: "x,y", value: { type: 'noJobs'|'noWorkers'|'noSupply'|'noShops', penalty: number }

    const RCI_SHORTAGE_PENALTY = 30;  // 부족 시 행복도 감소량 (고정)
    const RCI_SHORTAGE_UPDATE_INTERVAL = 10000;  // 10초마다 영향 건물 재선정
    let lastRCIShortageUpdate = 0;

    /**
     * RCI 부족에 따른 영향 건물 선정 및 업데이트
     * - 주민(R) 부족: 상업/산업 건물에 영향 (일할 사람이 없어요)
     * - 상업(C) 부족: 주거(일자리 부족), 산업(납품 매장 부족)에 영향
     * - 산업(I) 부족: 주거(일자리 부족), 상업(물건 공급 부족)에 영향
     */
    function updateRCIShortageEffects() {
        const now = Date.now();
        if (now - lastRCIShortageUpdate < RCI_SHORTAGE_UPDATE_INTERVAL) return;
        lastRCIShortageUpdate = now;

        // 이전 영향 초기화
        buildingShortageEffect.clear();

        if (typeof placedBuildings === 'undefined' || typeof cityStats === 'undefined') return;

        // 건물을 타입별로 분류
        const buildingsByType = {
            residential: [],
            commercial: [],
            industrial: []
        };

        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const userData = building.instance?.userData;
            if (!userData || userData.isAbandoned) continue;

            const zoneType = userData.zoneType || '';
            if (zoneType.includes('resident')) {
                buildingsByType.residential.push({ key, x: building.x, y: building.y });
            } else if (zoneType.includes('commercial')) {
                buildingsByType.commercial.push({ key, x: building.x, y: building.y });
            } else if (zoneType.includes('industrial')) {
                buildingsByType.industrial.push({ key, x: building.x, y: building.y });
            }
        }

        // RCI 수요 확인 (음수 = 해당 구역 부족)
        const rDemand = cityStats.residentialDemand || 0;  // 양수: 주거 필요, 음수: 주거 과잉
        const cDemand = cityStats.commercialDemand || 0;
        const iDemand = cityStats.industrialDemand || 0;

        // 부족량을 영향받는 건물 수로 변환 (부족 10당 건물 1개)
        const shortageToBuildingCount = (shortage) => Math.max(0, Math.floor(Math.abs(shortage) / 10));

        // 1. 주민(R) 부족 (rDemand > 0 = 주민이 더 필요) → 상업/산업에 영향
        if (rDemand > 0) {
            const affectedCount = shortageToBuildingCount(rDemand);

            // 상업 건물 영향 (일할 사람이 없어요)
            const commercialToAffect = shuffleArray([...buildingsByType.commercial]).slice(0, Math.ceil(affectedCount / 2));
            commercialToAffect.forEach(b => {
                buildingShortageEffect.set(b.key, { type: 'noWorkers', penalty: RCI_SHORTAGE_PENALTY });
            });

            // 산업 건물 영향 (일할 사람이 없어요)
            const industrialToAffect = shuffleArray([...buildingsByType.industrial]).slice(0, Math.ceil(affectedCount / 2));
            industrialToAffect.forEach(b => {
                buildingShortageEffect.set(b.key, { type: 'noWorkers', penalty: RCI_SHORTAGE_PENALTY });
            });
        }

        // 2. 상업(C) 부족 (cDemand > 0 = 상점이 더 필요) → 주거(일자리)/산업(납품처)에 영향
        if (cDemand > 0) {
            const affectedCount = shortageToBuildingCount(cDemand);

            // 주거 건물 영향 (일자리 부족)
            const residentialToAffect = shuffleArray([...buildingsByType.residential]).slice(0, Math.ceil(affectedCount / 2));
            residentialToAffect.forEach(b => {
                if (!buildingShortageEffect.has(b.key)) {
                    buildingShortageEffect.set(b.key, { type: 'noJobs', penalty: RCI_SHORTAGE_PENALTY });
                }
            });

            // 산업 건물 영향 (납품 매장 부족)
            const industrialToAffect = shuffleArray([...buildingsByType.industrial]).slice(0, Math.ceil(affectedCount / 2));
            industrialToAffect.forEach(b => {
                if (!buildingShortageEffect.has(b.key)) {
                    buildingShortageEffect.set(b.key, { type: 'noShops', penalty: RCI_SHORTAGE_PENALTY });
                }
            });
        }

        // 3. 산업(I) 부족 (iDemand > 0 = 공장이 더 필요) → 주거(일자리)/상업(물건 공급)에 영향
        if (iDemand > 0) {
            const affectedCount = shortageToBuildingCount(iDemand);

            // 주거 건물 영향 (일자리 부족)
            const residentialToAffect = shuffleArray([...buildingsByType.residential]).slice(0, Math.ceil(affectedCount / 2));
            residentialToAffect.forEach(b => {
                if (!buildingShortageEffect.has(b.key)) {
                    buildingShortageEffect.set(b.key, { type: 'noJobs', penalty: RCI_SHORTAGE_PENALTY });
                }
            });

            // 상업 건물 영향 (물건 공급 부족)
            const commercialToAffect = shuffleArray([...buildingsByType.commercial]).slice(0, Math.ceil(affectedCount / 2));
            commercialToAffect.forEach(b => {
                if (!buildingShortageEffect.has(b.key)) {
                    buildingShortageEffect.set(b.key, { type: 'noSupply', penalty: RCI_SHORTAGE_PENALTY });
                }
            });
        }
    }

    // 배열 섞기 (Fisher-Yates)
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // 건물별 행복도 계산
    function calculateBuildingHappiness(x, y) {
        // 땅값 기반 행복도 계산 (서비스 시설 영향 + 폐건물 페널티)
        const totalLandValue = typeof getTotalLandValue === 'function' ? getTotalLandValue(x, y) : 0;

        // 땅값을 행복도로 변환 (0 ~ 200 → 0 ~ 100 스케일)
        // 땅값 0 = 행복도 30, 땅값 100 = 행복도 80
        let happiness = 30 + totalLandValue * 0.5;

        // RCI 부족 페널티 적용
        const key = `${x},${y}`;
        const shortageEffect = buildingShortageEffect.get(key);
        if (shortageEffect) {
            happiness -= shortageEffect.penalty;
        }

        // 세금 페널티 적용 (세금율에 비례해 행복도 감소)
        // 기본 세금율 10%에서 페널티 없음, 20%면 최대 -20 페널티
        if (typeof budgetSystem !== 'undefined') {
            const avgTaxRate = (budgetSystem.taxRates.residential +
                               budgetSystem.taxRates.commercial +
                               budgetSystem.taxRates.industrial) / 3;
            // 10% 초과분에 대해 2배의 페널티 (10% = 0, 15% = -10, 20% = -20)
            const taxPenalty = Math.max(0, (avgTaxRate - 10) * 2);
            happiness -= taxPenalty;
        }

        return Math.round(Math.max(0, Math.min(100, happiness)));
    }

    // 세금 페널티 계산 (UI 표시용)
    function getTaxHappinessPenalty() {
        if (typeof budgetSystem === 'undefined') return 0;
        const avgTaxRate = (budgetSystem.taxRates.residential +
                           budgetSystem.taxRates.commercial +
                           budgetSystem.taxRates.industrial) / 3;
        return Math.round(Math.max(0, (avgTaxRate - 10) * 2));
    }

    // 건물의 RCI 부족 영향 상태 가져오기
    function getBuildingShortageEffect(x, y) {
        const key = `${x},${y}`;
        return buildingShortageEffect.get(key) || null;
    }

    // 행복도 레벨 문자열 반환
    function getHappinessLevel(happiness) {
        if (happiness <= HAPPINESS_THRESHOLDS.LOW) return 'low';
        if (happiness <= HAPPINESS_THRESHOLDS.MID) return 'mid';
        return 'high';
    }

    // 행복도 레벨 한글 반환
    function getHappinessLevelText(level) {
        switch (level) {
            case 'low': return '하';
            case 'mid': return '중';
            case 'high': return '상';
            default: return '중';
        }
    }

    /**
     * 건물의 주요 행복도 효과 분석
     * 가장 큰 영향을 주는 효과를 반환 (너프 우선)
     */
    function analyzeBuildingEffect(x, y) {
        if (x === undefined || y === undefined) return null;

        const effects = [];

        // 1. RCI 부족 너프 체크 (최우선)
        const shortageEffect = getBuildingShortageEffect(x, y);
        if (shortageEffect) {
            effects.push({
                type: shortageEffect.type,
                value: -shortageEffect.penalty,
                isPositive: false
            });
        }

        // 2. 서비스 시설 버프 체크
        if (typeof placedPublicBuildings !== 'undefined') {
            const serviceEffects = {
                police: 0,
                fire: 0,
                school: 0,
                park: 0,
                hospital: 0
            };

            placedPublicBuildings.forEach((building) => {
                if (building.ref) return;

                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (!config) return;

                // 서비스 건물 운영 상태 확인 (비운영 시설은 효과 미적용)
                if (typeof serviceBuildingManager !== 'undefined' &&
                    !serviceBuildingManager.isOperational(building.x, building.y)) {
                    return; // 비운영 시설은 효과 없음
                }

                const bx = building.x;
                const by = building.y;
                const bw = building.width || 2;
                const bd = building.depth || 2;

                // 건물 중심 좌표
                const centerX = bx + bw / 2;
                const centerY = by + bd / 2;

                // 타일 중심과의 거리 계산
                const dx = (x + 0.5) - centerX;
                const dy = (y + 0.5) - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 효과 범위 내에 있으면 버프 계산
                if (distance <= config.effectRadius) {
                    const falloff = 1 - (distance / config.effectRadius);
                    const bonus = config.landValueBonus * falloff;

                    // 건물 타입에 따른 효과 분류
                    const buildingType = building.type.toLowerCase();
                    if (buildingType.includes('police')) {
                        serviceEffects.police += bonus;
                    } else if (buildingType.includes('fire')) {
                        serviceEffects.fire += bonus;
                    } else if (buildingType.includes('school')) {
                        serviceEffects.school += bonus;
                    } else if (buildingType.includes('park')) {
                        serviceEffects.park += bonus;
                    } else if (buildingType.includes('hospital')) {
                        serviceEffects.hospital += bonus;
                    }
                }
            });

            // 가장 큰 서비스 효과 추가
            for (const [service, value] of Object.entries(serviceEffects)) {
                if (value > 0) {
                    effects.push({
                        type: service,
                        value: value,
                        isPositive: true
                    });
                }
            }
        }

        // 3. 낮은 땅값 너프 체크
        const baseLandValue = typeof getLandValue === 'function' ? getLandValue(x, y) : 0;
        if (baseLandValue < -30) {
            effects.push({
                type: 'lowLandValue',
                value: baseLandValue,
                isPositive: false
            });
        }

        // 효과 정렬 (부정적 효과 우선, 그 다음 효과 크기순)
        effects.sort((a, b) => {
            // 부정적 효과 우선
            if (!a.isPositive && b.isPositive) return -1;
            if (a.isPositive && !b.isPositive) return 1;
            // 같은 유형이면 절대값 크기순
            return Math.abs(b.value) - Math.abs(a.value);
        });

        return effects.length > 0 ? effects[0] : null;
    }

    // 시민 한마디 가져오기 (효과 원인 기반)
    function getCitizenQuote(zoneType, happinessLevel, x, y) {
        let type = 'residential';
        if (zoneType.includes('commercial')) type = 'commercial';
        else if (zoneType.includes('industrial')) type = 'industrial';

        // 건물 효과 분석
        if (x !== undefined && y !== undefined) {
            const effect = analyzeBuildingEffect(x, y);
            if (effect) {
                // 효과 타입에 따른 멘트 가져오기
                const effectQuotes = EFFECT_QUOTES[effect.type];
                if (effectQuotes && effectQuotes.length > 0) {
                    return effectQuotes[Math.floor(Math.random() * effectQuotes.length)];
                }
            }
        }

        // 효과가 없으면 기본 행복도 멘트
        const quotes = CITIZEN_QUOTES[type][happinessLevel] || CITIZEN_QUOTES[type].mid;
        return quotes[Math.floor(Math.random() * quotes.length)];
    }

    // ===== 화재 시스템 =====
    // 화재 상태 관리
    const burningBuildings = new Map();  // key: "x,y", value: { startTime, intensity, effects: { flames, smoke } }
    const FIRE_CHECK_INTERVAL = 10000;    // 10초마다 화재 발생 체크
    const FIRE_BASE_CHANCE = 0.001;       // 기본 화재 발생 확률 0.1%
    const FIRE_INDUSTRIAL_MULTIPLIER = 3; // 공장 화재 확률 3배
    const FIRE_SPREAD_CHANCE = 0.1;       // 인접 건물 화재 전파 확률 10%
    const FIRE_DURATION = 60000;          // 화재 지속 시간 60초 (소방서 없을 때)
    const FIRE_SUPPRESS_RATE = 0.8;       // 소방서 범위 내 진압 속도 80% 빠름
    let lastFireCheck = 0;

    // ===== 일일 통계 시스템 =====
    const dailyStats = {
        // 화재 통계
        fire: {
            totalFires: 0,              // 하루에 발생한 화재
            extinguishedFires: 0,       // 하루에 진압한 화재
            hazmatFires: 0,             // 하루에 진압한 위험물 화재 (공장)
            burnedBuildings: 0,         // 하루에 불에 탄 건물
            lastReset: Date.now()
        },
        // 범죄 통계
        crime: {
            totalCrimes: 0,             // 하루에 발생한 범죄
            arrestedCriminals: 0,       // 하루에 체포한 범죄자
            escapedCriminals: 0,        // 잡히지 않은 범죄자
            lastReset: Date.now()
        },
        // 의료 통계
        medical: {
            totalEmergencies: 0,        // 하루에 발생한 응급환자
            savedPatients: 0,           // 하루에 구조한 환자
            deadPatients: 0,            // 하루에 사망한 환자
            dischargedPatients: 0,      // 하루에 퇴원한 환자
            lastReset: Date.now()
        },
        // 경고 임계치
        thresholds: {
            burnedBuildings: 3,         // 전소 건물 경고 임계치
            escapedCriminals: 5,        // 도주 범죄자 경고 임계치
            deadPatients: 3             // 사망 환자 경고 임계치
        },
        // 경고 발송 여부 (중복 방지)
        warningsSent: {
            fire: false,
            crime: false,
            medical: false
        }
    };

    // 일일 통계 리셋 (게임 내 하루 기준)
    function resetDailyStats(type) {
        if (type === 'fire' || type === 'all') {
            dailyStats.fire.totalFires = 0;
            dailyStats.fire.extinguishedFires = 0;
            dailyStats.fire.hazmatFires = 0;
            dailyStats.fire.burnedBuildings = 0;
            dailyStats.fire.lastReset = Date.now();
            dailyStats.warningsSent.fire = false;
        }
        if (type === 'crime' || type === 'all') {
            dailyStats.crime.totalCrimes = 0;
            dailyStats.crime.arrestedCriminals = 0;
            dailyStats.crime.escapedCriminals = 0;
            dailyStats.crime.lastReset = Date.now();
            dailyStats.warningsSent.crime = false;
        }
        if (type === 'medical' || type === 'all') {
            dailyStats.medical.totalEmergencies = 0;
            dailyStats.medical.savedPatients = 0;
            dailyStats.medical.deadPatients = 0;
            dailyStats.medical.dischargedPatients = 0;
            dailyStats.medical.lastReset = Date.now();
            dailyStats.warningsSent.medical = false;
        }
    }

    // 통계 패널 업데이트
    function updateDailyStatsPanel() {
        // 화재 통계 패널
        const fireStatsPanel = document.getElementById('fireStatsPanel');
        if (fireStatsPanel && fireStatsPanel.style.display !== 'none') {
            document.getElementById('statBurnedBuildings').textContent = dailyStats.fire.burnedBuildings;
            document.getElementById('statExtinguishedFires').textContent = dailyStats.fire.extinguishedFires;
            document.getElementById('statTotalFires').textContent = dailyStats.fire.totalFires;
            document.getElementById('statHazmatFires').textContent = dailyStats.fire.hazmatFires;
        }

        // 범죄 통계 패널
        const crimeStatsPanel = document.getElementById('crimeStatsPanel');
        if (crimeStatsPanel && crimeStatsPanel.style.display !== 'none') {
            document.getElementById('statTotalCrimes').textContent = dailyStats.crime.totalCrimes;
            document.getElementById('statEscapedCriminals').textContent = dailyStats.crime.escapedCriminals;
            document.getElementById('statArrestedCriminals').textContent = dailyStats.crime.arrestedCriminals;
            document.getElementById('statPrisoners').textContent = getTotalPrisoners();
        }

        // 의료 통계 패널
        const medicalStatsPanel = document.getElementById('medicalStatsPanel');
        if (medicalStatsPanel && medicalStatsPanel.style.display !== 'none') {
            document.getElementById('statTotalEmergencies').textContent = dailyStats.medical.totalEmergencies;
            document.getElementById('statSavedPatients').textContent = dailyStats.medical.savedPatients;
            document.getElementById('statDeadPatients').textContent = dailyStats.medical.deadPatients;
            document.getElementById('statHospitalPatients').textContent = getTotalHospitalPatients();
            document.getElementById('statHospitalCapacity').textContent = getTotalHospitalCapacity();
        }
    }

    // 임계치 초과 경고 체크
    function checkDailyStatsWarnings() {
        // 화재 경고 - 전소 건물이 임계치 초과
        if (!dailyStats.warningsSent.fire && dailyStats.fire.burnedBuildings >= dailyStats.thresholds.burnedBuildings) {
            dailyStats.warningsSent.fire = true;
            toast({
                title: '⚠️ 화재 경고!',
                desc: `화재구역에 소방차가 제때 도착하지 못하여 ${dailyStats.fire.burnedBuildings}개 건물이 전소되었습니다. 소방서를 늘리세요!`,
                ms: 8000
            });
        }

        // 범죄 경고 - 도주 범죄자가 임계치 초과
        if (!dailyStats.warningsSent.crime && dailyStats.crime.escapedCriminals >= dailyStats.thresholds.escapedCriminals) {
            dailyStats.warningsSent.crime = true;
            toast({
                title: '⚠️ 치안 경고!',
                desc: `${dailyStats.crime.escapedCriminals}명의 범죄자가 도주했습니다. 경찰서를 늘리거나 감옥 정원을 확인하세요!`,
                ms: 8000
            });
        }

        // 의료 경고 - 사망 환자가 임계치 초과
        if (!dailyStats.warningsSent.medical && dailyStats.medical.deadPatients >= dailyStats.thresholds.deadPatients) {
            dailyStats.warningsSent.medical = true;
            toast({
                title: '⚠️ 의료 경고!',
                desc: `${dailyStats.medical.deadPatients}명의 환자가 제때 치료를 받지 못해 사망했습니다. 병원을 늘리세요!`,
                ms: 8000
            });
        }
    }

    // 화재 파티클 그룹
    const fireEffectsGroup = new THREE.Group();
    fireEffectsGroup.name = 'fireEffects';

    // ===== Three.quarks 화재 텍스처 생성 =====
    const textureLoader = new THREE.TextureLoader();

    // 불꽃 텍스처 (원형 그라데이션)
    function createFireTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 200, 50, 1)');
        gradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const fireTexture = createFireTexture();

    // 연기 텍스처 로드
    const smokeTextureSheet = textureLoader.load('/textures/msVFX_Stylized Smoke 1_Texture.png');
    smokeTextureSheet.colorSpace = THREE.SRGBColorSpace;

    // 연기 텍스처 (단일 프레임용)
    function createSmokeTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
        gradient.addColorStop(0.5, 'rgba(80, 80, 80, 0.5)');
        gradient.addColorStop(1, 'rgba(60, 60, 60, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const smokeTexture = createSmokeTexture();

    // ===== 물 이펙트 텍스처 생성 =====
    function createWaterTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(150, 200, 255, 1)');
        gradient.addColorStop(0.3, 'rgba(100, 180, 255, 0.9)');
        gradient.addColorStop(0.6, 'rgba(50, 150, 255, 0.6)');
        gradient.addColorStop(1, 'rgba(30, 120, 255, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const waterTexture = createWaterTexture();

    // 활성 물 이펙트 추적
    const activeWaterEffects = new Map();

    /**
     * 소방차 물 뿌리기 이펙트 생성
     */
    function createWaterSprayEffect(vehicle) {
        if (!vehicle || !vehicle.mesh) return null;

        const waterGroup = new THREE.Group();
        waterGroup.name = `water_spray_${vehicle.id}`;

        // ===== 물줄기 파티클 시스템 =====
        const waterSystem = new ParticleSystem({
            duration: 0,  // 무한 반복
            looping: true,
            startLife: new IntervalValue(0.4, 0.7),
            startSpeed: new IntervalValue(2.5, 4.0),
            startSize: new IntervalValue(0.08, 0.15),
            startRotation: new IntervalValue(0, Math.PI * 2),
            startColor: new RandomColor(
                new THREE.Vector4(0.6, 0.85, 1, 0.9),     // 밝은 하늘색
                new THREE.Vector4(0.4, 0.7, 1, 0.8)       // 파란색
            ),
            emissionOverTime: new ConstantValue(30),  // 60 -> 30 (성능 최적화)
            shape: new ConeEmitter({
                radius: 0.05,
                arc: Math.PI * 2,
                thickness: 0.5,
                angle: Math.PI / 12  // 좁은 원뿔 (물줄기)
            }),
            material: new THREE.MeshBasicMaterial({
                map: waterTexture,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            }),
            renderMode: RenderMode.BillBoard,
            renderOrder: 8,
            worldSpace: true
        });

        // 물줄기 행동 추가
        const waterSizeCurve = new Array(new Array(new Bezier(0.5, 0.8, 1, 0.3), 0));
        waterSystem.addBehavior(new SizeOverLife(new PiecewiseBezier(waterSizeCurve)));

        const waterColorStops = new Array(
            new Array(new THREE.Vector3(0.7, 0.9, 1), 0),
            new Array(new THREE.Vector3(0.5, 0.8, 1), 0.5),
            new Array(new THREE.Vector3(0.3, 0.6, 0.9), 1)
        );
        const waterAlphaStops = new Array(
            new Array(0.8, 0),
            new Array(0.6, 0.5),
            new Array(0, 1)
        );
        waterSystem.addBehavior(new ColorOverLife(new Gradient(waterColorStops, waterAlphaStops)));

        // 중력 효과 (물이 아래로 떨어지게)
        waterSystem.addBehavior(new ForceOverLife(
            new ConstantValue(0),
            new ConstantValue(-3),  // 중력
            new ConstantValue(0)
        ));

        waterSystem.emitter.name = 'water_stream';
        // 소방차 앞쪽 위에서 발사
        waterSystem.emitter.position.set(0, 0.4, 0.3);
        waterSystem.emitter.rotation.set(-Math.PI / 4, 0, 0);  // 45도 각도로 발사

        batchRenderer.addSystem(waterSystem);
        waterGroup.add(waterSystem.emitter);

        // ===== 물방울 튀김 파티클 =====
        const splashSystem = new ParticleSystem({
            duration: 0,
            looping: true,
            startLife: new IntervalValue(0.3, 0.5),
            startSpeed: new IntervalValue(0.5, 1.5),
            startSize: new IntervalValue(0.03, 0.08),
            startRotation: new IntervalValue(0, Math.PI * 2),
            startColor: new RandomColor(
                new THREE.Vector4(0.8, 0.95, 1, 0.7),
                new THREE.Vector4(0.6, 0.85, 1, 0.5)
            ),
            emissionOverTime: new ConstantValue(12),  // 25 -> 12 (성능 최적화)
            shape: new SphereEmitter({
                radius: 0.3,
                arc: Math.PI * 2,
                thickness: 1
            }),
            material: new THREE.MeshBasicMaterial({
                map: waterTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            }),
            renderMode: RenderMode.BillBoard,
            renderOrder: 7,
            worldSpace: true
        });

        const splashSizeCurve = new Array(new Array(new Bezier(1, 0.5, 0.2, 0), 0));
        splashSystem.addBehavior(new SizeOverLife(new PiecewiseBezier(splashSizeCurve)));

        splashSystem.addBehavior(new ForceOverLife(
            new IntervalValue(-0.3, 0.3),
            new ConstantValue(-2),
            new IntervalValue(-0.3, 0.3)
        ));

        splashSystem.emitter.name = 'water_splash';
        // 물이 떨어지는 지점 (소방차 앞 1.5칸)
        splashSystem.emitter.position.set(0, 0.1, 1.2);

        batchRenderer.addSystem(splashSystem);
        waterGroup.add(splashSystem.emitter);

        // 이펙트 데이터 저장
        waterGroup.userData.waterSystem = waterSystem;
        waterGroup.userData.splashSystem = splashSystem;
        waterGroup.userData.vehicleId = vehicle.id;

        return { group: waterGroup, waterSystem, splashSystem };
    }

    /**
     * 소방차에 물 이펙트 시작
     */
    function startWaterEffect(vehicle) {
        if (!vehicle || !vehicle.mesh) return;
        if (activeWaterEffects.has(vehicle.id)) return;  // 이미 이펙트 있음

        const effect = createWaterSprayEffect(vehicle);
        if (!effect) return;

        vehicle.mesh.add(effect.group);
        activeWaterEffects.set(vehicle.id, effect);

        // 화재 건물 방향으로 물줄기 회전
        if (vehicle.fireTarget) {
            const fireWorldX = (ORIGIN_X + vehicle.fireTarget.x + 0.5) * TILE_SIZE;
            const fireWorldZ = (ORIGIN_Z + vehicle.fireTarget.y + 0.5) * TILE_SIZE;

            // 소방차 월드 위치
            const vehicleWorldPos = new THREE.Vector3();
            vehicle.mesh.getWorldPosition(vehicleWorldPos);

            // 화재 방향 계산 (소방차 → 화재)
            const dirX = fireWorldX - vehicleWorldPos.x;
            const dirZ = fireWorldZ - vehicleWorldPos.z;

            // 소방차 메시의 현재 회전값 고려하여 상대 각도 계산
            const fireAngle = Math.atan2(dirX, dirZ);
            const vehicleAngle = vehicle.mesh.rotation.y;
            const relativeAngle = fireAngle - vehicleAngle;

            // 물줄기 그룹을 화재 방향으로 회전
            effect.group.rotation.y = relativeAngle;
        }

        console.log(`[Water] Started water spray effect for firetruck ${vehicle.id}`);
    }

    /**
     * 소방차 물 이펙트 중지
     */
    function stopWaterEffect(vehicle) {
        if (!vehicle) return;

        const effect = activeWaterEffects.get(vehicle.id);
        if (!effect) return;

        // 파티클 시스템 정지 및 제거
        if (effect.waterSystem) {
            effect.waterSystem.emitter.visible = false;
            batchRenderer.deleteSystem(effect.waterSystem);
        }
        if (effect.splashSystem) {
            effect.splashSystem.emitter.visible = false;
            batchRenderer.deleteSystem(effect.splashSystem);
        }

        // 그룹 제거
        if (vehicle.mesh && effect.group.parent === vehicle.mesh) {
            vehicle.mesh.remove(effect.group);
        }

        activeWaterEffects.delete(vehicle.id);

        console.log(`[Water] Stopped water spray effect for firetruck ${vehicle.id}`);
    }

    /**
     * Three.quarks 화재 이펙트 생성 (불꽃 + 연기 + 라이트)
     */
    function createFireEffect(x, y, buildingHeight = 1) {
        const fireGroup = new THREE.Group();
        fireGroup.name = `fire_${x}_${y}`;

        const worldPos = tileToWorldCenter(x, y);

        // ===== 불꽃 파티클 시스템 (Three.quarks) =====
        const flameSystem = new ParticleSystem({
            duration: 0,  // 무한 반복
            looping: true,
            startLife: new IntervalValue(0.3, 0.8),
            startSpeed: new IntervalValue(0.8, 1.5),
            startSize: new IntervalValue(0.15, 0.35),
            startRotation: new IntervalValue(0, Math.PI * 2),
            startColor: new RandomColor(
                new THREE.Vector4(1, 0.9, 0.3, 1),      // 밝은 노랑
                new THREE.Vector4(1, 0.3, 0, 1)         // 주황-빨강
            ),
            emissionOverTime: new ConstantValue(25),  // 40 -> 25 (성능 최적화)
            shape: new ConeEmitter({
                radius: 0.3,
                arc: Math.PI * 2,
                thickness: 1,
                angle: Math.PI / 8  // 좁은 원뿔
            }),
            material: new THREE.MeshBasicMaterial({
                map: fireTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            }),
            renderMode: RenderMode.BillBoard,
            renderOrder: 10,
            worldSpace: false
        });

        // 불꽃 행동 추가 (Thymeleaf 중첩배열 충돌 방지를 위해 Array() 사용)
        const flameSizeCurve = new Array(new Array(new Bezier(1, 0.8, 0.3, 0), 0));
        flameSystem.addBehavior(new SizeOverLife(new PiecewiseBezier(flameSizeCurve)));
        const flameColorStops = new Array(
            new Array(new THREE.Vector3(1, 1, 0.5), 0),           // 시작: 밝은 노랑
            new Array(new THREE.Vector3(1, 0.5, 0), 0.3),         // 중간: 주황
            new Array(new THREE.Vector3(1, 0.2, 0), 0.7),         // 끝: 빨강
            new Array(new THREE.Vector3(0.5, 0.1, 0), 1)          // 페이드: 어두운 빨강
        );
        const flameAlphaStops = new Array(
            new Array(1, 0),
            new Array(0.9, 0.5),
            new Array(0.3, 1)
        );
        flameSystem.addBehavior(new ColorOverLife(new Gradient(flameColorStops, flameAlphaStops)));
        const flameSpeedCurve = new Array(new Array(new Bezier(1, 0.5, 0.2, 0), 0));
        flameSystem.addBehavior(new SpeedOverLife(new PiecewiseBezier(flameSpeedCurve)));

        flameSystem.emitter.name = 'flames';
        flameSystem.emitter.position.set(0, buildingHeight, 0);
        flameSystem.emitter.rotation.set(-Math.PI / 2, 0, 0);  // 위를 향하게

        batchRenderer.addSystem(flameSystem);
        fireGroup.add(flameSystem.emitter);

        // ===== 연기 파티클 시스템 (Three.quarks) =====
        const smokeSystem = new ParticleSystem({
            duration: 0,
            looping: true,
            startLife: new IntervalValue(1.5, 3.0),
            startSpeed: new IntervalValue(0.3, 0.6),
            startSize: new IntervalValue(0.2, 0.5),
            startRotation: new IntervalValue(0, Math.PI * 2),
            startColor: new RandomColor(
                new THREE.Vector4(0.3, 0.3, 0.3, 0.6),
                new THREE.Vector4(0.5, 0.5, 0.5, 0.4)
            ),
            emissionOverTime: new ConstantValue(8),
            shape: new ConeEmitter({
                radius: 0.2,
                arc: Math.PI * 2,
                thickness: 1,
                angle: Math.PI / 6
            }),
            material: new THREE.MeshBasicMaterial({
                map: smokeTexture,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            }),
            renderMode: RenderMode.BillBoard,
            renderOrder: 5,
            worldSpace: false
        });

        // 연기 행동 추가 (Thymeleaf 중첩배열 충돌 방지를 위해 Array() 사용)
        const smokeSizeCurve = new Array(new Array(new Bezier(0.5, 1, 1.5, 2), 0));
        smokeSystem.addBehavior(new SizeOverLife(new PiecewiseBezier(smokeSizeCurve)));
        const smokeColorStops = new Array(
            new Array(new THREE.Vector3(0.4, 0.4, 0.4), 0),
            new Array(new THREE.Vector3(0.3, 0.3, 0.3), 0.5),
            new Array(new THREE.Vector3(0.2, 0.2, 0.2), 1)
        );
        const smokeAlphaStops = new Array(
            new Array(0.5, 0),
            new Array(0.4, 0.5),
            new Array(0, 1)
        );
        smokeSystem.addBehavior(new ColorOverLife(new Gradient(smokeColorStops, smokeAlphaStops)));
        smokeSystem.addBehavior(new RotationOverLife(new IntervalValue(-0.5, 0.5)));
        smokeSystem.addBehavior(new ForceOverLife(
            new ConstantValue(0),
            new ConstantValue(0.1),  // 약간 위로
            new IntervalValue(-0.05, 0.05)  // 약간 흔들림
        ));

        smokeSystem.emitter.name = 'smoke';
        smokeSystem.emitter.position.set(0, buildingHeight + 0.3, 0);
        smokeSystem.emitter.rotation.set(-Math.PI / 2, 0, 0);

        batchRenderer.addSystem(smokeSystem);
        fireGroup.add(smokeSystem.emitter);

        // ===== 불빛 (PointLight) - 더 강한 주황색 =====
        const fireLight = new THREE.PointLight(0xff6600, 2.5, 5);  // 범위 축소 (성능 최적화)
        fireLight.position.set(0, buildingHeight + 0.5, 0);
        fireGroup.add(fireLight);

        // 불빛 깜빡임 효과용 데이터
        fireGroup.userData.light = fireLight;
        fireGroup.userData.flameSystem = flameSystem;
        fireGroup.userData.smokeSystem = smokeSystem;
        fireGroup.userData.baseIntensity = 2.5;

        // 위치 설정
        fireGroup.position.set(worldPos.x, 0, worldPos.z);

        return { group: fireGroup, flameSystem, smokeSystem };
    }

    /**
     * Three.quarks 화재 파티클 업데이트 (불빛 깜빡임만 처리)
     * 파티클 자체는 batchRenderer에서 자동 업데이트됨
     */
    function updateFireParticles(fireData) {
        // 불빛 깜빡임 효과
        if (fireData.effects && fireData.effects.group && fireData.effects.group.userData.light) {
            const light = fireData.effects.group.userData.light;
            const baseIntensity = fireData.effects.group.userData.baseIntensity || 3;
            // 랜덤 깜빡임 (2.5 ~ 4.0)
            light.intensity = baseIntensity * (0.8 + Math.random() * 0.4);
        }
    }

    // 소방차 출동 관련 상수
    const FIRE_BURNOUT_TIME = 30000;      // 전소까지 제한 시간 30초
    const dispatchedFiretrucks = new Map(); // key: fireKey, value: { vehicle, fireStationKey }
    const stationFiretruckCount = new Map(); // key: stationKey, value: 현재 출동 중인 소방차 수
    const MAX_FIRETRUCKS_PER_STATION = 2; // 소방서당 최대 소방차 수

    /**
     * 가장 가까운 소방서 찾기 (여유 있는 소방서 우선)
     */
    function findNearestFireStation(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return null;

        let nearest = null;
        let minDistance = Infinity;

        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type !== 'fire') continue;

            // 서비스 건물 운영 상태 확인 (전력/도로)
            if (typeof serviceBuildingManager !== 'undefined' &&
                !serviceBuildingManager.isOperational(building.x, building.y)) continue;

            // 소방서 출동 가능 여부 확인 (최대 2대)
            const currentCount = stationFiretruckCount.get(key) || 0;
            if (currentCount >= MAX_FIRETRUCKS_PER_STATION) continue;

            const bx = building.x;
            const by = building.y;
            const bw = building.width || 2;
            const bd = building.depth || 2;

            const centerX = bx + bw / 2;
            const centerY = by + bd / 2;

            const dx = (x + 0.5) - centerX;
            const dy = (y + 0.5) - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < minDistance) {
                minDistance = distance;
                nearest = { key, x: bx, y: by, centerX, centerY, distance };
            }
        }

        return nearest;
    }

    /**
     * 긴급차량 사이렌 라이트 생성
     * @param {string} type - 'firetruck', 'police', 또는 'ambulance'
     * @returns {THREE.Group} 사이렌 라이트 그룹
     */
    function createSirenLights(type) {
        const sirenGroup = new THREE.Group();
        sirenGroup.name = 'sirenLights';

        // 라이트바 베이스 (검은색 박스)
        const barGeo = new THREE.BoxGeometry(0.08, 0.015, 0.03);
        const barMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const bar = new THREE.Mesh(barGeo, barMat);
        bar.position.set(0, 0.12, 0);
        sirenGroup.add(bar);

        // 타입별 색상 설정
        let leftColor, rightColor;
        if (type === 'police') {
            leftColor = 0x0066ff;   // 파랑
            rightColor = 0xff0000;  // 빨강
        } else if (type === 'ambulance') {
            leftColor = 0xff0000;   // 빨강
            rightColor = 0xffffff;  // 흰색
        } else {
            // firetruck (default)
            leftColor = 0xff0000;   // 빨강
            rightColor = 0xff6600;  // 주황
        }

        // 왼쪽 라이트
        const leftLightGeo = new THREE.SphereGeometry(0.012, 8, 8);
        const leftLightMat = new THREE.MeshBasicMaterial({
            color: leftColor,
            transparent: true,
            opacity: 1.0
        });
        const leftLight = new THREE.Mesh(leftLightGeo, leftLightMat);
        leftLight.position.set(-0.025, 0.12, 0);
        leftLight.name = 'sirenLeft';
        sirenGroup.add(leftLight);

        // 오른쪽 라이트
        const rightLightGeo = new THREE.SphereGeometry(0.012, 8, 8);
        const rightLightMat = new THREE.MeshBasicMaterial({
            color: rightColor,
            transparent: true,
            opacity: 0.3
        });
        const rightLight = new THREE.Mesh(rightLightGeo, rightLightMat);
        rightLight.position.set(0.025, 0.12, 0);
        rightLight.name = 'sirenRight';
        sirenGroup.add(rightLight);

        // 포인트 라이트 (실제 빛 효과)
        const pointLight = new THREE.PointLight(leftColor, 0.5, 1);
        pointLight.position.set(0, 0.15, 0);
        pointLight.name = 'sirenPointLight';
        sirenGroup.add(pointLight);

        // 사이렌 상태 저장
        sirenGroup.userData = {
            type: type,
            phase: 0,
            leftMat: leftLightMat,
            rightMat: rightLightMat,
            pointLight: pointLight,
            leftColor: leftColor,
            rightColor: rightColor
        };

        return sirenGroup;
    }

    /**
     * 사이렌 라이트 애니메이션 업데이트
     * @param {THREE.Group} sirenGroup - 사이렌 그룹
     * @param {number} deltaTime - 프레임 시간
     */
    function updateSirenLights(sirenGroup, deltaTime) {
        if (!sirenGroup || !sirenGroup.userData) return;

        const data = sirenGroup.userData;
        data.phase += deltaTime * 8;  // 빠른 깜빡임

        const flash = Math.sin(data.phase) > 0;

        // 왼쪽/오른쪽 번갈아 깜빡임
        data.leftMat.opacity = flash ? 1.0 : 0.2;
        data.rightMat.opacity = flash ? 0.2 : 1.0;

        // 포인트 라이트 색상 변경
        data.pointLight.color.setHex(flash ? data.leftColor : data.rightColor);
        data.pointLight.intensity = 0.3 + Math.abs(Math.sin(data.phase)) * 0.4;
    }

    /**
     * 소방차 출동
     */
    function dispatchFiretruck(fireX, fireY, fireStation) {
        if (!trafficManager || !trafficManager.initialized) {
            console.warn('[Fire] Traffic not initialized, cannot dispatch firetruck');
            return null;
        }

        // 소방서 인접 도로 찾기
        const stationRoad = trafficManager.findNearestRoad(fireStation.x, fireStation.y);
        if (!stationRoad) {
            console.warn('[Fire] No road near fire station');
            return null;
        }

        // 화재 건물 인접 도로 찾기
        const fireRoad = trafficManager.findNearestRoad(fireX, fireY);
        if (!fireRoad) {
            console.warn('[Fire] No road near fire location');
            return null;
        }

        // 경로 찾기
        const path = trafficManager.findPath(stationRoad.x, stationRoad.y, fireRoad.x, fireRoad.y);
        if (!path || path.length < 2) {
            console.warn('[Fire] No path to fire location');
            return null;
        }

        // 소방차 스폰
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) {
            console.warn('[Fire] No vehicle available');
            return null;
        }

        // 이전 사용에서 남은 속성 초기화
        vehicle.isMoveInVehicle = false;
        vehicle.isConstructionTruck = false;
        vehicle.constructionSite = null;
        vehicle.workStartTime = null;
        vehicle.isParked = false;
        vehicle.enterProgress = 0;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 소방차 타입으로 설정
        vehicle.vehicleTypeKey = 'firetruck';
        vehicle.type = 'firetruck';
        const vehicleTypeConfig = VEHICLE_TYPES['firetruck'];

        // 메쉬 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh('firetruck');
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 사이렌 라이트 추가
        const sirenLights = createSirenLights('firetruck');
        newMesh.add(sirenLights);
        vehicle.sirenLights = sirenLights;

        // 소방차 특수 속성
        vehicle.isFiretruck = true;
        vehicle.fireTarget = { x: fireX, y: fireY };
        vehicle.originBuilding = { x: fireStation.x, y: fireStation.y };
        vehicle.originStation = { x: fireStation.x, y: fireStation.y };  // 복귀용
        vehicle.stationKey = fireStation.key;  // 소방서 키 저장 (카운트 관리용)
        vehicle.destBuilding = { x: fireX, y: fireY };
        vehicle.activity = '🚒 화재 현장으로 출동 중!';
        vehicle.originTypeName = '소방서';
        vehicle.destTypeName = '화재 현장';
        vehicle.isReturning = false;

        // 소방서 출동 카운트 증가
        const currentCount = stationFiretruckCount.get(fireStation.key) || 0;
        stationFiretruckCount.set(fireStation.key, currentCount + 1);

        // 속도 설정 (소방차는 다른 차량보다 2배 빠름)
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 2.5;
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);  // 프리팹이 이미 내부 스케일 적용됨

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        console.log(`[Fire] Firetruck dispatched from (${fireStation.x},${fireStation.y}) to (${fireX},${fireY})`);
        return vehicle;
    }

    /**
     * 화재 발생
     */
    function startFire(x, y) {
        const key = `${x},${y}`;
        if (burningBuildings.has(key)) return;  // 이미 화재 중

        // 건물 높이 추정
        const building = placedBuildings.get(key);
        let buildingHeight = 1;
        if (building && building.instance) {
            const bbox = new THREE.Box3().setFromObject(building.instance);
            buildingHeight = bbox.max.y;
        }

        // 화재 이펙트 생성 (Three.quarks 파티클 시스템)
        const effects = createFireEffect(x, y, buildingHeight);
        fireEffectsGroup.add(effects.group);

        const fireData = {
            startTime: Date.now(),
            intensity: 1.0,
            effects: {
                group: effects.group,
                flameSystem: effects.flameSystem,
                smokeSystem: effects.smokeSystem
            },
            x, y,
            firetruckDispatched: false,
            firetruckArrived: false
        };

        burningBuildings.set(key, fireData);

        // 일일 통계 업데이트
        dailyStats.fire.totalFires++;
        updateDailyStatsPanel();

        console.log(`[Fire] Started at (${x}, ${y})`);

        // SNS 피드에 화재 알림
        if (typeof CitizenSNS !== 'undefined') {
            CitizenSNS.onEvent('fireStart', `(${x}, ${y}) 근처`);
        }

        // 소방서 찾아서 소방차 출동
        const nearestStation = findNearestFireStation(x, y);
        if (nearestStation) {
            const firetruck = dispatchFiretruck(x, y, nearestStation);
            if (firetruck) {
                fireData.firetruckDispatched = true;
                dispatchedFiretrucks.set(key, { vehicle: firetruck, stationKey: nearestStation.key });
            }
        }
    }

    /**
     * 건물 전소 처리 (폐건물로 전환)
     */
    function burnDownBuilding(x, y) {
        const key = `${x},${y}`;
        const building = placedBuildings.get(key);

        if (!building || !building.instance) return;

        // 폐건물로 전환
        const userData = building.instance.userData;
        if (userData) {
            userData.isAbandoned = true;
            userData.abandonedReason = '화재로 인해 전소되었습니다.';
            userData.abandonedTime = Date.now();
        }

        // 폐건물 아이콘 추가
        if (typeof addAbandonedIcon === 'function') {
            addAbandonedIcon(x, y);
        }

        // 폐건물 목록에 추가
        if (typeof abandonedBuildings !== 'undefined') {
            abandonedBuildings.add(key);
        }

        // 건물 색상을 검정색으로 변경 (전소 표시)
        building.instance.traverse((child) => {
            if (child.isMesh && child.material) {
                const burnedMaterial = child.material.clone();
                burnedMaterial.color.setHex(0x000000);  // 검정색
                child.material = burnedMaterial;
            }
        });

        console.log(`[Fire] Building burned down at (${x}, ${y})`);

        // SNS 피드에 전소 알림
        if (typeof CitizenSNS !== 'undefined') {
            CitizenSNS.onEvent('fireBurnout', `(${x}, ${y}) 근처`);
        }

        // 일일 통계 업데이트
        dailyStats.fire.burnedBuildings++;
        updateDailyStatsPanel();
        checkDailyStatsWarnings();
    }

    /**
     * 화재 진압 (소멸)
     */
    function extinguishFire(key, byFiretruck = false) {
        const fireData = burningBuildings.get(key);
        if (!fireData) return;

        // three.quarks 파티클 시스템 제거
        if (fireData.effects) {
            // 불꽃 파티클 시스템 제거
            if (fireData.effects.flameSystem) {
                batchRenderer.deleteSystem(fireData.effects.flameSystem);
                fireData.effects.flameSystem = null;
            }
            // 연기 파티클 시스템 제거
            if (fireData.effects.smokeSystem) {
                batchRenderer.deleteSystem(fireData.effects.smokeSystem);
                fireData.effects.smokeSystem = null;
            }
            // 그룹 (라이트 포함) 제거
            if (fireData.effects.group) {
                const group = fireData.effects.group;

                // 라이트 제거
                if (group.userData.light) {
                    group.remove(group.userData.light);
                    group.userData.light = null;
                }

                // 씬에서 그룹 제거
                fireEffectsGroup.remove(group);
                fireData.effects.group = null;
            }
        }

        // 출동 중인 소방차 정보 제거
        dispatchedFiretrucks.delete(key);

        burningBuildings.delete(key);
        console.log(`[Fire] Extinguished at ${key}` + (byFiretruck ? ' by firetruck' : ''));
    }

    /**
     * 소방차 도착 처리 - 잔화 작업 후 복귀
     */
    const FIRETRUCK_WORK_TIME = 5000;  // 잔화 작업 시간 (5초)

    function onFiretruckArrival(fireX, fireY, vehicle) {
        const key = `${fireX},${fireY}`;
        const fireData = burningBuildings.get(key);

        console.log(`[Fire] onFiretruckArrival called for (${fireX}, ${fireY}), fireData exists: ${!!fireData}`);

        if (!fireData) {
            // 이미 진압됨 - 잠시 대기 후 복귀 (잔화 작업 모션)
            console.log(`[Fire] Fire already extinguished at (${fireX}, ${fireY}), starting return after brief pause`);

            // 잠시 현장에서 대기 후 복귀
            if (vehicle && vehicle.mesh) {
                vehicle.state = 'working';
                vehicle.activity = '🔍 현장 확인 중...';
                vehicle.workStartTime = Date.now() - 3000;  // 2초만 대기 (5초 - 3초 = 2초)
                vehicle.isParked = true;
            } else {
                startFiretruckReturn(vehicle);
            }
            return;
        }

        fireData.firetruckArrived = true;

        // 즉시 화재 진압
        console.log(`[Fire] Extinguishing fire at (${fireX}, ${fireY})`);
        extinguishFire(key, true);

        // SNS 피드에 진화 완료 알림
        if (typeof CitizenSNS !== 'undefined') {
            CitizenSNS.onEvent('fireExtinguished', `(${fireX}, ${fireY}) 근처`);
        }

        // 일일 통계 업데이트
        dailyStats.fire.extinguishedFires++;

        // 위험물 화재 체크 (공장 건물)
        const building = placedBuildings.get(key);
        if (building && building.instance && building.instance.userData) {
            const zoneType = building.instance.userData.zoneType || '';
            if (zoneType.includes('industrial')) {
                dailyStats.fire.hazmatFires++;
            }
        }
        updateDailyStatsPanel();

        // 소방차를 갓길에 주차 (도로 옆으로 살짝 이동)
        if (vehicle && vehicle.mesh) {
            // 차량 상태를 작업 중으로 변경
            vehicle.state = 'working';
            vehicle.activity = '🧯 잔화 작업 중...';
            vehicle.workStartTime = Date.now();

            // 갓길 주차 - 현재 위치에서 도로 옆으로 살짝 이동
            const offsetX = Math.cos(vehicle.rotation) * 0.15;
            const offsetZ = Math.sin(vehicle.rotation) * 0.15;
            vehicle.parkPosition = {
                x: vehicle.position.x + offsetZ,
                z: vehicle.position.z + offsetX
            };
            vehicle.mesh.position.x = vehicle.parkPosition.x;
            vehicle.mesh.position.z = vehicle.parkPosition.z;

            // 비상등 깜빡임 효과를 위한 플래그
            vehicle.isParked = true;

            // 물 뿌리기 이펙트 시작
            startWaterEffect(vehicle);

            console.log(`[Fire] Firetruck parked at (${vehicle.parkPosition.x.toFixed(2)}, ${vehicle.parkPosition.z.toFixed(2)}), state: ${vehicle.state}`);
        } else {
            console.warn(`[Fire] Vehicle or mesh is null in onFiretruckArrival`);
        }
    }

    /**
     * 다른 화재가 있는지 확인하고 있으면 재출동
     * @returns {boolean} 재출동 했으면 true
     */
    function redirectFiretruckToNewFire(vehicle) {
        if (!vehicle || !burningBuildings || burningBuildings.size === 0) return false;

        // 현재 차량 위치
        const currentX = Math.floor(vehicle.position.x / TILE_SIZE + GRID_W / 2);
        const currentY = Math.floor(vehicle.position.z / TILE_SIZE + GRID_H / 2);

        // 출동 안 한 화재 찾기 (가장 가까운 것)
        let nearestFire = null;
        let nearestDist = Infinity;

        burningBuildings.forEach((fireData, key) => {
            // 이미 소방차가 출동했거나 도착한 화재는 스킵
            if (fireData.firetruckDispatched || fireData.firetruckArrived) return;

            const dist = Math.abs(fireData.x - currentX) + Math.abs(fireData.y - currentY);
            if (dist < nearestDist) {
                nearestDist = dist;
                nearestFire = { key, data: fireData };
            }
        });

        if (!nearestFire) return false;

        // 화재 위치로 경로 계산
        const currentRoadTile = findNearestRoadTile(currentX, currentY);
        if (!currentRoadTile) return false;

        const fireRoad = trafficManager.findNearestRoad(nearestFire.data.x, nearestFire.data.y);
        if (!fireRoad) return false;

        const path = trafficManager.findPath(currentRoadTile.x, currentRoadTile.y, fireRoad.x, fireRoad.y);
        if (!path || path.length < 2) return false;

        // 재출동 설정
        vehicle.isReturning = false;
        vehicle.fireTarget = { x: nearestFire.data.x, y: nearestFire.data.y };
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = { x: path[1].x, y: path[1].y };
        vehicle.progress = 0;
        vehicle.state = 'moving';
        vehicle.isParked = false;
        vehicle.activity = '🔥 다른 화재 현장으로 출동 중!';
        vehicle.destTypeName = '화재 현장';

        // 출동 속도로 설정
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 1.5;
        vehicle.targetSpeed = vehicle.speed;

        // 화재 데이터 업데이트
        nearestFire.data.firetruckDispatched = true;
        dispatchedFiretrucks.set(nearestFire.key, { vehicle, stationKey: vehicle.originStation?.key });

        console.log(`[Fire] Firetruck redirected to fire at (${nearestFire.data.x}, ${nearestFire.data.y})`);

        toast({
            title: '🚒 소방차 재출동!',
            desc: `(${nearestFire.data.x}, ${nearestFire.data.y}) 화재에 인근 소방차가 출동합니다!`,
            ms: 3000
        });

        return true;
    }

    /**
     * 소방차 소방서 복귀 시작
     */
    function startFiretruckReturn(vehicle) {
        if (!vehicle || !vehicle.originStation) {
            if (vehicle) {
                stopWaterEffect(vehicle);  // 물 이펙트 정지
                trafficManager.despawnVehicle(vehicle);
            }
            return;
        }

        // 물 뿌리기 이펙트 중지
        stopWaterEffect(vehicle);

        // 다른 화재가 있으면 재출동
        if (redirectFiretruckToNewFire(vehicle)) {
            return;
        }

        const stationX = vehicle.originStation.x;
        const stationY = vehicle.originStation.y;

        // 현재 위치에서 가장 가까운 도로 타일 찾기
        const currentRoadTile = findNearestRoadTile(
            Math.floor(vehicle.position.x / TILE_SIZE + GRID_W / 2),
            Math.floor(vehicle.position.z / TILE_SIZE + GRID_H / 2)
        );

        if (!currentRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 소방서 주변 도로 찾기
        const stationRoadTile = findNearestRoadTile(stationX, stationY);
        if (!stationRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 경로 계산
        const returnPath = trafficManager.findPath(
            currentRoadTile.x, currentRoadTile.y,
            stationRoadTile.x, stationRoadTile.y
        );

        if (!returnPath || returnPath.length < 2) {
            console.log('[Fire] No return path found, despawning');
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 모드 설정
        vehicle.isReturning = true;
        vehicle.fireTarget = null;
        vehicle.path = returnPath;
        vehicle.pathIndex = 0;
        vehicle.currentTile = { x: returnPath[0].x, y: returnPath[0].y };
        vehicle.targetTile = { x: returnPath[1].x, y: returnPath[1].y };
        vehicle.progress = 0;
        vehicle.state = 'moving';
        vehicle.isParked = false;
        vehicle.activity = '🏠 소방서로 복귀 중';
        vehicle.destTypeName = '소방서';

        // 속도를 일반 속도로 낮춤
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 1.15;
        vehicle.targetSpeed = vehicle.speed;

        console.log(`[Fire] Firetruck returning to station at (${stationX}, ${stationY})`);
    }

    /**
     * 가장 가까운 도로 타일 찾기
     */
    function findNearestRoadTile(x, y) {
        // 주변 탐색 범위
        const searchRadius = 5;

        for (let r = 0; r <= searchRadius; r++) {
            for (let dx = -r; dx <= r; dx++) {
                for (let dy = -r; dy <= r; dy++) {
                    if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;

                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx < 0 || ny < 0 || nx >= GRID_W || ny >= GRID_H) continue;

                    // isRoad 함수 사용 (mapData 스코프 문제 해결)
                    if (typeof isRoad === 'function' && isRoad(nx, ny)) {
                        return { x: nx, y: ny };
                    }
                }
            }
        }
        return null;
    }

    /**
     * 건물이 소방서 범위 내에 있는지 확인
     * 소방서의 효과 범위는 전 지역 (소방서가 하나라도 있으면 true)
     */
    function isInFireStationRange(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return false;

        // 소방서가 하나라도 있으면 전 지역 커버
        for (const [, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'fire') {
                return true;
            }
        }
        return false;
    }

    /**
     * 화재 발생 체크 (주기적 호출)
     */
    function checkFireOutbreak() {
        if (typeof placedBuildings === 'undefined') return;

        const now = Date.now();
        if (now - lastFireCheck < FIRE_CHECK_INTERVAL) return;
        lastFireCheck = now;

        // 민간 건물 목록 수집
        const civilianBuildings = [];
        placedBuildings.forEach((building, key) => {
            if (building.ref) return;
            const userData = building.instance?.userData;
            if (!userData) return;
            if (userData.isAbandoned) return;

            const zoneType = userData.zoneType || '';
            if (zoneType.includes('resident') || zoneType.includes('commercial') || zoneType.includes('industrial')) {
                civilianBuildings.push({
                    key,
                    x: building.x,
                    y: building.y,
                    zoneType,
                    isIndustrial: zoneType.includes('industrial')
                });
            }
        });

        if (civilianBuildings.length === 0) return;

        // 각 건물에 대해 화재 발생 확률 체크
        for (const building of civilianBuildings) {
            const key = building.key;
            if (burningBuildings.has(key)) continue;  // 이미 화재 중

            // 화재 확률 계산
            let fireChance = FIRE_BASE_CHANCE;

            // 공장은 화재 확률 증가
            if (building.isIndustrial) {
                fireChance *= FIRE_INDUSTRIAL_MULTIPLIER;
            }

            // 소방서 범위 내면 화재 확률 대폭 감소
            if (isInFireStationRange(building.x, building.y)) {
                fireChance *= 0.1;  // 90% 감소
            }

            // 인접 건물이 화재 중이면 전파 확률 추가
            const neighbors = [
                `${building.x - 1},${building.y}`,
                `${building.x + 1},${building.y}`,
                `${building.x},${building.y - 1}`,
                `${building.x},${building.y + 1}`
            ];

            for (const neighborKey of neighbors) {
                if (burningBuildings.has(neighborKey)) {
                    fireChance += FIRE_SPREAD_CHANCE;
                    break;  // 인접 화재는 한 번만 적용
                }
            }

            // 확률 체크
            if (Math.random() < fireChance) {
                startFire(building.x, building.y);
            }
        }
    }

    /**
     * 화재 진행 업데이트 (제한시간 체크)
     */
    let lastFiretruckRetryTime = 0;
    const FIRETRUCK_RETRY_INTERVAL = 5000;  // 5초마다 소방차 출동 재시도

    function updateFireProgress() {
        const now = Date.now();

        burningBuildings.forEach((fireData, key) => {
            // 파티클 애니메이션 업데이트
            updateFireParticles(fireData);

            // 소방차가 도착했으면 이미 처리됨
            if (fireData.firetruckArrived) return;

            // 제한시간 체크 (소방차가 도착하지 못하면 전소)
            const elapsed = now - fireData.startTime;

            if (elapsed >= FIRE_BURNOUT_TIME) {
                // 건물 전소
                burnDownBuilding(fireData.x, fireData.y);
                extinguishFire(key);
            }
        });

        // 소방차 출동 재시도 (소방서가 생겼을 때를 위해)
        if (now - lastFiretruckRetryTime > FIRETRUCK_RETRY_INTERVAL) {
            lastFiretruckRetryTime = now;
            retryFiretruckDispatch();
        }
    }

    /**
     * 소방차 출동 재시도 (출동하지 않은 화재에 대해)
     */
    function retryFiretruckDispatch() {
        burningBuildings.forEach((fireData, key) => {
            // 이미 소방차가 출동했거나 도착했으면 스킵
            if (fireData.firetruckDispatched || fireData.firetruckArrived) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            // 소방서 찾기
            const nearestStation = findNearestFireStation(x, y);
            if (!nearestStation) return;

            // 소방차 출동
            const firetruck = dispatchFiretruck(x, y, nearestStation);
            if (firetruck) {
                fireData.firetruckDispatched = true;
                dispatchedFiretrucks.set(key, { vehicle: firetruck, stationKey: nearestStation.key });
                console.log(`[Fire] Retry dispatched firetruck to fire at (${x}, ${y})`);

                toast({
                    title: '🚒 소방차 출동!',
                    desc: `(${x}, ${y}) 화재에 소방차가 출동했습니다!`,
                    ms: 3000
                });
            }
        });
    }

    /**
     * 화재 시스템 전체 업데이트 (animate에서 호출)
     */
    function updateFireSystem() {
        checkFireOutbreak();
        updateFireProgress();
    }

    /**
     * 소방서 설치 시 기존 화재에 소방차 출동
     * (소방차가 아직 출동하지 않은 화재에 대해 출동)
     */
    function dispatchFiretrucksToExistingFires() {
        if (!burningBuildings || burningBuildings.size === 0) return;

        let dispatched = 0;

        burningBuildings.forEach((fireData, key) => {
            // 이미 소방차가 출동한 화재는 스킵
            if (fireData.firetruckDispatched) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            // 소방서 찾기
            const nearestStation = findNearestFireStation(x, y);
            if (!nearestStation) return;

            // 소방차 출동
            const firetruck = dispatchFiretruck(x, y, nearestStation);
            if (firetruck) {
                fireData.firetruckDispatched = true;
                dispatchedFiretrucks.set(key, { vehicle: firetruck, stationKey: nearestStation.key });
                dispatched++;
                console.log(`[Fire] Dispatched firetruck to existing fire at (${x}, ${y})`);
            }
        });

        if (dispatched > 0) {
            toast({
                title: '🚒 소방차 출동!',
                desc: `${dispatched}건의 화재에 소방차가 출동했습니다!`,
                ms: 3000
            });
        }
    }

    // ===== 강도 사건 시스템 (CRIME SYSTEM) =====
    // 강도 사건 관련 상수
    const CRIME_BASE_CHANCE = 0.00002;          // 기본 발생 확률 (프레임당) - 대폭 감소
    const CRIME_COMMERCIAL_MULTIPLIER = 3.0;    // 상업 건물 발생 확률 배수
    const CRIME_RESOLUTION_TIME = 25000;        // 미해결 시 피해 시간 25초
    const CRIME_RETRY_INTERVAL = 5000;          // 경찰차 재출동 간격 5초
    const CRIME_POLICE_WORK_TIME = 4000;        // 현장 조사 시간 4초
    const CRIME_DAMAGE_HAPPINESS = -15;         // 미해결 시 행복도 피해
    const CRIME_DAMAGE_MONEY = 500;             // 미해결 시 자금 피해

    // 감옥 시스템 상수
    const MAX_PRISONERS_PER_STATION = 5;        // 경찰서당 최대 수감 인원
    const PRISONER_RELEASE_TIME = 30000;        // 수감자 석방 시간 (30초)

    // 강도 사건 데이터 구조
    const activeCrimes = new Map();             // key: "x,y", value: crimeData
    const dispatchedPoliceCars = new Map();     // key: crimeKey, value: { vehicle, stationKey }
    const stationPoliceCount = new Map();       // key: stationKey, value: 출동 중 경찰차 수
    const MAX_POLICE_PER_STATION = 2;           // 경찰서당 최대 경찰차 수
    const stationPrisoners = new Map();         // key: stationKey, value: [{ arrestTime }]
    let lastCrimeRetryTime = 0;
    let lastPrisonerReleaseCheck = 0;

    /**
     * 가장 가까운 경찰서 찾기 (여유 있는 경찰서 우선, 감옥 정원 체크)
     */
    function findNearestPoliceStation(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return null;

        let nearest = null;
        let minDistance = Infinity;

        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type !== 'police') continue;

            // 현재 출동 중인 경찰차 수 체크
            const currentCount = stationPoliceCount.get(key) || 0;
            if (currentCount >= MAX_POLICE_PER_STATION) continue;

            // 감옥 정원 체크 - 가득 차면 출동 불가
            const prisoners = stationPrisoners.get(key) || [];
            if (prisoners.length >= MAX_PRISONERS_PER_STATION) {
                console.log(`[Crime] Station ${key} prison full (${prisoners.length}/${MAX_PRISONERS_PER_STATION})`);
                continue;
            }

            // 경찰서 중심 좌표 계산
            const bx = building.x;
            const by = building.y;
            const centerX = bx + 1;  // 2x2 건물 중심
            const centerY = by + 1;

            const dx = centerX - x;
            const dy = centerY - y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < minDistance) {
                minDistance = distance;
                nearest = { key, x: bx, y: by, centerX, centerY, distance };
            }
        }

        return nearest;
    }

    /**
     * 경찰서에 수감자 추가
     */
    function addPrisoner(stationKey) {
        if (!stationKey) return;
        const prisoners = stationPrisoners.get(stationKey) || [];
        prisoners.push({ arrestTime: Date.now() });
        stationPrisoners.set(stationKey, prisoners);
        console.log(`[Crime] Prisoner added to ${stationKey} (${prisoners.length}/${MAX_PRISONERS_PER_STATION})`);
    }

    /**
     * 수감자 석방 (시간이 지난 수감자)
     */
    function releasePrisoners() {
        const now = Date.now();
        let totalReleased = 0;

        for (const [stationKey, prisoners] of stationPrisoners) {
            const remaining = prisoners.filter(p => (now - p.arrestTime) < PRISONER_RELEASE_TIME);
            const released = prisoners.length - remaining.length;
            if (released > 0) {
                stationPrisoners.set(stationKey, remaining);
                totalReleased += released;
                console.log(`[Crime] ${released} prisoner(s) released from ${stationKey} (${remaining.length}/${MAX_PRISONERS_PER_STATION})`);
            }
        }

        return totalReleased;
    }

    /**
     * 전체 수감자 수 계산
     */
    function getTotalPrisoners() {
        let total = 0;
        for (const [, prisoners] of stationPrisoners) {
            total += prisoners.length;
        }
        return total;
    }

    /**
     * 전체 감옥 정원 계산
     */
    function getTotalPrisonCapacity() {
        let capacity = 0;
        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'police') {
                capacity += MAX_PRISONERS_PER_STATION;
            }
        }
        return capacity;
    }

    /**
     * 경찰차 출동
     */
    function dispatchPoliceCar(crimeX, crimeY, policeStation) {
        if (!trafficManager || !trafficManager.initialized) {
            console.warn('[Crime] Traffic not initialized, cannot dispatch police');
            return null;
        }

        // 경찰서 인접 도로 찾기
        const stationRoad = trafficManager.findNearestRoad(policeStation.x, policeStation.y);
        if (!stationRoad) {
            console.warn('[Crime] No road near police station');
            return null;
        }

        // 범죄 현장 인접 도로 찾기
        const crimeRoad = trafficManager.findNearestRoad(crimeX, crimeY);
        if (!crimeRoad) {
            console.warn('[Crime] No road near crime location');
            return null;
        }

        // 경로 찾기
        const path = trafficManager.findPath(stationRoad.x, stationRoad.y, crimeRoad.x, crimeRoad.y);
        if (!path || path.length < 2) {
            console.warn('[Crime] No path to crime location');
            return null;
        }

        // 경찰차 스폰
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) {
            console.warn('[Crime] No vehicle available');
            return null;
        }

        // 이전 사용에서 남은 속성 초기화
        vehicle.isFiretruck = false;
        vehicle.isMoveInVehicle = false;
        vehicle.isConstructionTruck = false;
        vehicle.constructionSite = null;
        vehicle.fireTarget = null;
        vehicle.isReturning = false;
        vehicle.workStartTime = null;
        vehicle.isParked = false;
        vehicle.enterProgress = 0;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 경찰차 타입으로 설정
        vehicle.vehicleTypeKey = 'police';
        vehicle.type = 'police';
        const vehicleTypeConfig = VEHICLE_TYPES['police'];

        // 메쉬 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh('police');
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 사이렌 라이트 추가
        const sirenLights = createSirenLights('police');
        newMesh.add(sirenLights);
        vehicle.sirenLights = sirenLights;

        // 경찰차 특수 속성
        vehicle.isPoliceCar = true;
        vehicle.crimeTarget = { x: crimeX, y: crimeY };
        vehicle.originBuilding = { x: policeStation.x, y: policeStation.y };
        vehicle.originStation = { x: policeStation.x, y: policeStation.y };
        vehicle.stationKey = policeStation.key;
        vehicle.destBuilding = { x: crimeX, y: crimeY };
        vehicle.activity = '🚔 범죄 현장으로 출동 중!';
        vehicle.originTypeName = '경찰서';
        vehicle.destTypeName = '범죄 현장';
        vehicle.isReturning = false;

        // 경찰서 출동 카운트 증가
        const currentCount = stationPoliceCount.get(policeStation.key) || 0;
        stationPoliceCount.set(policeStation.key, currentCount + 1);

        // 속도 설정 (경찰차는 다른 차량보다 빠름)
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 2.3;
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        console.log(`[Crime] Police car dispatched from (${policeStation.x},${policeStation.y}) to (${crimeX},${crimeY})`);
        return vehicle;
    }

    /**
     * 강도 사건 발생
     */
    function startCrime(x, y, isCommercial = false) {
        const key = `${x},${y}`;
        if (activeCrimes.has(key)) return;  // 이미 사건 진행 중

        // 강도 사건 이펙트 생성
        const effects = createCrimeEffect(x, y);

        const crimeData = {
            startTime: Date.now(),
            effects: effects,
            x, y,
            isCommercial,
            policeDispatched: false,
            policeArrived: false
        };

        activeCrimes.set(key, crimeData);

        // 일일 통계 업데이트
        dailyStats.crime.totalCrimes++;
        updateDailyStatsPanel();

        console.log(`[Crime] Started at (${x}, ${y}), commercial: ${isCommercial}`);

        // 경찰서 찾아서 경찰차 출동
        const nearestStation = findNearestPoliceStation(x, y);
        if (nearestStation) {
            const policeCar = dispatchPoliceCar(x, y, nearestStation);
            if (policeCar) {
                crimeData.policeDispatched = true;
                dispatchedPoliceCars.set(key, { vehicle: policeCar, stationKey: nearestStation.key });
            }
        }
    }

    /**
     * 강도 사건 이펙트 생성 (수갑 아이콘)
     */
    function createCrimeEffect(x, y) {
        const group = new THREE.Group();

        // 건물 높이 추정
        const building = placedBuildings.get(`${x},${y}`);
        let buildingHeight = 1;
        if (building && building.instance) {
            const bbox = new THREE.Box3().setFromObject(building.instance);
            buildingHeight = bbox.max.y;
        }

        // 사이렌 아이콘 스프라이트 (빨간 배경 원 + 사이렌)
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = 128;
        iconCanvas.height = 128;
        const ctx = iconCanvas.getContext('2d');

        // 빨간 원 배경 (깜빡임용)
        ctx.beginPath();
        ctx.arc(64, 64, 56, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 4;
        ctx.stroke();

        // 사이렌 이모지
        ctx.font = '64px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('🚨', 64, 64);

        const texture = new THREE.CanvasTexture(iconCanvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(0.6, 0.6, 1);
        sprite.position.set(0, buildingHeight + 0.5, 0);
        sprite.name = 'crimeIcon';
        group.add(sprite);

        // 아이콘 애니메이션 데이터
        group.userData = {
            phase: 0,
            baseY: buildingHeight + 0.5,
            spriteMaterial: spriteMaterial
        };

        // 월드 좌표로 배치
        const worldPos = tileToWorldCenter(x, y);
        group.position.set(worldPos.x, 0, worldPos.z);

        // 이펙트 그룹에 추가
        if (typeof fireEffectsGroup !== 'undefined') {
            fireEffectsGroup.add(group);
        }

        return {
            group,
            sprite
        };
    }

    /**
     * 강도 사건 해결
     */
    function resolveCrime(key, byPolice = false) {
        const crimeData = activeCrimes.get(key);
        if (!crimeData) return;

        // 이펙트 제거
        if (crimeData.effects && crimeData.effects.group) {
            const group = crimeData.effects.group;

            // 먼저 모든 자식을 숨김 (렌더링 방지)
            group.traverse((child) => {
                child.visible = false;
            });

            // 씬에서 제거
            if (typeof fireEffectsGroup !== 'undefined') {
                fireEffectsGroup.remove(group);
            }

            // 다음 프레임에서 dispose (렌더링 완료 후)
            requestAnimationFrame(() => {
                group.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        // CanvasTexture는 dispose 후 가비지 컬렉터가 정리
                        // 재질만 명시적으로 dispose
                        child.material.dispose();
                    }
                });
            });

            // 참조 정리
            crimeData.effects.group = null;
            crimeData.effects.sprite = null;
        }

        // 출동 중인 경찰차 정보 제거
        dispatchedPoliceCars.delete(key);

        activeCrimes.delete(key);
        console.log(`[Crime] Resolved at ${key}` + (byPolice ? ' by police' : ' (escaped)'));

        // SNS 피드에 치안 이벤트 알림
        if (byPolice && typeof CitizenSNS !== 'undefined') {
            CitizenSNS.onEvent('crimeHandled', `(${crimeData.x}, ${crimeData.y}) 근처`);
        }
    }

    /**
     * 경찰차 도착 처리
     */
    function onPoliceCarArrival(crimeX, crimeY, vehicle) {
        const key = `${crimeX},${crimeY}`;
        const crimeData = activeCrimes.get(key);

        console.log(`[Crime] onPoliceCarArrival called for (${crimeX}, ${crimeY}), crimeData exists: ${!!crimeData}`);

        if (!crimeData) {
            // 이미 해결됨 - 잠시 대기 후 복귀
            console.log(`[Crime] Crime already resolved at (${crimeX}, ${crimeY})`);

            if (vehicle && vehicle.mesh) {
                vehicle.state = 'working';
                vehicle.activity = '🔍 현장 확인 중...';
                vehicle.workStartTime = Date.now() - 2000;  // 2초만 대기
                vehicle.isParked = true;
            } else {
                startPoliceCarReturn(vehicle);
            }
            return;
        }

        crimeData.policeArrived = true;

        // 범인 체포 (사건 해결)
        console.log(`[Crime] Resolving crime at (${crimeX}, ${crimeY})`);
        resolveCrime(key, true);

        // 수감자 추가 (범인 체포)
        if (vehicle && vehicle.stationKey) {
            addPrisoner(vehicle.stationKey);
        }

        // 일일 통계 업데이트 - 체포된 범죄자
        dailyStats.crime.arrestedCriminals++;
        updateDailyStatsPanel();

        // 경찰차 현장 조사 후 복귀
        if (vehicle && vehicle.mesh) {
            vehicle.state = 'working';
            vehicle.activity = '📋 현장 조사 중...';
            vehicle.workStartTime = Date.now();

            // 갓길 주차
            const offsetX = Math.cos(vehicle.rotation) * 0.15;
            const offsetZ = Math.sin(vehicle.rotation) * 0.15;
            vehicle.parkPosition = {
                x: vehicle.position.x + offsetZ,
                z: vehicle.position.z + offsetX
            };
            vehicle.mesh.position.x = vehicle.parkPosition.x;
            vehicle.mesh.position.z = vehicle.parkPosition.z;
            vehicle.isParked = true;

            console.log(`[Crime] Police car parked, state: ${vehicle.state}`);
        }
    }

    /**
     * 다른 범죄가 있는지 확인하고 있으면 재출동
     * @returns {boolean} 재출동 했으면 true
     */
    function redirectPoliceCarToNewCrime(vehicle) {
        if (!vehicle || !activeCrimes || activeCrimes.size === 0) return false;

        // 현재 차량 위치
        const currentX = Math.floor(vehicle.position.x / TILE_SIZE + GRID_W / 2);
        const currentY = Math.floor(vehicle.position.z / TILE_SIZE + GRID_H / 2);

        // 출동 안 한 범죄 찾기 (가장 가까운 것)
        let nearestCrime = null;
        let nearestDist = Infinity;

        activeCrimes.forEach((crimeData, key) => {
            // 이미 경찰차가 출동했거나 도착한 범죄는 스킵
            if (crimeData.policeDispatched || crimeData.policeArrived) return;

            const dist = Math.abs(crimeData.x - currentX) + Math.abs(crimeData.y - currentY);
            if (dist < nearestDist) {
                nearestDist = dist;
                nearestCrime = { key, data: crimeData };
            }
        });

        if (!nearestCrime) return false;

        // 범죄 위치로 경로 계산
        const currentRoadTile = findNearestRoadTile(currentX, currentY);
        if (!currentRoadTile) return false;

        const crimeRoad = trafficManager.findNearestRoad(nearestCrime.data.x, nearestCrime.data.y);
        if (!crimeRoad) return false;

        const path = trafficManager.findPath(currentRoadTile.x, currentRoadTile.y, crimeRoad.x, crimeRoad.y);
        if (!path || path.length < 2) return false;

        // 재출동 설정
        vehicle.isReturning = false;
        vehicle.crimeTarget = { x: nearestCrime.data.x, y: nearestCrime.data.y };
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = { x: path[1].x, y: path[1].y };
        vehicle.progress = 0;
        vehicle.state = 'moving';
        vehicle.isParked = false;
        vehicle.activity = '🚔 다른 범죄 현장으로 출동 중!';
        vehicle.destTypeName = '범죄 현장';

        // 출동 속도로 설정
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 1.5;
        vehicle.targetSpeed = vehicle.speed;

        // 범죄 데이터 업데이트
        nearestCrime.data.policeDispatched = true;
        dispatchedPoliceCars.set(nearestCrime.key, { vehicle, stationKey: vehicle.originStation?.key });

        console.log(`[Crime] Police car redirected to crime at (${nearestCrime.data.x}, ${nearestCrime.data.y})`);

        toast({
            title: '🚔 경찰차 재출동!',
            desc: `(${nearestCrime.data.x}, ${nearestCrime.data.y}) 사건에 인근 경찰차가 출동합니다!`,
            ms: 3000
        });

        return true;
    }

    /**
     * 경찰차 경찰서 복귀 시작
     */
    function startPoliceCarReturn(vehicle) {
        if (!vehicle || !vehicle.originStation) {
            if (vehicle) trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 다른 범죄가 있으면 재출동
        if (redirectPoliceCarToNewCrime(vehicle)) {
            return;
        }

        const stationX = vehicle.originStation.x;
        const stationY = vehicle.originStation.y;

        // 현재 위치에서 가장 가까운 도로 타일 찾기
        const currentRoadTile = findNearestRoadTile(
            Math.floor(vehicle.position.x / TILE_SIZE + GRID_W / 2),
            Math.floor(vehicle.position.z / TILE_SIZE + GRID_H / 2)
        );

        if (!currentRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 경찰서 주변 도로 찾기
        const stationRoadTile = findNearestRoadTile(stationX, stationY);
        if (!stationRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 경로 계산
        const returnPath = trafficManager.findPath(
            currentRoadTile.x, currentRoadTile.y,
            stationRoadTile.x, stationRoadTile.y
        );

        if (!returnPath || returnPath.length < 2) {
            console.log('[Crime] No return path found, despawning');
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 모드 설정
        vehicle.isReturning = true;
        vehicle.crimeTarget = null;
        vehicle.path = returnPath;
        vehicle.pathIndex = 0;
        vehicle.currentTile = { x: returnPath[0].x, y: returnPath[0].y };
        vehicle.targetTile = { x: returnPath[1].x, y: returnPath[1].y };
        vehicle.progress = 0;
        vehicle.state = 'moving';
        vehicle.isParked = false;
        vehicle.activity = '🏠 경찰서로 복귀 중';
        vehicle.destTypeName = '경찰서';

        // 속도를 일반 속도로 낮춤
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 1.15;
        vehicle.targetSpeed = vehicle.speed;

        console.log(`[Crime] Police car returning to station at (${stationX}, ${stationY})`);
    }

    /**
     * 건물이 경찰서 범위 내에 있는지 확인
     */
    function isInPoliceStationRange(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return false;

        // 경찰서가 하나라도 있으면 범위 내로 간주 (전역 효과)
        for (const [, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'police') {
                return true;
            }
        }
        return false;
    }

    /**
     * 강도 사건 발생 체크 (확률 기반)
     */
    function checkCrimeOutbreak() {
        if (typeof placedBuildings === 'undefined') return;

        // 경찰서 범위 체크 - 경찰서가 있으면 발생 확률 크게 감소
        const hasPolice = isInPoliceStationRange(0, 0);
        const policeReduction = hasPolice ? 0.3 : 1.0;  // 경찰서 있으면 30%로 감소

        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData || userData.isAbandoned) continue;

            // 이미 사건 중이면 스킵
            if (activeCrimes.has(key)) continue;

            // 건물 타입 확인
            const zoneType = userData.zoneType || '';
            const isCommercial = zoneType.includes('commercial');
            const isResidential = zoneType.includes('resident');

            if (!isCommercial && !isResidential) continue;

            // 발생 확률 계산
            let crimeChance = CRIME_BASE_CHANCE * policeReduction;
            if (isCommercial) {
                crimeChance *= CRIME_COMMERCIAL_MULTIPLIER;  // 상업 건물은 3배 확률
            }

            // 확률 체크
            if (Math.random() < crimeChance) {
                startCrime(x, y, isCommercial);
            }
        }
    }

    /**
     * 강도 사건 진행 업데이트
     */
    function updateCrimeProgress() {
        const now = Date.now();

        activeCrimes.forEach((crimeData, key) => {
            // 이펙트 애니메이션 업데이트
            updateCrimeEffects(crimeData);

            // 경찰이 도착했으면 이미 처리됨
            if (crimeData.policeArrived) return;

            // 제한시간 체크 (경찰이 도착하지 못하면 범인 도주)
            const elapsed = now - crimeData.startTime;

            if (elapsed >= CRIME_RESOLUTION_TIME) {
                // 범인 도주 - 피해 발생
                applyCrimeDamage(crimeData.x, crimeData.y, crimeData.isCommercial);
                resolveCrime(key, false);
            }
        });

        // 경찰차 출동 재시도
        if (now - lastCrimeRetryTime > CRIME_RETRY_INTERVAL) {
            lastCrimeRetryTime = now;
            retryCrimeDispatch();
        }
    }

    /**
     * 범죄 피해 적용 (체포 실패 시 건물 폐건물화)
     */
    function applyCrimeDamage(x, y, isCommercial) {
        // 일일 통계 업데이트 - 도주한 범죄자
        dailyStats.crime.escapedCriminals++;
        updateDailyStatsPanel();
        checkDailyStatsWarnings();

        // 돈 피해 (상업 건물은 2배)
        const moneyDamage = isCommercial ? CRIME_DAMAGE_MONEY * 2 : CRIME_DAMAGE_MONEY;
        if (typeof economy !== 'undefined') {
            economy.money = Math.max(0, economy.money - moneyDamage);
        }

        // 건물을 폐건물로 전환 (강도 사건으로 인한 이탈)
        const key = `${x},${y}`;
        const building = placedBuildings.get(key);
        if (building && building.instance) {
            const userData = building.instance.userData;
            if (userData && !userData.isAbandoned) {
                // 폐건물 사유 저장
                userData.abandonedReason = '강도 사건 때문에 못살겠어요!';
                markBuildingAbandoned(building, key);
            }
        }

        console.log(`[Crime] Damage applied: building abandoned at (${x}, ${y}), money -${moneyDamage}`);

        // SNS 피드에 치안 실패 이벤트 알림
        if (typeof CitizenSNS !== 'undefined') {
            CitizenSNS.onEvent('crimeFailed', `(${x}, ${y}) 근처`);
        }
    }

    /**
     * 강도 사건 이펙트 업데이트 (애니메이션)
     */
    function updateCrimeEffects(crimeData) {
        if (!crimeData.effects || !crimeData.effects.group) return;

        const time = Date.now() / 1000;
        const userData = crimeData.effects.group.userData;
        if (!userData) return;

        // 수갑 아이콘 위아래 흔들림 + 깜빡임
        if (crimeData.effects.sprite) {
            const bobbing = Math.sin(time * 4) * 0.1;
            crimeData.effects.sprite.position.y = userData.baseY + bobbing;

            // 깜빡임 효과
            if (userData.spriteMaterial) {
                userData.spriteMaterial.opacity = 0.7 + Math.sin(time * 6) * 0.3;
            }
        }
    }

    /**
     * 경찰차 출동 재시도
     */
    function retryCrimeDispatch() {
        activeCrimes.forEach((crimeData, key) => {
            if (crimeData.policeDispatched || crimeData.policeArrived) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            const nearestStation = findNearestPoliceStation(x, y);
            if (!nearestStation) return;

            const policeCar = dispatchPoliceCar(x, y, nearestStation);
            if (policeCar) {
                crimeData.policeDispatched = true;
                dispatchedPoliceCars.set(key, { vehicle: policeCar, stationKey: nearestStation.key });
                console.log(`[Crime] Retry dispatched police to crime at (${x}, ${y})`);
            }
        });
    }

    /**
     * 경찰서 설치 시 기존 사건에 경찰차 출동
     */
    function dispatchPoliceToExistingCrimes() {
        if (!activeCrimes || activeCrimes.size === 0) return;

        let dispatched = 0;

        activeCrimes.forEach((crimeData, key) => {
            if (crimeData.policeDispatched) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            const nearestStation = findNearestPoliceStation(x, y);
            if (!nearestStation) return;

            const policeCar = dispatchPoliceCar(x, y, nearestStation);
            if (policeCar) {
                crimeData.policeDispatched = true;
                dispatchedPoliceCars.set(key, { vehicle: policeCar, stationKey: nearestStation.key });
                dispatched++;

                console.log(`[Crime] Dispatched police to existing crime at (${x}, ${y})`);
            }
        });

        if (dispatched > 0) {
            toast({
                title: '🚔 경찰차 출동!',
                desc: `${dispatched}건의 사건에 경찰차가 출동했습니다!`,
                ms: 3000
            });
        }
    }

    /**
     * 강도 사건 시스템 전체 업데이트
     */
    function updateCrimeSystem() {
        checkCrimeOutbreak();
        updateCrimeProgress();

        // 수감자 석방 체크 (5초마다)
        const now = Date.now();
        if (now - lastPrisonerReleaseCheck > 5000) {
            releasePrisoners();
            lastPrisonerReleaseCheck = now;
        }
    }

    // ===== 의료 응급 시스템 (MEDICAL EMERGENCY SYSTEM) =====
    // 의료 응급 관련 상수
    const MEDICAL_BASE_CHANCE = 0.000015;          // 기본 발생 확률 (프레임당)
    const MEDICAL_DEATH_TIME = 30000;               // 미치료 시 사망 시간 30초
    const MEDICAL_RETRY_INTERVAL = 5000;            // 구급차 재출동 간격 5초
    const MEDICAL_AMBULANCE_WORK_TIME = 5000;       // 환자 이송 준비 시간 5초
    const MEDICAL_DAMAGE_HAPPINESS = -20;           // 사망 시 행복도 피해

    // 병원 시스템 상수
    const MAX_PATIENTS_PER_HOSPITAL = 8;            // 병원당 최대 환자 수용
    const PATIENT_DISCHARGE_TIME = 45000;           // 환자 퇴원 시간 (45초)
    const MAX_AMBULANCES_PER_HOSPITAL = 2;          // 병원당 최대 구급차 수

    // 의료 응급 데이터 구조
    const activeMedicalEmergencies = new Map();     // key: "x,y", value: emergencyData
    const dispatchedAmbulances = new Map();         // key: emergencyKey, value: { vehicle, hospitalKey }
    const hospitalAmbulanceCount = new Map();       // key: hospitalKey, value: 출동 중 구급차 수
    const hospitalPatients = new Map();             // key: hospitalKey, value: [{ admitTime }]
    let lastMedicalRetryTime = 0;
    let lastPatientDischargeCheck = 0;

    /**
     * 가장 가까운 병원 찾기 (여유 있는 병원 우선, 환자 정원 체크)
     */
    function findNearestHospital(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return null;

        let nearest = null;
        let minDistance = Infinity;

        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type !== 'hospital') continue;

            // 현재 출동 중인 구급차 수 체크
            const currentCount = hospitalAmbulanceCount.get(key) || 0;
            if (currentCount >= MAX_AMBULANCES_PER_HOSPITAL) continue;

            // 환자 정원 체크 - 가득 차면 출동 불가
            const patients = hospitalPatients.get(key) || [];
            if (patients.length >= MAX_PATIENTS_PER_HOSPITAL) {
                console.log(`[Medical] Hospital ${key} full (${patients.length}/${MAX_PATIENTS_PER_HOSPITAL})`);
                continue;
            }

            // 병원 중심 좌표 계산
            const bx = building.x;
            const by = building.y;
            const centerX = bx + 1;  // 2x2 건물 중심
            const centerY = by + 1;

            const dx = centerX - x;
            const dy = centerY - y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < minDistance) {
                minDistance = distance;
                nearest = { key, x: bx, y: by, centerX, centerY, distance };
            }
        }

        return nearest;
    }

    /**
     * 병원에 환자 입원
     */
    function addPatientToHospital(hospitalKey) {
        if (!hospitalKey) return;
        const patients = hospitalPatients.get(hospitalKey) || [];
        patients.push({ admitTime: Date.now() });
        hospitalPatients.set(hospitalKey, patients);
        console.log(`[Medical] Patient admitted to ${hospitalKey} (${patients.length}/${MAX_PATIENTS_PER_HOSPITAL})`);
    }

    /**
     * 환자 퇴원 (입원 시간이 지난 환자)
     */
    function dischargePatients() {
        const now = Date.now();
        let totalDischarged = 0;

        for (const [hospitalKey, patients] of hospitalPatients) {
            const remaining = patients.filter(p => (now - p.admitTime) < PATIENT_DISCHARGE_TIME);
            const discharged = patients.length - remaining.length;
            if (discharged > 0) {
                hospitalPatients.set(hospitalKey, remaining);
                totalDischarged += discharged;
                dailyStats.medical.dischargedPatients += discharged;
                console.log(`[Medical] ${discharged} patient(s) discharged from ${hospitalKey} (${remaining.length}/${MAX_PATIENTS_PER_HOSPITAL})`);
            }
        }

        return totalDischarged;
    }

    /**
     * 전체 입원 환자 수 계산
     */
    function getTotalHospitalPatients() {
        let total = 0;
        for (const [, patients] of hospitalPatients) {
            total += patients.length;
        }
        return total;
    }

    /**
     * 전체 병원 정원 계산
     */
    function getTotalHospitalCapacity() {
        let capacity = 0;
        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'hospital') {
                capacity += MAX_PATIENTS_PER_HOSPITAL;
            }
        }
        return capacity;
    }

    /**
     * 전체 환자 수 계산
     */
    function getTotalPatients() {
        let total = 0;
        for (const [, patients] of hospitalPatients) {
            total += patients.length;
        }
        return total;
    }

    /**
     * 구급차 출동
     */
    function dispatchAmbulance(emergencyX, emergencyY, hospital) {
        if (!trafficManager || !trafficManager.initialized) {
            console.warn('[Medical] Traffic not initialized, cannot dispatch ambulance');
            return null;
        }

        // 병원 인접 도로 찾기
        const hospitalRoad = trafficManager.findNearestRoad(hospital.x, hospital.y);
        if (!hospitalRoad) {
            console.warn('[Medical] No road near hospital');
            return null;
        }

        // 응급 현장 인접 도로 찾기
        const emergencyRoad = trafficManager.findNearestRoad(emergencyX, emergencyY);
        if (!emergencyRoad) {
            console.warn('[Medical] No road near emergency location');
            return null;
        }

        // 경로 찾기
        const path = trafficManager.findPath(hospitalRoad.x, hospitalRoad.y, emergencyRoad.x, emergencyRoad.y);
        if (!path || path.length < 2) {
            console.warn('[Medical] No path to emergency location');
            return null;
        }

        // 구급차 스폰
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) {
            console.warn('[Medical] No vehicle available');
            return null;
        }

        // 이전 사용에서 남은 속성 초기화
        vehicle.isFiretruck = false;
        vehicle.isPoliceCar = false;
        vehicle.isMoveInVehicle = false;
        vehicle.isConstructionTruck = false;
        vehicle.constructionSite = null;
        vehicle.fireTarget = null;
        vehicle.crimeTarget = null;
        vehicle.isReturning = false;
        vehicle.workStartTime = null;
        vehicle.isParked = false;
        vehicle.enterProgress = 0;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 구급차 타입으로 설정
        vehicle.vehicleTypeKey = 'ambulance';
        vehicle.type = 'ambulance';
        const vehicleTypeConfig = VEHICLE_TYPES['ambulance'];

        // 메쉬 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh('ambulance');
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 사이렌 라이트 추가
        const sirenLights = createSirenLights('ambulance');
        newMesh.add(sirenLights);
        vehicle.sirenLights = sirenLights;

        // 구급차 특수 속성
        vehicle.isAmbulance = true;
        vehicle.emergencyTarget = { x: emergencyX, y: emergencyY };
        vehicle.originBuilding = { x: hospital.x, y: hospital.y };
        vehicle.originHospital = { x: hospital.x, y: hospital.y };
        vehicle.hospitalKey = hospital.key;
        vehicle.destBuilding = { x: emergencyX, y: emergencyY };
        vehicle.activity = '🚑 응급환자에게 출동 중!';
        vehicle.originTypeName = '병원';
        vehicle.destTypeName = '응급 현장';
        vehicle.isReturning = false;

        // 병원 출동 카운트 증가
        const currentCount = hospitalAmbulanceCount.get(hospital.key) || 0;
        hospitalAmbulanceCount.set(hospital.key, currentCount + 1);

        // 속도 설정 (구급차는 다른 차량보다 빠름)
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 2.3;
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        console.log(`[Medical] Ambulance dispatched from (${hospital.x},${hospital.y}) to (${emergencyX},${emergencyY})`);
        return vehicle;
    }

    /**
     * 의료 응급 발생
     */
    function startMedicalEmergency(x, y) {
        const key = `${x},${y}`;
        if (activeMedicalEmergencies.has(key)) return;  // 이미 응급 진행 중

        // 의료 응급 이펙트 생성
        const effects = createMedicalEffect(x, y);

        const emergencyData = {
            startTime: Date.now(),
            effects: effects,
            x, y,
            ambulanceDispatched: false,
            ambulanceArrived: false
        };

        activeMedicalEmergencies.set(key, emergencyData);

        // 일일 통계 업데이트
        dailyStats.medical.totalEmergencies++;
        updateDailyStatsPanel();

        console.log(`[Medical] Emergency started at (${x}, ${y})`);

        // 병원 찾아서 구급차 출동
        const nearestHospital = findNearestHospital(x, y);
        if (nearestHospital) {
            const ambulance = dispatchAmbulance(x, y, nearestHospital);
            if (ambulance) {
                emergencyData.ambulanceDispatched = true;
                dispatchedAmbulances.set(key, { vehicle: ambulance, hospitalKey: nearestHospital.key });
            }
        }
    }

    /**
     * 의료 응급 이펙트 생성 (하트 아이콘 + 깜빡임)
     */
    function createMedicalEffect(x, y) {
        const group = new THREE.Group();

        // 건물 높이 추정
        const building = placedBuildings.get(`${x},${y}`);
        let buildingHeight = 1;
        if (building && building.instance) {
            const bbox = new THREE.Box3().setFromObject(building.instance);
            buildingHeight = bbox.max.y;
        }

        // 하트 아이콘 스프라이트 (빨간 배경 원 + 하트)
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = 128;
        iconCanvas.height = 128;
        const ctx = iconCanvas.getContext('2d');

        // 흰색 원 배경
        ctx.beginPath();
        ctx.arc(64, 64, 56, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(220, 50, 50, 0.9)';
        ctx.lineWidth = 4;
        ctx.stroke();

        // 적십자 (Red Cross)
        ctx.fillStyle = 'rgba(220, 50, 50, 1)';
        // 가로 막대
        ctx.fillRect(24, 52, 80, 24);
        // 세로 막대
        ctx.fillRect(52, 24, 24, 80);

        const texture = new THREE.CanvasTexture(iconCanvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(0.6, 0.6, 1);
        sprite.position.set(0, buildingHeight + 0.5, 0);
        sprite.name = 'medicalIcon';
        group.add(sprite);

        // 아이콘 애니메이션 데이터
        group.userData = {
            phase: 0,
            baseY: buildingHeight + 0.5,
            spriteMaterial: spriteMaterial
        };

        // 월드 좌표로 배치
        const worldPos = tileToWorldCenter(x, y);
        group.position.set(worldPos.x, 0, worldPos.z);

        // 이펙트 그룹에 추가
        if (typeof fireEffectsGroup !== 'undefined') {
            fireEffectsGroup.add(group);
        }

        return {
            group,
            sprite
        };
    }

    /**
     * 의료 응급 해결
     */
    function resolveMedicalEmergency(key, byAmbulance = false) {
        const emergencyData = activeMedicalEmergencies.get(key);
        if (!emergencyData) return;

        // 이펙트 제거
        if (emergencyData.effects && emergencyData.effects.group) {
            const group = emergencyData.effects.group;

            // userData 참조 먼저 정리
            if (group.userData) {
                group.userData.spriteMaterial = null;
                group.userData = null;
            }

            // 스프라이트 visible 먼저 false
            if (emergencyData.effects.sprite) {
                emergencyData.effects.sprite.visible = false;
            }

            // 씬에서 제거
            if (typeof fireEffectsGroup !== 'undefined') {
                fireEffectsGroup.remove(group);
            }

            // 다음 프레임에서 dispose (렌더링 완료 후)
            requestAnimationFrame(() => {
                group.traverse((child) => {
                    if (child.geometry) {
                        child.geometry.dispose();
                    }
                    if (child.material) {
                        // CanvasTexture는 dispose 후 가비지 컬렉터가 정리
                        // 재질만 명시적으로 dispose
                        child.material.dispose();
                    }
                });
            });

            // effects 참조 정리
            emergencyData.effects.group = null;
            emergencyData.effects.sprite = null;
        }

        // 출동 중인 구급차 정보 제거
        dispatchedAmbulances.delete(key);

        activeMedicalEmergencies.delete(key);
        console.log(`[Medical] Emergency resolved at ${key}` + (byAmbulance ? ' by ambulance' : ' (patient died)'));
    }

    /**
     * 구급차 도착 처리
     */
    function onAmbulanceArrival(emergencyX, emergencyY, vehicle) {
        const key = `${emergencyX},${emergencyY}`;
        const emergencyData = activeMedicalEmergencies.get(key);

        console.log(`[Medical] onAmbulanceArrival called for (${emergencyX}, ${emergencyY}), emergencyData exists: ${!!emergencyData}`);

        if (!emergencyData) {
            // 이미 해결됨 - 잠시 대기 후 복귀
            console.log(`[Medical] Emergency already resolved at (${emergencyX}, ${emergencyY})`);

            if (vehicle && vehicle.mesh) {
                vehicle.state = 'working';
                vehicle.activity = '🔍 현장 확인 중...';
                vehicle.workStartTime = Date.now() - 3000;  // 2초만 대기
                vehicle.isParked = true;
            } else {
                startAmbulanceReturn(vehicle);
            }
            return;
        }

        emergencyData.ambulanceArrived = true;

        // 환자 구조 (응급 해결)
        console.log(`[Medical] Resolving emergency at (${emergencyX}, ${emergencyY})`);
        resolveMedicalEmergency(key, true);

        // 병원에 환자 입원
        if (vehicle && vehicle.hospitalKey) {
            addPatientToHospital(vehicle.hospitalKey);
        }

        // 일일 통계 업데이트 - 구조된 환자
        dailyStats.medical.savedPatients++;
        updateDailyStatsPanel();

        // 구급차 현장 이송 준비 후 복귀
        if (vehicle && vehicle.mesh) {
            vehicle.state = 'working';
            vehicle.activity = '🏥 환자 이송 준비 중...';
            vehicle.workStartTime = Date.now();

            // 갓길 주차
            const offsetX = Math.cos(vehicle.rotation) * 0.15;
            const offsetZ = Math.sin(vehicle.rotation) * 0.15;
            vehicle.parkPosition = {
                x: vehicle.position.x + offsetZ,
                z: vehicle.position.z + offsetX
            };
            vehicle.mesh.position.x = vehicle.parkPosition.x;
            vehicle.mesh.position.z = vehicle.parkPosition.z;
            vehicle.isParked = true;

            console.log(`[Medical] Ambulance parked, state: ${vehicle.state}`);
        }
    }

    /**
     * 구급차 병원 복귀 시작
     */
    function startAmbulanceReturn(vehicle) {
        if (!vehicle || !vehicle.originHospital) {
            if (vehicle) trafficManager.despawnVehicle(vehicle);
            return;
        }

        const hospitalX = vehicle.originHospital.x;
        const hospitalY = vehicle.originHospital.y;

        // 현재 위치에서 가장 가까운 도로 타일 찾기
        const currentRoadTile = findNearestRoadTile(
            Math.floor(vehicle.position.x / TILE_SIZE + GRID_W / 2),
            Math.floor(vehicle.position.z / TILE_SIZE + GRID_H / 2)
        );

        if (!currentRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 병원 주변 도로 찾기
        const hospitalRoadTile = findNearestRoadTile(hospitalX, hospitalY);
        if (!hospitalRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 경로 계산
        const returnPath = trafficManager.findPath(
            currentRoadTile.x, currentRoadTile.y,
            hospitalRoadTile.x, hospitalRoadTile.y
        );

        if (!returnPath || returnPath.length < 2) {
            console.log('[Medical] No return path found, despawning');
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 모드 설정
        vehicle.isReturning = true;
        vehicle.emergencyTarget = null;
        vehicle.path = returnPath;
        vehicle.pathIndex = 0;
        vehicle.currentTile = { x: returnPath[0].x, y: returnPath[0].y };
        vehicle.targetTile = { x: returnPath[1].x, y: returnPath[1].y };
        vehicle.progress = 0;
        vehicle.state = 'moving';
        vehicle.isParked = false;
        vehicle.activity = '🏠 병원으로 복귀 중';
        vehicle.destTypeName = '병원';

        // 복귀 시에도 긴급 속도 유지 (환자 이송 완료 후 다음 출동 대비)
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 1.5;
        vehicle.targetSpeed = vehicle.speed;

        console.log(`[Medical] Ambulance returning to hospital at (${hospitalX}, ${hospitalY})`);
    }

    /**
     * 건물이 병원 범위 내에 있는지 확인
     */
    function isInHospitalRange(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return false;

        // 병원이 하나라도 있으면 범위 내로 간주 (전역 효과)
        for (const [, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'hospital') {
                return true;
            }
        }
        return false;
    }

    /**
     * 의료 응급 발생 체크 (확률 기반)
     */
    function checkMedicalOutbreak() {
        if (typeof placedBuildings === 'undefined') return;

        // 병원 범위 체크 - 병원이 있으면 발생 확률 크게 감소
        const hasHospital = isInHospitalRange(0, 0);
        const hospitalReduction = hasHospital ? 0.4 : 1.0;  // 병원 있으면 40%로 감소

        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData || userData.isAbandoned) continue;

            // 이미 응급 중이면 스킵
            if (activeMedicalEmergencies.has(key)) continue;

            // 주거 건물에서만 응급환자 발생
            const zoneType = userData.zoneType || '';
            const isResidential = zoneType.includes('resident');

            if (!isResidential) continue;

            // 발생 확률 계산
            let medicalChance = MEDICAL_BASE_CHANCE * hospitalReduction;

            // 확률 체크
            if (Math.random() < medicalChance) {
                startMedicalEmergency(x, y);
            }
        }
    }

    /**
     * 의료 응급 진행 업데이트
     */
    function updateMedicalProgress() {
        const now = Date.now();

        activeMedicalEmergencies.forEach((emergencyData, key) => {
            // 이펙트 애니메이션 업데이트
            updateMedicalEffects(emergencyData);

            // 구급차가 도착했으면 이미 처리됨
            if (emergencyData.ambulanceArrived) return;

            // 제한시간 체크 (구급차가 도착하지 못하면 환자 사망)
            const elapsed = now - emergencyData.startTime;

            if (elapsed >= MEDICAL_DEATH_TIME) {
                // 환자 사망 - 피해 발생
                applyMedicalDeath(emergencyData.x, emergencyData.y);
                resolveMedicalEmergency(key, false);
            }
        });

        // 구급차 출동 재시도
        if (now - lastMedicalRetryTime > MEDICAL_RETRY_INTERVAL) {
            lastMedicalRetryTime = now;
            retryMedicalDispatch();
        }
    }

    /**
     * 환자 사망 피해 적용 (구급차 미도착 시)
     */
    function applyMedicalDeath(x, y) {
        // 일일 통계 업데이트 - 사망 환자
        dailyStats.medical.deadPatients++;
        updateDailyStatsPanel();
        checkDailyStatsWarnings();

        // 행복도 피해
        if (typeof cityStats !== 'undefined') {
            cityStats.happiness = Math.max(0, (cityStats.happiness || 50) + MEDICAL_DAMAGE_HAPPINESS);
        }

        console.log(`[Medical] Patient died at (${x}, ${y}), happiness ${MEDICAL_DAMAGE_HAPPINESS}`);
    }

    /**
     * 의료 응급 이펙트 업데이트 (애니메이션)
     */
    function updateMedicalEffects(emergencyData) {
        if (!emergencyData.effects || !emergencyData.effects.group) return;

        const time = Date.now() / 1000;
        const userData = emergencyData.effects.group.userData;
        if (!userData) return;

        // 하트 아이콘 위아래 흔들림 + 깜빡임 (더 빠르게)
        if (emergencyData.effects.sprite) {
            const bobbing = Math.sin(time * 5) * 0.1;
            emergencyData.effects.sprite.position.y = userData.baseY + bobbing;

            // 깜빡임 효과 (빠르게)
            if (userData.spriteMaterial) {
                userData.spriteMaterial.opacity = 0.6 + Math.sin(time * 8) * 0.4;
            }
        }
    }

    /**
     * 구급차 출동 재시도
     */
    function retryMedicalDispatch() {
        activeMedicalEmergencies.forEach((emergencyData, key) => {
            if (emergencyData.ambulanceDispatched || emergencyData.ambulanceArrived) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            const nearestHospital = findNearestHospital(x, y);
            if (!nearestHospital) return;

            const ambulance = dispatchAmbulance(x, y, nearestHospital);
            if (ambulance) {
                emergencyData.ambulanceDispatched = true;
                dispatchedAmbulances.set(key, { vehicle: ambulance, hospitalKey: nearestHospital.key });
                console.log(`[Medical] Retry dispatched ambulance to emergency at (${x}, ${y})`);
            }
        });
    }

    /**
     * 병원 설치 시 기존 응급에 구급차 출동
     */
    function dispatchAmbulanceToExistingEmergencies() {
        if (!activeMedicalEmergencies || activeMedicalEmergencies.size === 0) return;

        let dispatched = 0;

        activeMedicalEmergencies.forEach((emergencyData, key) => {
            if (emergencyData.ambulanceDispatched) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            const nearestHospital = findNearestHospital(x, y);
            if (!nearestHospital) return;

            const ambulance = dispatchAmbulance(x, y, nearestHospital);
            if (ambulance) {
                emergencyData.ambulanceDispatched = true;
                dispatchedAmbulances.set(key, { vehicle: ambulance, hospitalKey: nearestHospital.key });
                dispatched++;

                console.log(`[Medical] Dispatched ambulance to existing emergency at (${x}, ${y})`);
            }
        });

        if (dispatched > 0) {
            toast({
                title: '🚑 구급차 출동!',
                desc: `${dispatched}건의 응급에 구급차가 출동했습니다!`,
                ms: 3000
            });
        }
    }

    /**
     * 의료 응급 시스템 전체 업데이트
     */
    function updateMedicalSystem() {
        checkMedicalOutbreak();
        updateMedicalProgress();

        // 환자 퇴원 체크 (5초마다)
        const now = Date.now();
        if (now - lastPatientDischargeCheck > 5000) {
            dischargePatients();
            lastPatientDischargeCheck = now;
        }
    }

    // ===== 도시 전체 행복도 시스템 =====
    let previousCityHappiness = 50;  // 이전 행복도 (추세 계산용)
    let cityHappinessHistory = [];   // 행복도 이력 (추세 계산용)
    const CITY_HAPPINESS_UPDATE_INTERVAL = 2000;  // 2초마다 업데이트
    let lastCityHappinessUpdate = 0;

    /**
     * 도시 전체 행복도 평균 계산 (인구 가중 평균)
     */
    function calculateCityHappiness() {
        if (typeof placedBuildings === 'undefined') return 50;

        let totalHappiness = 0;
        let totalPopulation = 0;

        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData || userData.isAbandoned) continue;

            // 주거 건물만 인구 가중치 적용
            const zoneType = userData.zoneType || '';
            const isResidential = zoneType.includes('resident');

            // 건물 행복도 계산
            const happiness = calculateBuildingHappiness(x, y);

            if (isResidential) {
                // 인구 가중 평균 (주거 건물)
                const size = userData.size || '1x1';
                const tier = userData.tier || 'low';
                const capacityKey = `${size}_${tier}`;
                const population = BUILDING_CAPACITY[capacityKey] || 2;

                totalHappiness += happiness * population;
                totalPopulation += population;
            } else {
                // 상업/산업 건물은 가중치 1
                totalHappiness += happiness;
                totalPopulation += 1;
            }
        }

        if (totalPopulation === 0) return 50;
        return Math.round(totalHappiness / totalPopulation);
    }

    // 행복도에 따른 그라데이션 색상 계산 (빨강 → 노랑 → 초록)
    function getHappinessColor(happiness) {
        // 0 = 빨강(#f87171), 50 = 노랑(#fbbf24), 100 = 초록(#4ade80)
        const h = Math.max(0, Math.min(100, happiness));

        if (h <= 50) {
            // 빨강 → 노랑 (0-50)
            const ratio = h / 50;
            const r = Math.round(248 + (251 - 248) * ratio);  // 248 → 251
            const g = Math.round(113 + (191 - 113) * ratio);  // 113 → 191
            const b = Math.round(113 + (36 - 113) * ratio);   // 113 → 36
            return `rgb(${r}, ${g}, ${b})`;
        } else {
            // 노랑 → 초록 (50-100)
            const ratio = (h - 50) / 50;
            const r = Math.round(251 + (74 - 251) * ratio);   // 251 → 74
            const g = Math.round(191 + (222 - 191) * ratio);  // 191 → 222
            const b = Math.round(36 + (128 - 36) * ratio);    // 36 → 128
            return `rgb(${r}, ${g}, ${b})`;
        }
    }

    /**
     * 도시 행복도 UI 업데이트
     */
    function updateCityHappinessDisplay() {
        const now = Date.now();
        if (now - lastCityHappinessUpdate < CITY_HAPPINESS_UPDATE_INTERVAL) return;
        lastCityHappinessUpdate = now;

        const happiness = calculateCityHappiness();

        // cityStats에도 저장
        cityStats.happiness = happiness;

        // UI 요소
        const iconEl = document.getElementById('cityHappinessIcon');
        const numberEl = document.getElementById('cityHappinessNumber');
        const trendEl = document.getElementById('cityHappinessTrend');

        if (!numberEl) return;

        // 숫자 업데이트 (정확한 정수 표시)
        numberEl.textContent = happiness;

        // 동적 색상 적용 (그라데이션)
        numberEl.style.color = getHappinessColor(happiness);

        // 이모지 업데이트 (더 세분화)
        if (iconEl) {
            if (happiness <= 20) {
                iconEl.textContent = '😭';
            } else if (happiness <= 35) {
                iconEl.textContent = '😢';
            } else if (happiness <= 45) {
                iconEl.textContent = '😟';
            } else if (happiness <= 55) {
                iconEl.textContent = '😐';
            } else if (happiness <= 75) {
                iconEl.textContent = '🙂';
            } else {
                iconEl.textContent = '😊';
            }
        }

        // 추세 업데이트 (이력 기반)
        if (trendEl) {
            cityHappinessHistory.push(happiness);
            if (cityHappinessHistory.length > 5) {
                cityHappinessHistory.shift();
            }

            if (cityHappinessHistory.length >= 2) {
                const oldAvg = cityHappinessHistory.slice(0, -1).reduce((a, b) => a + b, 0) / (cityHappinessHistory.length - 1);
                const diff = happiness - oldAvg;

                trendEl.classList.remove('up', 'down', 'stable');
                if (diff > 2) {
                    trendEl.textContent = '↑';
                    trendEl.classList.add('up');
                } else if (diff < -2) {
                    trendEl.textContent = '↓';
                    trendEl.classList.add('down');
                } else {
                    trendEl.textContent = '→';
                    trendEl.classList.add('stable');
                }
            }
        }

        previousCityHappiness = happiness;
    }

    // 낮은 행복도 건물 체크 및 폐건물 전환 (5초마다 호출)
    let lastHappinessCheckTime = 0;
    const HAPPINESS_CHECK_INTERVAL = 5000;  // 5초마다 체크

    function updateBuildingHappinessStatus() {
        const now = Date.now();
        if (now - lastHappinessCheckTime < HAPPINESS_CHECK_INTERVAL) return;
        lastHappinessCheckTime = now;

        if (typeof placedBuildings === 'undefined') return;

        placedBuildings.forEach((building, key) => {
            if (building.ref) return;  // 참조 건물 스킵

            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData) return;

            // 이미 폐건물이면 스킵
            if (userData.isAbandoned) return;

            // 행복도 계산
            const happiness = calculateBuildingHappiness(x, y);

            // 행복도 20 이하일 때만 폐건물 전환 가능
            if (happiness <= ABANDON_HAPPINESS_THRESHOLD) {
                // 낮은 행복도 시작 추적 (랜덤 폐건물화 시간 설정)
                if (!buildingLowHappinessTime.has(key)) {
                    // 각 건물마다 랜덤한 폐건물화 시간 설정
                    const randomAbandonTime = MIN_ABANDON_TIME + Math.random() * (MAX_ABANDON_TIME - MIN_ABANDON_TIME);
                    buildingLowHappinessTime.set(key, {
                        startTime: now,
                        abandonTime: randomAbandonTime,
                        building: building
                    });
                    console.log(`Building at (${x},${y}) entered critical happiness (${happiness}), abandon in ${Math.round(randomAbandonTime/1000)}s`);
                } else {
                    // 낮은 행복도 지속 시간 체크
                    const trackData = buildingLowHappinessTime.get(key);
                    const duration = now - trackData.startTime;

                    if (duration >= trackData.abandonTime) {
                        // 폐건물로 전환
                        const userData = building.instance?.userData;
                        if (userData) {
                            userData.abandonedReason = '행복도가 너무 낮아서 이사갑니다...';
                        }
                        convertToAbandonedBuilding(building, key);
                        buildingLowHappinessTime.delete(key);
                        console.log(`Building at (${x},${y}) converted to abandoned after ${Math.round(duration/1000)}s of low happiness (${happiness})`);
                    }
                }
            } else {
                // 행복도 회복 (20 초과) - 추적 중지
                if (buildingLowHappinessTime.has(key)) {
                    buildingLowHappinessTime.delete(key);
                    console.log(`Building at (${x},${y}) happiness recovered to ${happiness}`);
                }
            }
        });
    }

    // 건물을 폐건물로 전환
    function convertToAbandonedBuilding(building, key) {
        const { instance } = building;
        const userData = instance?.userData;
        if (!userData || userData.isAbandoned) return;

        userData.isAbandoned = true;
        building.isAbandoned = true;
        abandonedBuildings.add(key);

        // 회색 적용 (applyAbandonedMaterials와 동일)
        applyAbandonedMaterials(instance);

        // 폐건물 아이콘 표시
        showAbandonedIcon(building, building.x, building.y);

        // 입주민 퇴거 (인구 감소)
        if (userData.zoneType && userData.zoneType.includes('residential')) {
            const popKey = getBuildingKey(building.x, building.y, userData.size || '1x1');
            if (buildingPopulations && buildingPopulations.has(popKey)) {
                buildingPopulations.delete(popKey);
                cityStats.population = calculateTotalPopulation();
                updateStatsDisplay();
            }
        }
    }

    const grid = Array.from({ length: GRID_W }, () =>
        Array(GRID_H).fill(CELL.EMPTY)
    );

    const blocked = Array.from({ length: GRID_W }, () =>
        Array(GRID_H).fill(0)
    );

    // 원본 맵 파일의 해안선 위치 저장 (해변 타일은 이 위치에만 생성됨)
    const originalCoastline = new Set();
    // 원본 맵 파일의 바다/해변 타일 저장 (풍량 계산용)
    const originalSeaTiles = new Set();

    function tileToWorldCenter(x, y) {
        return {
            x: (ORIGIN_X + x + 0.5) * TILE_SIZE,
            z: (ORIGIN_Z + y + 0.5) * TILE_SIZE,
        };
    }

    function worldToTile(wx, wz) {
        const gx = Math.floor(wx / TILE_SIZE - ORIGIN_X);
        const gy = Math.floor(wz / TILE_SIZE - ORIGIN_Z);
        if (gx < 0 || gy < 0 || gx >= GRID_W || gy >= GRID_H) return null;
        return { x: gx, y: gy };
    }

    // 3D 오브젝트 완전 삭제 (geometry, material, texture 모두 dispose)
    function disposeObject3D(object) {
        if (!object) return;

        object.traverse((child) => {
            if (child.geometry) {
                child.geometry.dispose();
            }
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(mat => {
                        if (mat.map) mat.map.dispose();
                        mat.dispose();
                    });
                } else {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
            }
        });

        // 자식들도 제거
        while (object.children.length > 0) {
            object.remove(object.children[0]);
        }
    }

    function isRoad(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        const v = grid[x][y];
        return v === CELL.ROAD || v === CELL.LOCKED_ROAD || v === CELL.BRIDGE ||
               v === CELL.ROAD_4LANE || v === CELL.LOCKED_ROAD_4LANE;
    }

    function is4LaneRoad(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        const v = grid[x][y];
        return v === CELL.ROAD_4LANE || v === CELL.LOCKED_ROAD_4LANE;
    }

    function is2LaneRoad(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        const v = grid[x][y];
        return v === CELL.ROAD || v === CELL.LOCKED_ROAD || v === CELL.BRIDGE;
    }

    // 4차선 도로 원점인지 확인 (2x2의 좌하단)
    function is4LaneOrigin(x, y) {
        return road4laneOrigins.has(`${x},${y}`);
    }

    // grid에서 4차선 도로 원점 재구성 (로드 시 사용)
    function rebuild4LaneOrigins() {
        road4laneOrigins.clear();

        // 4차선 도로 타일을 스캔하여 원점 찾기
        // 원점은 2x2 영역의 좌하단 (가장 작은 x, y 좌표)
        const visited = new Set();

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const v = grid[x][y];
                if (v !== CELL.ROAD_4LANE && v !== CELL.LOCKED_ROAD_4LANE) continue;
                if (visited.has(`${x},${y}`)) continue;

                // 이 타일이 속한 2x2 영역의 원점 찾기
                // 원점은 가장 작은 x, y 좌표 (좌하단)
                // 중요: 이미 방문한 셀(다른 2x2 블록)은 원점 계산에서 제외
                let originX = x, originY = y;

                // 왼쪽 타일이 4차선이고 아직 방문하지 않은 경우에만 원점 후보
                const leftKey = `${x-1},${y}`;
                if (x > 0 && !visited.has(leftKey) &&
                    (grid[x-1][y] === CELL.ROAD_4LANE || grid[x-1][y] === CELL.LOCKED_ROAD_4LANE)) {
                    originX = x - 1;
                }
                // 아래 타일이 4차선이고 아직 방문하지 않은 경우에만 원점 후보
                const bottomKey = `${originX},${y-1}`;
                if (y > 0 && !visited.has(bottomKey) &&
                    (grid[originX][y-1] === CELL.ROAD_4LANE || grid[originX][y-1] === CELL.LOCKED_ROAD_4LANE)) {
                    originY = y - 1;
                }

                // 2x2 영역 검증 (모든 셀이 4차선이고 아직 방문하지 않음)
                let valid = true;
                for (let dx = 0; dx < 2 && valid; dx++) {
                    for (let dy = 0; dy < 2 && valid; dy++) {
                        const cx = originX + dx;
                        const cy = originY + dy;
                        if (cx >= GRID_W || cy >= GRID_H) {
                            valid = false;
                        } else if (visited.has(`${cx},${cy}`)) {
                            // 이미 다른 2x2 블록에 속한 셀
                            valid = false;
                        } else {
                            const cv = grid[cx][cy];
                            if (cv !== CELL.ROAD_4LANE && cv !== CELL.LOCKED_ROAD_4LANE) {
                                valid = false;
                            }
                        }
                    }
                }

                if (valid) {
                    // 원점 등록
                    road4laneOrigins.set(`${originX},${originY}`, { variant: 'straight', rotY: 0 });

                    // 2x2 영역 방문 표시
                    for (let dx = 0; dx < 2; dx++) {
                        for (let dy = 0; dy < 2; dy++) {
                            visited.add(`${originX + dx},${originY + dy}`);
                        }
                    }
                } else {
                    // 유효하지 않은 경우 현재 셀만 방문 표시 (무한 루프 방지)
                    visited.add(`${x},${y}`);
                }
            }
        }

        console.log(`4차선 도로 원점 재구성 완료: ${road4laneOrigins.size}개`);
    }

    // 저장된 4차선 도로 원점 복원
    function restore4LaneOrigins(origins) {
        road4laneOrigins.clear();

        for (const origin of origins) {
            const { x, y, variant, rotY } = origin;

            // 해당 위치가 실제로 4차선 도로인지 검증
            if (x >= 0 && x < GRID_W - 1 && y >= 0 && y < GRID_H - 1) {
                let valid = true;
                for (let dx = 0; dx < 2 && valid; dx++) {
                    for (let dy = 0; dy < 2 && valid; dy++) {
                        const cv = grid[x + dx][y + dy];
                        if (cv !== CELL.ROAD_4LANE && cv !== CELL.LOCKED_ROAD_4LANE) {
                            valid = false;
                        }
                    }
                }

                if (valid) {
                    road4laneOrigins.set(`${x},${y}`, {
                        variant: variant || 'straight',
                        rotY: rotY || 0
                    });
                }
            }
        }

        console.log(`4차선 도로 원점 복원 완료: ${road4laneOrigins.size}개`);
    }

    // 4차선 도로의 원점 찾기 (해당 셀이 속한 2x2의 원점)
    function find4LaneOrigin(x, y) {
        if (!is4LaneRoad(x, y)) return null;
        // 자신이 원점인지
        if (is4LaneOrigin(x, y)) return { x, y };
        // 좌하단으로 한 칸씩 체크
        if (is4LaneOrigin(x - 1, y)) return { x: x - 1, y };
        if (is4LaneOrigin(x, y - 1)) return { x, y: y - 1 };
        if (is4LaneOrigin(x - 1, y - 1)) return { x: x - 1, y: y - 1 };
        return null;
    }

    // 4차선 도로 2x2 배치 가능 여부 확인
    function canPlace4LaneRoad(x, y) {
        for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
                const cx = x + dx;
                const cy = y + dy;
                if (!inBounds(cx, cy)) return false;
                if (isLocked(cx, cy)) return false;
                // 2차선 도로(CELL.ROAD)는 덮어씌우기 허용
                const cellType = grid[cx][cy];
                if (isBlocked(cx, cy) && cellType !== CELL.ROAD) return false;
                // 공공시설 위에는 도로 설치 불가
                if (placedPublicBuildings && placedPublicBuildings.has(`${cx},${cy}`)) return false;
                // 확장 터빈/패널 위에는 도로 설치 불가
                if (findExpansionTurbineAt(cx, cy)) return false;
                if (findExpansionSolarAt(cx, cy)) return false;
                // 바다 위에는 도로 설치 불가
                if (cellType === CELL.OCEAN) return false;
            }
        }

        // 나란히(평행) 도로 설치 방지 - 4면의 인접 셀에 4차선 도로가 있으면 설치 불가
        // 단, 4차선끼리 끝과 끝이 연결되는 경우는 허용 (직선 연속 배치 가능)
        // 2차선 도로는 덮어씌우기 가능하므로 2차선 연결은 항상 허용

        // 서쪽 면 체크 (x-1, y), (x-1, y+1) - 4차선만 체크
        const westHas4Lane = (inBounds(x-1, y) && is4LaneRoad(x-1, y)) ||
                            (inBounds(x-1, y+1) && is4LaneRoad(x-1, y+1));
        // 서쪽에 4차선이 연결된 경우는 허용 (원점이 x-2에 있으면 연결)
        const westIs4LaneConnection = road4laneOrigins.has(`${x-2},${y}`);
        if (westHas4Lane && !westIs4LaneConnection) return false;

        // 동쪽 면 체크 (x+2, y), (x+2, y+1) - 4차선만 체크
        const eastHas4Lane = (inBounds(x+2, y) && is4LaneRoad(x+2, y)) ||
                            (inBounds(x+2, y+1) && is4LaneRoad(x+2, y+1));
        // 동쪽에 4차선이 연결된 경우는 허용 (원점이 x+2에 있으면 연결)
        const eastIs4LaneConnection = road4laneOrigins.has(`${x+2},${y}`);
        if (eastHas4Lane && !eastIs4LaneConnection) return false;

        // 남쪽 면 체크 (x, y-1), (x+1, y-1) - 4차선만 체크
        const southHas4Lane = (inBounds(x, y-1) && is4LaneRoad(x, y-1)) ||
                             (inBounds(x+1, y-1) && is4LaneRoad(x+1, y-1));
        // 남쪽에 4차선이 연결된 경우는 허용 (원점이 y-2에 있으면 연결)
        const southIs4LaneConnection = road4laneOrigins.has(`${x},${y-2}`);
        if (southHas4Lane && !southIs4LaneConnection) return false;

        // 북쪽 면 체크 (x, y+2), (x+1, y+2) - 4차선만 체크
        const northHas4Lane = (inBounds(x, y+2) && is4LaneRoad(x, y+2)) ||
                             (inBounds(x+1, y+2) && is4LaneRoad(x+1, y+2));
        // 북쪽에 4차선이 연결된 경우는 허용 (원점이 y+2에 있으면 연결)
        const northIs4LaneConnection = road4laneOrigins.has(`${x},${y+2}`);
        if (northHas4Lane && !northIs4LaneConnection) return false;

        return true;
    }

    // 4차선 도로 2x2 배치
    function place4LaneRoad(x, y) {
        if (!canPlace4LaneRoad(x, y)) return false;

        let zoneCleared = false;

        // 4개 셀 모두 ROAD_4LANE으로 설정
        for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
                const cx = x + dx;
                const cy = y + dy;
                // 기존 건물 철거
                if (typeof removeBuildingAt === 'function') {
                    removeBuildingAt(cx, cy, true);
                }
                // 나무 제거
                if (typeof removeTreeAt === 'function') {
                    removeTreeAt(cx, cy);
                }
                // 구역 지정 확인
                const cell = grid[cx][cy];
                if (cell === CELL.ZONE_RESIDENTIAL || cell === CELL.ZONE_COMMERCIAL || cell === CELL.ZONE_INDUSTRIAL) {
                    zoneCleared = true;
                }
                grid[cx][cy] = CELL.ROAD_4LANE;
            }
        }

        // 원점 등록 (variant와 rotY는 나중에 rebuildRoadModels에서 계산)
        road4laneOrigins.set(`${x},${y}`, { variant: 'straight', rotY: 0 });

        // 구역이 도로로 대체되었으면 구역 시각 업데이트
        if (zoneCleared) {
            rebuildZoneInstances(false);
        }

        // 디버깅: 설치된 4차선 도로 방향 출력
        const mask = get4LaneRoadMask(x, y);
        const isNS = (mask === 5 || mask === 1 || mask === 4);
        const isEW = (mask === 10 || mask === 2 || mask === 8);
        const direction = isNS ? '세로' : (isEW ? '가로' : '기타');
        console.log(`[4차선 설치] (${x},${y}) - ${direction} (mask: ${mask})`);

        return true;
    }

    // 4차선 도로 철거
    function remove4LaneRoad(x, y) {
        const origin = find4LaneOrigin(x, y);
        if (!origin) return false;

        // 4개 셀 모두 EMPTY로 설정
        for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
                const cx = origin.x + dx;
                const cy = origin.y + dy;
                if (inBounds(cx, cy)) {
                    grid[cx][cy] = CELL.EMPTY;
                }
            }
        }

        // 원점 삭제
        road4laneOrigins.delete(`${origin.x},${origin.y}`);

        return true;
    }

    // 4차선 도로의 variant 가져오기 (rebuildRoadModels 전에도 사용 가능)
    function get4LaneVariant(originX, originY) {
        const data = road4laneOrigins.get(`${originX},${originY}`);
        if (!data) return null;

        // 마스크 계산하여 variant 결정
        const mask = get4LaneRoadMask(originX, originY);
        const { key: variant } = pickRoadVariant(mask);
        return { variant, mask };
    }

    // 2차선 도로가 4차선 도로 옆에 배치 가능한지 검사
    // 반환: { valid: boolean, reason?: string }
    function validate2LaneNear4Lane(x, y) {
        // 인접한 4차선 도로 찾기
        const directions = [
            { dx: 0, dy: 1 },   // 북쪽
            { dx: 0, dy: -1 },  // 남쪽
            { dx: 1, dy: 0 },   // 동쪽
            { dx: -1, dy: 0 },  // 서쪽
        ];

        for (const dir of directions) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;

            if (!is4LaneRoad(nx, ny)) continue;

            const origin = find4LaneOrigin(nx, ny);
            if (!origin) continue;

            // 2차선이 4차선의 어느 면에 접하는지 계산
            let touchSide;
            if (x < origin.x) touchSide = 'W';
            else if (x >= origin.x + 2) touchSide = 'E';
            else if (y < origin.y) touchSide = 'S';
            else if (y >= origin.y + 2) touchSide = 'N';
            else continue;  // 4차선 내부

            const variantInfo = get4LaneVariant(origin.x, origin.y);
            if (!variantInfo) continue;

            const { variant, mask } = variantInfo;

            // 규칙 1: 직선 또는 끝부분 타일에만 연결 가능
            // mask: 5=남북직선, 10=동서직선, 1=북끝, 4=남끝, 2=동끝, 8=서끝
            const canConnect = (mask === 5 || mask === 10 || mask === 1 || mask === 4 || mask === 2 || mask === 8);
            if (!canConnect) {
                return {
                    valid: false,
                    reason: '2차선은 4차선 직선/끝 도로에만 연결할 수 있습니다'
                };
            }

            // 남북 방향 (직선 또는 끝): mask 5, 1, 4
            const isNorthSouthType = (mask === 5 || mask === 1 || mask === 4);
            // 동서 방향 (직선 또는 끝): mask 10, 2, 8
            const isEastWestType = (mask === 10 || mask === 2 || mask === 8);

            // 규칙 2: 옆면에만 연결 가능 (정면 불가)
            if (isNorthSouthType && (touchSide === 'N' || touchSide === 'S')) {
                return {
                    valid: false,
                    reason: '2차선은 4차선 도로의 정면에 연결할 수 없습니다 (옆면만 가능)'
                };
            }
            if (isEastWestType && (touchSide === 'E' || touchSide === 'W')) {
                return {
                    valid: false,
                    reason: '2차선은 4차선 도로의 정면에 연결할 수 없습니다 (옆면만 가능)'
                };
            }

            // 규칙 3: 4차선 타일 한 면에 인접한 두 타일 중 하나에만 2차선 배치 가능
            // 예: 서쪽 면은 (origin.x-1, origin.y)와 (origin.x-1, origin.y+1) 두 칸
            //     이 두 칸 중 하나에만 2차선을 놓을 수 있음
            let otherCellX, otherCellY;
            if (touchSide === 'W') {
                otherCellX = origin.x - 1;
                otherCellY = (y === origin.y) ? origin.y + 1 : origin.y;
            } else if (touchSide === 'E') {
                otherCellX = origin.x + 2;
                otherCellY = (y === origin.y) ? origin.y + 1 : origin.y;
            } else if (touchSide === 'S') {
                otherCellY = origin.y - 1;
                otherCellX = (x === origin.x) ? origin.x + 1 : origin.x;
            } else {  // touchSide === 'N'
                otherCellY = origin.y + 2;
                otherCellX = (x === origin.x) ? origin.x + 1 : origin.x;
            }

            if (is2LaneRoad(otherCellX, otherCellY)) {
                return {
                    valid: false,
                    reason: '4차선 도로의 한 면에는 2차선을 연속으로 배치할 수 없습니다'
                };
            }
        }

        return { valid: true };
    }

    // 2차선 도로가 2x2 블록을 형성하는지 검사
    // 2차선 도로끼리 2x2 정사각형으로 붙어있으면 안됨
    function validate2LaneNo2x2Block(x, y) {
        // (x, y)에 2차선을 놓았을 때 2x2 블록이 완성되는지 확인
        // 4가지 경우: (x,y)가 2x2 블록의 각 코너가 되는 경우
        const corners = [
            // (x, y)가 좌하단
            [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }],
            // (x, y)가 우하단
            [{ dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 1 }],
            // (x, y)가 좌상단
            [{ dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 1, dy: -1 }],
            // (x, y)가 우상단
            [{ dx: -1, dy: 0 }, { dx: 0, dy: -1 }, { dx: -1, dy: -1 }],
        ];

        for (const offsets of corners) {
            let allRoads = true;
            for (const off of offsets) {
                const nx = x + off.dx;
                const ny = y + off.dy;
                if (!is2LaneRoad(nx, ny)) {
                    allRoads = false;
                    break;
                }
            }
            if (allRoads) {
                return {
                    valid: false,
                    reason: '2차선 도로는 2x2 블록으로 배치할 수 없습니다'
                };
            }
        }

        return { valid: true };
    }

    // 경로 내에서 4차선 한 면에 연속 배치가 발생하는지 검사
    // path: [{x, y}, ...] 배열
    function validatePathNo4LaneConsecutive(path) {
        if (!path || path.length < 2) return { valid: true };

        // 경로의 각 셀이 어느 4차선의 어느 면에 인접한지 수집
        // key: "originX,originY,side", value: [{x, y}, ...]
        const sideMap = new Map();

        for (const pt of path) {
            // 이 셀 주변의 4차선 확인
            const directions = [
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
            ];

            for (const dir of directions) {
                const nx = pt.x + dir.dx;
                const ny = pt.y + dir.dy;

                if (!is4LaneRoad(nx, ny)) continue;

                const origin = find4LaneOrigin(nx, ny);
                if (!origin) continue;

                // 어느 면에 접하는지 계산
                let touchSide;
                if (pt.x < origin.x) touchSide = 'W';
                else if (pt.x >= origin.x + 2) touchSide = 'E';
                else if (pt.y < origin.y) touchSide = 'S';
                else if (pt.y >= origin.y + 2) touchSide = 'N';
                else continue;

                const key = `${origin.x},${origin.y},${touchSide}`;
                if (!sideMap.has(key)) {
                    sideMap.set(key, []);
                }
                sideMap.get(key).push(pt);
            }
        }

        // 같은 면에 2개 이상의 경로 셀이 있으면 오류
        for (const [key, cells] of sideMap) {
            if (cells.length >= 2) {
                return {
                    valid: false,
                    reason: '4차선 도로의 한 면에는 2차선을 연속으로 배치할 수 없습니다'
                };
            }
        }

        return { valid: true };
    }

    // 경로 내에서 기존 도로 옆에 연속으로 2칸 이상 배치되는지 검사
    // path: [{x, y}, ...] 배열
    function validatePathNoParallelToRoad(path) {
        if (!path || path.length < 2) return { valid: true };

        // 경로를 Set으로 변환 (빠른 조회용)
        const pathSet = new Set(path.map(p => `${p.x},${p.y}`));

        // 각 셀이 기존 도로(경로 제외)에 인접한지 확인
        function isAdjacentToExistingRoad(x, y) {
            const directions = [
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
            ];
            for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                // 경로에 포함된 셀은 제외
                if (pathSet.has(`${nx},${ny}`)) continue;
                // 기존 도로인지 확인 (2차선 또는 4차선)
                if (is2LaneRoad(nx, ny) || is4LaneRoad(nx, ny)) {
                    return true;
                }
            }
            return false;
        }

        // 경로에서 연속된 2개 셀이 모두 기존 도로에 인접하면 오류
        for (let i = 0; i < path.length - 1; i++) {
            const curr = path[i];
            const next = path[i + 1];

            // 두 셀이 서로 인접한지 확인
            const dx = Math.abs(curr.x - next.x);
            const dy = Math.abs(curr.y - next.y);
            const isAdjacent = (dx + dy === 1);

            if (isAdjacent) {
                const currAdj = isAdjacentToExistingRoad(curr.x, curr.y);
                const nextAdj = isAdjacentToExistingRoad(next.x, next.y);

                if (currAdj && nextAdj) {
                    return {
                        valid: false,
                        reason: '기존 도로 옆에 2칸 이상 연속으로 배치할 수 없습니다'
                    };
                }
            }
        }

        return { valid: true };
    }

    function isWater(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        return grid[x][y] === CELL.WATER;
    }

    function isBridge(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        return grid[x][y] === CELL.BRIDGE;
    }

    function isBeach(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        return grid[x][y] === CELL.BEACH;
    }

    function isOcean(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        return grid[x][y] === CELL.OCEAN;
    }

    // 수로 또는 다리인지 확인 (다리 아래에도 수로가 있으므로)
    function isWaterOrBridge(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        const v = grid[x][y];
        return v === CELL.WATER || v === CELL.BRIDGE;
    }

    function isLocked(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        return grid[x][y] === CELL.LOCKED_ROAD;
    }

    function isBlocked(x, y) {
        if (!inBounds(x, y)) return true;
        if (!blocked[x]) return true;
        return blocked[x][y] === 1;
    }

    function isZone(x, y) {
        if (!inBounds(x, y)) return false;
        if (!grid[x]) return false;
        const v = grid[x][y];
        return v === CELL.ZONE_RESIDENTIAL || v === CELL.ZONE_COMMERCIAL || v === CELL.ZONE_INDUSTRIAL;
    }

    // 수로 마스크 계산 (다리 아래에도 수로가 있으므로 함께 처리)
    function getWaterMask(x, y) {
        if (!isWaterOrBridge(x, y)) return 0;
        let mask = 0;
        for (const [, d] of Object.entries(DIR)) {
            const nx = x + d.dx;
            const ny = y + d.dy;
            if (inBounds(nx, ny) && isWaterOrBridge(nx, ny)) {
                mask |= d.bit;
            }
        }
        return mask;
    }

    // 다리 여부 확인 (도로가 수로 위에 있어야 하는지)
    function shouldBeBridge(x, y) {
        // 현재 위치가 수로인지 확인
        if (!isWater(x, y)) return false;
        return true; // 수로 위에 도로를 놓으면 다리
    }

    // 다리의 방향 확인 (인접 도로 방향 기준)
    function getBridgeRotation(x, y) {
        // 인접한 도로 방향 확인
        let roadMask = 0;
        for (const [, d] of Object.entries(DIR)) {
            const nx = x + d.dx;
            const ny = y + d.dy;
            if (inBounds(nx, ny)) {
                const v = grid[nx][ny];
                if (v === CELL.ROAD || v === CELL.LOCKED_ROAD || v === CELL.BRIDGE) {
                    roadMask |= d.bit;
                }
            }
        }
        // 도로가 남-북으로 연결되면 다리도 남-북
        if ((roadMask & 5) !== 0) return Math.PI / 2; // N=1, S=4 -> 세로
        if ((roadMask & 10) !== 0) return 0; // E=2, W=8 -> 가로
        return 0;
    }

    function getZoneType(x, y) {
        if (!inBounds(x, y)) return CELL.EMPTY;
        if (!grid[x]) return CELL.EMPTY;
        return grid[x][y];
    }

    // 도로에 인접한지 확인 (상하좌우)
    function isAdjacentToRoad(x, y) {
        const neighbors = [
            { dx: 0, dy: -1 },  // 북
            { dx: 1, dy: 0 },   // 동
            { dx: 0, dy: 1 },   // 남
            { dx: -1, dy: 0 },  // 서
        ];

        for (const { dx, dy } of neighbors) {
            const nx = x + dx;
            const ny = y + dy;
            if (inBounds(nx, ny) && isRoad(nx, ny)) {
                return true;
            }
        }
        return false;
    }

    // 구역 지정 가능 여부 확인
    function canPlaceZone(x, y) {
        if (!inBounds(x, y)) return false;
        if (isRoad(x, y)) return false;
        if (isWaterOrBridge(x, y)) return false;  // 수로/다리 위 구역지정 금지
        if (isZone(x, y)) return false;
        if (isBlocked(x, y)) return false;
        if (!isAdjacentToRoad(x, y)) return false;
        if (findExpansionTurbineAt(x, y)) return false;  // 확장 터빈 위 구역지정 금지
        if (findExpansionSolarAt(x, y)) return false;  // 확장 패널 위 구역지정 금지
        return true;
    }

    /**
     * 마우스 월드 좌표에서 가장 가까운 설치 가능한 구역 타일 찾기
     * @param {number} worldX - 마우스 월드 X 좌표
     * @param {number} worldZ - 마우스 월드 Z 좌표
     * @param {number} maxRadius - 최대 검색 반경 (타일 단위)
     * @returns {{x: number, y: number, dist: number} | null} 가장 가까운 설치 가능 타일
     */
    function findNearestPlaceableZoneTile(worldX, worldZ, maxRadius = 5) {
        let nearest = null;
        let nearestDist = Infinity;

        // 마우스 위치를 타일 좌표로 변환 (부동소수점)
        const tileX = worldX / TILE_SIZE + GRID_W / 2;
        const tileZ = worldZ / TILE_SIZE + GRID_H / 2;

        // 정수 타일 좌표
        const centerTileX = Math.floor(tileX);
        const centerTileZ = Math.floor(tileZ);

        // 검색 범위 내 타일 순회
        for (let dx = -maxRadius; dx <= maxRadius; dx++) {
            for (let dy = -maxRadius; dy <= maxRadius; dy++) {
                const tx = centerTileX + dx;
                const ty = centerTileZ + dy;

                if (!inBounds(tx, ty)) continue;
                if (!canPlaceZone(tx, ty)) continue;

                // 타일 중심과 마우스 위치 간의 거리 계산
                const tileCenterX = tx + 0.5;
                const tileCenterZ = ty + 0.5;
                const dist = Math.sqrt(
                    Math.pow(tileCenterX - tileX, 2) +
                    Math.pow(tileCenterZ - tileZ, 2)
                );

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = { x: tx, y: ty, dist: dist };
                }
            }
        }

        return nearest;
    }

    /* =========================================================
     * GROUND (투명 - 클릭 감지용)
     * ========================================================= */
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(GRID_W * TILE_SIZE, GRID_H * TILE_SIZE),
        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const gridHelper = new THREE.GridHelper(
        GRID_W * TILE_SIZE,
        GRID_W,
        0xaaaaaa,
        0xcccccc
    );
    gridHelper.position.y = 0.01;
    gridHelper.visible = false;  // 기본 숨김, 도로/수로 모드에서만 표시
    scene.add(gridHelper);

    /* =========================================================
     * INSTANCED MESHES
     * ========================================================= */
    const roadGeo = new THREE.BoxGeometry(TILE_SIZE, 0.08, TILE_SIZE);

    const roadMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
    const roadMesh = new THREE.InstancedMesh(roadGeo, roadMat, GRID_W * GRID_H);
    roadMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    roadMesh.castShadow = true;
    roadMesh.receiveShadow = true;
    scene.add(roadMesh);

    const lockedMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const lockedRoadMesh = new THREE.InstancedMesh(roadGeo, lockedMat, GRID_W * GRID_H);
    lockedRoadMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    lockedRoadMesh.castShadow = true;
    lockedRoadMesh.receiveShadow = true;
    scene.add(lockedRoadMesh);

    // 구역 시각화 메시 - 같은 구역끼리 이어지도록 전체 타일 크기 사용
    const zoneGeo = new THREE.BoxGeometry(TILE_SIZE, 0.15, TILE_SIZE);

    const residentialMat = new THREE.MeshStandardMaterial({
        color: ZONE_COLORS[CELL.ZONE_RESIDENTIAL],
        emissive: ZONE_COLORS[CELL.ZONE_RESIDENTIAL],
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.85,
        depthTest: false,   // 건물 위에 표시
        depthWrite: false,
    });
    const residentialMesh = new THREE.InstancedMesh(zoneGeo, residentialMat, GRID_W * GRID_H);
    residentialMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    residentialMesh.receiveShadow = false;
    residentialMesh.renderOrder = 999;  // 건물 위에 렌더링
    scene.add(residentialMesh);

    const commercialMat = new THREE.MeshStandardMaterial({
        color: ZONE_COLORS[CELL.ZONE_COMMERCIAL],
        emissive: ZONE_COLORS[CELL.ZONE_COMMERCIAL],
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.85,
        depthTest: false,   // 건물 위에 표시
        depthWrite: false,
    });
    const commercialMesh = new THREE.InstancedMesh(zoneGeo, commercialMat, GRID_W * GRID_H);
    commercialMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    commercialMesh.receiveShadow = false;
    commercialMesh.renderOrder = 999;  // 건물 위에 렌더링
    scene.add(commercialMesh);

    const industrialMat = new THREE.MeshStandardMaterial({
        color: ZONE_COLORS[CELL.ZONE_INDUSTRIAL],
        emissive: ZONE_COLORS[CELL.ZONE_INDUSTRIAL],
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.85,
        depthTest: false,   // 건물 위에 표시
        depthWrite: false,
    });
    const industrialMesh = new THREE.InstancedMesh(zoneGeo, industrialMat, GRID_W * GRID_H);
    industrialMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    industrialMesh.receiveShadow = false;
    industrialMesh.renderOrder = 999;  // 건물 위에 렌더링
    scene.add(industrialMesh);

    // 구역 메시 초기 가시성 - 숨김 (구역 모드에서만 표시)
    residentialMesh.visible = false;
    commercialMesh.visible = false;
    industrialMesh.visible = false;

    /* =========================================================
     * LAND VALUE VISUALIZATION SYSTEM - 땅값 시각화 (2D 그라데이션)
     * 부드러운 픽셀 그라데이션으로 땅값 표현
     * 낮음=빨강, 중간=흰색, 높음=초록/청록
     * ========================================================= */
    const landValueGroup = new THREE.Group();
    landValueGroup.name = "landValueGroup";
    landValueGroup.visible = false;
    landValueGroup.renderOrder = 999;  // 다른 오브젝트 위에 렌더링
    scene.add(landValueGroup);

    // 땅값 오버레이 텍스처 및 메시
    let landValueOverlayMesh = null;
    let landValueCanvas = null;
    let landValueCtx = null;
    let landValueTexture = null;

    // 건물 원본 머티리얼 저장 (땅값 뷰용)
    const buildingOriginalMaterialsForLandValue = new Map();
    // 차량 원본 머티리얼 저장 (땅값 뷰용)
    const vehicleOriginalMaterialsForLandValue = new Map();

    // 땅값 색상: -100=빨강, 0=흰색, 100=청색
    function getLandValueColor(value) {
        // 값 범위: -100 ~ 100 (0이 중간)
        const MIN_VAL = -100;
        const MAX_VAL = 100;
        const MID_VAL = 0;

        // 정규화
        const clamped = Math.max(MIN_VAL, Math.min(MAX_VAL, value));

        if (clamped <= MID_VAL) {
            // 빨강 -> 흰색 (-100 -> 0)
            const t = (clamped - MIN_VAL) / (MID_VAL - MIN_VAL);  // 0 ~ 1
            return {
                r: 255,
                g: Math.round(255 * t),
                b: Math.round(255 * t)
            };
        } else {
            // 흰색 -> 청색 (0 -> 100)
            const t = (clamped - MID_VAL) / (MAX_VAL - MID_VAL);  // 0 ~ 1
            return {
                r: Math.round(255 * (1 - t)),
                g: Math.round(255 * (1 - t)),
                b: 255
            };
        }
    }

    // THREE.Color용 땅값 색상
    function getLandValueColorThree(value) {
        const c = getLandValueColor(value);
        return new THREE.Color(c.r / 255, c.g / 255, c.b / 255);
    }

    // 땅값 데이터 배열 생성
    function createLandValueDataArray() {
        const data = [];
        for (let z = 0; z < GRID_H; z++) {
            data[z] = [];
            for (let x = 0; x < GRID_W; x++) {
                const baseLandValue = getLandValue(x, z);
                const serviceBonus = typeof getServiceBonus === 'function' ? getServiceBonus(x, z) : 0;
                data[z][x] = baseLandValue + serviceBonus;
            }
        }
        return data;
    }

    // Smoothstep 함수 (부드러운 보간)
    function smoothstep(edge0, edge1, x) {
        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
    }

    // 메타볼 스타일 영향력 계산 (부드러운 곡선 falloff)
    function metaballInfluence(dist, radius) {
        if (dist >= radius) return 0;
        // 부드러운 곡선 감쇠 (코사인 기반)
        const t = dist / radius;
        return Math.pow(1 - t * t, 2);  // Wendland 커널 변형
    }

    // 땅값 시각화 생성 (메타볼 스타일 곡선 영역)
    function createLandValueVisualization() {
        // 기존 오버레이 제거
        if (landValueOverlayMesh) {
            landValueGroup.remove(landValueOverlayMesh);
            if (landValueOverlayMesh.geometry) landValueOverlayMesh.geometry.dispose();
            if (landValueOverlayMesh.material) landValueOverlayMesh.material.dispose();
            if (landValueTexture) landValueTexture.dispose();
        }

        // 캔버스 생성 (고해상도)
        const resolution = 8;  // 타일당 픽셀 수 (높을수록 부드러움)
        const canvasW = GRID_W * resolution;
        const canvasH = GRID_H * resolution;

        landValueCanvas = document.createElement('canvas');
        landValueCanvas.width = canvasW;
        landValueCanvas.height = canvasH;
        landValueCtx = landValueCanvas.getContext('2d');

        // 땅값 데이터 생성
        const rawData = createLandValueDataArray();

        // 영향력 범위 (타일 단위)
        const influenceRadius = 3.5;

        // 캔버스에 메타볼 스타일 그라데이션 그리기
        const imageData = landValueCtx.createImageData(canvasW, canvasH);

        for (let py = 0; py < canvasH; py++) {
            for (let px = 0; px < canvasW; px++) {
                // 픽셀 좌표를 그리드 좌표로 변환
                const gx = (px + 0.5) / resolution;
                const gz = (py + 0.5) / resolution;

                // 주변 타일들의 영향력을 합산 (메타볼 방식)
                let weightedSum = 0;
                let totalWeight = 0;

                // 영향력 범위 내 타일들 검사
                const searchRadius = Math.ceil(influenceRadius) + 1;
                const centerX = Math.floor(gx);
                const centerZ = Math.floor(gz);

                for (let dz = -searchRadius; dz <= searchRadius; dz++) {
                    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                        const tx = centerX + dx;
                        const tz = centerZ + dz;

                        // 범위 체크
                        if (tx < 0 || tx >= GRID_W || tz < 0 || tz >= GRID_H) continue;

                        // 타일 중심까지의 거리
                        const tileCenterX = tx + 0.5;
                        const tileCenterZ = tz + 0.5;
                        const dist = Math.sqrt(
                            Math.pow(gx - tileCenterX, 2) +
                            Math.pow(gz - tileCenterZ, 2)
                        );

                        // 메타볼 영향력 계산
                        const influence = metaballInfluence(dist, influenceRadius);
                        if (influence > 0) {
                            weightedSum += rawData[tz][tx] * influence;
                            totalWeight += influence;
                        }
                    }
                }

                // 가중 평균 계산
                const value = totalWeight > 0 ? weightedSum / totalWeight : 0;

                const color = getLandValueColor(value);
                const idx = (py * canvasW + px) * 4;
                imageData.data[idx] = color.r;
                imageData.data[idx + 1] = color.g;
                imageData.data[idx + 2] = color.b;
                imageData.data[idx + 3] = 220;  // 선명하게
            }
        }

        landValueCtx.putImageData(imageData, 0, 0);

        // 텍스처 생성
        landValueTexture = new THREE.CanvasTexture(landValueCanvas);
        landValueTexture.minFilter = THREE.LinearFilter;
        landValueTexture.magFilter = THREE.LinearFilter;
        landValueTexture.needsUpdate = true;

        // 지면 오버레이 평면 생성
        const planeW = GRID_W * TILE_SIZE;
        const planeH = GRID_H * TILE_SIZE;
        const planeGeo = new THREE.PlaneGeometry(planeW, planeH);
        const planeMat = new THREE.MeshBasicMaterial({
            map: landValueTexture,
            transparent: true,
            opacity: 0.85,
            depthWrite: false,
            depthTest: true,
            side: THREE.DoubleSide,
        });

        landValueOverlayMesh = new THREE.Mesh(planeGeo, planeMat);
        landValueOverlayMesh.rotation.x = -Math.PI / 2;  // 수평으로 눕히기
        landValueOverlayMesh.position.set(0, 0.15, 0);  // 지면 위 (잔디보다 위)
        landValueOverlayMesh.renderOrder = 1;  // 렌더링 순서 조정
        landValueGroup.add(landValueOverlayMesh);

        // 건물 색상 적용
        applyLandValueToBuildings(rawData);
    }

    // 건물에 땅값 색상 적용
    function applyLandValueToBuildings(blurredData) {
        buildingOriginalMaterialsForLandValue.clear();

        buildingGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                // 원본 머티리얼 저장
                buildingOriginalMaterialsForLandValue.set(child.uuid, child.material);

                // 건물 위치에서 땅값 가져오기
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);

                // 월드 좌표 -> 그리드 좌표
                const gx = Math.floor(worldPos.x / TILE_SIZE + GRID_W / 2);
                const gz = Math.floor(worldPos.z / TILE_SIZE + GRID_H / 2);

                // 범위 체크
                const clampedX = Math.max(0, Math.min(GRID_W - 1, gx));
                const clampedZ = Math.max(0, Math.min(GRID_H - 1, gz));

                const value = blurredData[clampedZ][clampedX];
                const color = getLandValueColorThree(value);

                // 땅값 색상으로 머티리얼 교체
                child.material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    roughness: 0.8,
                    metalness: 0.0,
                });
            }
        });
    }

    // 차량 회색 재질 (공유, 성능 최적화)
    const vehicleGrayMaterial = new THREE.MeshStandardMaterial({
        color: 0x888888,
        roughness: 0.8,
        metalness: 0.0,
    });

    // 차량에 회색 적용 (땅값 뷰)
    function applyLandValueToVehicles() {
        vehicleOriginalMaterialsForLandValue.clear();

        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            trafficManager.vehicleGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    vehicleOriginalMaterialsForLandValue.set(child.uuid, child.material);
                    child.material = vehicleGrayMaterial;  // 공유 재질 사용 (성능 최적화)
                }
            });
        }
    }

    // 건물 원래 머티리얼 복원
    function restoreBuildingMaterialsFromLandValue() {
        const materialsToDispose = [];

        buildingGroup.traverse((child) => {
            if (child.isMesh && buildingOriginalMaterialsForLandValue.has(child.uuid)) {
                const originalMaterial = buildingOriginalMaterialsForLandValue.get(child.uuid);
                const currentMaterial = child.material;

                // 현재 재질이 원본과 다르면 (땅값 뷰 재질) 폐기 예약
                if (currentMaterial && currentMaterial !== originalMaterial) {
                    // 땅값 재질의 UUID를 색상 캐시에서 제거
                    const currentMats = Array.isArray(currentMaterial) ? currentMaterial : [currentMaterial];
                    currentMats.forEach(mat => {
                        if (mat && mat.uuid) {
                            originalObjectColors.delete(mat.uuid);
                        }
                        materialsToDispose.push(mat);
                    });
                }

                // 안전한 머티리얼 할당 사용
                safeAssignMaterial(child, originalMaterial);
            }
        });

        // 땅값 재질 dispose (복원 후에 안전하게)
        materialsToDispose.forEach(mat => {
            if (mat && mat.dispose) mat.dispose();
        });

        buildingOriginalMaterialsForLandValue.clear();

        // 차량 머티리얼도 복원 (공유 재질은 dispose하지 않음)
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            trafficManager.vehicleGroup.traverse((child) => {
                if (child.isMesh && vehicleOriginalMaterialsForLandValue.has(child.uuid)) {
                    const originalMaterial = vehicleOriginalMaterialsForLandValue.get(child.uuid);
                    safeAssignMaterial(child, originalMaterial);
                }
            });

            // 모든 차량도 명시적으로 복원 (vehicleGroup.traverse가 놓칠 수 있음)
            if (trafficManager.vehicles) {
                trafficManager.vehicles.forEach(vehicle => {
                    if (vehicle.mesh) {
                        vehicle.mesh.traverse((child) => {
                            if (child.isMesh && vehicleOriginalMaterialsForLandValue.has(child.uuid)) {
                                const originalMaterial = vehicleOriginalMaterialsForLandValue.get(child.uuid);
                                safeAssignMaterial(child, originalMaterial);
                            }
                        });
                    }
                });
            }
        }

        vehicleOriginalMaterialsForLandValue.clear();

        // 색상 틴트 강제 재계산
        lastColorTintHour = -1;
    }

    // 땅값 뷰 토글
    let isLandValueViewActive = false;

    /* =========================================================
     * SERVICE BUILDING VIEW MODE - 서비스 건물 범례 모드
     * 소방서, 경찰서, 학교, 병원, 공원 등의 건물을 초록색으로 하이라이트
     * ========================================================= */
    let activeServiceViewType = null;  // 현재 활성화된 서비스 뷰 타입
    const serviceViewOriginalMaterials = new Map();  // 원본 재질 저장

    // 서비스 건물 하이라이트용 재질 (초록색 반투명)
    const serviceHighlightMaterial = new THREE.MeshStandardMaterial({
        color: 0x44ff66,
        transparent: true,
        opacity: 0.85,
        emissive: 0x22aa44,
        emissiveIntensity: 0.3,
        roughness: 0.5,
        metalness: 0.0,
    });

    /**
     * 서비스 건물 뷰 모드 진입
     * @param {string} serviceType - 'fire', 'police', 'school', 'hospital', 'park'
     */
    function enterServiceBuildingView(serviceType) {
        // 이미 같은 뷰가 활성화되어 있으면 종료
        if (activeServiceViewType === serviceType) {
            exitServiceBuildingView();
            return;
        }

        // 다른 서비스 뷰가 활성화되어 있으면 먼저 종료 (전환 모드)
        if (activeServiceViewType) {
            exitServiceBuildingView(true);  // isSwitching = true
        }

        // 구역 모드에서 진입하는 경우 구역 모드 상태 정리
        if (isZoneMode() || currentMode === MODE.ZONE_DELETE) {
            // 구역 메시 숨기기
            residentialMesh.visible = false;
            commercialMesh.visible = false;
            industrialMesh.visible = false;

            // 좌측 사이드바 숨기기
            if (leftSidebar) leftSidebar.classList.remove('visible');

            // 구역 모드 힌트 숨기기
            const zoneModeHint = document.getElementById('zoneModeHint');
            if (zoneModeHint) zoneModeHint.classList.remove('visible');

            // 구역 범례 숨기기
            hideDataViewLegend();

            // 땅값/인구 뷰가 활성화되어 있으면 종료
            if (isLandValueViewActive) exitLandValueView();
            if (isPopulationViewActive) exitPopulationView();

            // 현재 모드를 카메라로 변경 (구역 모드 상태 해제)
            currentMode = MODE.CAMERA;
        }

        activeServiceViewType = serviceType;

        // 구역 모드 효과 적용 (흰색/회색 배경)
        applyZoneModeEffect();

        // 모든 건물 불투명 처리 (범례 가시성 향상)
        setAllBuildingsTransparent(1.0);

        // 서비스 효과 범위 표시
        showServiceEffects(serviceType);

        // 해당 타입의 건물들을 초록색으로 하이라이트 (반투명 해제)
        highlightServiceBuildings(serviceType);

        // 서비스 타입별 확률 바 표시
        if (serviceType === 'fire') {
            showFireProbabilityBars();
        } else if (serviceType === 'police') {
            showCrimeProbabilityBars();
        } else if (serviceType === 'hospital') {
            showPatientProbabilityBars();
        }

        // 서비스 뷰 범례 표시
        showServiceViewLegend(serviceType);

        console.log(`[ServiceView] Entered: ${serviceType}`);
    }

    /**
     * 서비스 건물 뷰 모드 종료
     */
    function exitServiceBuildingView(isSwitching = false) {
        if (!activeServiceViewType) return;

        const prevType = activeServiceViewType;
        activeServiceViewType = null;

        // 확률 바 숨기기 (모든 타입)
        hideFireProbabilityBars();
        hideCrimeProbabilityBars();
        hidePatientProbabilityBars();

        // 서비스 효과 범위 숨기기
        clearServiceEffects();

        // 서비스 간 전환이 아닐 때만 재질 복원 (전환 시에는 새 서비스 뷰에서 처리)
        if (!isSwitching) {
            // 구역 모드 효과 복원 (모든 건물을 원래 색상으로 한 번에 복원) - 강제 복원
            restoreOriginalMaterials(true);

            // 모든 건물 투명도 복원
            restoreAllBuildingOpacity();
        }

        // 서비스 뷰 원래 재질 맵 클리어
        serviceViewOriginalMaterials.clear();

        // 범례 숨기기
        hideServiceViewLegend();

        // 건물 팝업 숨기기 (전환이 아닐 때만)
        if (!isSwitching) {
            if (typeof hidePublicBuildingPopup === 'function') {
                hidePublicBuildingPopup();
            }
            if (typeof hideBuildingPopup === 'function') {
                hideBuildingPopup();
            }
        }

        console.log(`[ServiceView] Exited: ${prevType}`);
    }

    /**
     * 해당 타입의 서비스 건물들을 초록색으로 하이라이트
     */
    function highlightServiceBuildings(serviceType) {
        serviceViewOriginalMaterials.clear();

        // placedPublicBuildings에서 해당 타입의 건물 찾기
        placedPublicBuildings.forEach((building, key) => {
            if (building.ref) return;  // 참조는 스킵
            if (building.type !== serviceType) return;
            if (!building.instance) return;

            // 건물의 모든 메시에 하이라이트 재질 적용
            building.instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    serviceViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = serviceHighlightMaterial;
                }
            });
        });
    }

    /**
     * 서비스 건물 재질 복원
     */
    function restoreServiceBuildingMaterials() {
        placedPublicBuildings.forEach((building, key) => {
            if (building.ref) return;
            if (!building.instance) return;

            building.instance.traverse((child) => {
                if (child.isMesh && serviceViewOriginalMaterials.has(child.uuid)) {
                    const originalMaterial = serviceViewOriginalMaterials.get(child.uuid);
                    child.material = originalMaterial;
                }
            });
        });

        serviceViewOriginalMaterials.clear();
    }

    /* =========================================================
     * FIRE PROBABILITY BAR VISUALIZATION - 화재 확률 막대 그래프
     * 소방 뷰 활성화 시 건물 위에 화재 확률 막대 표시
     * ========================================================= */
    const fireProbabilityBarsGroup = new THREE.Group();
    fireProbabilityBarsGroup.name = "fireProbabilityBarsGroup";
    fireProbabilityBarsGroup.visible = false;
    fireProbabilityBarsGroup.renderOrder = 9999;  // 건물 위에 렌더링
    scene.add(fireProbabilityBarsGroup);

    // 화재 확률 바 재사용 풀
    const fireBarPool = [];
    const fireBarMaterials = {
        low: new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false }),      // 초록 (낮음)
        medium: new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false }),   // 노랑 (중간)
        high: new THREE.MeshBasicMaterial({ color: 0xef4444, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false })      // 빨강 (높음)
    };
    const fireBarGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);  // 정사각형 바

    /**
     * 건물별 화재 확률 계산
     */
    function getFireProbabilityForBuilding(building, x, y) {
        let fireChance = FIRE_BASE_CHANCE;

        // 공장은 3배
        if (building.zoneType === CELL.ZONE_INDUSTRIAL) {
            fireChance *= FIRE_INDUSTRIAL_MULTIPLIER;
        }

        // 소방서 범위 체크
        const isProtected = isInFireStationRange(x, y);
        if (isProtected) {
            fireChance *= 0.1;  // 90% 감소
        }

        // 주변 화재 확산 체크
        const nearbyFire = checkNearbyFire(x, y);
        if (nearbyFire) {
            fireChance += FIRE_SPREAD_CHANCE || 0.02;
        }

        return fireChance;
    }

    /**
     * 주변 화재 여부 체크
     */
    function checkNearbyFire(x, y) {
        if (typeof activeFires === 'undefined') return false;
        const checkRange = 3;
        for (const fire of activeFires) {
            if (!fire) continue;
            const dist = Math.abs(fire.x - x) + Math.abs(fire.y - y);
            if (dist <= checkRange) return true;
        }
        return false;
    }

    /**
     * 화재 확률에 따른 색상 결정
     */
    function getFireBarMaterial(probability) {
        // 기본 확률 기준
        const baseChance = FIRE_BASE_CHANCE;
        const ratio = probability / baseChance;

        if (ratio <= 0.5) return fireBarMaterials.low;       // 낮음 (보호됨)
        if (ratio <= 2) return fireBarMaterials.medium;      // 중간 (일반)
        return fireBarMaterials.high;                         // 높음 (공장 등)
    }

    /**
     * 화재 확률 바 생성 또는 풀에서 가져오기
     */
    function getFireBar() {
        if (fireBarPool.length > 0) {
            return fireBarPool.pop();
        }
        // 새 바 생성 (값 바만)
        const barGroup = new THREE.Group();
        barGroup.renderOrder = 9999;
        const valueBar = new THREE.Mesh(fireBarGeometry, fireBarMaterials.medium);
        valueBar.name = 'valueBar';
        valueBar.renderOrder = 9999;
        barGroup.add(valueBar);
        return barGroup;
    }

    /**
     * 화재 확률 바를 풀로 반환
     */
    function returnFireBar(barGroup) {
        barGroup.visible = false;
        fireBarPool.push(barGroup);
    }

    /**
     * 모든 건물에 화재 확률 바 표시
     */
    function showFireProbabilityBars() {
        // 기존 바 숨기기 및 풀로 반환
        while (fireProbabilityBarsGroup.children.length > 0) {
            const bar = fireProbabilityBarsGroup.children[0];
            fireProbabilityBarsGroup.remove(bar);
            returnFireBar(bar);
        }

        const buildingsArray = getPlacedBuildingsArray();
        const maxBarHeight = 3;  // 최대 바 높이

        for (const { key, building } of buildingsArray) {
            if (!building.instance) continue;

            const [x, y] = key.split(',').map(Number);
            const fireProb = getFireProbabilityForBuilding(building, x, y);

            // 확률을 높이로 변환 (0 ~ 최대 FIRE_BASE_CHANCE * 3)
            const maxProb = FIRE_BASE_CHANCE * FIRE_INDUSTRIAL_MULTIPLIER;
            const normalizedProb = Math.min(fireProb / maxProb, 1);
            const barHeight = normalizedProb * maxBarHeight;

            if (barHeight < 0.05) continue;  // 너무 작은 바는 스킵

            // 바 가져오기
            const barGroup = getFireBar();
            barGroup.visible = true;

            // 값 바 설정
            const valueBar = barGroup.getObjectByName('valueBar');
            if (valueBar) {
                valueBar.material = getFireBarMaterial(fireProb);
                valueBar.scale.y = barHeight;
                valueBar.position.y = barHeight / 2;
            }

            // hover용 데이터 저장
            barGroup.userData.probability = fireProb;
            barGroup.userData.barType = 'fire';

            // 위치 설정 (지상에서 시작) - 바운딩 박스로 중심 좌표 계산
            if (building.instance) {
                const bbox = new THREE.Box3().setFromObject(building.instance);
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                barGroup.position.set(center.x, 0, center.z);
            } else {
                const worldX = x - GRID_W / 2 + 0.5;
                const worldZ = y - GRID_H / 2 + 0.5;
                barGroup.position.set(worldX, 0, worldZ);
            }

            fireProbabilityBarsGroup.add(barGroup);
        }

        fireProbabilityBarsGroup.visible = true;
    }

    /**
     * 화재 확률 바 숨기기
     */
    function hideFireProbabilityBars() {
        fireProbabilityBarsGroup.visible = false;

        // 모든 바를 풀로 반환
        while (fireProbabilityBarsGroup.children.length > 0) {
            const bar = fireProbabilityBarsGroup.children[0];
            fireProbabilityBarsGroup.remove(bar);
            returnFireBar(bar);
        }
    }

    /* =========================================================
     * CRIME PROBABILITY BARS (범죄 발생 확률 바) - 경찰 뷰용
     * ========================================================= */
    const crimeProbabilityBarsGroup = new THREE.Group();
    crimeProbabilityBarsGroup.name = "crimeProbabilityBarsGroup";
    crimeProbabilityBarsGroup.visible = false;
    crimeProbabilityBarsGroup.renderOrder = 9999;  // 건물 위에 렌더링
    scene.add(crimeProbabilityBarsGroup);

    const crimeBarPool = [];
    const crimeBarMaterials = {
        low: new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false }),
        medium: new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false }),
        high: new THREE.MeshBasicMaterial({ color: 0xef4444, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false })
    };
    const crimeBarGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);  // 정사각형 바

    // 범죄 확률 바 표시용 상수
    const CRIME_VIEW_BASE_PROB = 0.008;  // 기본 범죄 발생 확률 (뷰용)
    const CRIME_VIEW_COMMERCIAL_MULT = 2;  // 상업지역 범죄 배수 (뷰용)

    function getCrimeProbabilityForBuilding(building, x, y) {
        let crimeChance = CRIME_VIEW_BASE_PROB;

        // 상업지역은 2배
        if (building.zoneType === CELL.ZONE_COMMERCIAL) {
            crimeChance *= CRIME_VIEW_COMMERCIAL_MULT;
        }

        // 경찰서 범위 체크
        const isProtected = isInPoliceStationRange(x, y);
        if (isProtected) {
            crimeChance *= 0.1;  // 90% 감소
        }

        return crimeChance;
    }

    // isInPoliceStationRange는 기존 함수 재사용 (line ~18219)

    function getCrimeBarMaterial(probability) {
        const ratio = probability / CRIME_VIEW_BASE_PROB;
        if (ratio <= 0.5) return crimeBarMaterials.low;
        if (ratio <= 2) return crimeBarMaterials.medium;
        return crimeBarMaterials.high;
    }

    function getCrimeBar() {
        if (crimeBarPool.length > 0) return crimeBarPool.pop();
        const barGroup = new THREE.Group();
        barGroup.renderOrder = 9999;
        const valueBar = new THREE.Mesh(crimeBarGeometry, crimeBarMaterials.medium);
        valueBar.name = 'valueBar';
        valueBar.renderOrder = 9999;
        barGroup.add(valueBar);
        return barGroup;
    }

    function returnCrimeBar(barGroup) {
        barGroup.visible = false;
        crimeBarPool.push(barGroup);
    }

    function showCrimeProbabilityBars() {
        while (crimeProbabilityBarsGroup.children.length > 0) {
            const bar = crimeProbabilityBarsGroup.children[0];
            crimeProbabilityBarsGroup.remove(bar);
            returnCrimeBar(bar);
        }

        const buildingsArray = getPlacedBuildingsArray();
        const maxBarHeight = 3;
        const maxProb = CRIME_VIEW_BASE_PROB * CRIME_VIEW_COMMERCIAL_MULT;

        for (const { key, building } of buildingsArray) {
            if (!building.instance) continue;
            const [x, y] = key.split(',').map(Number);
            const crimeProb = getCrimeProbabilityForBuilding(building, x, y);
            const normalizedProb = Math.min(crimeProb / maxProb, 1);
            const barHeight = normalizedProb * maxBarHeight;

            if (barHeight < 0.05) continue;

            const barGroup = getCrimeBar();
            barGroup.visible = true;

            const valueBar = barGroup.getObjectByName('valueBar');
            if (valueBar) {
                valueBar.material = getCrimeBarMaterial(crimeProb);
                valueBar.scale.y = barHeight;
                valueBar.position.y = barHeight / 2;
            }

            // hover용 데이터 저장
            barGroup.userData.probability = crimeProb;
            barGroup.userData.barType = 'crime';

            // 위치 설정 (지상에서 시작) - 바운딩 박스로 중심 좌표 계산
            if (building.instance) {
                const bbox = new THREE.Box3().setFromObject(building.instance);
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                barGroup.position.set(center.x, 0, center.z);
            } else {
                const worldX = x - GRID_W / 2 + 0.5;
                const worldZ = y - GRID_H / 2 + 0.5;
                barGroup.position.set(worldX, 0, worldZ);
            }

            crimeProbabilityBarsGroup.add(barGroup);
        }

        crimeProbabilityBarsGroup.visible = true;
    }

    function hideCrimeProbabilityBars() {
        crimeProbabilityBarsGroup.visible = false;
        while (crimeProbabilityBarsGroup.children.length > 0) {
            const bar = crimeProbabilityBarsGroup.children[0];
            crimeProbabilityBarsGroup.remove(bar);
            returnCrimeBar(bar);
        }
    }

    /* =========================================================
     * PATIENT PROBABILITY BARS (환자 발생 확률 바) - 병원 뷰용
     * ========================================================= */
    const patientProbabilityBarsGroup = new THREE.Group();
    patientProbabilityBarsGroup.name = "patientProbabilityBarsGroup";
    patientProbabilityBarsGroup.visible = false;
    patientProbabilityBarsGroup.renderOrder = 9999;  // 건물 위에 렌더링
    scene.add(patientProbabilityBarsGroup);

    const patientBarPool = [];
    const patientBarMaterials = {
        low: new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false }),
        medium: new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false }),
        high: new THREE.MeshBasicMaterial({ color: 0xef4444, transparent: true, opacity: 0.9, depthTest: false, depthWrite: false })
    };
    const patientBarGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);  // 정사각형 바

    // 환자 발생 확률 상수
    const PATIENT_BASE_CHANCE = 0.006;  // 기본 환자 발생 확률
    const PATIENT_INDUSTRIAL_MULTIPLIER = 2.5;  // 공업지역 환자 발생 배수

    function getPatientProbabilityForBuilding(building, x, y) {
        let patientChance = PATIENT_BASE_CHANCE;

        // 공업지역은 2.5배 (오염으로 인한 건강 문제)
        if (building.zoneType === CELL.ZONE_INDUSTRIAL) {
            patientChance *= PATIENT_INDUSTRIAL_MULTIPLIER;
        }

        // 병원 범위 체크
        const isProtected = isInHospitalRange(x, y);
        if (isProtected) {
            patientChance *= 0.2;  // 80% 감소 (의료 서비스 제공)
        }

        return patientChance;
    }

    // isInHospitalRange는 기존 함수 재사용 (line ~18976)

    function getPatientBarMaterial(probability) {
        const ratio = probability / PATIENT_BASE_CHANCE;
        if (ratio <= 0.5) return patientBarMaterials.low;
        if (ratio <= 2) return patientBarMaterials.medium;
        return patientBarMaterials.high;
    }

    function getPatientBar() {
        if (patientBarPool.length > 0) return patientBarPool.pop();
        const barGroup = new THREE.Group();
        barGroup.renderOrder = 9999;
        const valueBar = new THREE.Mesh(patientBarGeometry, patientBarMaterials.medium);
        valueBar.name = 'valueBar';
        valueBar.renderOrder = 9999;
        barGroup.add(valueBar);
        return barGroup;
    }

    function returnPatientBar(barGroup) {
        barGroup.visible = false;
        patientBarPool.push(barGroup);
    }

    function showPatientProbabilityBars() {
        while (patientProbabilityBarsGroup.children.length > 0) {
            const bar = patientProbabilityBarsGroup.children[0];
            patientProbabilityBarsGroup.remove(bar);
            returnPatientBar(bar);
        }

        const buildingsArray = getPlacedBuildingsArray();
        const maxBarHeight = 3;
        const maxProb = PATIENT_BASE_CHANCE * PATIENT_INDUSTRIAL_MULTIPLIER;

        for (const { key, building } of buildingsArray) {
            if (!building.instance) continue;
            const [x, y] = key.split(',').map(Number);
            const patientProb = getPatientProbabilityForBuilding(building, x, y);
            const normalizedProb = Math.min(patientProb / maxProb, 1);
            const barHeight = normalizedProb * maxBarHeight;

            if (barHeight < 0.05) continue;

            const barGroup = getPatientBar();
            barGroup.visible = true;

            const valueBar = barGroup.getObjectByName('valueBar');
            if (valueBar) {
                valueBar.material = getPatientBarMaterial(patientProb);
                valueBar.scale.y = barHeight;
                valueBar.position.y = barHeight / 2;
            }

            // hover용 데이터 저장
            barGroup.userData.probability = patientProb;
            barGroup.userData.barType = 'patient';

            // 위치 설정 (지상에서 시작) - 바운딩 박스로 중심 좌표 계산
            if (building.instance) {
                const bbox = new THREE.Box3().setFromObject(building.instance);
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                barGroup.position.set(center.x, 0, center.z);
            } else {
                const worldX = x - GRID_W / 2 + 0.5;
                const worldZ = y - GRID_H / 2 + 0.5;
                barGroup.position.set(worldX, 0, worldZ);
            }

            patientProbabilityBarsGroup.add(barGroup);
        }

        patientProbabilityBarsGroup.visible = true;
    }

    function hidePatientProbabilityBars() {
        patientProbabilityBarsGroup.visible = false;
        while (patientProbabilityBarsGroup.children.length > 0) {
            const bar = patientProbabilityBarsGroup.children[0];
            patientProbabilityBarsGroup.remove(bar);
            returnPatientBar(bar);
        }
    }

    /* =========================================================
     * PROBABILITY BAR HOVER TOOLTIP - 확률 바 호버 툴팁
     * ========================================================= */

    // 툴팁 엘리먼트 생성
    const probBarTooltip = document.createElement('div');
    probBarTooltip.id = 'probBarTooltip';
    probBarTooltip.style.cssText = `
        position: fixed;
        background: rgba(0, 0, 0, 0.85);
        color: #fff;
        padding: calc(6px * var(--ui-scale, 1)) calc(10px * var(--ui-scale, 1));
        border-radius: calc(4px * var(--ui-scale, 1));
        font-size: var(--font-sm, 11px);
        font-weight: 600;
        pointer-events: none;
        z-index: 10000;
        display: none;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    document.body.appendChild(probBarTooltip);

    // 확률 바 레이캐스터
    const probBarRaycaster = new THREE.Raycaster();
    const probBarMouse = new THREE.Vector2();

    // 확률 바 호버 핸들러
    function handleProbabilityBarHover(e) {
        // 서비스 뷰가 활성화되어 있지 않으면 무시
        if (!activeServiceViewType) {
            probBarTooltip.style.display = 'none';
            return;
        }

        const rect = renderer.domElement.getBoundingClientRect();
        probBarMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        probBarMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        probBarRaycaster.setFromCamera(probBarMouse, camera);

        // 활성화된 확률 바 그룹만 검사
        let targetGroup = null;
        if (activeServiceViewType === 'fire' && fireProbabilityBarsGroup.visible) {
            targetGroup = fireProbabilityBarsGroup;
        } else if (activeServiceViewType === 'police' && crimeProbabilityBarsGroup.visible) {
            targetGroup = crimeProbabilityBarsGroup;
        } else if (activeServiceViewType === 'hospital' && patientProbabilityBarsGroup.visible) {
            targetGroup = patientProbabilityBarsGroup;
        }

        if (!targetGroup) {
            probBarTooltip.style.display = 'none';
            return;
        }

        const intersects = probBarRaycaster.intersectObjects(targetGroup.children, true);

        if (intersects.length > 0) {
            // 부모 그룹에서 userData 가져오기
            let barGroup = intersects[0].object;
            while (barGroup && !barGroup.userData.barType) {
                barGroup = barGroup.parent;
            }

            if (barGroup && barGroup.userData.probability !== undefined) {
                const prob = barGroup.userData.probability;
                const barType = barGroup.userData.barType;

                // 확률을 퍼센트로 표시
                const percent = (prob * 100).toFixed(2);

                let label = '';
                if (barType === 'fire') label = '🔥 화재 확률';
                else if (barType === 'crime') label = '🚔 범죄 확률';
                else if (barType === 'patient') label = '🏥 환자 발생';

                probBarTooltip.textContent = `${label}: ${percent}%`;
                probBarTooltip.style.display = 'block';
                probBarTooltip.style.left = (e.clientX + 15) + 'px';
                probBarTooltip.style.top = (e.clientY + 15) + 'px';
            }
        } else {
            probBarTooltip.style.display = 'none';
        }
    }

    // 호버 이벤트 등록 (throttle 적용)
    renderer.domElement.addEventListener('mousemove', throttle(handleProbabilityBarHover, 50));

    /**
     * 서비스 뷰 범례 표시
     */
    // 소방 범례 업데이트 인터벌 ID
    let fireLegendUpdateInterval = null;

    function showServiceViewLegend(serviceType) {
        const config = PUBLIC_BUILDING_MODELS[serviceType];
        if (!config || !dataViewLegend) return;

        // 범례 설정
        if (legendIcon) legendIcon.textContent = config.icon;
        if (legendTitle) legendTitle.textContent = config.name + ' 현황';

        // 통계 정보
        let buildingCount = 0;
        placedPublicBuildings.forEach((building, key) => {
            if (!building.ref && building.type === serviceType) buildingCount++;
        });

        if (legendStatLabel) legendStatLabel.textContent = '배치된 수';
        if (legendStatValue) legendStatValue.textContent = `${buildingCount}개`;

        // 소방 현황 섹션 (소방 뷰 전용)
        const legendFireStats = document.getElementById('legendFireStats');
        if (serviceType === 'fire' && legendFireStats) {
            legendFireStats.style.display = 'block';
            updateFireLegendStats();
            // 2초마다 실시간 업데이트 (최적화)
            if (fireLegendUpdateInterval) clearInterval(fireLegendUpdateInterval);
            fireLegendUpdateInterval = setInterval(updateFireLegendStats, 2000);
        } else if (legendFireStats) {
            legendFireStats.style.display = 'none';
            if (fireLegendUpdateInterval) {
                clearInterval(fireLegendUpdateInterval);
                fireLegendUpdateInterval = null;
            }
        }

        // 모든 범례 아이템 숨기기
        if (legendLandValueItem) legendLandValueItem.style.display = 'none';
        if (legendBuildingValueItem) legendBuildingValueItem.style.display = 'none';
        if (legendPopulationItem) legendPopulationItem.style.display = 'none';
        if (legendTrafficItem) legendTrafficItem.style.display = 'none';
        if (legendWindItem) legendWindItem.style.display = 'none';

        dataViewLegend.classList.add('visible');
    }

    /**
     * 소방 범례 통계 업데이트
     */
    function updateFireLegendStats() {
        // 현재 화재 건수
        const activeFiresEl = document.getElementById('legendActiveFiresValue');
        if (activeFiresEl && typeof burningBuildings !== 'undefined') {
            const fireCount = burningBuildings.size;
            activeFiresEl.textContent = `${fireCount}건`;
            activeFiresEl.style.color = fireCount > 0 ? '#ef4444' : '#22c55e';
        }

        // 소방서 수 계산
        let fireStationCount = 0;
        placedPublicBuildings.forEach((building, key) => {
            if (!building.ref && building.type === 'fire') fireStationCount++;
        });

        // 총 소방차 수 (소방서당 2대)
        const totalFiretrucks = fireStationCount * MAX_FIRETRUCKS_PER_STATION;
        const totalFiretrucksEl = document.getElementById('legendTotalFiretrucksValue');
        if (totalFiretrucksEl) {
            totalFiretrucksEl.textContent = `${totalFiretrucks}대`;
        }

        // 출동 중인 소방차
        const dispatchedCount = typeof dispatchedFiretrucks !== 'undefined' ? dispatchedFiretrucks.size : 0;
        const dispatchedEl = document.getElementById('legendDispatchedFiretrucksValue');
        if (dispatchedEl) {
            dispatchedEl.textContent = `${dispatchedCount}대`;
        }

        // 대기 중인 소방차
        const availableCount = Math.max(0, totalFiretrucks - dispatchedCount);
        const availableEl = document.getElementById('legendAvailableFiretrucksValue');
        if (availableEl) {
            availableEl.textContent = `${availableCount}대`;
        }

        // 화재 확률 표시
        const legendFireChanceValue = document.getElementById('legendFireChanceValue');
        if (legendFireChanceValue) {
            const baseChance = FIRE_BASE_CHANCE * 100;
            const protectedChance = FIRE_BASE_CHANCE * 0.1 * 100;
            const industrialChance = FIRE_BASE_CHANCE * FIRE_INDUSTRIAL_MULTIPLIER * 100;
            legendFireChanceValue.innerHTML = `일반: ${baseChance.toFixed(2)}%<br>보호: ${protectedChance.toFixed(3)}%<br>공장: ${industrialChance.toFixed(2)}%`;
        }
    }

    /**
     * 서비스 뷰 범례 숨기기
     */
    function hideServiceViewLegend() {
        if (dataViewLegend) {
            dataViewLegend.classList.remove('visible');
        }
        // 소방 현황 섹션 숨기기 및 인터벌 정리
        const legendFireStats = document.getElementById('legendFireStats');
        if (legendFireStats) legendFireStats.style.display = 'none';
        if (fireLegendUpdateInterval) {
            clearInterval(fireLegendUpdateInterval);
            fireLegendUpdateInterval = null;
        }
    }

    /**
     * 서비스 뷰가 활성화되어 있는지 확인
     */
    function isServiceViewActive() {
        return activeServiceViewType !== null;
    }

    /* =========================================================
     * VIEW MODE MANAGER - 통합 범례 모드 관리
     * 모든 데이터 뷰 모드(땅값, 인구, 교통량, 전력, 수도)를 통합 관리
     * ========================================================= */
    const ViewModeManager = {
        // 현재 활성화된 뷰 모드
        activeMode: null,

        // 뷰 모드 타입 상수
        TYPES: {
            LAND_VALUE: 'landValue',
            POPULATION: 'population',
            TRAFFIC: 'traffic',
            POWER: 'power',
            WATER: 'water',
            WIND: 'wind'
        },

        // 뷰 모드별 설정
        configs: {
            landValue: {
                isActiveFlag: () => isLandValueViewActive,
                setActiveFlag: (val) => { isLandValueViewActive = val; },
                group: () => landValueGroup,
                button: () => btnLandValue,
                legendType: 'landValue',
                restoreFn: () => restoreBuildingMaterialsFromLandValue(),
                animationFrameId: () => landValueAnimationFrameId,
                cancelAnimation: () => {
                    if (landValueAnimationFrameId) {
                        cancelAnimationFrame(landValueAnimationFrameId);
                        landValueAnimationFrameId = null;
                    }
                }
            },
            population: {
                isActiveFlag: () => isPopulationViewActive,
                setActiveFlag: (val) => { isPopulationViewActive = val; },
                group: () => populationGroup,
                button: () => btnPopulation,
                legendType: 'population',
                restoreFn: () => restoreOriginalMaterials(true),
                animationFrameId: () => populationAnimationFrameId,
                cancelAnimation: () => {
                    if (populationAnimationFrameId) {
                        cancelAnimationFrame(populationAnimationFrameId);
                        populationAnimationFrameId = null;
                    }
                }
            },
            traffic: {
                isActiveFlag: () => isTrafficViewActive,
                setActiveFlag: (val) => { isTrafficViewActive = val; },
                group: () => trafficViewGroup,
                button: () => btnTrafficView,
                legendType: 'traffic',
                restoreFn: () => restoreOriginalMaterials(true),
                cleanupFn: () => {
                    // 교통량 뷰 전용 정리
                    if (trafficViewGroup) {
                        while (trafficViewGroup.children.length > 0) {
                            const child = trafficViewGroup.children[0];
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (child.material.map) {
                                    child.material.map.dispose();
                                    child.material.map = null;
                                }
                                child.material.dispose();
                            }
                            trafficViewGroup.remove(child);
                        }
                    }
                    trafficTexture = null;
                    trafficTextureData = null;
                    trafficPlane = null;
                    trafficOutline = null;

                    // 격자 투명도 원래대로 복원
                    if (typeof gridHelper !== 'undefined' && gridHelper.material) {
                        gridHelper.material.opacity = 1;
                    }
                }
            },
            power: {
                isActiveFlag: () => powerManager?.isPowerViewActive,
                setActiveFlag: (val) => { if (powerManager) powerManager.isPowerViewActive = val; },
                group: () => powerManager?.powerLineGroup,
                iconGroup: () => powerManager?.powerIconGroup,
                button: () => btnPower,
                restoreFn: () => { if (powerManager) powerManager.restorePowerViewMaterials(); },
                cleanupFn: () => { hideUtilityLegend(); }
            },
            water: {
                isActiveFlag: () => waterManager?.isWaterViewActive,
                setActiveFlag: (val) => { if (waterManager) waterManager.isWaterViewActive = val; },
                group: () => waterManager?.waterPipeGroup,
                iconGroup: () => waterManager?.waterIconGroup,
                button: () => btnWater,
                restoreFn: () => { if (waterManager) waterManager.restoreWaterViewMaterials(); },
                cleanupFn: () => { hideUtilityLegend(); }
            },
            sewage: {
                isActiveFlag: () => sewageManager?.isSewageViewActive,
                setActiveFlag: (val) => { if (sewageManager) sewageManager.isSewageViewActive = val; },
                group: () => sewageManager?.sewagePipeGroup,
                iconGroup: () => sewageManager?.sewageIconGroup,
                button: () => btnSewage,
                // 머티리얼 복원은 oceanSewageSystem이 담당
                restoreFn: () => { if (oceanSewageSystem) oceanSewageSystem.toggleView(false); },
                cleanupFn: () => { hideUtilityLegend(); }
            },
            wind: {
                isActiveFlag: () => isWindViewActive,
                setActiveFlag: (val) => { isWindViewActive = val; },
                group: () => windViewGroup,
                button: () => btnWindView,
                legendType: 'wind',
                restoreFn: () => restoreOriginalMaterials(true),
                cleanupFn: () => {
                    // 풍량 뷰 전용 정리
                    if (windViewGroup) {
                        while (windViewGroup.children.length > 0) {
                            const child = windViewGroup.children[0];
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (child.material.map) {
                                    child.material.map.dispose();
                                    child.material.map = null;
                                }
                                child.material.dispose();
                            }
                            windViewGroup.remove(child);
                        }
                    }
                    windTexture = null;
                    windTextureData = null;
                    windPlane = null;

                    // 풍량 커서 게이지 정리
                    cachedWindDistanceMap = null;
                    const windCursorEl = document.getElementById('windCursorGauge');
                    if (windCursorEl) windCursorEl.classList.remove('visible');
                }
            }
        },

        // 특정 뷰 모드 종료
        exitViewMode(type) {
            const config = this.configs[type];
            if (!config) return;

            // 이미 비활성화 상태면 스킵
            if (!config.isActiveFlag()) return;

            // 플래그 비활성화
            config.setActiveFlag(false);

            // 애니메이션 취소
            if (config.cancelAnimation) config.cancelAnimation();

            // 그룹 숨기기
            const group = config.group();
            if (group) group.visible = false;

            // 아이콘 그룹도 숨기기 (전력/수도)
            if (config.iconGroup) {
                const iconGroup = config.iconGroup();
                if (iconGroup) iconGroup.visible = false;
            }

            // 머티리얼 복원
            if (config.restoreFn) config.restoreFn();

            // 모든 건물 투명도 복원 (데이터 뷰 종료 시)
            restoreAllBuildingOpacity();

            // 추가 정리 (교통량 뷰 등)
            if (config.cleanupFn) config.cleanupFn();

            // 버튼 상태 업데이트
            const button = config.button();
            if (button) button.classList.remove('active');

            // 범례 패널 숨기기
            if (config.legendType) hideDataViewLegend();

            // Bloom 효과 복원 (다른 뷰 모드가 없을 때만)
            if (!this.isAnyViewActive()) {
                if (typeof bloomPass !== 'undefined' && GRAPHICS_SETTINGS.bloomEnabled) {
                    bloomPass.enabled = true;
                }
            }

            // 환경 효과 재적용
            forceUpdateEnvironmentEffects();

            // 활성 모드 해제
            if (this.activeMode === type) {
                this.activeMode = null;
            }

            console.log(`View Mode Exit: ${type}`);
        },

        // 모든 뷰 모드 종료
        exitAllViewModes() {
            Object.keys(this.configs).forEach(type => {
                this.exitViewMode(type);
            });
        },

        // 특정 타입 제외하고 모든 뷰 모드 종료
        exitAllExcept(exceptType) {
            Object.keys(this.configs).forEach(type => {
                if (type !== exceptType) {
                    this.exitViewMode(type);
                }
            });
        },

        // 현재 활성화된 뷰 모드 확인
        isAnyViewActive() {
            return Object.keys(this.configs).some(type => this.configs[type].isActiveFlag());
        },

        // 특정 뷰 모드 활성화 확인
        isViewActive(type) {
            const config = this.configs[type];
            return config ? config.isActiveFlag() : false;
        }
    };

    /* =========================================================
     * DATA VIEW LEGEND PANEL - 범례 패널 관리
     * ========================================================= */
    const dataViewLegend = document.getElementById('dataViewLegend');
    const legendIcon = document.getElementById('legendIcon');
    const legendTitle = document.getElementById('legendTitle');
    const legendStatLabel = document.getElementById('legendStatLabel');
    const legendStatValue = document.getElementById('legendStatValue');
    const legendLandValueItem = document.getElementById('legendLandValue');
    const legendBuildingValueItem = document.getElementById('legendBuildingValue');
    const legendPopulationItem = document.getElementById('legendPopulation');
    const legendTrafficItem = document.getElementById('legendTraffic');
    const legendWindItem = document.getElementById('legendWind');
    const legendClose = document.getElementById('legendClose');
    const legendTerrainColor = document.getElementById('legendTerrainColor');
    const legendBuildingColor = document.getElementById('legendBuildingColor');
    const legendPopColor = document.getElementById('legendPopColor');
    const legendTrafficColor = document.getElementById('legendTrafficColor');

    let currentLegendType = null;

    function showDataViewLegend(type) {
        if (!dataViewLegend) return;

        currentLegendType = type;

        // 모든 범례 아이템 숨기기
        if (legendLandValueItem) legendLandValueItem.style.display = 'none';
        if (legendBuildingValueItem) legendBuildingValueItem.style.display = 'none';
        if (legendPopulationItem) legendPopulationItem.style.display = 'none';
        if (legendTrafficItem) legendTrafficItem.style.display = 'none';
        if (legendWindItem) legendWindItem.style.display = 'none';

        if (type === 'landValue') {
            legendIcon.textContent = '💰';
            legendTitle.textContent = '땅값';
            legendStatLabel.textContent = '평균 땅값';

            // 평균 땅값 계산
            const avgLandValue = calculateAverageLandValue();
            legendStatValue.textContent = `₩${formatNumber(avgLandValue)}/칸`;

            // 범례 아이템 표시
            if (legendLandValueItem) legendLandValueItem.style.display = 'block';
            if (legendBuildingValueItem) legendBuildingValueItem.style.display = 'block';

        } else if (type === 'population') {
            legendIcon.textContent = '👥';
            legendTitle.textContent = '인구';
            legendStatLabel.textContent = '총 인구';
            legendStatValue.textContent = `${cityStats.population.toLocaleString()}명`;

            // 범례 아이템 표시
            if (legendPopulationItem) legendPopulationItem.style.display = 'block';

        } else if (type === 'traffic') {
            legendIcon.textContent = '🚗';
            legendTitle.textContent = '교통량';
            legendStatLabel.textContent = '평균 혼잡도';

            // 평균 교통량 계산
            const avgTraffic = calculateAverageTraffic();
            legendStatValue.textContent = `${avgTraffic}%`;

            // 범례 아이템 표시
            if (legendTrafficItem) legendTrafficItem.style.display = 'block';

        } else if (type === 'wind') {
            legendIcon.textContent = '💨';
            legendTitle.textContent = '풍량';
            legendStatLabel.textContent = '평균 풍량';

            // 평균 풍량 계산
            const avgWind = calculateAverageWindStrength();
            legendStatValue.textContent = `${avgWind.toFixed(1)}%`;

            // 풍량 범례 아이템 표시
            if (legendWindItem) legendWindItem.style.display = 'block';

            console.log(`[Wind] originalSeaTiles: ${originalSeaTiles.size}, avgWind: ${avgWind.toFixed(1)}%`);

        } else if (type === 'zone') {
            legendIcon.textContent = '🏘️';
            legendTitle.textContent = '구역 설정';
            legendStatLabel.textContent = '구역 타일 수';

            // 구역 타일 수 계산
            const tiles = countZoneTiles();
            legendStatValue.textContent = `주거 ${tiles.residential} / 상업 ${tiles.commercial} / 산업 ${tiles.industrial}`;

            // 구역 모드에서는 별도의 범례 아이템 없음 (구역 색상은 메시로 표시)
        }

        dataViewLegend.classList.add('visible');
    }

    function hideDataViewLegend() {
        if (!dataViewLegend) return;
        dataViewLegend.classList.remove('visible');
        currentLegendType = null;
    }

    // 평균 땅값 계산
    function calculateAverageLandValue() {
        let totalLandValue = 0;
        let tileCount = 0;

        for (let y = 0; y < GRID_H; y++) {
            for (let x = 0; x < GRID_W; x++) {
                const cell = grid[x][y];
                // 빈 타일과 도로 제외
                if (cell !== CELL.EMPTY && cell !== CELL.ROAD && cell !== CELL.LOCKED_ROAD) {
                    const baseLandValue = getLandValue(x, y);
                    const serviceBonus = getServiceBonus(x, y);
                    totalLandValue += baseLandValue + serviceBonus;
                    tileCount++;
                }
            }
        }

        return tileCount > 0 ? Math.round(totalLandValue / tileCount) : 0;
    }

    // 숫자 포맷 (천 단위 콤마)
    function formatNumber(num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // 평균 교통량 계산
    function calculateAverageTraffic() {
        if (!trafficManager || !trafficManager.initialized) return 0;

        let totalTraffic = 0;
        let roadCount = 0;

        for (let y = 0; y < GRID_H; y++) {
            for (let x = 0; x < GRID_W; x++) {
                const cell = grid[x][y];
                if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD) {
                    const traffic = trafficManager.getTrafficLevel(x, y);
                    totalTraffic += traffic;
                    roadCount++;
                }
            }
        }

        return roadCount > 0 ? Math.round(totalTraffic / roadCount) : 0;
    }

    // 범례 패널 닫기 버튼 이벤트
    if (legendClose) {
        legendClose.addEventListener('click', () => {
            // 현재 활성화된 뷰 종료 및 모드 변경
            // 모드를 변경하지 않으면 applyZoneModeEffect가 다시 호출되어 흰색 효과가 재적용됨
            if (isLandValueViewActive) {
                exitLandValueView();
                setMode(MODE.CAMERA);  // 카메라 모드로 복귀
            } else if (isPopulationViewActive) {
                exitPopulationView();
                setMode(MODE.CAMERA);  // 카메라 모드로 복귀
            } else if (isTrafficViewActive) {
                hideTrafficView();
                if (btnTrafficView) btnTrafficView.classList.remove('active');
                setMode(MODE.BUILD);
            }
        });
    }

    // 체크박스 이벤트 (선택적 기능 토글)
    if (legendTerrainColor) {
        legendTerrainColor.addEventListener('change', (e) => {
            if (landValueOverlayMesh) {
                landValueOverlayMesh.visible = e.target.checked;
            }
        });
    }

    if (legendBuildingColor) {
        legendBuildingColor.addEventListener('change', (e) => {
            // 건물 색상 토글 기능 (현재는 시각적 피드백용)
            // 실제 기능은 추후 구현 가능
        });
    }

    /* =========================================================
     * UTILITY LEGEND PANEL - 전력/수도 게이지 패널
     * ========================================================= */
    const utilityLegend = document.getElementById('utilityLegend');
    const utilityLegendIcon = document.getElementById('utilityLegendIcon');
    const utilityLegendTitle = document.getElementById('utilityLegendTitle');
    const utilityLegendClose = document.getElementById('utilityLegendClose');
    const gaugeNeedle = document.getElementById('gaugeNeedle');
    const gaugeValue = document.getElementById('gaugeValue');
    const gaugeMaxLabel = document.getElementById('gaugeMaxLabel');
    const utilityCurrentUsage = document.getElementById('utilityCurrentUsage');
    const utilityTotalCapacity = document.getElementById('utilityTotalCapacity');
    const utilityRemaining = document.getElementById('utilityRemaining');
    const utilityStatus = document.getElementById('utilityStatus');

    let currentUtilityType = null;  // 'power' or 'water'
    let utilityUpdateInterval = null;

    // 유틸리티 범례 표시
    function showUtilityLegend(type) {
        if (!utilityLegend) return;

        currentUtilityType = type;

        // 기존 업데이트 인터벌 정리
        if (utilityUpdateInterval) {
            clearInterval(utilityUpdateInterval);
        }

        // 타입별 설정
        utilityLegend.classList.remove('power', 'water', 'sewage');
        utilityLegend.classList.add(type);

        if (type === 'power') {
            utilityLegendIcon.textContent = '⚡';
            utilityLegendTitle.textContent = '전력';
        } else if (type === 'water') {
            utilityLegendIcon.textContent = '💧';
            utilityLegendTitle.textContent = '수도';
        } else if (type === 'sewage') {
            utilityLegendIcon.textContent = '🚽';
            utilityLegendTitle.textContent = '하수';
        }

        // 초기 업데이트
        updateUtilityGauge();

        // 주기적 업데이트 (1초마다)
        utilityUpdateInterval = setInterval(updateUtilityGauge, 2000);  // 최적화: 2초

        utilityLegend.classList.add('visible');
    }

    // 유틸리티 범례 숨기기
    function hideUtilityLegend() {
        if (!utilityLegend) return;

        utilityLegend.classList.remove('visible');
        currentUtilityType = null;

        if (utilityUpdateInterval) {
            clearInterval(utilityUpdateInterval);
            utilityUpdateInterval = null;
        }
    }

    // 게이지 업데이트
    function updateUtilityGauge() {
        if (!currentUtilityType) return;

        let usage = 0;
        let capacity = 0;
        let unit = '';

        if (currentUtilityType === 'power') {
            usage = cityStats.powerUsage || 0;
            capacity = cityStats.powerCapacity || 0;
            unit = 'kW';
        } else if (currentUtilityType === 'water') {
            usage = cityStats.waterUsage || 0;
            capacity = cityStats.waterCapacity || 0;
            unit = 'L';
        } else if (currentUtilityType === 'sewage') {
            usage = cityStats.sewageUsage || 0;
            capacity = cityStats.sewageCapacity || 0;
            unit = 'L';
        }

        // 백분율 계산 (용량이 0이면 0%, 초과하면 100% 이상 가능)
        const percentage = capacity > 0 ? Math.min((usage / capacity) * 100, 120) : 0;
        const displayPercentage = Math.round(percentage);

        // 바늘 회전 (0% = -90도(왼쪽), 100% = 90도(오른쪽), 선형 보간)
        // 0% -> -90도, 50% -> 0도, 100% -> 90도
        // 바늘은 -90도(0)와 90도(총용량) 사이에서만 움직임
        const needleAngle = Math.max(-90, Math.min(90, -90 + (percentage / 100) * 180));
        if (gaugeNeedle) {
            // CSS transform 사용 (transform-origin과 함께 작동)
            gaugeNeedle.style.transform = `rotate(${needleAngle}deg)`;
        }

        // 값 표시 업데이트
        if (gaugeValue) {
            gaugeValue.textContent = `${displayPercentage}%`;
        }

        if (gaugeMaxLabel) {
            gaugeMaxLabel.textContent = capacity.toLocaleString();
        }

        if (utilityCurrentUsage) {
            utilityCurrentUsage.textContent = `${usage.toLocaleString()} ${unit}`;
        }

        if (utilityTotalCapacity) {
            utilityTotalCapacity.textContent = `${capacity.toLocaleString()} ${unit}`;
        }

        const remaining = capacity - usage;
        if (utilityRemaining) {
            utilityRemaining.textContent = `${remaining.toLocaleString()} ${unit}`;
        }

        // 상태 업데이트
        updateUtilityStatus(percentage, remaining);

        // 하수 모드일 때 원기둥 시각화 업데이트
        if (currentUtilityType === 'sewage') {
            updateSewageCylinders(usage, capacity);
        }
    }

    // 하수 원기둥 시각화 업데이트
    function updateSewageCylinders(usage, capacity) {
        const stack = document.getElementById('sewageCylinderStack');
        const currentValue = document.getElementById('sewageCurrentValue');
        const capacityValue = document.getElementById('sewageCapacityValue');

        if (!stack) return;

        // 값 표시 업데이트
        if (currentValue) currentValue.textContent = usage.toLocaleString() + ' L';
        if (capacityValue) capacityValue.textContent = capacity.toLocaleString() + ' L';

        // 최대 5개의 원기둥으로 표시 (각 원기둥 = 용량의 20%)
        const cylinderCount = 5;
        const percentPerCylinder = 100 / cylinderCount;  // 20%씩

        // 백분율 계산
        const totalPercent = capacity > 0 ? (usage / capacity) * 100 : 0;

        // 원기둥 HTML 생성 (아래에서 위로 쌓음)
        let cylindersHtml = '';
        for (let i = cylinderCount - 1; i >= 0; i--) {
            const cylinderThreshold = i * percentPerCylinder;
            const cylinderMax = (i + 1) * percentPerCylinder;

            if (totalPercent >= cylinderMax) {
                // 완전히 채워진 원기둥
                cylindersHtml += '<div class="sewage-cylinder filled"></div>';
            } else if (totalPercent > cylinderThreshold) {
                // 부분적으로 채워진 원기둥
                const fillPercent = ((totalPercent - cylinderThreshold) / percentPerCylinder) * 100;
                cylindersHtml += `<div class="sewage-cylinder partial" style="--fill-percent: ${fillPercent}%"></div>`;
            } else {
                // 비어있는 원기둥
                cylindersHtml += '<div class="sewage-cylinder"></div>';
            }
        }

        stack.innerHTML = cylindersHtml;
    }

    // 상태 표시 업데이트
    function updateUtilityStatus(percentage, remaining) {
        if (!utilityStatus) return;

        const highlightRow = utilityRemaining?.closest('.utility-stat-row');

        utilityStatus.classList.remove('warning', 'danger');
        if (highlightRow) highlightRow.classList.remove('warning', 'danger');

        const statusIcon = utilityStatus.querySelector('.utility-status-icon');
        const statusText = utilityStatus.querySelector('.utility-status-text');

        if (percentage >= 100) {
            // 용량 초과
            utilityStatus.classList.add('danger');
            if (highlightRow) highlightRow.classList.add('danger');
            if (statusIcon) statusIcon.textContent = '⚠️';
            if (statusText) statusText.textContent = '용량 초과! 시설 추가 필요';
        } else if (percentage >= 80) {
            // 경고 상태
            utilityStatus.classList.add('warning');
            if (highlightRow) highlightRow.classList.add('warning');
            if (statusIcon) statusIcon.textContent = '⚠️';
            if (statusText) statusText.textContent = '용량 부족 주의';
        } else {
            // 정상 상태
            if (statusIcon) statusIcon.textContent = '✓';
            if (statusText) statusText.textContent = '정상 공급 중';
        }
    }

    // 유틸리티 범례 닫기 버튼
    if (utilityLegendClose) {
        utilityLegendClose.addEventListener('click', () => {
            hideUtilityLegend();
            // 관련 모드 종료
            if (currentMode === MODE.POWER_VIEW ||
                currentMode === MODE.PLACE_POWER_COAL ||
                currentMode === MODE.PLACE_POWER_WIND ||
                currentMode === MODE.PLACE_POWER_SOLAR) {
                setMode(MODE.CAMERA);
            } else if (currentMode === MODE.WATER_VIEW ||
                       currentMode === MODE.PLACE_WATER_PUMP_COAST) {
                setMode(MODE.CAMERA);
            } else if (currentMode === MODE.SEWAGE_VIEW ||
                       currentMode === MODE.PLACE_WASTEWATER) {
                setMode(MODE.CAMERA);
            }
        });
    }

    function toggleLandValueView() {
        if (isLandValueViewActive) {
            exitLandValueView();
        } else {
            enterLandValueView();
        }
    }

    let landValueAnimationFrameId = null;

    function enterLandValueView() {
        if (isLandValueViewActive) return;

        // 인구 뷰가 켜져있으면 끄기
        if (typeof isPopulationViewActive !== 'undefined' && isPopulationViewActive) {
            exitPopulationView();
        }

        isLandValueViewActive = true;

        // Bloom 효과 끄기
        if (typeof bloomPass !== 'undefined') {
            bloomPass.enabled = false;
        }

        // 땅값 시각화 생성 및 표시
        createLandValueVisualization();
        landValueGroup.visible = true;

        // 차량도 회색으로 변경 (땅값 뷰에서 시각적 일관성)
        applyLandValueToVehicles();

        // 페이드인 애니메이션
        animateLandValueFadeIn();

        // 모드 변경
        setMode(MODE.LAND_VALUE_VIEW);

        // 버튼 상태 업데이트
        if (btnLandValue) btnLandValue.classList.add('active');
        if (btnPopulation) btnPopulation.classList.remove('active');

        // 범례 패널 표시
        showDataViewLegend('landValue');

        console.log("Land Value View: ON");
    }

    function exitLandValueView() {
        // ViewModeManager에 위임
        ViewModeManager.exitViewMode('landValue');
    }

    // 땅값 뷰 페이드인 애니메이션
    function animateLandValueFadeIn() {
        if (landValueAnimationFrameId) {
            cancelAnimationFrame(landValueAnimationFrameId);
        }

        const animationDuration = 400;  // 0.4초
        const startTime = performance.now();

        if (landValueOverlayMesh) {
            landValueOverlayMesh.material.opacity = 0;
        }

        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);

            // easeOutCubic 이징
            const eased = 1 - Math.pow(1 - progress, 3);

            if (landValueOverlayMesh) {
                landValueOverlayMesh.material.opacity = 0.7 * eased;
            }

            if (progress < 1) {
                landValueAnimationFrameId = requestAnimationFrame(animate);
            } else {
                landValueAnimationFrameId = null;
            }
        }

        landValueAnimationFrameId = requestAnimationFrame(animate);
    }

    /* =========================================================
     * POPULATION SYSTEM - 인구 시스템
     * 건물 크기에 따른 인구 배정 (1x1 빌라: 작음, 2x2 아파트: 큼)
     * ========================================================= */

    // 건물별 인구 데이터 저장 (buildingKey -> population)
    const buildingPopulations = new Map();

    // 인구 범위 설정
    const POPULATION_RANGES = {
        "1x1": { min: 5, max: 15 },    // 빌라: 5-15명
        "2x2": { min: 30, max: 60 }    // 아파트: 30-60명
    };

    // 건물에 인구 배정 (랜덤하게)
    function assignBuildingPopulation(buildingKey, size) {
        if (buildingPopulations.has(buildingKey)) {
            return buildingPopulations.get(buildingKey);
        }

        const range = POPULATION_RANGES[size] || POPULATION_RANGES["1x1"];
        const population = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        buildingPopulations.set(buildingKey, population);
        return population;
    }

    // 건물 키 생성 (좌표 기반)
    function getBuildingKey(x, y, size) {
        return `${x},${y},${size}`;
    }

    // 총 인구 계산
    function calculateTotalPopulation() {
        let total = 0;
        buildingPopulations.forEach(pop => total += pop);
        return total;
    }

    /* =========================================================
     * AGE DISTRIBUTION SYSTEM - 건물별 연령 분포
     * ========================================================= */

    // 건물별 연령 분포 데이터 저장 (buildingKey -> {children, teens, young, adult, elderly})
    const buildingAgeDistributions = new Map();

    // 연령 분포 색상 (파이 차트용)
    const AGE_COLORS = {
        children: '#fbbf24',  // 어린이 - 노랑
        teens: '#f97316',     // 청소년 - 주황
        young: '#ef4444',     // 청년 - 빨강
        adult: '#22c55e',     // 성인 - 초록
        elderly: '#9ca3af'    // 노인 - 회색
    };

    /**
     * 건물의 연령 분포 데이터 가져오기/생성
     * @param {string} buildingKey - 건물 키
     * @param {number} totalPopulation - 건물 총 인구
     * @returns {object} - {children, teens, young, adult, elderly}
     */
    function getBuildingAgeDistribution(buildingKey, totalPopulation) {
        if (buildingAgeDistributions.has(buildingKey)) {
            return buildingAgeDistributions.get(buildingKey);
        }

        // 연령 분포 랜덤 생성 (가중치 적용)
        // 기본 비율: 어린이 10%, 청소년 15%, 청년 25%, 성인 35%, 노인 15%
        const weights = {
            children: 0.10 + (Math.random() * 0.1 - 0.05),  // 5~15%
            teens: 0.15 + (Math.random() * 0.1 - 0.05),     // 10~20%
            young: 0.25 + (Math.random() * 0.15 - 0.075),   // 17.5~32.5%
            adult: 0.35 + (Math.random() * 0.15 - 0.075),   // 27.5~42.5%
            elderly: 0.15 + (Math.random() * 0.1 - 0.05)    // 10~20%
        };

        // 가중치 합이 1이 되도록 정규화
        const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
        Object.keys(weights).forEach(key => {
            weights[key] = weights[key] / totalWeight;
        });

        // 인구 분배
        let remaining = totalPopulation;
        const distribution = {
            children: 0,
            teens: 0,
            young: 0,
            adult: 0,
            elderly: 0
        };

        // 각 연령대에 인구 분배 (마지막은 나머지로)
        const keys = ['children', 'teens', 'young', 'adult'];
        keys.forEach(key => {
            const count = Math.round(totalPopulation * weights[key]);
            distribution[key] = Math.min(count, remaining);
            remaining -= distribution[key];
        });
        distribution.elderly = Math.max(0, remaining);

        buildingAgeDistributions.set(buildingKey, distribution);
        return distribution;
    }

    /**
     * 파이 차트 그리기
     * @param {HTMLCanvasElement} canvas - 캔버스 요소
     * @param {object} data - 연령 분포 데이터
     */
    function drawAgeDistributionChart(canvas, data) {
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) / 2 - 5;

        // 캔버스 초기화
        ctx.clearRect(0, 0, width, height);

        // 총 인구 계산
        const total = data.children + data.teens + data.young + data.adult + data.elderly;
        if (total === 0) return;

        // 파이 차트 그리기
        let startAngle = -Math.PI / 2;  // 12시 방향에서 시작
        const ageGroups = ['children', 'teens', 'young', 'adult', 'elderly'];

        ageGroups.forEach(group => {
            const value = data[group];
            if (value <= 0) return;

            const sliceAngle = (value / total) * 2 * Math.PI;
            const endAngle = startAngle + sliceAngle;

            // 파이 조각 그리기
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.closePath();

            ctx.fillStyle = AGE_COLORS[group];
            ctx.fill();

            // 테두리
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();

            startAngle = endAngle;
        });

        // 중앙 원 (도넛 차트 스타일)
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.4, 0, 2 * Math.PI);
        ctx.fillStyle = 'rgba(45, 50, 58, 0.95)';
        ctx.fill();

        // 중앙에 총 인구 표시
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${Math.round(radius * 0.3)}px 'Segoe UI', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(total.toString(), centerX, centerY);
    }

    /**
     * 연령 분포 섹션 업데이트
     * @param {string} buildingKey - 건물 키
     * @param {number} population - 건물 인구
     * @param {boolean} show - 표시 여부
     */
    function updateAgeDistributionSection(buildingKey, population, show) {
        const section = document.getElementById('ageDistributionSection');
        if (!section) return;

        if (!show || population <= 0) {
            section.style.display = 'none';
            return;
        }

        section.style.display = 'block';

        // 연령 분포 데이터 가져오기
        const ageData = getBuildingAgeDistribution(buildingKey, population);

        // 라벨 업데이트
        document.getElementById('ageChildren').textContent = ageData.children;
        document.getElementById('ageTeens').textContent = ageData.teens;
        document.getElementById('ageYoung').textContent = ageData.young;
        document.getElementById('ageAdult').textContent = ageData.adult;
        document.getElementById('ageElderly').textContent = ageData.elderly;

        // 파이 차트 그리기
        const canvas = document.getElementById('ageChartCanvas');
        drawAgeDistributionChart(canvas, ageData);
    }

    /* =========================================================
     * BUILDING NAME SYSTEM - 건물 이름 생성
     * ========================================================= */

    // 건물별 이름 데이터 저장 (buildingKey -> name)
    const buildingNames = new Map();

    // 건물 이름 조합용 데이터
    const BUILDING_NAME_PREFIXES = {
        residential: ['해피', '그린', '블루', '골든', '스마트', '파크', '선샤인', '레이크', '힐', '스카이'],
        commercial: ['플라자', '센터', '마트', '타운', '스퀘어', '몰', '파크', '스트리트', '에비뉴', '코너'],
        industrial: ['테크', '스틸', '파워', '메탈', '프라임', '글로벌', '메가', '퍼스트', '유니온', '월드']
    };

    const BUILDING_NAME_SUFFIXES = {
        residential: ['빌라', '하우스', '팰리스', '맨션', '아파트', '타워', '레지던스', '힐스', '파크', '테라스'],
        commercial: ['마켓', '슈퍼', '스토어', '샵', '백화점', '편의점', '쇼핑몰', '상가', '시장', '마트'],
        industrial: ['공장', '웨어하우스', '팩토리', '센터', '산업', '물류', '제조', '창고', '단지', '플랜트']
    };

    // 랜덤 건물 이름 생성
    function generateBuildingName(zoneType) {
        const type = zoneType.includes('residential') ? 'residential' :
                     zoneType.includes('commercial') ? 'commercial' : 'industrial';

        const prefixes = BUILDING_NAME_PREFIXES[type];
        const suffixes = BUILDING_NAME_SUFFIXES[type];

        const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
        const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];

        // 1-999 사이의 랜덤 숫자 (간혹 추가)
        const addNumber = Math.random() > 0.5;
        const number = addNumber ? ` ${Math.floor(Math.random() * 999) + 1}` : '';

        return prefix + ' ' + suffix + number;
    }

    // 건물에 이름 배정 (없으면 새로 생성)
    function assignBuildingName(buildingKey, zoneType) {
        if (buildingNames.has(buildingKey)) {
            return buildingNames.get(buildingKey);
        }

        const name = generateBuildingName(zoneType);
        buildingNames.set(buildingKey, name);
        return name;
    }

    /* =========================================================
     * POPULATION VISUALIZATION SYSTEM - 인구 시각화
     * ========================================================= */
    const populationGroup = new THREE.Group();
    populationGroup.name = "populationGroup";
    populationGroup.visible = false;
    populationGroup.renderOrder = 999;  // 다른 오브젝트 위에 렌더링
    scene.add(populationGroup);

    let isPopulationViewActive = false;
    let populationAnimationFrameId = null;

    // 인구 수치 시각화 생성
    function createPopulationVisualization() {
        // 기존 시각화 제거
        while (populationGroup.children.length > 0) {
            const child = populationGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            populationGroup.remove(child);
        }

        // 건물 그룹에서 주거 건물만 찾아서 그래프 생성
        const maxPopulation = POPULATION_RANGES["2x2"].max;  // 최대 인구로 정규화

        console.log(`Population View: buildingGroup has ${buildingGroup.children.length} children`);

        buildingGroup.children.forEach(building => {
            // 주거 건물만 처리 (zoneType이 'residential'로 시작하면 OK)
            const zoneType = building.userData?.zoneType || '';
            if (!zoneType.includes('residential')) return;

            const size = building.userData.size || "1x1";
            const x = building.userData.tileX;
            const y = building.userData.tileY;
            const key = getBuildingKey(x, y, size);

            // 인구 배정 (없으면 새로 생성)
            const population = assignBuildingPopulation(key, size);

            // 그래프 높이 계산 (최대 2.0 유닛)
            const targetHeight = (population / maxPopulation) * 2.0;

            // 초록색 그래프 생성 (처음에는 높이 0으로) - 건물 위에 렌더링
            const geo = new THREE.BoxGeometry(TILE_SIZE * 0.4, 0.01, TILE_SIZE * 0.4);
            const mat = new THREE.MeshBasicMaterial({
                color: 0x4ade80,  // 초록색
                transparent: true,
                opacity: 0.9,
                depthTest: false,
                depthWrite: false
            });

            const bar = new THREE.Mesh(geo, mat);

            // 2x2 건물은 중앙에, 1x1은 타일 중심에
            const offsetX = size === "2x2" ? 1 : 0.5;
            const offsetZ = size === "2x2" ? 1 : 0.5;

            bar.position.set(
                (x - GRID_W / 2 + offsetX) * TILE_SIZE,
                0.01,  // 애니메이션 시작 높이
                (y - GRID_H / 2 + offsetZ) * TILE_SIZE
            );

            // 애니메이션용 데이터 저장
            bar.userData.targetHeight = targetHeight;
            bar.userData.currentHeight = 0.01;
            bar.userData.population = population;

            populationGroup.add(bar);
        });

        console.log(`Population View: created ${populationGroup.children.length} bars`);

        // 그래프 높이 애니메이션 시작
        animatePopulationBars();
    }

    // 그래프 애니메이션 (0에서 원래 높이까지)
    function animatePopulationBars() {
        if (populationAnimationFrameId) {
            cancelAnimationFrame(populationAnimationFrameId);
        }

        const animationDuration = 500;  // 0.5초
        const startTime = performance.now();

        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);

            // easeOutCubic 이징
            const eased = 1 - Math.pow(1 - progress, 3);

            populationGroup.children.forEach(bar => {
                const targetHeight = bar.userData.targetHeight;
                const newHeight = 0.01 + (targetHeight - 0.01) * eased;

                // 스케일로 높이 조절
                bar.scale.y = newHeight / 0.01;
                bar.position.y = newHeight / 2;
            });

            if (progress < 1) {
                populationAnimationFrameId = requestAnimationFrame(animate);
            } else {
                populationAnimationFrameId = null;
            }
        }

        populationAnimationFrameId = requestAnimationFrame(animate);
    }

    // 인구 뷰 토글
    function togglePopulationView() {
        if (isPopulationViewActive) {
            exitPopulationView();
        } else {
            enterPopulationView();
        }
    }

    function enterPopulationView() {
        if (isPopulationViewActive) return;

        // 땅값 뷰가 켜져있으면 끄기
        if (isLandValueViewActive) {
            exitLandValueView();
        }

        isPopulationViewActive = true;

        // Bloom 효과 끄기
        if (typeof bloomPass !== 'undefined') {
            bloomPass.enabled = false;
        }

        // 구역 모드 효과 적용 (흰색)
        applyZoneModeEffect();

        // 주거 건물 반투명 처리
        applyResidentialTransparency();

        // 인구 시각화 생성 및 표시
        createPopulationVisualization();
        populationGroup.visible = true;

        // 모드 변경
        setMode(MODE.POPULATION_VIEW);

        // 버튼 상태 업데이트
        if (btnPopulation) btnPopulation.classList.add('active');
        if (btnLandValue) btnLandValue.classList.remove('active');

        // 범례 패널 표시
        showDataViewLegend('population');

        console.log("Population View: ON");
    }

    /* =========================================================
     * WIND VIEW SYSTEM - 풍량 시각화 시스템
     * 바다와의 거리에 따라 풍량을 하늘색 그라데이션으로 표시
     * ========================================================= */
    const windViewGroup = new THREE.Group();
    windViewGroup.name = "windViewGroup";
    windViewGroup.visible = false;
    windViewGroup.renderOrder = 999;  // 다른 오브젝트 위에 렌더링
    scene.add(windViewGroup);

    let isWindViewActive = false;
    let windTexture = null;
    let windTextureData = null;
    let windPlane = null;

    // 바다 타일과의 최단 거리 계산 (BFS) - 원본 맵 기준
    function calculateDistanceToSea() {
        const distanceMap = new Array(GRID_W).fill(null).map(() => new Array(GRID_H).fill(Infinity));
        const queue = [];

        // 원본 맵의 바다/해변 타일을 시작점으로 추가
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const key = `${x},${y}`;
                if (originalSeaTiles.has(key)) {
                    distanceMap[x][y] = 0;
                    queue.push({ x, y });
                }
            }
        }

        // BFS로 거리 계산
        const directions = [];
        directions.push([-1, 0], [1, 0], [0, -1], [0, 1]);
        while (queue.length > 0) {
            const { x, y } = queue.shift();
            const currentDist = distanceMap[x][y];

            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                    if (distanceMap[nx][ny] > currentDist + 1) {
                        distanceMap[nx][ny] = currentDist + 1;
                        queue.push({ x: nx, y: ny });
                    }
                }
            }
        }

        return distanceMap;
    }

    // 풍량 계산 (바다 거리 기반, 0~1)
    function calculateWindStrength(distanceToSea) {
        // 최대 거리 (이 거리 이상은 풍량 0)
        const maxDistance = 50;
        // 바다에서 가까울수록 풍량 높음 (1에 가까움)
        const strength = Math.max(0, 1 - (distanceToSea / maxDistance));
        return strength;
    }

    // 풍량 → 하늘색 색상 변환 (풍량 높을수록 진한 하늘색)
    function getWindColor(strength) {
        // 풍량 0: 연한 하늘색 (0.9, 0.95, 1.0)
        // 풍량 1: 진한 하늘색 (0.0, 0.5, 0.9)
        const r = 0.9 - strength * 0.9;      // 0.9 → 0.0
        const g = 0.95 - strength * 0.45;    // 0.95 → 0.5
        const b = 1.0 - strength * 0.1;      // 1.0 → 0.9
        return { r, g, b };
    }

    // 풍량 텍스처 생성
    function createWindTexture() {
        const distanceMap = calculateDistanceToSea();

        // 텍스처 데이터 생성
        windTextureData = new Uint8Array(GRID_W * GRID_H * 4);

        for (let y = 0; y < GRID_H; y++) {
            for (let x = 0; x < GRID_W; x++) {
                // X축, Z축 모두 반전하여 텍스처에 저장
                const flippedX = GRID_W - 1 - x;
                const flippedY = GRID_H - 1 - y;
                const idx = (y * GRID_W + x) * 4;
                const key = `${flippedX},${flippedY}`;

                // 바다/해변은 항상 풍량 1 (최대)
                let strength;
                if (originalSeaTiles.has(key)) {
                    strength = 1;
                } else {
                    const distance = distanceMap[flippedX][flippedY];
                    strength = calculateWindStrength(distance);
                }
                const color = getWindColor(strength);

                windTextureData[idx] = Math.floor(color.r * 255);
                windTextureData[idx + 1] = Math.floor(color.g * 255);
                windTextureData[idx + 2] = Math.floor(color.b * 255);
                windTextureData[idx + 3] = Math.floor(strength * 180 + 50);  // 투명도 (50~230)
            }
        }

        // 텍스처 생성
        windTexture = new THREE.DataTexture(
            windTextureData,
            GRID_W,
            GRID_H,
            THREE.RGBAFormat
        );
        windTexture.flipY = false;  // Y축 뒤집힘 방지
        windTexture.needsUpdate = true;
        windTexture.magFilter = THREE.LinearFilter;
        windTexture.minFilter = THREE.LinearFilter;

        return windTexture;
    }

    // 풍량 시각화 생성
    function createWindVisualization() {
        // 기존 시각화 제거
        while (windViewGroup.children.length > 0) {
            const child = windViewGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (child.material.map) child.material.map.dispose();
                child.material.dispose();
            }
            windViewGroup.remove(child);
        }

        // 텍스처 생성
        createWindTexture();

        // 평면 생성
        const geometry = new THREE.PlaneGeometry(GRID_W * TILE_SIZE, GRID_H * TILE_SIZE);
        const material = new THREE.MeshBasicMaterial({
            map: windTexture,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        windPlane = new THREE.Mesh(geometry, material);
        windPlane.rotation.x = -Math.PI / 2;
        windPlane.position.set(
            ORIGIN_X + GRID_W / 2,
            0.15,  // 지면 바로 위
            ORIGIN_Z + GRID_H / 2
        );
        windViewGroup.add(windPlane);
    }

    // 평균 풍량 계산 (원본 맵 기준)
    function calculateAverageWindStrength() {
        const distanceMap = calculateDistanceToSea();
        let totalStrength = 0;
        let count = 0;

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const key = `${x},${y}`;
                if (!originalSeaTiles.has(key)) {
                    totalStrength += calculateWindStrength(distanceMap[x][y]);
                    count++;
                }
            }
        }

        return count > 0 ? (totalStrength / count) * 100 : 0;  // 백분율로 반환
    }

    // 풍량 뷰 토글
    function toggleWindView() {
        if (isWindViewActive) {
            // 풍량 뷰 종료
            ViewModeManager.exitViewMode('wind');
            setMode(MODE.CAMERA);
            if (btnWindView) btnWindView.classList.remove('active');
            hideDataViewLegend();
            console.log("Wind View: OFF");
            return;
        }

        // 다른 데이터 뷰 종료
        ViewModeManager.exitAllExcept('wind');

        // 풍량 뷰 활성화
        isWindViewActive = true;

        // 건물 흰색 처리 (구역 모드 효과)
        applyZoneModeEffect();

        // 풍량 시각화 생성 및 표시
        createWindVisualization();
        windViewGroup.visible = true;

        // 모드 변경
        setMode(MODE.WIND_VIEW);

        // 버튼 상태 업데이트
        if (btnWindView) btnWindView.classList.add('active');

        // 범례 패널 표시
        showDataViewLegend('wind');

        console.log("Wind View: ON");
    }

    // ─── 풍량 커서 게이지 시스템 ───
    const windCursorGaugeEl = document.getElementById('windCursorGauge');
    const windGaugeFillEl = document.getElementById('windGaugeFill');
    const windGaugeValueEl = document.getElementById('windGaugeValue');
    let cachedWindDistanceMap = null;

    // 풍량 뷰 활성화 시 distanceMap 캐싱
    function cacheWindDistanceMap() {
        cachedWindDistanceMap = calculateDistanceToSea();
    }

    // 그리드 좌표에서 풍량 가져오기
    function getWindStrengthAtGrid(gx, gy) {
        // 캐시 없으면 즉석 계산
        if (!cachedWindDistanceMap) {
            cachedWindDistanceMap = calculateDistanceToSea();
        }
        if (gx < 0 || gx >= GRID_W || gy < 0 || gy >= GRID_H) return 0;

        const key = `${gx},${gy}`;
        // 바다/해변은 항상 풍량 1
        if (originalSeaTiles.has(key)) {
            return 1;
        }

        const distance = cachedWindDistanceMap[gx][gy];
        return calculateWindStrength(distance);
    }

    // 풍력발전소 전력 출력 계산 (풍량에 비례)
    function calculateWindTurbinePower(x, y, basePower, expansions, expansionPower) {
        const windStrength = getWindStrengthAtGrid(x, y);
        const totalBasePower = basePower + (expansions * expansionPower);
        const actualPower = Math.round(totalBasePower * windStrength);
        return { actualPower, windStrength, totalBasePower };
    }

    // 풍량 커서 게이지용 재사용 객체
    const _windRaycaster = new THREE.Raycaster();
    const _windMouse = new THREE.Vector2();

    // 풍량 커서 게이지 업데이트
    function updateWindCursorGauge(e) {
        if (!isWindViewActive || !windCursorGaugeEl) {
            if (windCursorGaugeEl) windCursorGaugeEl.classList.remove('visible');
            return;
        }

        // 캐시된 rect 사용
        const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        // Raycaster로 그리드 좌표 계산 - 재사용 객체 사용
        _windMouse.set(mouseX, mouseY);
        _windRaycaster.setFromCamera(_windMouse, camera);

        const hits = _windRaycaster.intersectObject(ground, false);
        if (!hits.length) {
            windCursorGaugeEl.classList.remove('visible');
            return;
        }

        const point = hits[0].point;
        const tile = worldToTile(point.x, point.z);
        if (!tile) {
            windCursorGaugeEl.classList.remove('visible');
            return;
        }

        const { x: gx, y: gy } = tile;
        const strength = getWindStrengthAtGrid(gx, gy);
        const percentage = Math.round(strength * 100);

        // 게이지 위치 업데이트 (커서 오른쪽 아래)
        windCursorGaugeEl.style.left = (e.clientX + 15) + 'px';
        windCursorGaugeEl.style.top = (e.clientY + 15) + 'px';

        // 게이지 값 업데이트
        windGaugeFillEl.style.width = percentage + '%';
        windGaugeValueEl.textContent = percentage + '%';

        // 게이지 색상 (풍량에 따라 연한 하늘색 → 진한 하늘색)
        const color = getWindColor(strength);
        windGaugeFillEl.style.background = `rgb(${Math.floor(color.r * 255)}, ${Math.floor(color.g * 255)}, ${Math.floor(color.b * 255)})`;

        windCursorGaugeEl.classList.add('visible');
    }

    // 마우스 이동 이벤트 리스너 추가
    renderer.domElement.addEventListener('mousemove', updateWindCursorGauge);

    // 마우스가 캔버스를 벗어나면 게이지 숨기기
    renderer.domElement.addEventListener('mouseleave', () => {
        if (windCursorGaugeEl) windCursorGaugeEl.classList.remove('visible');
    });

    // toggleWindView 수정: 풍량 뷰 활성화 시 distanceMap 캐싱
    const originalToggleWindView = toggleWindView;
    toggleWindView = function() {
        originalToggleWindView();
        if (isWindViewActive) {
            cacheWindDistanceMap();
        } else {
            cachedWindDistanceMap = null;
            if (windCursorGaugeEl) windCursorGaugeEl.classList.remove('visible');
        }
    };

    // 주거 건물 반투명 처리 (인구 뷰용)
    function applyResidentialTransparency() {
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            if (!building.instance) continue;

            // 주거 건물만 반투명 처리
            const isResidential = building.zoneType === CELL.ZONE_RESIDENTIAL;
            if (isResidential) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            mat.transparent = true;
                            mat.opacity = 0.4;
                            mat.needsUpdate = true;
                        });
                    }
                });
            }
        }
    }

    // 주거 건물 반투명 복원
    function restoreResidentialTransparency() {
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            if (!building.instance) continue;

            const isResidential = building.zoneType === CELL.ZONE_RESIDENTIAL;
            if (isResidential) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            mat.transparent = false;
                            mat.opacity = 1.0;
                            mat.needsUpdate = true;
                        });
                    }
                });
            }
        }
    }

    // 모든 건물 반투명 처리 (서비스 뷰 진입 시)
    function setAllBuildingsTransparent(opacity = 0.4) {
        // 민간 건물 반투명
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            if (!building.instance) continue;

            building.instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        mat.transparent = true;
                        mat.opacity = opacity;
                        mat.needsUpdate = true;
                    });
                }
            });
        }

        // 공공시설 반투명 (하이라이트된 건물은 나중에 덮어씀)
        if (placedPublicBuildings) {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref || !building.instance) return;

                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            mat.transparent = true;
                            mat.opacity = opacity;
                            mat.needsUpdate = true;
                        });
                    }
                });
            });
        }
    }

    // 모든 건물 투명도 복원 (데이터 뷰 종료 시)
    function restoreAllBuildingOpacity() {
        // 민간 건물 복원
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            if (!building.instance) continue;
            // 폐건물은 스킵 (회색 유지)
            if (building.isAbandoned) continue;

            building.instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        mat.transparent = false;
                        mat.opacity = 1.0;
                        mat.needsUpdate = true;
                    });
                }
            });
        }

        // 공공시설 복원
        if (placedPublicBuildings) {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref || !building.instance) return;

                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            mat.transparent = false;
                            mat.opacity = 1.0;
                            mat.needsUpdate = true;
                        });
                    }
                });
            });
        }
    }

    function exitPopulationView() {
        // ViewModeManager에 위임
        ViewModeManager.exitViewMode('population');
    }

    /* =========================================================
     * GRAPH HOVER TOOLTIP - 그래프 호버 시 툴팁 표시
     * ========================================================= */
    const graphRaycaster = new THREE.Raycaster();
    const graphMouse = new THREE.Vector2();

    function handleGraphHover(e) {
        if (!graphTooltip) return;

        // 캐시된 rect 사용
        const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
        graphMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        graphMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        graphRaycaster.setFromCamera(graphMouse, camera);

        // 인구 뷰 모드
        if (currentMode === MODE.POPULATION_VIEW && populationGroup.visible) {
            const intersects = graphRaycaster.intersectObjects(populationGroup.children);

            if (intersects.length > 0) {
                const bar = intersects[0].object;
                const population = bar.userData?.population;

                if (population !== undefined) {
                    graphTooltip.querySelector('.label').textContent = '인구: ';
                    graphTooltip.querySelector('.value').textContent = `${population}명`;
                    graphTooltip.className = '';
                    graphTooltip.style.display = 'block';
                    graphTooltip.style.left = (e.clientX + 15) + 'px';
                    graphTooltip.style.top = (e.clientY + 15) + 'px';
                    return;
                }
            }
        }

        // 땅값 뷰 모드 (2D 오버레이에서 좌표 기반으로 값 계산)
        if (currentMode === MODE.LAND_VALUE_VIEW && landValueGroup.visible && landValueOverlayMesh) {
            const intersects = graphRaycaster.intersectObject(landValueOverlayMesh);

            if (intersects.length > 0) {
                const point = intersects[0].point;

                // 월드 좌표 -> 그리드 좌표
                const gx = Math.floor(point.x / TILE_SIZE + GRID_W / 2);
                const gz = Math.floor(point.z / TILE_SIZE + GRID_H / 2);

                // 범위 체크
                if (gx >= 0 && gx < GRID_W && gz >= 0 && gz < GRID_H) {
                    const baseLandValue = getLandValue(gx, gz);
                    const serviceBonus = typeof getServiceBonus === 'function' ? getServiceBonus(gx, gz) : 0;
                    const totalValue = baseLandValue + serviceBonus;

                    graphTooltip.querySelector('.label').textContent = '땅값: ';
                    graphTooltip.querySelector('.value').textContent = `${Math.round(totalValue)}`;
                    graphTooltip.className = 'landvalue';
                    graphTooltip.style.display = 'block';
                    graphTooltip.style.left = (e.clientX + 15) + 'px';
                    graphTooltip.style.top = (e.clientY + 15) + 'px';
                    return;
                }
            }
        }

        // 호버하지 않으면 숨김
        graphTooltip.style.display = 'none';
    }

    /* =========================================================
     * ZONE MODE MATERIAL SYSTEM
     * 수치 모드 진입 시 모든 오브젝트를 흰색으로 변경
     * 건물은 반투명, 지형/도로는 불투명
     * ========================================================= */
    const originalMaterials = new Map();  // mesh uuid -> original material(s)
    let isZoneModeActive = false;

    // 폴백 머티리얼 (복원 실패 시 사용)
    const fallbackMaterial = new THREE.MeshLambertMaterial({
        color: 0x888888,
        transparent: false,
    });

    // 머티리얼 유효성 검사 및 안전한 복원 헬퍼
    function isValidMaterial(mat) {
        if (!mat) return false;
        // 기본적인 머티리얼 속성 확인
        if (typeof mat !== 'object') return false;
        // isMaterial 체크 (Three.js 머티리얼인지 확인)
        if (!mat.isMaterial) return false;
        // map이 있는 경우 유효한 텍스처인지 확인
        if (mat.map) {
            // 이미 disposed된 텍스처 확인 (source나 image가 없으면 disposed됨)
            if (!mat.map.source && !mat.map.image) {
                mat.map = null;  // disposed된 map 제거
                mat.needsUpdate = true;  // 머티리얼 업데이트 필요
            }
        }
        return true;
    }

    function safeAssignMaterial(mesh, material) {
        if (!mesh) return false;

        try {
            if (!material) {
                mesh.material = fallbackMaterial.clone();
                return false;
            }

            if (Array.isArray(material)) {
                const validMaterials = material.filter(m => isValidMaterial(m));
                if (validMaterials.length > 0) {
                    mesh.material = validMaterials;
                    return true;
                } else {
                    mesh.material = fallbackMaterial.clone();
                    return false;
                }
            } else if (isValidMaterial(material)) {
                mesh.material = material;
                return true;
            } else {
                mesh.material = fallbackMaterial.clone();
                return false;
            }
        } catch (e) {
            console.warn('Material assignment failed:', e);
            mesh.material = fallbackMaterial.clone();
            return false;
        }
    }

    // 토대(잔디)용 흰색 머티리얼 (불투명) - 구역 모드에서 흰색 배경
    const whiteMaterialSolid = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.5,
        roughness: 0.9,
        metalness: 0.0,
        transparent: false,
    });

    // 도로/수로/다리용 회색 머티리얼 (불투명) - 토대와 구분
    const grayMaterialSolid = new THREE.MeshStandardMaterial({
        color: 0x888888,
        emissive: 0xaaaaaa,
        emissiveIntensity: 0.3,
        roughness: 0.9,
        metalness: 0.0,
        transparent: false,
    });

    // 건물용 회색 머티리얼 (불투명) - 구역 색상과 구분
    const grayMaterialBuilding = new THREE.MeshStandardMaterial({
        color: 0x666666,
        emissive: 0x888888,
        emissiveIntensity: 0.25,
        roughness: 0.9,
        metalness: 0.0,
        transparent: false,
    });

    // 데이터 뷰 모드 진입 전 환경 설정 저장용
    let savedEnvironment = null;

    function applyZoneModeEffect() {
        if (isZoneModeActive) return;
        isZoneModeActive = true;
        originalMaterials.clear();

        // 현재 환경 설정 저장 (밤일 때 복원용)
        savedEnvironment = {
            skyboxVisible: skyboxMesh.visible,
            skyboxBlendDaySunset: skyboxBlendDaySunset,
            skyboxBlendSunsetNight: skyboxBlendSunsetNight,
            sceneEnvironment: scene.environment,
            hemiIntensity: hemiLight.intensity,
            hemiSkyColor: hemiLight.color.getHex(),
            hemiGroundColor: hemiLight.groundColor.getHex(),
            dirIntensity: dir.intensity,
            dirColor: dir.color.getHex(),
            nightAmbientIntensity: nightAmbient.intensity,
            exposure: renderer.toneMappingExposure,
            fogColor: scene.fog.color.getHex(),
            fogDensity: scene.fog.density,
            bloomStrength: bloomPass.strength,
        };

        // 데이터 뷰용 밝은 환경 설정
        skyboxMesh.visible = false;  // Skybox 숨김
        scene.background = new THREE.Color(0xf0f0f0);  // 밝은 회색 배경
        scene.environment = null;  // 환경맵 비활성화
        hemiLight.intensity = 1.2;
        hemiLight.color.setHex(0xffffff);
        hemiLight.groundColor.setHex(0xffffff);
        dir.intensity = 1.0;
        dir.color.setHex(0xffffff);
        nightAmbient.intensity = 0.3;
        renderer.toneMappingExposure = 1.2;
        scene.fog.color.setHex(0xf0f0f0);
        scene.fog.density = 0.005;
        bloomPass.strength = 0.1;

        // 토대(잔디)는 흰색
        grassGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                originalMaterials.set(child.uuid, child.material);
                child.material = whiteMaterialSolid.clone();
            }
        });

        // 나무도 흰색 (데이터 뷰에서 잘 보이도록)
        treeGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                originalMaterials.set(child.uuid, child.material);
                child.material = whiteMaterialSolid.clone();
            }
        });

        // 도로, 수로, 다리는 회색 (토대와 구분)
        const grayGroups = [roadGroup, waterGroup, bridgeGroup];
        grayGroups.forEach(group => {
            group.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialSolid;  // 공유 재질 사용 (성능 최적화)
                }
            });
        });

        // 건물은 해당 구역 타입 색상으로 표시 (반투명)
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            if (!building.instance) continue;

            // 구역 타입에 따른 색상 결정
            let buildingColor = 0x888888; // 기본 회색
            if (building.zoneType === CELL.ZONE_RESIDENTIAL) {
                buildingColor = ZONE_COLORS[CELL.ZONE_RESIDENTIAL]; // 초록
            } else if (building.zoneType === CELL.ZONE_COMMERCIAL) {
                buildingColor = ZONE_COLORS[CELL.ZONE_COMMERCIAL]; // 파랑
            } else if (building.zoneType === CELL.ZONE_INDUSTRIAL) {
                buildingColor = ZONE_COLORS[CELL.ZONE_INDUSTRIAL]; // 노랑
            }

            const zoneMat = new THREE.MeshLambertMaterial({
                color: buildingColor,
                transparent: false,
                opacity: 1.0
            });

            building.instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = zoneMat;
                }
            });
        }

        // 공공시설은 회색으로 표시
        placedPublicBuildings.forEach((building) => {
            if (building.ref || !building.instance) return;
            building.instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialBuilding;
                }
            });
            // 풍력발전기 확장 터빈(애드온)도 회색으로 표시
            if (building.expansionInstances && building.expansionInstances.length > 0) {
                building.expansionInstances.forEach(exp => {
                    if (exp.instance) {
                        exp.instance.traverse((child) => {
                            if (child.isMesh && child.material) {
                                originalMaterials.set(child.uuid, child.material);
                                child.material = grayMaterialBuilding;
                            }
                        });
                    }
                });
            }
        });

        // 차량도 회색 (교통 시스템이 초기화된 경우)
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            trafficManager.vehicleGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialBuilding;  // 공유 재질 사용 (성능 최적화)
                }
            });
        }
    }

    function restoreOriginalMaterials(force = false) {
        if (!force && !isZoneModeActive) return;
        isZoneModeActive = false;

        // 저장된 환경 설정 복원
        if (savedEnvironment) {
            // Skybox 상태 복원
            skyboxMesh.visible = savedEnvironment.skyboxVisible;
            skyboxBlendDaySunset = savedEnvironment.skyboxBlendDaySunset;
            skyboxBlendSunsetNight = savedEnvironment.skyboxBlendSunsetNight;
            skyboxMaterial.uniforms.tBlendDaySunset.value = skyboxBlendDaySunset;
            skyboxMaterial.uniforms.tBlendSunsetNight.value = skyboxBlendSunsetNight;
            scene.background = null;  // Skybox가 배경 담당
            scene.environment = savedEnvironment.sceneEnvironment;
            // 조명 설정 복원
            hemiLight.intensity = savedEnvironment.hemiIntensity;
            hemiLight.color.setHex(savedEnvironment.hemiSkyColor);
            hemiLight.groundColor.setHex(savedEnvironment.hemiGroundColor);
            dir.intensity = savedEnvironment.dirIntensity;
            dir.color.setHex(savedEnvironment.dirColor);
            nightAmbient.intensity = savedEnvironment.nightAmbientIntensity;
            renderer.toneMappingExposure = savedEnvironment.exposure;
            scene.fog.color.setHex(savedEnvironment.fogColor);
            scene.fog.density = savedEnvironment.fogDensity;
            bloomPass.strength = savedEnvironment.bloomStrength;
            savedEnvironment = null;
        }

        const groups = [grassGroup, treeGroup, roadGroup, waterGroup, bridgeGroup, buildingGroup];

        // 차량 그룹도 추가
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            groups.push(trafficManager.vehicleGroup);
        }

        // 머티리얼 복원 헬퍼 함수
        function restoreMeshMaterial(child) {
            if (child.isMesh && originalMaterials.has(child.uuid)) {
                // 폐건물인지 확인 - 폐건물은 회색 유지
                let parentObj = child;
                while (parentObj.parent && !parentObj.userData?.isAbandoned) {
                    parentObj = parentObj.parent;
                }
                if (parentObj.userData?.isAbandoned) {
                    // 폐건물은 회색으로 유지
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        if (mat.color) mat.color.setHex(ABANDONED_GRAY);
                    });
                    return;
                }

                const currentMaterial = child.material;
                const originalMaterial = originalMaterials.get(child.uuid);

                // 현재 재질 (흰색 재질)의 UUID를 색상 캐시에서 제거
                if (currentMaterial && currentMaterial !== originalMaterial) {
                    const currentMats = Array.isArray(currentMaterial) ? currentMaterial : [currentMaterial];
                    currentMats.forEach(mat => {
                        if (mat && mat.uuid) {
                            originalObjectColors.delete(mat.uuid);
                        }
                    });
                }

                // 안전한 머티리얼 할당 사용
                safeAssignMaterial(child, originalMaterial);
            }
        }

        groups.forEach(group => {
            group.traverse(restoreMeshMaterial);
        });

        // 모든 차량(활성/비활성 포함) 명시적 복원
        // vehicleGroup.traverse가 비활성 차량을 놓칠 수 있으므로 명시적으로 처리
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicles) {
            trafficManager.vehicles.forEach(vehicle => {
                if (vehicle.mesh) {
                    vehicle.mesh.traverse(restoreMeshMaterial);
                }
            });
        }

        // 풍력발전기 확장 터빈(애드온) 복원
        placedPublicBuildings.forEach((building) => {
            if (building.ref) return;
            if (building.expansionInstances && building.expansionInstances.length > 0) {
                building.expansionInstances.forEach(exp => {
                    if (exp.instance) {
                        exp.instance.traverse(restoreMeshMaterial);
                    }
                });
            }
        });

        originalMaterials.clear();

        // 색상 틴트 강제 재계산
        lastColorTintHour = -1;

        // 복원 후 시간대별 색감 다시 적용
        forceUpdateEnvironmentEffects();
    }

    // 환경 효과 강제 업데이트 (통계 모드 종료 시 호출)
    function forceUpdateEnvironmentEffects() {
        lastColorTintHour = -1;  // 강제 업데이트
        const hour = (timeState.gameTime / 3600) % 24;
        const isNight = hour >= 20 || hour < 5;
        updateSceneColorTint(hour, isNight);

        // 건물 발광도 다시 적용
        updateBuildingEmissive(isNight);
    }

    /* =========================================================
     * PUBLIC BUILDING PLACEMENT MODE EFFECT
     * 건물 설치 모드 진입 시 같은 종류는 초록색, 나머지는 흰색
     * ========================================================= */
    // placedPublicBuildings는 상단에서 초기화됨 (TDZ 방지)

    const placementOriginalMaterials = new Map();
    let isPlacementModeActive = false;
    let currentPlacementType = null;

    // 설치 모드용 초록색 머티리얼 (같은 종류 건물)
    const greenMaterialPlacement = new THREE.MeshStandardMaterial({
        color: 0x44ff66,
        transparent: true,
        opacity: 0.8,
    });

    // 설치 모드용 회색 머티리얼 (건물/차량용)
    const grayMaterialPlacement = new THREE.MeshStandardMaterial({
        color: 0x666666,
        emissive: 0x888888,
        emissiveIntensity: 0.25,
        transparent: false,
    });

    function applyPlacementModeEffect(buildingType) {
        if (isPlacementModeActive) {
            restorePlacementModeEffect();
        }

        isPlacementModeActive = true;
        currentPlacementType = buildingType;
        placementOriginalMaterials.clear();

        // 공공시설 메시 UUID 수집 (나중에 buildingGroup에서 제외하기 위해)
        const publicBuildingMeshUuids = new Set();
        placedPublicBuildings.forEach((building, key) => {
            if (building.instance) {
                building.instance.traverse((child) => {
                    if (child.isMesh) {
                        publicBuildingMeshUuids.add(child.uuid);
                    }
                });
            }
        });

        // 토대(잔디) - 흰색
        grassGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                placementOriginalMaterials.set(child.uuid, child.material);
                child.material = whiteMaterialSolid.clone();
            }
        });

        // 나무 - 흰색
        treeGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                placementOriginalMaterials.set(child.uuid, child.material);
                child.material = whiteMaterialSolid.clone();
            }
        });

        // 도로, 수로, 다리 - 회색 (토대와 구분)
        const grayGroups = [roadGroup, waterGroup, bridgeGroup];
        grayGroups.forEach(group => {
            group.traverse((child) => {
                if (child.isMesh && child.material) {
                    placementOriginalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialSolid.clone();
                }
            });
        });

        // 일반 건물 - 회색 (공공시설 제외)
        buildingGroup.traverse((child) => {
            if (child.isMesh && child.material && !publicBuildingMeshUuids.has(child.uuid)) {
                placementOriginalMaterials.set(child.uuid, child.material);
                child.material = grayMaterialPlacement.clone();
            }
        });

        // 배치된 공공시설 - 같은 종류는 초록색, 다른 종류는 회색
        placedPublicBuildings.forEach((building, key) => {
            if (building.instance) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        placementOriginalMaterials.set(child.uuid, child.material);
                        if (building.type === buildingType) {
                            // 같은 종류 - 초록색
                            child.material = greenMaterialPlacement.clone();
                        } else {
                            // 다른 종류 - 회색
                            child.material = grayMaterialPlacement.clone();
                        }
                    }
                });
            }
        });

        // 차량 - 회색
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            trafficManager.vehicleGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    placementOriginalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialPlacement.clone();
                }
            });
        }
    }

    function restorePlacementModeEffect() {
        if (!isPlacementModeActive) return;
        isPlacementModeActive = false;
        currentPlacementType = null;

        const groups = [grassGroup, treeGroup, roadGroup, waterGroup, bridgeGroup, buildingGroup];

        // 차량 그룹도 추가
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            groups.push(trafficManager.vehicleGroup);
        }

        // 안전한 머티리얼 복원 헬퍼 함수
        function safeRestorePlacementMaterial(child) {
            if (child.isMesh && placementOriginalMaterials.has(child.uuid)) {
                const originalMaterial = placementOriginalMaterials.get(child.uuid);
                safeAssignMaterial(child, originalMaterial);
            }
        }

        // 일반 그룹 복원
        groups.forEach(group => {
            group.traverse(safeRestorePlacementMaterial);
        });

        // 공공시설 복원
        placedPublicBuildings.forEach((building, key) => {
            if (building.instance) {
                building.instance.traverse(safeRestorePlacementMaterial);
            }
        });

        placementOriginalMaterials.clear();

        // 복원 후 시간대별 색감 다시 적용
        lastColorTintHour = -1;
        const hour = (timeState.gameTime / 3600) % 24;
        const isNight = hour >= 20 || hour < 5;
        updateSceneColorTint(hour, isNight);
        updateBuildingEmissive(isNight);
    }

    // 플로팅 금액 표시
    function showFloatingCost(cost, clientX, clientY) {
        const floater = document.createElement('div');
        floater.className = 'floating-cost';
        floater.textContent = `-₩${cost.toLocaleString()}`;
        floater.style.left = clientX + 'px';
        floater.style.top = clientY + 'px';
        document.body.appendChild(floater);

        // 애니메이션 후 제거
        setTimeout(() => {
            floater.remove();
        }, 1200);
    }

    // 카메라 흔들림 이펙트
    function shakeCamera(intensity = 0.15, duration = 400) {
        const startTime = Date.now();
        const originalY = camera.position.y;

        function animateShake() {
            const elapsed = Date.now() - startTime;
            if (elapsed >= duration) {
                camera.position.y = originalY;
                return;
            }

            const progress = elapsed / duration;
            const decay = 1 - progress;  // 점점 감소
            const shake = Math.sin(progress * Math.PI * 2) * intensity * decay;
            camera.position.y = originalY + shake;

            requestAnimationFrame(animateShake);
        }

        animateShake();
    }

    // 건물 낙하 이펙트
    function animateBuildingDrop(instance, targetY, onComplete) {
        const startY = targetY + 3;  // 3유닛 위에서 시작
        instance.position.y = startY;

        const duration = 400;  // 0.4초
        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            if (elapsed >= duration) {
                instance.position.y = targetY;
                if (onComplete) onComplete();
                return;
            }

            // easeOutBounce 효과
            const progress = elapsed / duration;
            const eased = 1 - Math.pow(1 - progress, 3);  // easeOutCubic
            instance.position.y = startY + (targetY - startY) * eased;

            requestAnimationFrame(animate);
        }

        animate();
    }

    // 서비스 효과 물결 이모지 표시 - 카메라 이동 시에도 건물 위에 고정
    const activeServiceEmojis = [];  // 활성 이모지 추적 배열

    function showServiceEffectRipple(centerX, centerY, effectRadius, isPositive = true) {
        const emoji = isPositive ? '😊' : '😢';
        const affectedBuildings = [];

        // 효과 범위 내 민간건물 찾기
        placedBuildings.forEach((building, key) => {
            // 참조 타일은 스킵
            if (building.ref) return;

            const bx = building.x;
            const by = building.y;
            const bCenterX = bx + (building.width || 1) / 2;
            const bCenterY = by + (building.depth || 1) / 2;

            const dx = bCenterX - centerX;
            const dy = bCenterY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= effectRadius && distance > 0) {
                affectedBuildings.push({
                    instance: building.instance,
                    x: bx,
                    y: by,
                    width: building.width || 1,
                    depth: building.depth || 1,
                    distance: distance
                });
            }
        });

        // 거리순 정렬 (가까운 것부터)
        affectedBuildings.sort((a, b) => a.distance - b.distance);

        // 물결처럼 순차적으로 이모지 표시
        affectedBuildings.forEach((building, index) => {
            const delay = building.distance * 50;  // 거리에 비례한 딜레이 (1칸당 50ms)

            setTimeout(() => {
                // 건물 인스턴스의 실제 3D 위치 사용
                if (!building.instance) return;

                // 건물 머리 위 위치 계산 (건물 높이 + 오프셋)
                const bbox = new THREE.Box3().setFromObject(building.instance);
                const buildingHeight = bbox.max.y;

                const worldPos = new THREE.Vector3(
                    building.instance.position.x,
                    buildingHeight + 0.5,  // 건물 꼭대기 위
                    building.instance.position.z
                );

                // 이모지 요소 생성
                const emojiEl = document.createElement('div');
                emojiEl.className = 'service-emoji';
                emojiEl.textContent = emoji;
                document.body.appendChild(emojiEl);

                // 활성 이모지 추적에 등록
                const emojiData = {
                    element: emojiEl,
                    worldPos: worldPos,
                    startTime: performance.now(),
                    duration: 1500
                };
                activeServiceEmojis.push(emojiData);

                // 초기 위치 업데이트
                updateServiceEmojiPosition(emojiData);

                // 애니메이션 후 제거
                setTimeout(() => {
                    const idx = activeServiceEmojis.indexOf(emojiData);
                    if (idx > -1) activeServiceEmojis.splice(idx, 1);
                    emojiEl.remove();
                }, 1500);
            }, delay);
        });
    }

    // 개별 이모지 위치 업데이트
    function updateServiceEmojiPosition(emojiData) {
        const screenPos = emojiData.worldPos.clone().project(camera);

        // 카메라 뒤에 있으면 숨김
        if (screenPos.z > 1) {
            emojiData.element.style.display = 'none';
            return;
        }

        const clientX = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const clientY = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

        // 화면 밖이면 숨김
        if (clientX < -50 || clientX > window.innerWidth + 50 || clientY < -50 || clientY > window.innerHeight + 50) {
            emojiData.element.style.display = 'none';
            return;
        }

        emojiData.element.style.display = 'block';
        emojiData.element.style.left = clientX + 'px';
        emojiData.element.style.top = clientY + 'px';
    }

    // 모든 활성 이모지 위치 업데이트 (렌더 루프에서 호출)
    function updateAllServiceEmojis() {
        activeServiceEmojis.forEach(emojiData => {
            updateServiceEmojiPosition(emojiData);
        });
    }

    /* =========================================================
     * ROAD CONNECTIVITY CHECK (도로 연결 체크)
     * ========================================================= */
    // disconnectIcons는 더 이상 사용하지 않음 - 통합 상태 아이콘 시스템 사용
    const disconnectIcons = new Map();  // 레거시 호환용 (빈 맵)
    let connectedRoads = new Set();     // 외곽 도로에 연결된 도로들
    const disconnectedBuildings = new Set();  // 연결 끊긴 건물 추적

    // 도로 끊김 폐건물화 시스템
    const buildingRoadDisconnectTime = new Map();  // 건물별 도로 끊긴 시작 시간 (key: "x,y", value: timestamp)
    const buildingRoadAbandonTime = new Map();     // 건물별 폐건물화 예정 시간 (랜덤, 정규분포)
    const ROAD_DISCONNECT_ABANDON_MEAN = 45000;    // 도로 끊김 폐건물 평균 시간 (45초)
    const ROAD_DISCONNECT_ABANDON_STDDEV = 15000;  // 폐건물화 시간 표준편차 (15초)

    // 외곽 도로(LOCKED_ROAD, LOCKED_ROAD_4LANE)에서 BFS로 연결된 모든 도로 찾기
    function findConnectedRoads() {
        connectedRoads.clear();
        const queue = [];

        // 외곽 도로(LOCKED_ROAD, LOCKED_ROAD_4LANE)에서 시작
        for (let gx = 0; gx < GRID_W; gx++) {
            for (let gy = 0; gy < GRID_H; gy++) {
                const cell = grid[gx][gy];
                if (cell === CELL.LOCKED_ROAD || cell === CELL.LOCKED_ROAD_4LANE) {
                    const key = `${gx},${gy}`;
                    connectedRoads.add(key);
                    queue.push({ x: gx, y: gy });
                }
            }
        }

        // BFS로 연결된 도로 탐색 (2차선 및 4차선 도로 포함)
        const directions = [ [0, 1], [0, -1], [1, 0], [-1, 0] ];
        while (queue.length > 0) {
            const { x, y } = queue.shift();

            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                const key = `${nx},${ny}`;
                if (connectedRoads.has(key)) continue;

                const cell = grid[nx][ny];
                // 2차선 및 4차선 도로 모두 체크
                if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD ||
                    cell === CELL.ROAD_4LANE || cell === CELL.LOCKED_ROAD_4LANE) {
                    connectedRoads.add(key);
                    queue.push({ x: nx, y: ny });
                }
            }
        }
    }

    // 건물이 연결된 도로에 인접해 있는지 체크
    function isBuildingConnectedToRoad(building) {
        const width = building.width || 1;
        const depth = building.depth || 1;
        const directions = [ [0, 1], [0, -1], [1, 0], [-1, 0] ];

        // 건물의 모든 타일 주변 체크
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const bx = building.x + dx;
                const by = building.y + dy;

                for (const [ddx, ddy] of directions) {
                    const nx = bx + ddx;
                    const ny = by + ddy;
                    const key = `${nx},${ny}`;

                    if (connectedRoads.has(key)) {
                        return true;  // 연결된 도로에 인접
                    }
                }
            }
        }
        return false;
    }

    // 끊김 상태 추가 (통합 시스템 사용)
    function createDisconnectIcon(building, buildingKey) {
        const [x, y] = buildingKey.split(',').map(Number);
        disconnectedBuildings.add(buildingKey);
        addBuildingStatus(x, y, 'NO_ROAD', building);
    }

    // 끊김 상태 제거 (통합 시스템 사용)
    function removeDisconnectIcon(buildingKey) {
        const [x, y] = buildingKey.split(',').map(Number);
        disconnectedBuildings.delete(buildingKey);
        removeBuildingStatus(x, y, 'NO_ROAD');
    }

    // 레거시 호환 함수 (더 이상 개별 위치 업데이트 필요 없음)
    function updateDisconnectIconPosition(iconData) {
        // 통합 시스템에서 처리
    }

    // 레거시 호환 함수
    function updateAllDisconnectIcons() {
        // 통합 시스템의 updateAllStatusIcons()에서 처리
    }

    // 도로 연결 상태 체크 및 상태 업데이트
    function updateRoadConnectivity() {
        // 연결된 도로 찾기
        findConnectedRoads();

        const now = Date.now();

        // 모든 건물 체크 (최적화: Array 캐시 사용)
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const isConnected = isBuildingConnectedToRoad(building);
            const wasDisconnected = disconnectedBuildings.has(key);

            if (!isConnected && !wasDisconnected) {
                // 연결 안됨 + 상태 없음 → 상태 추가
                createDisconnectIcon(building, key);

                // 도로 끊김 시작 시간 기록 + 랜덤 폐건물화 시간 설정
                if (!buildingRoadDisconnectTime.has(key)) {
                    buildingRoadDisconnectTime.set(key, now);
                    // 정규분포 랜덤 시간 (Box-Muller 변환)
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    const abandonTime = Math.max(15000, ROAD_DISCONNECT_ABANDON_MEAN + z * ROAD_DISCONNECT_ABANDON_STDDEV);
                    buildingRoadAbandonTime.set(key, abandonTime);
                }
            } else if (isConnected && wasDisconnected) {
                // 연결됨 + 상태 있음 → 상태 제거
                removeDisconnectIcon(key);
                // 폐건물화 타이머 초기화
                buildingRoadDisconnectTime.delete(key);
                buildingRoadAbandonTime.delete(key);
            }
        }

        // 삭제된 건물의 아이콘 정리
        disconnectIcons.forEach((iconData, key) => {
            if (!placedBuildings.has(key)) {
                removeDisconnectIcon(key);
            }
        });

        // 도로 끊김으로 인한 폐건물 체크
        checkRoadDisconnectAbandonment();
    }

    // 도로 끊김으로 인한 폐건물 체크
    function checkRoadDisconnectAbandonment() {
        const now = Date.now();

        buildingRoadDisconnectTime.forEach((startTime, key) => {
            const building = placedBuildings.get(key);
            if (!building || building.ref) return;

            // 이미 폐건물이면 스킵
            if (building.isAbandoned || building.instance?.userData?.isAbandoned) return;

            const abandonTime = buildingRoadAbandonTime.get(key) || ROAD_DISCONNECT_ABANDON_MEAN;
            const elapsed = now - startTime;

            if (elapsed >= abandonTime) {
                // 폐건물로 전환
                abandonBuildingByRoadDisconnect(building, key);
                // 타이머 정리
                buildingRoadDisconnectTime.delete(key);
                buildingRoadAbandonTime.delete(key);
            }
        });
    }

    // 건물을 폐건물로 전환 (도로 끊김)
    function abandonBuildingByRoadDisconnect(building, key) {
        const [x, y] = key.split(',').map(Number);

        if (!building.instance || !building.instance.userData) return;
        if (building.instance.userData.isAbandoned) return;

        // 폐건물 사유 및 시간 저장
        const userData = building.instance.userData;
        userData.abandonedReason = '도로가 끊겨서 살 수 없어요...';

        // 폐건물 상태 설정
        userData.isAbandoned = true;
        building.isAbandoned = true;
        building.abandonedReason = userData.abandonedReason;

        // 폐건물 목록에 추가
        abandonedBuildings.add(key);

        // 폐건물 색상 적용
        applyAbandonedMaterials(building.instance);

        // 도로 끊김 상태 아이콘 제거 (폐건물 아이콘으로 대체됨)
        removeBuildingStatus(x, y, 'NO_ROAD');
        disconnectedBuildings.delete(key);

        // 폐건물 상태 아이콘 표시 (통합 시스템)
        addBuildingStatus(x, y, 'ABANDONED', building);

        console.log(`[RoadDisconnect] Building abandoned at ${key}: 도로 끊김`);
        markDirty();
    }

    // 도로가 어느 방향에 있는지 감지 (상/하 vs 좌/우)
    // 비율 기반으로 판단하여 비대칭 건물(3x4 등)도 정확히 처리
    function detectRoadSide(gx, gy, width, depth) {
        const result = detectRoadSideWithCount(gx, gy, width, depth);
        return { side: result.side, direction: result.direction };
    }

    // 도로가 어느 방향에 있는지 감지 + 도로 존재 여부 반환
    function detectRoadSideWithCount(gx, gy, width, depth) {
        let topRoads = 0, bottomRoads = 0, leftRoads = 0, rightRoads = 0;

        // 위쪽 (y - 1)
        for (let dx = 0; dx < width; dx++) {
            if (inBounds(gx + dx, gy - 1) && isRoad(gx + dx, gy - 1)) topRoads++;
        }
        // 아래쪽 (y + depth)
        for (let dx = 0; dx < width; dx++) {
            if (inBounds(gx + dx, gy + depth) && isRoad(gx + dx, gy + depth)) bottomRoads++;
        }
        // 왼쪽 (x - 1)
        for (let dy = 0; dy < depth; dy++) {
            if (inBounds(gx - 1, gy + dy) && isRoad(gx - 1, gy + dy)) leftRoads++;
        }
        // 오른쪽 (x + width)
        for (let dy = 0; dy < depth; dy++) {
            if (inBounds(gx + width, gy + dy) && isRoad(gx + width, gy + dy)) rightRoads++;
        }

        const maxHorizontal = Math.max(topRoads, bottomRoads);
        const maxVertical = Math.max(leftRoads, rightRoads);
        const totalRoads = topRoads + bottomRoads + leftRoads + rightRoads;

        // 비율 기반 비교 (비대칭 건물 지원)
        // width=3, depth=4일 때 위쪽 3칸 vs 왼쪽 4칸이면 둘 다 100%로 동등
        const horizontalRatio = width > 0 ? maxHorizontal / width : 0;
        const verticalRatio = depth > 0 ? maxVertical / depth : 0;

        // 도로가 주로 좌/우에 있으면 'vertical', 상/하에 있으면 'horizontal'
        // 비율이 같을 때는 'horizontal' (기본 방향 유지, shortSideFacesRoad 건물의 짧은 면이 위/아래)
        if (verticalRatio > horizontalRatio) {
            return { side: 'vertical', direction: leftRoads >= rightRoads ? 'left' : 'right', hasRoad: totalRoads > 0 };
        } else {
            return { side: 'horizontal', direction: topRoads >= bottomRoads ? 'top' : 'bottom', hasRoad: totalRoads > 0 };
        }
    }

    // 공공시설 배치
    function placePublicBuilding(gx, gy, type, clientX = null, clientY = null) {
        const prefabData = getRandomPublicPrefab(type);
        if (!prefabData) {
            console.warn(`No prefab found for ${type}`);
            return false;
        }

        // displayWidth/displayDepth 우선 사용 (하수처리장, 취수장 등 회전된 건물)
        const modelConfig = PUBLIC_BUILDING_MODELS[type];
        const originalWidth = modelConfig?.displayWidth || prefabData.width || 2;
        const originalDepth = modelConfig?.displayDepth || prefabData.depth || 2;
        let width = originalWidth;
        let depth = originalDepth;

        // shortSideFacesRoad: 도로를 바라봤을 때 오른쪽 코너에 앵커 배치
        let shortSideRotation = 0;
        let anchorOffset = { x: width / 2, z: depth / 2 };  // 기본값: 중심
        let roadSide = 'bottom';  // 기본값: 도로가 아래쪽 (확장 방향 결정용)

        if (modelConfig?.shortSideFacesRoad && width !== depth) {
            const swappedRoad = detectRoadSideWithCount(gx, gy, depth, width);
            const originalRoad = detectRoadSideWithCount(gx, gy, width, depth);

            if (swappedRoad.side === 'vertical' && swappedRoad.hasRoad) {
                // 세로 도로 (좌/우) - footprint 90도 회전
                [width, depth] = [depth, width];

                if (swappedRoad.direction === 'left') {
                    // 도로가 왼쪽: 서쪽을 바라봄 (뒤로=+X, 왼쪽=-Z, 오른쪽=+Z)
                    anchorOffset = { x: 0 + 0.5, z: 0 - 0.5 + 1 };
                    shortSideRotation = Math.PI / 2;
                    roadSide = 'left';
                } else {
                    // 도로가 오른쪽: 동쪽을 바라봄 (뒤로=-X, 왼쪽=+Z, 오른쪽=-Z)
                    anchorOffset = { x: width - 0.5, z: depth + 0.5 - 1 };
                    shortSideRotation = -Math.PI / 2;
                    roadSide = 'right';
                }
            } else if (originalRoad.hasRoad) {
                // 가로 도로 (상/하) - footprint 유지, 180도 추가 회전
                if (originalRoad.direction === 'top') {
                    // 도로가 위쪽: 북쪽을 바라봄 (뒤로=+Z, 왼쪽=-X)
                    anchorOffset = { x: width - 0.5, z: 0 + 0.5 };
                    shortSideRotation = 0;  // 180 + 180 = 0
                    roadSide = 'top';
                } else {
                    // 도로가 아래쪽: 남쪽을 바라봄 (뒤로=-Z, 왼쪽=+X)
                    anchorOffset = { x: 0 + 0.5, z: depth - 0.5 };
                    shortSideRotation = Math.PI;  // 0 + 180
                    roadSide = 'bottom';
                }
            }
        }

        // 배치 가능 여부 확인 (도로, 수로, 공공시설은 거부, 민간건물은 철거)
        const civilBuildingsToRemove = [];

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const cx = gx + dx;
                const cy = gy + dy;
                if (cx < 0 || cx >= GRID_W || cy < 0 || cy >= GRID_H) {
                    toast({ title: '배치 불가', desc: '맵 경계를 벗어납니다.' });
                    return false;
                }
                const cell = grid[cx][cy];

                // 도로나 수로 위에는 배치 불가
                if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD ||
                    cell === CELL.ROAD_4LANE || cell === CELL.LOCKED_ROAD_4LANE ||
                    cell === CELL.WATER || cell === CELL.BRIDGE) {
                    toast({ title: '배치 불가', desc: '도로나 수로 위에는 건설할 수 없습니다.' });
                    return false;
                }

                // 이미 배치된 공공시설 확인 (참조 타일 포함)
                const key = `${cx},${cy}`;
                if (placedPublicBuildings.has(key)) {
                    toast({ title: '배치 불가', desc: '이미 공공시설이 있습니다.' });
                    return false;
                }

                // 확장 터빈/패널 위에는 건설 불가
                if (findExpansionTurbineAt(cx, cy)) {
                    toast({ title: '배치 불가', desc: '확장 터빈 위에는 건설할 수 없습니다.' });
                    return false;
                }
                if (findExpansionSolarAt(cx, cy)) {
                    toast({ title: '배치 불가', desc: '확장 패널 위에는 건설할 수 없습니다.' });
                    return false;
                }

                // 민간건물이 있으면 철거 목록에 추가
                const civilBuilding = typeof findBuildingAt === 'function' ? findBuildingAt(cx, cy) : null;
                if (civilBuilding && !civilBuildingsToRemove.includes(civilBuilding)) {
                    civilBuildingsToRemove.push(civilBuilding);
                }
            }
        }

        // 비용 확인 및 차감
        const cost = PUBLIC_BUILDING_MODELS[type]?.cost || 1000;
        if (!trySpend(cost, PUBLIC_BUILDING_MODELS[type]?.name || type)) {
            return false;
        }

        // 민간건물 철거
        for (const building of civilBuildingsToRemove) {
            if (typeof removeBuildingAt === 'function') {
                removeBuildingAt(building.x, building.y);
            }
        }

        // 나무 제거 (공공시설 영역 내)
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                removeTreeAt(gx + dx, gy + dy);
            }
        }

        // 구역 지정 삭제 (서비스 건물이 들어서는 타일)
        let zoneCleared = false;
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const cx = gx + dx;
                const cy = gy + dy;
                const cell = grid[cx][cy];
                if (cell === CELL.ZONE_RESIDENTIAL || cell === CELL.ZONE_COMMERCIAL || cell === CELL.ZONE_INDUSTRIAL) {
                    grid[cx][cy] = CELL.EMPTY;
                    zoneCleared = true;
                }
            }
        }
        // 구역이 삭제되었으면 시각적 업데이트
        if (zoneCleared) {
            rebuildZoneInstances(false);  // 건물 유지
        }

        // 건물이 차지하는 모든 타일에서 잔디 제거
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                removeGrassTileAt(gx + dx, gy + dy);
            }
        }

        // 플로팅 금액 표시
        if (clientX !== null && clientY !== null) {
            showFloatingCost(cost, clientX, clientY);
        }

        // 모델 인스턴스 생성
        const instance = prefabData.prefab.clone();

        // 클론된 인스턴스의 초기 회전 리셋 (나중에 다시 설정함)
        instance.rotation.set(0, 0, 0);

        // 머티리얼을 조명 반응형으로 강제 교체
        instance.traverse((child) => {
            if (child.isMesh && child.material) {
                const convertMaterial = (mat) => {
                    const newMat = new THREE.MeshLambertMaterial({
                        color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                        map: mat.map || null,
                        transparent: mat.transparent || false,
                        opacity: mat.opacity !== undefined ? mat.opacity : 1,
                        side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                    });
                    return newMat;
                };

                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => convertMaterial(m));
                } else {
                    child.material = convertMaterial(child.material);
                }
            }
        });

        // 위치 계산
        const worldX = ORIGIN_X + gx + anchorOffset.x;
        const worldZ = ORIGIN_Z + gy + anchorOffset.z;
        const targetY = -(prefabData.minY || 0);

        // 모델 오프셋 적용 (방파제 인접 시설 등)
        const modelOffsetX = modelConfig?.modelOffsetX || 0;
        const modelOffsetZ = modelConfig?.modelOffsetZ || 0;

        // 센터 오프셋 (앵커 배치일 때는 적용하지 않음)
        const useAnchor = modelConfig?.shortSideFacesRoad && originalWidth !== originalDepth;
        const centerOffsetX = useAnchor ? 0 : (prefabData.centerOffsetX || 0);
        const centerOffsetZ = useAnchor ? 0 : (prefabData.centerOffsetZ || 0);

        instance.position.set(
            worldX - centerOffsetX + modelOffsetX,
            targetY,
            worldZ - centerOffsetZ + modelOffsetZ
        );

        // 회전 적용
        if (modelConfig?.shortSideFacesRoad) {
            // shortSideFacesRoad: 모델 기본 회전 + 도로 방향 회전
            const baseRotation = modelConfig?.rotationY || 0;
            instance.rotation.y = baseRotation + shortSideRotation;
        } else if (modelConfig?.requiresBreakwater) {
            // 방파제 인접 시설: 기본 회전만 적용
            instance.rotation.y = modelConfig?.rotationY || 0;
        } else {
            const roadDirection = findNearestRoadDirection(gx, gy, width, depth);
            instance.rotation.y += roadDirection;
        }

        // 그림자 설정
        instance.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        // 공공시설 userData 설정 (클릭 감지용)
        instance.userData = {
            isPublicBuilding: true,
            publicBuildingType: type,
            tileX: gx,
            tileY: gy,
            width: width,
            depth: depth,
            name: PUBLIC_BUILDING_MODELS[type]?.name || type
        };

        // 씬에 추가
        buildingGroup.add(instance);

        // 구역 모드 중 추가된 건물은 원래 머티리얼 저장 후 회색으로 변경
        if (isZoneModeActive) {
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialBuilding.clone();
                }
            });
        }

        // 낙하 이펙트 + 카메라 흔들림
        animateBuildingDrop(instance, targetY, () => {
            shakeCamera(0.12, 250);
        });

        // 차지하는 타일들
        const tiles = [];
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                tiles.push(`${gx + dx},${gy + dy}`);
            }
        }

        // 추적 정보 저장 (코너 앵커 정보 포함)
        const primaryKey = `${gx},${gy}`;
        placedPublicBuildings.set(primaryKey, {
            type, instance, tiles: new Set(tiles), x: gx, y: gy, width, depth,
            shortSideRotation, roadSide,
            expansions: 0,  // 확장 터빈 수 (풍력발전기용)
            expansionInstances: []  // 확장 터빈 3D 인스턴스들
        });

        // 참조 키 추가
        for (const tileKey of tiles) {
            if (tileKey !== primaryKey) {
                placedPublicBuildings.set(tileKey, { ref: primaryKey });
            }
        }

        markDirty();
        toast({ title: '건설 완료', desc: `${PUBLIC_BUILDING_MODELS[type]?.name || type} 설치됨`, success: true });

        // 예산 업데이트
        updateBudgetDisplay();

        // 서비스 효과 물결 이모지 표시 (이로운 시설 = 스마일)
        const config = PUBLIC_BUILDING_MODELS[type];
        if (config && config.effectRadius) {
            const centerX = gx + width / 2;
            const centerY = gy + depth / 2;
            // 모든 공공시설은 이로운 효과 (isPositive = true)
            // 나쁜 효과 시설이 있으면 isNegativeEffect 속성 확인
            const isPositive = !config.isNegativeEffect;
            setTimeout(() => {
                showServiceEffectRipple(centerX, centerY, config.effectRadius, isPositive);
            }, 400);  // 건물 낙하 후 표시
        }

        // 소방서 설치 시 기존 화재에 소방차 출동
        if (type === 'fire') {
            setTimeout(() => {
                dispatchFiretrucksToExistingFires();
            }, 500);  // 건물 설치 완료 후
        }

        // 경찰서 설치 시 기존 사건에 경찰차 출동
        if (type === 'police') {
            setTimeout(() => {
                dispatchPoliceToExistingCrimes();
            }, 500);  // 건물 설치 완료 후
        }

        // 병원 설치 시 기존 응급환자에 구급차 출동
        if (type === 'hospital') {
            setTimeout(() => {
                dispatchAmbulanceToExistingEmergencies();
            }, 500);  // 건물 설치 완료 후
        }

        // 발전소 설치 시 전력망에 등록
        if (config && config.isPowerPlant) {
            powerManager.addPowerPlant(gx, gy, type, config);
        }

        // 풍력 발전소 터빈 애니메이션 재생
        if (type === 'powerplant_wind') {
            // GLB 내장 애니메이션이 있으면 재생
            if (prefabData.animations && prefabData.animations.length > 0) {
                const mixer = new THREE.AnimationMixer(instance);
                prefabData.animations.forEach(clip => {
                    const action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat, Infinity);
                    action.play();
                });
                // 믹서 등록 (렌더 루프에서 업데이트)
                activeAnimationMixers.push({
                    mixer: mixer,
                    instance: instance,
                    key: primaryKey
                });
                console.log(`Wind turbine animation started for ${primaryKey}`);
            }

            // 프로펠러(Helice_Eolienne) 수동 회전 등록
            let propeller = null;
            instance.traverse((child) => {
                if (child.name === 'Helice_Eolienne') {
                    propeller = child;
                }
            });
            if (propeller) {
                // 랜덤 시작 회전값 설정
                propeller.rotation.x = Math.random() * Math.PI * 2;
                windTurbinePropellers.push({
                    propeller: propeller,
                    key: primaryKey,
                    speed: 1.33  // 회전 속도 (라디안/초) - 2.0의 2/3
                });
                console.log(`Wind turbine propeller registered for ${primaryKey}`);
            }
        }

        // 서비스 건물 설치 시 서비스 범위 등록
        if (!config?.isPowerPlant) {
            // 일반 건물은 전력망 재계산 (소비량 변경)
            if (powerManager.initialized) {
                powerManager.recalculatePowerGrid();
            }
        }

        // 수도시설 설치 시 수도망에 등록
        if (config && config.isWaterFacility) {
            waterManager.addWaterFacility(gx, gy, type, config);
        } else {
            // 일반 건물은 수도망 재계산 (소비량 변경)
            if (waterManager.initialized) {
                waterManager.recalculateWaterGrid();
            }
        }

        // 하수시설 설치 시 하수망에 등록
        if (config && config.isSewageFacility) {
            sewageManager.addSewageFacility(gx, gy, type, config);
            // 바다 방류 시스템에 방류 지점 추가
            if (oceanSewageSystem.initialized) {
                const facilityData = {
                    x: gx,
                    y: gy,
                    width: config.displayWidth || 2,
                    depth: config.displayDepth || 4,
                    capacity: config.sewageCapacity || 500
                };
                oceanSewageSystem.addDischargePoint(gx, gy, facilityData);
            }
        } else {
            // 일반 건물은 하수망 재계산 (사용량 변경)
            if (sewageManager.initialized) {
                sewageManager.recalculateSewageGrid();
            }
        }

        // 설치 후 색상 효과 재적용
        if (isPlacementModeActive) {
            // 새 건물에 색상 적용
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    placementOriginalMaterials.set(child.uuid, child.material.clone());
                    if (type === currentPlacementType) {
                        child.material = greenMaterialPlacement.clone();
                    } else {
                        child.material = grayMaterialPlacement.clone();
                    }
                }
            });
        }

        // 전력 뷰 모드일 때 새 건물에 회색 머티리얼 적용 및 원본 저장
        if (powerManager && powerManager.isPowerViewActive) {
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    // 원본 머티리얼 저장 (복원용)
                    powerManager.powerViewOriginalMaterials.set(child.uuid, child.material);
                    // 회색 적용
                    child.material = grayMat.clone();
                }
            });
        }

        // 수도 뷰 모드일 때 새 건물에 회색 머티리얼 적용 및 원본 저장
        if (waterManager && waterManager.isWaterViewActive) {
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    // 원본 머티리얼 저장 (복원용)
                    waterManager.waterViewOriginalMaterials.set(child.uuid, child.material);
                    // 회색 적용
                    child.material = grayMat.clone();
                }
            });
        }

        // SNS 피드에 건물 건설 알림
        if (typeof CitizenSNS !== 'undefined') {
            const snsEventMap = {
                'fire': 'fireStationBuilt',
                'fire_small': 'fireStationBuilt',
                'police': 'policeHelp',
                'police_small': 'policeHelp',
                'hospital': 'hospitalBuilt',
                'school': 'schoolBuilt',
                'school_small': 'schoolBuilt',
                'park': 'parkBuilt',
                'park_small': 'parkBuilt'
            };
            const snsEvent = snsEventMap[type];
            if (snsEvent) {
                CitizenSNS.onEvent(snsEvent, `(${gx}, ${gy}) 근처`);
            }
        }

        return true;
    }

    // 공공시설 찾기
    function findPublicBuildingAt(gx, gy) {
        const key = `${gx},${gy}`;
        const entry = placedPublicBuildings.get(key);
        if (!entry) return null;
        if (entry.ref) {
            return placedPublicBuildings.get(entry.ref);
        }
        return entry;
    }

    // 공공시설 삭제 (철거 애니메이션 포함)
    const demolishingPublicBuildings = new Set();

    function removePublicBuilding(gx, gy) {
        const building = findPublicBuildingAt(gx, gy);
        if (!building || building.ref) return false;

        // 이미 철거 중이면 무시
        const buildingKey = `${building.x},${building.y}`;
        if (demolishingPublicBuildings.has(buildingKey)) return false;
        demolishingPublicBuildings.add(buildingKey);

        // 선택된 건물이면 팝업과 아웃라인 제거
        if (selectedBuilding === building.instance) {
            hideBuildingPopup();
            clearBuildingOutline();
            selectedBuilding = null;
        }
        // 철거 하이라이트 제거
        if (building.instance && demolishHighlightedObject === building.instance) {
            clearDemolishHighlight();
        }

        // 모든 상태 아이콘 제거 (통합 시스템)
        clearAllBuildingStatuses(building.x, building.y);

        // 서비스 효과 물결 이모지 표시 (철거 시 반대 효과)
        const config = PUBLIC_BUILDING_MODELS[building.type];
        if (config && config.effectRadius) {
            const centerX = building.x + (building.width || 2) / 2;
            const centerY = building.y + (building.depth || 2) / 2;
            // 이로운 시설 철거 = 슬픔, 나쁜 시설 철거 = 기쁨
            const isPositive = config.isNegativeEffect === true;
            showServiceEffectRipple(centerX, centerY, config.effectRadius, isPositive);
        }

        // 발전소 제거 시 전력망에서 등록 해제
        if (config && config.isPowerPlant) {
            powerManager.removePowerPlant(building.x, building.y);
        } else if (powerManager.initialized) {
            // 일반 건물 제거 시 전력망 재계산
            powerManager.recalculatePowerGrid();
        }

        // 풍력 발전소 애니메이션 믹서 정리
        if (building.type === 'powerplant_wind') {
            const mixerIndex = activeAnimationMixers.findIndex(m => m.key === buildingKey);
            if (mixerIndex !== -1) {
                const mixerData = activeAnimationMixers[mixerIndex];
                if (mixerData.mixer) {
                    mixerData.mixer.stopAllAction();
                }
                activeAnimationMixers.splice(mixerIndex, 1);
                console.log(`Wind turbine animation stopped for ${buildingKey}`);
            }

            // 프로펠러 수동 회전 배열에서 제거
            const propellerIndex = windTurbinePropellers.findIndex(p => p.key === buildingKey);
            if (propellerIndex !== -1) {
                windTurbinePropellers.splice(propellerIndex, 1);
                console.log(`Wind turbine propeller removed for ${buildingKey}`);
            }

            // 확장 터빈들도 함께 철거 (철거 이펙트 적용)
            if (building.expansionInstances && building.expansionInstances.length > 0) {
                building.expansionInstances.forEach((exp, idx) => {
                    // 확장 터빈 프로펠러 제거
                    const expPropellerKey = `${building.x},${building.y}_exp${idx + 1}`;
                    const expPropIdx = windTurbinePropellers.findIndex(p => p.key === expPropellerKey);
                    if (expPropIdx !== -1) {
                        windTurbinePropellers.splice(expPropIdx, 1);
                    }
                    // 철거 이펙트 적용 후 제거
                    if (exp.instance) {
                        animateExpansionDemolish(exp, idx * 100);
                    } else {
                        // 잔디 타일 복구
                        for (let dx = 0; dx < (exp.width || 3); dx++) {
                            for (let dy = 0; dy < (exp.depth || 1); dy++) {
                                addGrassTileAt(exp.x + dx, exp.y + dy);
                            }
                        }
                    }
                });
                building.expansionInstances = [];
                console.log(`Wind turbine expansions removed for ${buildingKey}`);
            }
        }

        // 태양광 발전소 확장 패널들 함께 철거
        if (building.type === 'powerplant_solar') {
            if (building.expansionInstances && building.expansionInstances.length > 0) {
                building.expansionInstances.forEach((exp, idx) => {
                    // 철거 이펙트 적용 후 제거
                    if (exp.instance) {
                        animateExpansionDemolish(exp, idx * 100);
                    } else {
                        // 잔디 타일 복구
                        for (let dx = 0; dx < (exp.width || 3); dx++) {
                            for (let dy = 0; dy < (exp.depth || 1); dy++) {
                                addGrassTileAt(exp.x + dx, exp.y + dy);
                            }
                        }
                    }
                });
                building.expansionInstances = [];
                console.log(`Solar panel expansions removed for ${buildingKey}`);
            }
        }

        // 수도시설 제거 시 수도망에서 등록 해제
        if (config && config.isWaterFacility) {
            waterManager.removeWaterFacility(building.x, building.y);
        } else if (waterManager.initialized) {
            // 일반 건물 제거 시 수도망 재계산
            waterManager.recalculateWaterGrid();
        }

        // 추적에서 먼저 제거 (재배치 방지)
        const primaryKey = `${building.x},${building.y}`;
        for (const tileKey of building.tiles) {
            placedPublicBuildings.delete(tileKey);
        }
        placedPublicBuildings.delete(primaryKey);

        // 철거 애니메이션 실행
        if (building.instance) {
            animateDemolish(building, () => {
                // 애니메이션 완료 후 씬에서 제거 및 메모리 해제
                buildingGroup.remove(building.instance);
                disposeObject3D(building.instance);

                // 잔디 타일 복구 (시각적)
                const width = building.width || 2;
                const depth = building.depth || 2;
                for (let dx = 0; dx < width; dx++) {
                    for (let dy = 0; dy < depth; dy++) {
                        addGrassTileAt(building.x + dx, building.y + dy);
                    }
                }

                // 철거 완료
                demolishingPublicBuildings.delete(buildingKey);

                // 교통 시스템에 건물 변경 알림
                if (trafficManager.initialized) {
                    trafficManager.onBuildingChange();
                }
            });
        } else {
            demolishingPublicBuildings.delete(buildingKey);
        }

        markDirty();

        // 예산 업데이트
        updateBudgetDisplay();

        return true;
    }

    // 확장 터빈 찾기 (좌표로)
    function findExpansionTurbineAt(gx, gy) {
        for (const [key, building] of placedPublicBuildings) {
            if (building.ref || building.type !== 'powerplant_wind') continue;
            if (!building.expansionInstances || building.expansionInstances.length === 0) continue;

            for (let i = 0; i < building.expansionInstances.length; i++) {
                const exp = building.expansionInstances[i];
                const expWidth = exp.width || 3;
                const expDepth = exp.depth || 1;

                // 확장 터빈 영역 내에 있는지 확인
                if (gx >= exp.x && gx < exp.x + expWidth &&
                    gy >= exp.y && gy < exp.y + expDepth) {
                    return { building, expansionIndex: i, expansion: exp };
                }
            }
        }
        return null;
    }

    // 확장 터빈 개별 삭제
    function removeExpansionTurbine(gx, gy) {
        const found = findExpansionTurbineAt(gx, gy);
        if (!found) return false;

        const { building, expansionIndex, expansion } = found;
        const buildingKey = `${building.x},${building.y}`;

        // 선택된 확장 터빈이면 아웃라인 제거
        if (expansion.instance && demolishHighlightedObject === expansion.instance) {
            clearDemolishHighlight();
        }
        if (selectedBuilding === expansion.instance) {
            hideBuildingPopup();
            clearBuildingOutline();
            selectedBuilding = null;
        }

        // 씬에서 제거
        if (expansion.instance) {
            scene.remove(expansion.instance);
            disposeObject3D(expansion.instance);
        }

        // 프로펠러 배열에서 제거
        const expPropellerKey = `${building.x},${building.y}_exp${expansionIndex + 1}`;
        const expPropIdx = windTurbinePropellers.findIndex(p => p.key === expPropellerKey);
        if (expPropIdx !== -1) {
            windTurbinePropellers.splice(expPropIdx, 1);
        }

        // 잔디 타일 복구
        for (let dx = 0; dx < (expansion.width || 3); dx++) {
            for (let dy = 0; dy < (expansion.depth || 1); dy++) {
                addGrassTileAt(expansion.x + dx, expansion.y + dy);
                // tiles에서도 제거
                const tileKey = `${expansion.x + dx},${expansion.y + dy}`;
                if (building.tiles instanceof Set) {
                    building.tiles.delete(tileKey);
                } else if (Array.isArray(building.tiles)) {
                    const idx = building.tiles.indexOf(tileKey);
                    if (idx !== -1) building.tiles.splice(idx, 1);
                }
            }
        }

        // 배열에서 제거
        building.expansionInstances.splice(expansionIndex, 1);
        building.expansions = building.expansionInstances.length;

        // 전력망 업데이트 (풍량에 비례한 전력 계산)
        if (powerManager && powerManager.initialized) {
            const config = PUBLIC_BUILDING_MODELS['powerplant_wind'];
            const { actualPower } = calculateWindTurbinePower(
                building.x, building.y,
                config.powerOutput,
                building.expansions,
                config.expansionPowerOutput
            );
            powerManager.updatePowerPlantOutput(building.x, building.y, actualPower);
            powerManager.recalculatePowerGrid();
        }

        // UI 업데이트
        updateWindTurbineExpansionStatus(building.x, building.y);

        markDirty();
        toast({ title: '철거 완료', desc: '확장 터빈이 철거되었습니다' });
        console.log(`Expansion turbine ${expansionIndex + 1} removed for ${buildingKey}`);

        return true;
    }

    // 태양광 확장 패널 찾기 (좌표로)
    function findExpansionSolarAt(gx, gy) {
        for (const [key, building] of placedPublicBuildings) {
            if (building.ref || building.type !== 'powerplant_solar') continue;
            if (!building.expansionInstances || building.expansionInstances.length === 0) continue;

            for (let i = 0; i < building.expansionInstances.length; i++) {
                const exp = building.expansionInstances[i];
                const expWidth = exp.width || 3;
                const expDepth = exp.depth || 1;

                // 확장 패널 영역 내에 있는지 확인
                if (gx >= exp.x && gx < exp.x + expWidth &&
                    gy >= exp.y && gy < exp.y + expDepth) {
                    return { building, expansionIndex: i, expansion: exp };
                }
            }
        }
        return null;
    }

    // 태양광 확장 패널 개별 삭제
    function removeExpansionSolar(gx, gy) {
        const found = findExpansionSolarAt(gx, gy);
        if (!found) return false;

        const { building, expansionIndex, expansion } = found;
        const buildingKey = `${building.x},${building.y}`;

        // 선택된 확장 패널이면 아웃라인 제거
        if (expansion.instance && demolishHighlightedObject === expansion.instance) {
            clearDemolishHighlight();
        }
        if (selectedBuilding === expansion.instance) {
            hideBuildingPopup();
            clearBuildingOutline();
            selectedBuilding = null;
        }

        // 철거 이펙트 적용 후 제거
        if (expansion.instance) {
            animateExpansionDemolish(expansion, 0);
        } else {
            // 잔디 타일 복구
            for (let dx = 0; dx < (expansion.width || 3); dx++) {
                for (let dy = 0; dy < (expansion.depth || 1); dy++) {
                    addGrassTileAt(expansion.x + dx, expansion.y + dy);
                }
            }
        }

        // tiles에서 제거
        for (let dx = 0; dx < (expansion.width || 3); dx++) {
            for (let dy = 0; dy < (expansion.depth || 1); dy++) {
                const tileKey = `${expansion.x + dx},${expansion.y + dy}`;
                if (building.tiles instanceof Set) {
                    building.tiles.delete(tileKey);
                } else if (Array.isArray(building.tiles)) {
                    const idx = building.tiles.indexOf(tileKey);
                    if (idx !== -1) building.tiles.splice(idx, 1);
                }
            }
        }

        // 배열에서 제거
        building.expansionInstances.splice(expansionIndex, 1);
        building.expansions = building.expansionInstances.length;

        // 전력망 업데이트
        if (powerManager && powerManager.initialized) {
            const config = PUBLIC_BUILDING_MODELS['powerplant_solar'];
            const totalPower = config.powerOutput + (building.expansions * config.expansionPowerOutput);
            powerManager.updatePowerPlantOutput(building.x, building.y, totalPower);
            powerManager.recalculatePowerGrid();
        }

        // UI 업데이트
        updateSolarPanelExpansionStatus(building.x, building.y);

        markDirty();
        toast({ title: '철거 완료', desc: '확장 패널이 철거되었습니다' });
        console.log(`Expansion solar panel ${expansionIndex + 1} removed for ${buildingKey}`);

        return true;
    }

    /* =========================================================
     * 방파제 시스템 (BREAKWATER)
     * ========================================================= */
    const breakwaterGroup = new THREE.Group();
    scene.add(breakwaterGroup);

    // 타일이 육지인지 확인 (바다/해변/수로/방파제가 아닌 것)
    function isLandTile(cell) {
        return cell !== CELL.OCEAN && cell !== CELL.BEACH &&
               cell !== CELL.WATER && cell !== CELL.BREAKWATER &&
               cell !== undefined;
    }

    // 바다 타일이 육지와 인접한지 확인
    function isOceanAdjacentToLand(x, y) {
        const dirs = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
        for (const dir of dirs) {
            const dx = dir.dx, dy = dir.dy;
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                if (isLandTile(grid[nx][ny])) {
                    return true;
                }
            }
        }
        return false;
    }

    // 타일이 방파제와 인접한지 확인
    function isAdjacentToBreakwater(x, y) {
        const dirs = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
        for (const dir of dirs) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                if (grid[nx][ny] === CELL.BREAKWATER) {
                    return true;
                }
            }
        }
        return false;
    }

    // 방파제 좌표를 2x2 격자로 스냅
    function snapToBreakwaterGrid(x, y) {
        return {
            x: Math.floor(x / 2) * 2,
            y: Math.floor(y / 2) * 2
        };
    }

    // 방파제 설치 가능 여부 확인 (2x2 격자에만 설치 가능, 해변 포함 필수)
    function canPlaceBreakwater(gx, gy) {
        // 2x2 격자 스냅 확인 (짝수 좌표만 허용)
        if (gx % 2 !== 0 || gy % 2 !== 0) {
            return false;
        }

        let hasBeach = false;

        // 2x2 영역 체크
        for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
                const x = gx + dx;
                const y = gy + dy;

                if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) {
                    return false;
                }

                const cell = grid[x][y];

                // 해변 또는 바다만 허용
                if (cell !== CELL.BEACH && cell !== CELL.OCEAN) {
                    return false;
                }

                // 해변 타일이 포함되어 있는지 확인
                if (cell === CELL.BEACH) {
                    hasBeach = true;
                }
            }
        }

        // 최소 1개의 해변 타일이 포함되어야 함
        return hasBeach;
    }

    // 방파제 배치 (silent: 토스트 메시지 숨김 - 드래그 설치용)
    function placeBreakwater(gx, gy, silent = false) {
        if (!canPlaceBreakwater(gx, gy)) {
            if (!silent) {
                toast({
                    title: '설치 불가',
                    desc: '방파제는 해변가 위에만 설치할 수 있습니다.'
                });
            }
            return false;
        }

        // 2x2 영역을 방파제로 설정
        for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
                const x = gx + dx;
                const y = gy + dy;

                // 기존 바다/해변 타일 제거
                removeOceanTileAt(x, y);
                removeBeachTileAt(x, y);

                // 그리드 업데이트
                grid[x][y] = CELL.BREAKWATER;
            }
        }

        // 방파제 3D 모델 생성
        createBreakwaterModel(gx, gy);

        markDirty();

        return true;
    }

    // 방파제 GLB 모델 캐시
    const BREAKWATER_HEIGHT_OFFSET = -0.15;  // 방파제 높이 오프셋 (낮추기)
    let breakwaterPrefab = null;

    // 방파제 모델 로드 (road_tile_river_2x2_008.glb)
    loader.load('/models/road_tile_river_2x2_008.glb', (gltf) => {
        const prefab = gltf.scene;
        prefab.scale.set(1, 1, 1);
        prefab.updateMatrixWorld(true);

        prefab.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;

                // 바다 타일과 동일한 MeshLambertMaterial로 변환 (일관된 조명 반응)
                const convertMaterial = (mat) => {
                    return new THREE.MeshLambertMaterial({
                        color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                        map: mat.map || null,
                        transparent: mat.transparent || false,
                        opacity: mat.opacity !== undefined ? mat.opacity : 1,
                        side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                    });
                };

                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => convertMaterial(m));
                } else {
                    child.material = convertMaterial(child.material);
                }
            }
        });

        // 2x2 타일에 맞게 스케일
        const box0 = new THREE.Box3().setFromObject(prefab);
        const size0 = new THREE.Vector3();
        box0.getSize(size0);
        const targetSize = TILE_SIZE * 2;
        const s = targetSize / Math.max(size0.x, size0.z);
        prefab.scale.setScalar(s);
        prefab.updateMatrixWorld(true);

        breakwaterPrefab = prefab;
        console.log('방파제 모델(road_tile_river_2x2_008.glb) 로드 완료');

        // 모델 로드 후 기존 폴백 박스 재구성
        rebuildBreakwaters();
    }, undefined, (error) => {
        console.error('방파제 모델 로드 실패:', error);
    });

    // 방파제 프리팹 반환
    function getBreakwaterPrefab() {
        return breakwaterPrefab;
    }

    // 방파제 3D 모델 생성
    function createBreakwaterModel(gx, gy) {
        const breakwaterPrefab = getBreakwaterPrefab();
        if (breakwaterPrefab) {
            // 그룹으로 감싸서 중심 회전 적용
            const group = new THREE.Group();

            // GLB 모델 복제
            const model = breakwaterPrefab.clone();
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // 모델 중심점 계산
            const box = new THREE.Box3().setFromObject(model);
            const center = new THREE.Vector3();
            box.getCenter(center);

            // 모델을 센터 오프셋만큼 이동 (그룹 원점이 모델 중심이 되도록)
            model.position.set(-center.x, -box.min.y, -center.z);

            group.add(model);

            // 그룹을 90도 회전 (모델 중심 기준)
            group.rotation.y = -Math.PI / 2;

            // 2x2 타일 중앙 위치로 그룹 이동
            const worldX = (ORIGIN_X + gx + 1) * TILE_SIZE;
            const worldZ = (ORIGIN_Z + gy + 1) * TILE_SIZE;
            group.position.set(worldX, BREAKWATER_HEIGHT_OFFSET, worldZ);

            group.userData.gridX = gx;
            group.userData.gridY = gy;
            group.userData.type = 'breakwater';

            breakwaterGroup.add(group);
            return group;
        } else {
            // 폴백: 모델 로드 전 간단한 박스
            console.warn('방파제 모델 없음, 폴백 박스 사용');
            const group = new THREE.Group();
            const fallbackGeometry = new THREE.BoxGeometry(2, 0.3, 2);
            const fallbackMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.9
            });
            const fallback = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
            fallback.position.y = 0.15;
            group.add(fallback);

            const worldX = (ORIGIN_X + gx + 1) * TILE_SIZE;
            const worldZ = (ORIGIN_Z + gy + 1) * TILE_SIZE;
            group.position.set(worldX, BREAKWATER_HEIGHT_OFFSET, worldZ);

            group.userData.gridX = gx;
            group.userData.gridY = gy;
            group.userData.type = 'breakwater';

            breakwaterGroup.add(group);
            return group;
        }
    }

    // 특정 위치의 방파제 제거
    function removeBreakwaterAt(gx, gy) {
        // 2x2 원점 찾기
        let originX = gx, originY = gy;

        // 방파제의 원점 찾기 (그룹에서 검색)
        for (let i = breakwaterGroup.children.length - 1; i >= 0; i--) {
            const bw = breakwaterGroup.children[i];
            const bwX = bw.userData.gridX;
            const bwY = bw.userData.gridY;

            // 클릭한 위치가 이 방파제의 2x2 영역 내에 있는지 확인
            if (gx >= bwX && gx < bwX + 2 && gy >= bwY && gy < bwY + 2) {
                originX = bwX;
                originY = bwY;

                // 3D 모델 제거
                breakwaterGroup.remove(bw);
                disposeObject3D(bw);

                // 그리드를 원본 해안선에 따라 복원
                for (let dx = 0; dx < 2; dx++) {
                    for (let dy = 0; dy < 2; dy++) {
                        const x = originX + dx;
                        const y = originY + dy;
                        const key = `${x},${y}`;

                        // 원본 해안선 위치면 해변, 아니면 바다로 복원
                        if (originalCoastline.has(key)) {
                            grid[x][y] = CELL.BEACH;
                            removeOceanTileAt(x, y);
                            addBeachTileAt(x, y);
                        } else {
                            grid[x][y] = CELL.OCEAN;
                            removeBeachTileAt(x, y);
                            addOceanTileAt(x, y);
                        }
                    }
                }

                markDirty();
                return true;
            }
        }

        return false;
    }

    // 저장된 방파제 복원
    function restoreBreakwater(gx, gy) {
        createBreakwaterModel(gx, gy);
    }

    // 방파제 타일 재구성 (로드 시)
    function rebuildBreakwaters() {
        // 기존 방파제 모델 모두 제거
        while (breakwaterGroup.children.length > 0) {
            const child = breakwaterGroup.children[0];
            breakwaterGroup.remove(child);
            disposeObject3D(child);
        }

        // 그리드에서 방파제 원점 찾기 (좌상단 기준)
        const processed = new Set();

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (grid[x][y] === CELL.BREAKWATER && !processed.has(`${x},${y}`)) {
                    // 이 위치가 2x2의 원점인지 확인 (좌상단)
                    // 간단히: x, y가 방파제이고, x+1,y / x,y+1 / x+1,y+1 도 방파제면 원점
                    if (x + 1 < GRID_W && y + 1 < GRID_H &&
                        grid[x + 1][y] === CELL.BREAKWATER &&
                        grid[x][y + 1] === CELL.BREAKWATER &&
                        grid[x + 1][y + 1] === CELL.BREAKWATER) {

                        createBreakwaterModel(x, y);

                        // 처리됨 표시
                        processed.add(`${x},${y}`);
                        processed.add(`${x + 1},${y}`);
                        processed.add(`${x},${y + 1}`);
                        processed.add(`${x + 1},${y + 1}`);
                    }
                }
            }
        }
    }

    // 저장된 공공시설 복원 (로드 시 사용 - 비용 없음, 애니메이션 없음)
    function restorePublicBuilding(gx, gy, type, savedRotation = null, savedWidth = null, savedDepth = null, savedRoadDirection = null) {
        const prefabData = getRandomPublicPrefab(type);
        if (!prefabData) {
            return false;
        }

        // displayWidth/displayDepth 우선 사용 (하수처리장, 취수장 등 회전된 건물)
        const modelConfig = PUBLIC_BUILDING_MODELS[type];
        const originalWidth = modelConfig?.displayWidth || prefabData.width || 2;
        const originalDepth = modelConfig?.displayDepth || prefabData.depth || 2;
        let width = savedWidth || originalWidth;
        let depth = savedDepth || originalDepth;

        // shortSideFacesRoad: 도로를 바라봤을 때 오른쪽 코너에 앵커 배치
        let shortSideRotation = 0;
        let anchorOffset = { x: width / 2, z: depth / 2 };  // 기본값: 중심
        let roadSide = savedRoadDirection || 'bottom';  // 저장된 값 사용 또는 기본값

        if (modelConfig?.shortSideFacesRoad && originalWidth !== originalDepth) {
            if (savedRoadDirection) {
                // 복원 시: 저장된 roadSide에 따라 shortSideRotation과 anchorOffset 재계산
                // 주의: savedWidth/savedDepth가 있으면 이미 스왑된 값이므로 스왑하지 않음
                switch (savedRoadDirection) {
                    case 'left':
                        // 세로 도로 (좌) - footprint 90도 회전
                        // savedWidth/savedDepth가 없을 때만 스왑
                        if (!savedWidth || !savedDepth) {
                            [width, depth] = [depth, width];
                        }
                        anchorOffset = { x: 0 + 0.5, z: 0 - 0.5 + 1 };
                        shortSideRotation = Math.PI / 2;
                        break;
                    case 'right':
                        // 세로 도로 (우) - footprint 90도 회전
                        if (!savedWidth || !savedDepth) {
                            [width, depth] = [depth, width];
                        }
                        anchorOffset = { x: width - 0.5, z: depth + 0.5 - 1 };
                        shortSideRotation = -Math.PI / 2;
                        break;
                    case 'top':
                        // 가로 도로 (상) - footprint 유지
                        anchorOffset = { x: width - 0.5, z: 0 + 0.5 };
                        shortSideRotation = 0;
                        break;
                    case 'bottom':
                    default:
                        // 가로 도로 (하) - footprint 유지
                        anchorOffset = { x: 0 + 0.5, z: depth - 0.5 };
                        shortSideRotation = Math.PI;
                        break;
                }
            } else {
                // 새 배치 시: 도로 방향 감지
                const swappedRoad = detectRoadSideWithCount(gx, gy, depth, width);
                const originalRoad = detectRoadSideWithCount(gx, gy, width, depth);

                if (swappedRoad.side === 'vertical' && swappedRoad.hasRoad) {
                    // 세로 도로 (좌/우) - footprint 90도 회전
                    [width, depth] = [depth, width];

                    if (swappedRoad.direction === 'left') {
                        // 도로가 왼쪽: 서쪽을 바라봄 (뒤로=+X, 왼쪽=-Z, 오른쪽=+Z)
                        anchorOffset = { x: 0 + 0.5, z: 0 - 0.5 + 1 };
                        shortSideRotation = Math.PI / 2;
                        roadSide = 'left';
                    } else {
                        // 도로가 오른쪽: 동쪽을 바라봄 (뒤로=-X, 왼쪽=+Z, 오른쪽=-Z)
                        anchorOffset = { x: width - 0.5, z: depth + 0.5 - 1 };
                        shortSideRotation = -Math.PI / 2;
                        roadSide = 'right';
                    }
                } else if (originalRoad.hasRoad) {
                    // 가로 도로 (상/하) - footprint 유지, 180도 추가 회전
                    if (originalRoad.direction === 'top') {
                        // 도로가 위쪽: 북쪽을 바라봄 (뒤로=+Z, 왼쪽=-X)
                        anchorOffset = { x: width - 0.5, z: 0 + 0.5 };
                        shortSideRotation = 0;  // 180 + 180 = 0
                        roadSide = 'top';
                    } else {
                        // 도로가 아래쪽: 남쪽을 바라봄 (뒤로=-Z, 왼쪽=+X)
                        anchorOffset = { x: 0 + 0.5, z: depth - 0.5 };
                        shortSideRotation = Math.PI;  // 0 + 180
                        roadSide = 'bottom';
                    }
                }
            }
        }

        // 이미 배치된 공공시설 확인
        const primaryKey = `${gx},${gy}`;
        if (placedPublicBuildings.has(primaryKey)) {
            return false;
        }

        // 건물이 차지하는 모든 타일에서 잔디 제거
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                removeGrassTileAt(gx + dx, gy + dy);
            }
        }

        // 모델 인스턴스 생성
        const instance = prefabData.prefab.clone();

        // 클론된 인스턴스의 초기 회전 리셋 (나중에 다시 설정함)
        instance.rotation.set(0, 0, 0);

        // 머티리얼을 조명 반응형으로 강제 교체
        instance.traverse((child) => {
            if (child.isMesh && child.material) {
                const convertMaterial = (mat) => {
                    const newMat = new THREE.MeshLambertMaterial({
                        color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                        map: mat.map || null,
                        transparent: mat.transparent || false,
                        opacity: mat.opacity !== undefined ? mat.opacity : 1,
                        side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                    });
                    return newMat;
                };

                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => convertMaterial(m));
                } else {
                    child.material = convertMaterial(child.material);
                }
            }
        });

        // 위치 계산
        const worldX = ORIGIN_X + gx + anchorOffset.x;
        const worldZ = ORIGIN_Z + gy + anchorOffset.z;
        const targetY = -(prefabData.minY || 0);

        // 모델 오프셋 적용 (방파제 인접 시설 등)
        const modelOffsetX = modelConfig?.modelOffsetX || 0;
        const modelOffsetZ = modelConfig?.modelOffsetZ || 0;

        // 센터 오프셋 (앵커 배치일 때는 적용하지 않음)
        const useAnchor = modelConfig?.shortSideFacesRoad && originalWidth !== originalDepth;
        const centerOffsetX = useAnchor ? 0 : (prefabData.centerOffsetX || 0);
        const centerOffsetZ = useAnchor ? 0 : (prefabData.centerOffsetZ || 0);

        instance.position.set(
            worldX - centerOffsetX + modelOffsetX,
            targetY,
            worldZ - centerOffsetZ + modelOffsetZ
        );

        // 회전 적용
        if (modelConfig?.shortSideFacesRoad) {
            // shortSideFacesRoad: 모델 기본 회전 + 도로 방향 회전
            const baseRotation = modelConfig?.rotationY || 0;
            instance.rotation.y = baseRotation + shortSideRotation;
        } else if (savedRotation !== null && savedRotation !== undefined) {
            instance.rotation.y = savedRotation;
        } else if (modelConfig?.requiresBreakwater) {
            // 방파제 인접 시설: 기본 회전만 적용
            instance.rotation.y = modelConfig?.rotationY || 0;
        } else {
            const roadDirection = findNearestRoadDirection(gx, gy, width, depth);
            instance.rotation.y += roadDirection;
        }

        // 그림자 설정
        instance.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        // userData 설정
        instance.userData = {
            isPublicBuilding: true,
            publicBuildingType: type,
            tileX: gx,
            tileY: gy,
            width: width,
            depth: depth,
            name: PUBLIC_BUILDING_MODELS[type]?.name || type
        };

        // 씬에 추가
        buildingGroup.add(instance);

        // 차지하는 타일들
        const tiles = [];
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                tiles.push(`${gx + dx},${gy + dy}`);
            }
        }

        // 추적 정보 저장 (코너 앵커 정보 포함)
        placedPublicBuildings.set(primaryKey, {
            type, instance, tiles, x: gx, y: gy, width, depth,
            shortSideRotation, roadSide,
            expansions: 0,  // 확장 터빈 수 (풍력발전기용)
            expansionInstances: []  // 확장 터빈 3D 인스턴스들
        });

        // 참조 키 추가
        for (const tileKey of tiles) {
            if (tileKey !== primaryKey) {
                placedPublicBuildings.set(tileKey, { ref: primaryKey });
            }
        }

        // 발전소인 경우 전력망에 등록
        const config = PUBLIC_BUILDING_MODELS[type];
        if (config && config.isPowerPlant && powerManager.initialized) {
            powerManager.addPowerPlant(gx, gy, type, config);
        }

        // 풍력 발전소 터빈 애니메이션 재생 (복원 시)
        if (type === 'powerplant_wind') {
            // GLB 내장 애니메이션이 있으면 재생
            if (prefabData.animations && prefabData.animations.length > 0) {
                const mixer = new THREE.AnimationMixer(instance);
                prefabData.animations.forEach(clip => {
                    const action = mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat, Infinity);
                    action.play();
                });
                activeAnimationMixers.push({
                    mixer: mixer,
                    instance: instance,
                    key: primaryKey
                });
                console.log(`Wind turbine animation restored for ${primaryKey}`);
            }

            // 프로펠러(Helice_Eolienne) 수동 회전 등록 (복원 시)
            let propeller = null;
            instance.traverse((child) => {
                if (child.name === 'Helice_Eolienne') {
                    propeller = child;
                }
            });
            if (propeller) {
                windTurbinePropellers.push({
                    propeller: propeller,
                    key: primaryKey,
                    speed: 2.0  // 회전 속도 (라디안/초)
                });
                console.log(`Wind turbine propeller restored for ${primaryKey}`);
            }
        }

        // 수도시설인 경우 수도망에 등록
        if (config && config.isWaterFacility && waterManager.initialized) {
            waterManager.addWaterFacility(gx, gy, type, config);
        }

        // 하수시설인 경우 하수망에 등록
        if (config && config.isSewageFacility && sewageManager.initialized) {
            sewageManager.addSewageFacility(gx, gy, type, config);
            // 바다 방류 시스템에 방류 지점 추가
            if (oceanSewageSystem.initialized) {
                const facilityData = {
                    x: gx,
                    y: gy,
                    width: config.displayWidth || 2,
                    depth: config.displayDepth || 4,
                    capacity: config.sewageCapacity || 500
                };
                oceanSewageSystem.addDischargePoint(gx, gy, facilityData);
            }
        }

        console.log(`Restored public building: ${type} at (${gx},${gy})`);
        return true;
    }

    // 저장된 모든 공공시설 복원
    function restoreAllPublicBuildings(publicBuildingsData) {
        if (!publicBuildingsData || !Array.isArray(publicBuildingsData)) return;

        console.log(`Restoring ${publicBuildingsData.length} public buildings...`);

        for (const buildingData of publicBuildingsData) {
            restorePublicBuilding(
                buildingData.x,
                buildingData.y,
                buildingData.type,
                buildingData.rotation,  // 저장된 회전값 전달
                buildingData.width,     // 저장된 width (shortSideFacesRoad 건물용)
                buildingData.depth,     // 저장된 depth
                buildingData.roadSide   // 저장된 도로 방향 (확장 방향 결정용)
            );

            // 풍력 발전소 확장 터빈 복원
            if (buildingData.type === 'powerplant_wind' && buildingData.expansions && buildingData.expansions.length > 0) {
                const building = findPublicBuildingAt(buildingData.x, buildingData.y);
                if (building) {
                    restoreWindTurbineExpansions(building, buildingData.expansions);
                }
            }

            // 태양광 발전소 확장 패널 복원
            if (buildingData.type === 'powerplant_solar' && buildingData.expansions && buildingData.expansions.length > 0) {
                const building = findPublicBuildingAt(buildingData.x, buildingData.y);
                if (building) {
                    restoreSolarPanelExpansions(building, buildingData.expansions);
                }
            }
        }

        // 전력망/수도망 재계산
        if (powerManager.initialized) {
            powerManager.recalculatePowerGrid();
        }
        if (waterManager.initialized) {
            waterManager.recalculateWaterGrid();
        }
    }

    // 풍력 발전소 확장 터빈 복원
    function restoreWindTurbineExpansions(building, expansionsData) {
        if (!building || !expansionsData || expansionsData.length === 0) return;

        console.log(`Restoring ${expansionsData.length} wind turbine expansions for building at ${building.x},${building.y}`);

        // 확장 인스턴스 배열 초기화
        if (!building.expansionInstances) {
            building.expansionInstances = [];
        }

        expansionsData.forEach((expData, idx) => {
            const { x: expX, y: expY, width, depth } = expData;

            // 잔디 타일 제거
            for (let dx = 0; dx < width; dx++) {
                for (let dy = 0; dy < depth; dy++) {
                    removeGrassTileAt(expX + dx, expY + dy);
                }
            }

            // 월드 좌표 계산
            const worldX = ORIGIN_X + expX + width / 2;
            const worldZ = ORIGIN_Z + expY + depth / 2;

            // 터빈 기준 왼쪽 방향 오프셋 (1칸)
            const roadSide = building.roadSide || 'bottom';
            let leftOffsetX = 0, leftOffsetZ = 0;
            switch (roadSide) {
                case 'bottom': leftOffsetX = -1; break;
                case 'top': leftOffsetX = 1; break;
                case 'left': leftOffsetZ = -1; break;
                case 'right': leftOffsetZ = 1; break;
            }

            // 모델 로드 및 배치
            const expLoader = new GLTFLoader();
            expLoader.load('/models/turbin_module.glb', (gltf) => {
                const instance = gltf.scene;

                instance.position.set(worldX + leftOffsetX, 0.02, worldZ + leftOffsetZ);

                // 메인 터빈과 같은 회전 적용
                instance.rotation.y = building.instance?.rotation.y || 0;

                // 스케일 조정
                instance.scale.setScalar(0.132);

                // 그림자 설정 및 머티리얼을 조명 반응형으로 교체
                instance.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        const oldMat = child.material;
                        child.material = new THREE.MeshLambertMaterial({
                            color: oldMat.color ? oldMat.color.clone() : new THREE.Color(0xffffff),
                            map: oldMat.map || null,
                            transparent: oldMat.transparent || false,
                            opacity: oldMat.opacity !== undefined ? oldMat.opacity : 1,
                            side: oldMat.side || THREE.FrontSide
                        });
                    }
                });

                scene.add(instance);

                // 확장 정보 저장
                const expansionInfo = {
                    x: expX,
                    y: expY,
                    width: width,
                    depth: depth,
                    instance: instance,
                    slotNum: idx + 1
                };
                building.expansionInstances.push(expansionInfo);

                // 프로펠러 수동 회전 등록 (turbin_module.glb의 프로펠러 이름 검색)
                instance.traverse((child) => {
                    const nameLower = (child.name || '').toLowerCase();
                    if (child.name === 'Helice_Eolienne' || nameLower.includes('propeller') || nameLower.includes('helice')) {
                        child.rotation.x = Math.random() * Math.PI * 2;  // 랜덤 시작 회전
                        const expPropellerKey = `${building.x},${building.y}_exp${idx + 1}`;
                        windTurbinePropellers.push({
                            key: expPropellerKey,
                            propeller: child,
                            speed: 1.33  // 메인 터빈과 동일한 속도
                        });
                        console.log(`[풍력 확장 복원] 프로펠러 등록: ${child.name}`);
                    }
                });

                // tiles에 확장 터빈 타일 추가
                for (let dx = 0; dx < width; dx++) {
                    for (let dy = 0; dy < depth; dy++) {
                        const tileKey = `${expX + dx},${expY + dy}`;
                        if (building.tiles instanceof Set) {
                            building.tiles.add(tileKey);
                        } else if (Array.isArray(building.tiles)) {
                            if (!building.tiles.includes(tileKey)) {
                                building.tiles.push(tileKey);
                            }
                        }
                    }
                }

                // 확장 수 업데이트
                building.expansions = building.expansionInstances.length;

                console.log(`Restored expansion ${idx + 1} at ${expX},${expY}`);
            });
        });

        // 전력망 업데이트 (풍량에 비례한 전력 계산)
        if (powerManager && powerManager.initialized) {
            const config = PUBLIC_BUILDING_MODELS['powerplant_wind'];
            const { actualPower } = calculateWindTurbinePower(
                building.x, building.y,
                config.powerOutput,
                expansionsData.length,
                config.expansionPowerOutput
            );
            setTimeout(() => {
                powerManager.updatePowerPlantOutput(building.x, building.y, actualPower);
                powerManager.recalculatePowerGrid();
            }, 500);  // 모델 로드 후 업데이트
        }
    }

    // 태양광 패널 확장 복원
    function restoreSolarPanelExpansions(building, expansionsData) {
        if (!building || !expansionsData || expansionsData.length === 0) return;

        console.log(`Restoring ${expansionsData.length} solar panel expansions for building at ${building.x},${building.y}`);

        if (!building.expansionInstances) {
            building.expansionInstances = [];
        }

        const config = PUBLIC_BUILDING_MODELS['powerplant_solar'];

        expansionsData.forEach((expData, idx) => {
            const { x: expX, y: expY, width, depth } = expData;

            // 잔디 타일 제거
            for (let dx = 0; dx < width; dx++) {
                for (let dy = 0; dy < depth; dy++) {
                    removeGrassTileAt(expX + dx, expY + dy);
                }
            }

            // 월드 좌표 계산
            const worldX = ORIGIN_X + expX + width / 2;
            const worldZ = ORIGIN_Z + expY + depth / 2;

            // 패널 기준 왼쪽 방향 오프셋 (1칸) - 풍력 터빈과 동일
            const roadSide = building.roadSide || 'bottom';
            let leftOffsetX = 0, leftOffsetZ = 0;
            switch (roadSide) {
                case 'bottom': leftOffsetX = -1; break;
                case 'top': leftOffsetX = 1; break;
                case 'left': leftOffsetZ = -1; break;
                case 'right': leftOffsetZ = 1; break;
            }

            // 모델 로드 및 배치
            const expLoader = new GLTFLoader();
            const modelPath = config.expansionModelPath || '/models/solarpanel_addon.glb';
            expLoader.load(modelPath, (gltf) => {
                const instance = gltf.scene;

                instance.position.set(worldX + leftOffsetX, 0.02, worldZ + leftOffsetZ);
                instance.rotation.y = building.instance?.rotation.y || 0;
                instance.scale.setScalar(0.132);  // 풍력과 동일한 스케일

                // 그림자 설정 및 머티리얼을 조명 반응형으로 교체 (풍력과 동일)
                instance.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        const oldMat = child.material;
                        child.material = new THREE.MeshLambertMaterial({
                            color: oldMat.color ? oldMat.color.clone() : new THREE.Color(0xffffff),
                            map: oldMat.map || null,
                            transparent: oldMat.transparent || false,
                            opacity: oldMat.opacity !== undefined ? oldMat.opacity : 1,
                            side: oldMat.side || THREE.FrontSide
                        });
                    }
                });

                scene.add(instance);

                // 확장 정보 저장
                const expansionInfo = {
                    x: expX,
                    y: expY,
                    width: width,
                    depth: depth,
                    instance: instance,
                    slotNum: idx + 1
                };
                building.expansionInstances.push(expansionInfo);

                // 타일 점유 표시
                for (let dx = 0; dx < width; dx++) {
                    for (let dy = 0; dy < depth; dy++) {
                        const tileKey = `${expX + dx},${expY + dy}`;
                        if (building.tiles instanceof Set) {
                            building.tiles.add(tileKey);
                        } else if (Array.isArray(building.tiles)) {
                            if (!building.tiles.includes(tileKey)) {
                                building.tiles.push(tileKey);
                            }
                        }
                    }
                }

                building.expansions = building.expansionInstances.length;
                console.log(`Restored expansion ${idx + 1} at ${expX},${expY}`);
            });
        });

        // 전력망 업데이트
        if (powerManager && powerManager.initialized) {
            const totalPower = config.powerOutput + (expansionsData.length * config.expansionPowerOutput);
            setTimeout(() => {
                powerManager.updatePowerPlantOutput(building.x, building.y, totalPower);
                powerManager.recalculatePowerGrid();
            }, 500);
        }
    }

    // 기존 프리뷰 메시 (폴백용)
    const previewMat = new THREE.MeshStandardMaterial({
        color: 0x00aa88,
        transparent: true,
        opacity: 0.35,
    });
    const previewMesh = new THREE.InstancedMesh(roadGeo, previewMat, GRID_W * GRID_H);
    previewMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    previewMesh.visible = false;  // 기본 숨김

    // 모델 기반 프리뷰 그룹
    const previewGroup = new THREE.Group();
    scene.add(previewGroup);

    roadMesh.visible = false;
    lockedRoadMesh.visible = false;

    /* =========================================================
     * GHOST TILE
     * ========================================================= */
    const ghost = new THREE.Mesh(
        new THREE.BoxGeometry(TILE_SIZE, 0.08, TILE_SIZE),
        new THREE.MeshStandardMaterial({ transparent: true, opacity: 0.35 })
    );
    ghost.visible = false;
    ghost.castShadow = true;
    scene.add(ghost);

    const tmp = new THREE.Object3D();

    /* =========================================================
     * TILE GROUPS (잔디, 도로, 수로, 다리, 나무)
     * ========================================================= */
    const grassGroup = new THREE.Group();
    const roadGroup = new THREE.Group();
    const waterGroup = new THREE.Group();
    const bridgeGroup = new THREE.Group();
    const treeGroup = new THREE.Group();  // 나무 그룹
    const beachGroup = new THREE.Group();  // 해변 타일 그룹
    const oceanGroup = new THREE.Group();  // 바다 타일 그룹
    scene.add(beachGroup);   // 해변은 가장 밑에
    scene.add(oceanGroup);   // 바다
    scene.add(grassGroup);
    scene.add(waterGroup);
    scene.add(roadGroup);
    scene.add(bridgeGroup);
    scene.add(treeGroup);  // 나무는 도로/다리 위에 렌더링
    scene.add(buildingGroup);
    scene.add(buildingPreviewGroup);  // 건물 설치 미리보기
    scene.add(breakwaterPreviewGroup);  // 방파제 설치 미리보기
    scene.add(expansionPreviewGroup);   // 풍력발전기 확장 프리뷰
    scene.add(serviceEffectGroup);    // 서비스 시설 효과 범위 표시
    scene.add(fireEffectsGroup);      // 화재 이펙트

    // 나무 데이터 저장소 (key: "x,y", value: { modelIndex, offsetX, offsetZ, rotation, scale, mesh })
    const placedTrees = new Map();

    // ========== 배경 산 모델 ==========
    let mountainModel = null;
    const mountainDefaults = { scale: 1.0, y: 0, x: 0, z: -30 };

    loader.load('/models/ExtremeLowPolyMountain.glb', (gltf) => {
        mountainModel = gltf.scene;
        mountainModel.position.set(mountainDefaults.x, mountainDefaults.y, mountainDefaults.z);
        mountainModel.scale.setScalar(mountainDefaults.scale);

        // 그림자 설정
        mountainModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        scene.add(mountainModel);
        console.log('[Mountain] Background mountain loaded');

        // 슬라이더 초기값 설정
        const scaleSlider = document.getElementById('mountainScaleSlider');
        const heightSlider = document.getElementById('mountainHeightSlider');
        const posXSlider = document.getElementById('mountainPosXSlider');
        const posZSlider = document.getElementById('mountainPosZSlider');
        if (scaleSlider) scaleSlider.value = mountainDefaults.scale;
        if (heightSlider) heightSlider.value = mountainDefaults.y;
        if (posXSlider) posXSlider.value = mountainDefaults.x;
        if (posZSlider) posZSlider.value = mountainDefaults.z;
        updateMountainSliderLabels();
    }, undefined, (error) => {
        console.error('[Mountain] Failed to load mountain model:', error);
    });

    function updateMountainSliderLabels() {
        const scaleVal = document.getElementById('mountainScaleValue');
        const heightVal = document.getElementById('mountainHeightValue');
        const posXVal = document.getElementById('mountainPosXValue');
        const posZVal = document.getElementById('mountainPosZValue');
        const scaleSlider = document.getElementById('mountainScaleSlider');
        const heightSlider = document.getElementById('mountainHeightSlider');
        const posXSlider = document.getElementById('mountainPosXSlider');
        const posZSlider = document.getElementById('mountainPosZSlider');

        if (scaleVal && scaleSlider) scaleVal.textContent = parseFloat(scaleSlider.value).toFixed(1);
        if (heightVal && heightSlider) heightVal.textContent = parseFloat(heightSlider.value).toFixed(1);
        if (posXVal && posXSlider) posXVal.textContent = parseInt(posXSlider.value);
        if (posZVal && posZSlider) posZVal.textContent = parseInt(posZSlider.value);
    }

    function clearTileGroup(group) {
        for (let i = group.children.length - 1; i >= 0; i--) {
            group.remove(group.children[i]);
        }
    }

    function clearRoadGroup() {
        clearTileGroup(roadGroup);
        // 가로등 풀 리셋 (배열만 초기화, 풀은 유지)
        activeStreetLightMap.forEach(poolItem => returnStreetLightToPool(poolItem));
        activeStreetLightMap.clear();
        streetLights.length = 0;
        lastStreetLightState = null;
    }

    function clearWaterGroup() {
        clearTileGroup(waterGroup);
    }

    function clearGrassGroup() {
        clearTileGroup(grassGroup);
    }

    function clearBridgeGroup() {
        clearTileGroup(bridgeGroup);
    }

    function clearBeachGroup() {
        clearTileGroup(beachGroup);
    }

    function clearOceanGroup() {
        clearTileGroup(oceanGroup);
    }

    // 해변 타일 배치
    const BEACH_HEIGHT_OFFSET = -0.15;  // 해변 높이 오프셋 (잔디보다 낮음)
    function addBeachTileAt(x, y) {
        // 해당 위치의 기존 해변 타일 제거 (중복 방지)
        removeBeachTileAt(x, y);
        // 해당 위치의 잔디 타일 제거
        removeGrassTileAt(x, y);

        const prefab = tilePrefabs.beach;
        if (!prefab) {
            console.warn('Beach prefab not found');
            return;
        }

        // 래퍼 그룹 생성 (정확한 위치 지정용)
        const tile = new THREE.Group();
        const clonedModel = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        // 모델 중심점 계산
        const box = new THREE.Box3().setFromObject(clonedModel);
        const center = new THREE.Vector3();
        box.getCenter(center);

        // 클론 모델을 래퍼 내에서 중앙 정렬
        clonedModel.position.set(-center.x, 0, -center.z);

        clonedModel.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = false;
                child.receiveShadow = true;
                child.material = child.material.clone();
            }
        });

        tile.add(clonedModel);

        tile.userData.gridX = x;
        tile.userData.gridY = y;

        const yPos = tileMinY.beach ? -tileMinY.beach + BEACH_HEIGHT_OFFSET : BEACH_HEIGHT_OFFSET;
        tile.position.set(c.x, yPos, c.z);
        beachGroup.add(tile);
    }

    // 특정 위치의 해변 타일 제거
    function removeBeachTileAt(x, y) {
        for (let i = beachGroup.children.length - 1; i >= 0; i--) {
            const tile = beachGroup.children[i];
            if (tile.userData.gridX === x && tile.userData.gridY === y) {
                beachGroup.remove(tile);
                return true;
            }
        }
        return false;
    }

    // 바다 타일 배치
    const OCEAN_HEIGHT_OFFSET = -0.15;  // 바다 높이 오프셋 (해변보다 낮음)

    // 바다 가장자리인지 확인 (맵 내부에서 바다가 아닌 타일과 인접한 경우에만)
    function isOceanEdge(x, y) {
        const directions = [
            { dx: -1, dy: 0 },  // 왼쪽
            { dx: 1, dy: 0 },   // 오른쪽
            { dx: 0, dy: -1 },  // 위
            { dx: 0, dy: 1 },   // 아래
        ];

        for (const dir of directions) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;

            // 그리드 범위 밖이면 무시 (맵 가장자리는 edge로 간주하지 않음)
            if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) {
                continue;
            }

            const adjCell = grid[nx][ny];
            // 맵 내부에서 인접 타일이 바다/해변/방파제가 아니면 가장자리 (육지에 인접)
            if (adjCell !== CELL.OCEAN && adjCell !== CELL.BEACH && adjCell !== CELL.BREAKWATER) {
                return true;
            }
        }

        return false;  // 맵 내 모든 인접 타일이 바다/해변이거나 맵 경계면 중앙
    }

    function addOceanTileAt(x, y, isEdge = null) {
        // 해당 위치의 잔디 타일 제거
        removeGrassTileAt(x, y);

        // isEdge가 명시적으로 전달되지 않으면 자동 판단
        if (isEdge === null) {
            isEdge = isOceanEdge(x, y);
        }

        const prefabKey = isEdge ? 'edge' : 'middle';
        const prefab = tilePrefabs.ocean ? tilePrefabs.ocean[prefabKey] : null;

        // 타일 중심 좌표 계산 (1x1 기준)
        let c = tileToWorldCenter(x, y);

        let tile;

        if (prefab) {
            // 래퍼 그룹 생성 (정확한 위치 지정용)
            tile = new THREE.Group();
            const clonedModel = prefab.clone(true);

            // 바다 타일 스케일 (원본 크기)
            // clonedModel.scale은 prefab 로딩 시 이미 TILE_SIZE에 맞게 설정됨

            // 모델 중심점 계산
            const box = new THREE.Box3().setFromObject(clonedModel);
            const center = new THREE.Vector3();
            box.getCenter(center);

            // 클론 모델을 래퍼 내에서 중앙 정렬 (원점에 중심이 오도록)
            clonedModel.position.set(-center.x, 0, -center.z);

            // 재질 설정 (원본 텍스처 색상 유지)
            clonedModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = false;
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material = child.material.clone();
                    }
                }
            });

            tile.add(clonedModel);

            const baseY = tileMinY.ocean && tileMinY.ocean[prefabKey] ? -tileMinY.ocean[prefabKey] : 0;
            tile.position.set(c.x, baseY + OCEAN_HEIGHT_OFFSET, c.z);
        } else {
            // 모델이 없으면 간단한 평면으로 대체
            console.warn(`Ocean prefab '${prefabKey}' not found, using fallback`);
            const tileSize = TILE_SIZE * 0.98;  // 원본 크기
            const geo = new THREE.PlaneGeometry(tileSize, tileSize);
            const mat = new THREE.MeshLambertMaterial({
                color: 0x4a90d9,  // 기본 바다색
                side: THREE.DoubleSide
            });
            tile = new THREE.Mesh(geo, mat);
            tile.rotation.x = -Math.PI / 2;
            tile.position.set(c.x, OCEAN_HEIGHT_OFFSET, c.z);
        }

        tile.userData.gridX = x;
        tile.userData.gridY = y;
        tile.userData.isOceanEdge = isEdge;

        oceanGroup.add(tile);
    }

    // 특정 위치의 바다 타일 제거
    function removeOceanTileAt(x, y) {
        for (let i = oceanGroup.children.length - 1; i >= 0; i--) {
            const tile = oceanGroup.children[i];
            if (tile.userData.gridX === x && tile.userData.gridY === y) {
                oceanGroup.remove(tile);
                return true;
            }
        }
        return false;
    }

    // 잔디 타일 배치
    function addGrassTileAt(x, y) {
        // 바다, 해변, 방파제 타일에는 잔디를 배치하지 않음
        if (!inBounds(x, y)) return;
        const cellValue = grid[x][y];
        if (cellValue === CELL.OCEAN || cellValue === CELL.BEACH || cellValue === CELL.BREAKWATER) return;

        const prefab = tilePrefabs.grass;
        if (!prefab) return;

        const tile = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = false;
                child.receiveShadow = true;
                child.material = child.material.clone();
            }
        });

        // 그리드 좌표 저장 (나중에 찾아서 제거할 수 있도록)
        tile.userData.gridX = x;
        tile.userData.gridY = y;

        tile.position.set(c.x, -tileMinY.grass, c.z);
        grassGroup.add(tile);
    }

    // 특정 위치의 잔디 타일 제거
    function removeGrassTileAt(x, y) {
        for (let i = grassGroup.children.length - 1; i >= 0; i--) {
            const tile = grassGroup.children[i];
            if (tile.userData.gridX === x && tile.userData.gridY === y) {
                grassGroup.remove(tile);
                return true;
            }
        }
        return false;
    }

    // 수로 타일 배치 (2x2 모델)
    const WATER_HEIGHT_OFFSET = -0.15;  // 수로 높이 오프셋
    function addWaterTileAt(gx, gy) {
        const prefab = tilePrefabs.water;
        if (!prefab) return null;

        // 그룹 래퍼 사용 (중심 회전을 위해)
        const group = new THREE.Group();
        const model = prefab.clone(true);

        model.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = false;
                child.receiveShadow = true;
                child.material = child.material.clone();
            }
        });

        // 모델을 그룹 원점에 배치 (오프셋 적용)
        model.position.set(
            -waterCenterOffset.x,
            -waterMinY + WATER_HEIGHT_OFFSET,
            -waterCenterOffset.z
        );

        group.add(model);
        group.rotation.y = -Math.PI / 2;  // 시계방향 90도 회전

        // 2x2 타일의 중심 위치 계산
        const worldX = (ORIGIN_X + gx + 1) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + gy + 1) * TILE_SIZE;
        group.position.set(worldX, 0, worldZ);

        group.userData.gridX = gx;
        group.userData.gridY = gy;
        group.userData.type = 'water';

        waterGroup.add(group);
        return group;
    }

    // 다리 타일 배치 (수로 위에 다리 모델 사용)
    const BRIDGE_HEIGHT_OFFSET = -0.15;  // 수로와 동일한 높이
    function addBridgeTileAt(x, y, rotY) {
        // 다리 전용 모델 사용
        const prefab = tilePrefabs.bridge;
        if (!prefab) return;

        const tile = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.receiveShadow = true;
                child.material = child.material.clone();
            }
        });

        // 수로 위 높이에 배치
        tile.position.set(c.x, -tileMinY.bridge + BRIDGE_HEIGHT_OFFSET, c.z);
        tile.rotation.y = rotY + Math.PI / 2;  // 90도 추가 회전
        bridgeGroup.add(tile);
    }

    // 모든 잔디 타일 재구성
    function rebuildGrassTiles() {
        clearGrassGroup();
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const v = grid[x][y];
                // 바다, 해변은 명시적으로 제외
                if (v === CELL.OCEAN || v === CELL.BEACH) continue;
                // 빈 땅, 구역만 잔디 표시 (도로, 수로, 다리 등 제외)
                if (v === CELL.EMPTY || isZone(x, y)) {
                    addGrassTileAt(x, y);
                }
            }
        }
    }

    // 타일이 바다에 인접한지 확인 (상하좌우)
    function isAdjacentToOcean(x, y) {
        const dirs = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
        for (const dir of dirs) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                if (grid[nx][ny] === CELL.OCEAN) {
                    return true;
                }
            }
        }
        return false;
    }

    // 타일이 육지에 인접한지 확인 (상하좌우)
    function isAdjacentToLand(x, y) {
        const dirs = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
        for (const dir of dirs) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                const cell = grid[nx][ny];
                // 육지: 빈 땅, 구역, 도로, 잔디 등 (바다, 해변, 방파제 제외)
                if (cell !== CELL.OCEAN && cell !== CELL.BEACH && cell !== CELL.BREAKWATER) {
                    return true;
                }
            }
        }
        return false;
    }

    // 해변 타일이 올바른 위치(육지 쪽, 방파제 인접 아님)에 있는지 확인
    function isBeachAlreadyOnLandSide() {
        let hasBeach = false;
        let hasOceanAdjacentToLand = false;

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (grid[x][y] === CELL.BEACH) {
                    hasBeach = true;
                    // 방파제에 인접한 해변 → 정리 필요
                    if (isAdjacentToBreakwater(x, y)) {
                        return false;
                    }

                    // 해변이 바다와 육지 모두에 인접해야 올바른 위치
                    const adjOcean = isAdjacentToOcean(x, y);
                    const adjLand = isAdjacentToLand(x, y);
                    if (!adjOcean || !adjLand) {
                        return false;
                    }
                }

                // 바다가 육지에 인접한 경우 체크 (해변이 필요한 위치)
                if (grid[x][y] === CELL.OCEAN && isAdjacentToLand(x, y)) {
                    hasOceanAdjacentToLand = true;
                }
            }
        }

        // 해변이 없지만 바다가 육지에 인접한 경우 → 해변 생성 필요
        if (!hasBeach && hasOceanAdjacentToLand) {
            return false;
        }

        // 모든 해변 타일이 올바른 위치에 있음
        return true;
    }

    // 해변 타일 재계산 (육지에 인접한 바다를 해변으로 변환)
    // 반환값: true = 변환됨, false = 이미 올바른 위치
    function recalculateBeachTiles() {
        // 이미 해변이 올바른 위치에 있으면 재계산 스킵
        if (isBeachAlreadyOnLandSide()) {
            console.log('해변 타일이 이미 올바른 위치에 있음 - 재계산 스킵');
            return false;
        }

        console.log('해변 타일 재계산 시작');

        // 1단계: 기존 해변 타일을 바다로 변환
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (grid[x][y] === CELL.BEACH) {
                    grid[x][y] = CELL.OCEAN;
                }
            }
        }

        // 2단계: 육지에 인접한 바다를 해변으로 변환 (방파제 인접 제외)
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const cell = grid[x][y];
                // 바다 타일 중 육지에 인접한 것을 해변으로 변환
                if (cell === CELL.OCEAN && isAdjacentToLand(x, y)) {
                    // 방파제 인접 위치는 건너뜀
                    if (isAdjacentToBreakwater(x, y)) continue;
                    grid[x][y] = CELL.BEACH;
                    // 원본 해안선에 추가 (처음 생성 시)
                    originalCoastline.add(`${x},${y}`);
                }
            }
        }

        return true;
    }

    // 모든 해변 타일 재구성 (그리드 기준)
    function rebuildBeachTiles() {
        clearBeachGroup();
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                // 그리드가 해변인 경우에만 타일 생성
                if (grid[x][y] === CELL.BEACH) {
                    addBeachTileAt(x, y);
                }
            }
        }
    }

    // 모든 바다 타일 재구성 (모든 타일 1x1)
    function rebuildOceanTiles() {
        clearOceanGroup();

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (isOcean(x, y)) {
                    const isEdge = isOceanEdge(x, y);
                    addOceanTileAt(x, y, isEdge);
                }
            }
        }
    }

    // 모든 수로 타일 재구성 (2x2 블록 기반)
    function rebuildWaterTiles() {
        clearWaterGroup();
        const renderedOrigins = new Set();

        for (let x = 0; x < GRID_W - 1; x++) {
            for (let y = 0; y < GRID_H - 1; y++) {
                const key = `${x},${y}`;
                if (renderedOrigins.has(key)) continue;

                // 2x2 블록이 모두 수로인지 확인
                if (isWater(x, y) && isWater(x + 1, y) &&
                    isWater(x, y + 1) && isWater(x + 1, y + 1)) {
                    addWaterTileAt(x, y);
                    renderedOrigins.add(key);
                    // 다른 모서리도 마킹하여 중복 방지
                    renderedOrigins.add(`${x + 1},${y}`);
                    renderedOrigins.add(`${x},${y + 1}`);
                    renderedOrigins.add(`${x + 1},${y + 1}`);
                }
            }
        }
    }

    // 모든 다리 타일 재구성
    function rebuildBridgeTiles() {
        clearBridgeGroup();
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (!isBridge(x, y)) continue;
                const rotY = getBridgeRotation(x, y);
                addBridgeTileAt(x, y, rotY);
            }
        }
    }

    // 모든 타일 재구성
    function rebuildAllTiles() {
        rebuildGrassTiles();     // 잔디 먼저
        rebuildBeachTiles();     // 해변 (잔디 제거)
        rebuildOceanTiles();     // 바다 (잔디 제거)
        rebuildWaterTiles();
        rebuildBridgeTiles();
        rebuildRoadModels();
    }

    /* =========================================================
     * TREE SYSTEM - 나무 배치 시스템
     * ========================================================= */

    // 시드 기반 난수 생성기 (Mulberry32)
    function mulberry32(seed) {
        return function() {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
    }

    // 나무 그룹 초기화
    function clearTreeGroup() {
        for (let i = treeGroup.children.length - 1; i >= 0; i--) {
            treeGroup.remove(treeGroup.children[i]);
        }
        placedTrees.clear();
    }

    // 특정 타일에 나무 추가
    function addTreeAt(x, y, modelIndex, offsetX = 0, offsetZ = 0) {
        if (!tilePrefabs.trees[modelIndex]) return null;

        const key = `${x},${y}`;
        // 이미 있으면 제거
        if (placedTrees.has(key)) {
            removeTreeAt(x, y);
        }

        const prefab = tilePrefabs.trees[modelIndex];
        const tree = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        // 타일 내 오프셋 적용 (타일 경계 내에서 랜덤 위치)
        const offsetLimit = TILE_SIZE * 0.4;  // 타일 중심에서 최대 40% 이동
        tree.position.set(
            c.x + offsetX * offsetLimit,
            0,  // 지면 높이
            c.z + offsetZ * offsetLimit
        );
        // 회전은 항상 랜덤 (DB 저장 안 함)
        tree.rotation.y = Math.random() * Math.PI * 2;
        // 스케일도 항상 랜덤 0.5~0.65 (DB 저장 안 함)
        const scale = 0.5 + Math.random() * 0.15;
        tree.scale.setScalar(scale);

        // 랜덤으로 일부 나무 색상을 약간 짙게 (30% 확률, DB 저장 안 함)
        const isDarker = Math.random() < 0.3;
        const darkenFactor = isDarker ? (0.6 + Math.random() * 0.25) : 1.0;  // 0.6~0.85 어둡게

        // 그림자 설정 및 색상 조정
        tree.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material = child.material.clone();
                    // 짙은 색상 적용
                    if (isDarker && child.material.color) {
                        child.material.color.multiplyScalar(darkenFactor);
                    }
                }
            }
        });

        // 그리드 좌표 저장
        tree.userData.gridX = x;
        tree.userData.gridY = y;

        treeGroup.add(tree);

        // 데이터 저장 (rotation, scale 제외 - DB 사용량 감소)
        placedTrees.set(key, {
            modelIndex,
            offsetX,
            offsetZ,
            mesh: tree
        });

        return tree;
    }

    // 특정 타일의 나무 제거
    function removeTreeAt(x, y) {
        const key = `${x},${y}`;
        const treeData = placedTrees.get(key);
        if (treeData && treeData.mesh) {
            treeGroup.remove(treeData.mesh);
            placedTrees.delete(key);
            return true;
        }
        return false;
    }

    // 타일이 나무를 배치할 수 있는지 확인
    function canPlaceTreeAt(x, y) {
        if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return false;
        const cell = grid[x][y];
        // 빈 땅(잔디)에만 나무 배치 가능
        return cell === CELL.EMPTY;
    }

    // 시드 기반 나무 배치 생성 (새 맵 생성 시 호출)
    function generateTreesWithSeed(seed = Date.now()) {
        console.log(`[Trees] Generating trees with seed: ${seed}`);
        clearTreeGroup();

        const rng = mulberry32(seed);

        // 클러스터 설정 (2배 증가)
        const numClusters = Math.floor(30 + rng() * 20);  // 30-50개 클러스터
        const clusters = [];

        // 클러스터 중심점 생성
        for (let i = 0; i < numClusters; i++) {
            const cx = Math.floor(rng() * (GRID_W - 4)) + 2;  // 외곽 제외
            const cy = Math.floor(rng() * (GRID_H - 4)) + 2;
            const size = Math.floor(2 + rng() * 4);  // 2-5 범위
            const density = 0.3 + rng() * 0.4;  // 30-70% 밀도
            clusters.push({ cx, cy, size, density });
        }

        // 각 클러스터에 나무 배치
        let totalTrees = 0;
        for (const cluster of clusters) {
            for (let dx = -cluster.size; dx <= cluster.size; dx++) {
                for (let dy = -cluster.size; dy <= cluster.size; dy++) {
                    const x = cluster.cx + dx;
                    const y = cluster.cy + dy;

                    // 클러스터 중심에서의 거리
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > cluster.size) continue;

                    // 확률 계산 (중심에 가까울수록 높음)
                    const falloff = 1 - (dist / cluster.size);
                    const chance = cluster.density * falloff;

                    if (rng() < chance && canPlaceTreeAt(x, y)) {
                        // 나무 속성 랜덤 생성 (rotation, scale 제외 - 로드 시 랜덤 생성)
                        const modelIndex = Math.floor(rng() * tilePrefabs.trees.length);
                        const offsetX = (rng() - 0.5) * 2;  // -1 ~ 1
                        const offsetZ = (rng() - 0.5) * 2;

                        addTreeAt(x, y, modelIndex, offsetX, offsetZ);
                        totalTrees++;
                    }
                }
            }
        }

        // 추가로 흩뿌려진 나무 (20-40% - 2배 증가)
        const scatteredCount = Math.floor(totalTrees * (0.2 + rng() * 0.2));
        for (let i = 0; i < scatteredCount; i++) {
            const x = Math.floor(rng() * GRID_W);
            const y = Math.floor(rng() * GRID_H);

            if (canPlaceTreeAt(x, y) && !placedTrees.has(`${x},${y}`)) {
                const modelIndex = Math.floor(rng() * tilePrefabs.trees.length);
                const offsetX = (rng() - 0.5) * 2;
                const offsetZ = (rng() - 0.5) * 2;

                addTreeAt(x, y, modelIndex, offsetX, offsetZ);
                totalTrees++;
            }
        }

        console.log(`[Trees] Generated ${totalTrees} trees in ${clusters.length} clusters`);
        return totalTrees;
    }

    // 저장된 나무 데이터에서 복원
    function restoreTreesFromData(treesData) {
        if (!treesData || !Array.isArray(treesData) || treesData.length === 0) {
            console.log('[Trees] No saved tree data to restore');
            return;
        }

        clearTreeGroup();
        let restoredCount = 0;

        for (const tree of treesData) {
            const { x, y, modelIndex, offsetX, offsetZ } = tree;

            // 해당 타일이 여전히 잔디인지 확인
            if (canPlaceTreeAt(x, y)) {
                // rotation, scale은 addTreeAt에서 랜덤 생성 (DB 저장 안 함)
                addTreeAt(x, y, modelIndex, offsetX || 0, offsetZ || 0);
                restoredCount++;
            }
        }

        console.log(`[Trees] Restored ${restoredCount}/${treesData.length} trees`);
    }

    // 타일 변경 시 해당 위치의 나무 제거 체크
    function checkAndRemoveTreeAtTile(x, y) {
        if (!canPlaceTreeAt(x, y)) {
            const removed = removeTreeAt(x, y);
            if (removed) {
                console.log(`[Trees] Tree removed at (${x}, ${y}) - tile changed`);
            }
        }
    }

    // 나무 데이터 추출 (저장용 - rotation, scale 제외하여 DB 사용량 감소)
    function extractTreesData() {
        const treesData = [];
        placedTrees.forEach((data, key) => {
            const [x, y] = key.split(',').map(Number);
            treesData.push({
                x,
                y,
                modelIndex: data.modelIndex,
                offsetX: data.offsetX,
                offsetZ: data.offsetZ
            });
        });
        return treesData;
    }

    function addRoadModelAt(x, y, key, rotY, is4Lane = false) {
        const prefab = is4Lane ? road4lanePrefabs[key] : roadPrefabs[key];
        if (!prefab) return;

        const tile = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        // 복제된 모델에 그림자 설정 적용 및 머티리얼 복제
        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.receiveShadow = true;
                child.material = child.material.clone();
                // emissive 색상 초기화 (혼잡도 시각화 제거)
                child.material.emissive = new THREE.Color(0x000000);
                child.material.emissiveIntensity = 0;
            }
        });

        tile.position.set(c.x, 0, c.z);
        tile.rotation.y = rotY;
        tile.updateMatrixWorld(true);

        const minYRef = is4Lane ? tileMinY.road4lane : roadMinY;
        const centerOffsetRef = is4Lane ? road4laneCenterOffset : roadCenterOffset;

        tile.position.y -= minYRef[key];

        const offset = centerOffsetRef[key].clone();
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
        tile.position.x -= offset.x;
        tile.position.z -= offset.z;
        tile.position.y -= 0.02;  // 도로 높이 조정

        // 타일 좌표 저장 (철거 모드 하이라이트용)
        tile.userData.tileX = x;
        tile.userData.tileY = y;
        tile.userData.isRoad = true;
        tile.userData.is4Lane = is4Lane;

        // 가로등 위치 등록 - PointLight 추가 (LOD 시스템으로 관리)
        // 디버그: 모든 자식 객체 이름 출력 (한 번만)
        if (!window._roadChildNamesLogged) window._roadChildNamesLogged = new Set();
        if (!window._roadChildNamesLogged.has(key)) {
            const childNames = [];
            tile.traverse((c) => { if (c.name) childNames.push(c.name); });
            console.log(`[Road ${key}] Child names:`, childNames);
            window._roadChildNamesLogged.add(key);
        }

        // 가로등 위치 저장 (풀링 시스템에서 관리)
        tile.traverse((child) => {
            const name = child.name?.toLowerCase() || '';
            if (name.includes('light') || name.includes('lamp') || name.includes('stolb') || name.includes('lantern') || name.includes('fon') || name.includes('post')) {
                streetLights.push({ mesh: child, tile: tile });
            }
        });

        roadGroup.add(tile);
    }

    // 4차선 도로 2x2 모델 추가 (원점 좌표 기준)
    function addRoad4LaneModelAt(originX, originY, key, rotY) {
        const prefab = road4lanePrefabs[key];
        if (!prefab) return;

        const tile = prefab.clone(true);

        // 2x2 타일 중앙 위치 계산
        // 원점(originX, originY)부터 2x2 영역의 중앙은 (originX+1, originY+1) 코너
        const worldX = (ORIGIN_X + originX + 1) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + originY + 1) * TILE_SIZE;

        // 복제된 모델에 그림자 설정 적용 및 머티리얼 복제
        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.receiveShadow = true;
                child.material = child.material.clone();
                child.material.emissive = new THREE.Color(0x000000);
                child.material.emissiveIntensity = 0;
            }
        });

        // 센터 오프셋 적용
        const offset = road4laneCenterOffset[key].clone();
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);

        tile.position.set(worldX - offset.x, 0, worldZ - offset.z);
        tile.rotation.y = rotY;
        tile.updateMatrixWorld(true);

        // minY 적용
        tile.position.y -= (tileMinY.road4lane[key] || 0);
        tile.position.y -= 0.02;

        // 타일 좌표 저장 (철거 모드 하이라이트용)
        tile.userData.originX = originX;
        tile.userData.originY = originY;
        tile.userData.isRoad = true;
        tile.userData.is4Lane = true;
        // 4차선이 차지하는 타일들 (2x2)
        tile.userData.tiles = [
            {x: originX, y: originY},
            {x: originX + 1, y: originY},
            {x: originX, y: originY + 1},
            {x: originX + 1, y: originY + 1}
        ];

        // 가로등 위치 저장 (풀링 시스템에서 관리)
        tile.traverse((child) => {
            const name = child.name?.toLowerCase() || '';
            if (name.includes('light') || name.includes('lamp') || name.includes('stolb') || name.includes('lantern') || name.includes('fon') || name.includes('post')) {
                streetLights.push({ mesh: child, tile: tile });
            }
        });

        roadGroup.add(tile);
    }

    // 4차선 도로 연결 마스크 계산 (2x2 타일 기준)
    // 4차선 도로 형태는 오직 다른 4차선 도로와의 연결만 고려 (2차선 무시)
    function get4LaneRoadMask(originX, originY) {
        let mask = 0;

        // 북쪽 (y+2): 상단에 4차선 도로가 있는지 확인
        if (is4LaneRoad(originX, originY + 2) || is4LaneRoad(originX + 1, originY + 2)) {
            mask |= DIR.N.bit;
        }
        // 남쪽 (y-1): 하단에 4차선 도로가 있는지 확인
        if (is4LaneRoad(originX, originY - 1) || is4LaneRoad(originX + 1, originY - 1)) {
            mask |= DIR.S.bit;
        }
        // 동쪽 (x+2): 우측에 4차선 도로가 있는지 확인
        if (is4LaneRoad(originX + 2, originY) || is4LaneRoad(originX + 2, originY + 1)) {
            mask |= DIR.E.bit;
        }
        // 서쪽 (x-1): 좌측에 4차선 도로가 있는지 확인
        if (is4LaneRoad(originX - 1, originY) || is4LaneRoad(originX - 1, originY + 1)) {
            mask |= DIR.W.bit;
        }

        return mask;
    }

    // 4차선 타일의 각 위치에 2차선이 연결되어 있는지 확인
    // 위치 번호 (좌상단부터 시계방향): 1=좌상단, 2=우상단, 4=우하단, 3=좌하단
    // +---+---+
    // | 1 | 2 |  (oy+1)
    // +---+---+
    // | 3 | 4 |  (oy)
    // +---+---+
    //  ox  ox+1
    function get4Lane2LaneConnections(originX, originY, roadMask) {
        const ox = originX;
        const oy = originY;

        // 각 위치의 2차선 연결 여부
        let conn = { 1: false, 2: false, 3: false, 4: false };

        // 남북 방향 도로 (직선 또는 끝부분) - 동서 면에서 2차선 연결 가능
        // mask 5 = N+S (직선), mask 1 = N only (북쪽 끝), mask 4 = S only (남쪽 끝)
        const isNorthSouthType = (roadMask === 5 || roadMask === 1 || roadMask === 4);

        // 동서 방향 도로 (직선 또는 끝부분) - 남북 면에서 2차선 연결 가능
        // mask 10 = E+W (직선), mask 2 = E only (동쪽 끝), mask 8 = W only (서쪽 끝)
        const isEastWestType = (roadMask === 10 || roadMask === 2 || roadMask === 8);

        if (isNorthSouthType) {
            conn[1] = is2LaneRoad(ox - 1, oy + 1); // 위치1의 서쪽
            conn[3] = is2LaneRoad(ox - 1, oy);     // 위치3의 서쪽
            conn[2] = is2LaneRoad(ox + 2, oy + 1); // 위치2의 동쪽
            conn[4] = is2LaneRoad(ox + 2, oy);     // 위치4의 동쪽
        } else if (isEastWestType) {
            conn[1] = is2LaneRoad(ox, oy + 2);     // 위치1의 북쪽
            conn[2] = is2LaneRoad(ox + 1, oy + 2); // 위치2의 북쪽
            conn[3] = is2LaneRoad(ox, oy - 1);     // 위치3의 남쪽
            conn[4] = is2LaneRoad(ox + 1, oy - 1); // 위치4의 남쪽
        }

        const hasAny = conn[1] || conn[2] || conn[3] || conn[4];
        if (!hasAny) return null;

        return conn;
    }

    // 2차선 연결에 따른 4차선 모델 및 회전 결정
    // 기본 모델: 3,4 연결 = road_tile_2x2_1, 2,4 연결 = road_tile_2x2_7, 4만 = road_tile_2x2_3
    // 기본 모델들은 모두 180도 회전 적용
    function get4LaneModelFor2LaneConnection(roadMask, conn) {
        if (!conn) return null;

        // 디버깅: 연결 위치 출력 (연결이 있을 때만)
        const connectedPositions = [];
        if (conn[1]) connectedPositions.push('1');
        if (conn[2]) connectedPositions.push('2');
        if (conn[3]) connectedPositions.push('3');
        if (conn[4]) connectedPositions.push('4');
        const isNS = (roadMask === 5 || roadMask === 1 || roadMask === 4);
        const isEW = (roadMask === 10 || roadMask === 2 || roadMask === 8);
        const direction = isNS ? '세로' : (isEW ? '가로' : '기타');
        if (connectedPositions.length > 0) {
            console.log(`[4차선 연결] ${direction} - ${connectedPositions.join(', ')}`);
        }

        // 남북 방향 도로 (직선 또는 끝부분): mask 5, 1, 4
        const isNorthSouthType = (roadMask === 5 || roadMask === 1 || roadMask === 4);
        // 동서 방향 도로 (직선 또는 끝부분): mask 10, 2, 8
        const isEastWestType = (roadMask === 10 || roadMask === 2 || roadMask === 8);

        // 남북 방향: 서쪽면(1,3) 또는 동쪽면(2,4) 연결
        if (isNorthSouthType) {
            const westAny = conn[1] || conn[3];  // 서쪽에 1개 이상 연결
            const eastAny = conn[2] || conn[4];  // 동쪽에 1개 이상 연결
            const westFull = conn[1] && conn[3]; // 서쪽 둘 다 연결
            const eastFull = conn[2] && conn[4]; // 동쪽 둘 다 연결

            // 양쪽 모두 연결 (서쪽에 1개 이상 AND 동쪽에 1개 이상)
            if (westAny && eastAny) {
                // 평행 연결: 같은 행 (1-2 상단행, 3-4 하단행)
                const parallelTop = conn[1] && conn[2];    // 상단행 평행
                const parallelBottom = conn[3] && conn[4]; // 하단행 평행
                // 대각선 연결: 다른 행 (1-4, 3-2)
                const diagonal14 = conn[1] && conn[4] && !conn[2] && !conn[3]; // 좌상-우하
                const diagonal32 = conn[3] && conn[2] && !conn[1] && !conn[4]; // 좌하-우상

                if (diagonal14) {
                    // 대각선 1-4 (좌상-우하): road_tile_2x2_7 모델 사용
                    return { variant: 'straight_side_corner', rotY: Math.PI + Math.PI / 2 };
                } else if (diagonal32) {
                    // 대각선 3-2 (우상-좌하): road_tile_2x2_7 reversal 모델 사용
                    return { variant: 'straight_side_corner_reversed', rotY: Math.PI + Math.PI / 2 };
                } else {
                    // 평행 또는 복합 연결: road_tile_2x2_1 모델 사용
                    // 아래쪽(3,4)에만 연결된 경우 180도 추가 회전
                    const bottomOnly = (conn[3] || conn[4]) && !conn[1] && !conn[2];
                    const baseRotY = Math.PI / 2 + Math.PI;
                    return { variant: 'straight_both_sides', rotY: bottomOnly ? baseRotY + Math.PI : baseRotY };
                }
            } else if (eastFull) {
                // 동쪽 양쪽 연결 (2,4): road_tile_2x2_7 기본 + 180도
                return { variant: 'straight_side_corner', rotY: Math.PI +Math.PI /2 };
            } else if (westFull) {
                // 서쪽 양쪽 연결 (1,3): road_tile_2x2_7 + 360도 (180+180)
                return { variant: 'straight_side_corner', rotY: Math.PI * 2+Math.PI /2 };
            } else if (conn[4]) {
                // 위치4만 (동쪽 하단): road_tile_2x2_3 reversal + 180도 + 180도
                return { variant: 'straight_side_single_reversed', rotY: Math.PI + Math.PI /2 + Math.PI};
            } else if (conn[2]) {
                // 위치2만 (동쪽 상단): road_tile_2x2_3 기본 + 180도
                return { variant: 'straight_side_single', rotY: Math.PI + Math.PI /2};
            } else if (conn[3]) {
                // 위치3만 (서쪽 하단): road_tile_2x2_3 기본 + 180도 + 180도
                return { variant: 'straight_side_single', rotY: Math.PI + Math.PI /2 + Math.PI};
            } else if (conn[1]) {
                // 위치1만 (서쪽 상단): road_tile_2x2_3 reversal + 180도
                return { variant: 'straight_side_single_reversed', rotY: Math.PI + Math.PI /2};
            }
        }
        // 동서 방향: 북쪽면(1,2) 또는 남쪽면(3,4) 연결
        else if (isEastWestType) {
            const northAny = conn[1] || conn[2];  // 북쪽에 1개 이상 연결
            const southAny = conn[3] || conn[4];  // 남쪽에 1개 이상 연결
            const northFull = conn[1] && conn[2]; // 북쪽 둘 다 연결
            const southFull = conn[3] && conn[4]; // 남쪽 둘 다 연결

            // 양쪽 모두 연결 (북쪽에 1개 이상 AND 남쪽에 1개 이상)
            if (northAny && southAny) {
                // 평행 연결: 같은 열 (1-3 좌측열, 2-4 우측열)
                const parallelLeft = conn[1] && conn[3];   // 좌측열 평행
                const parallelRight = conn[2] && conn[4];  // 우측열 평행
                // 대각선 연결: 다른 열 (1-4, 2-3)
                const diagonal14 = conn[1] && conn[4] && !conn[2] && !conn[3]; // 좌상-우하
                const diagonal23 = conn[2] && conn[3] && !conn[1] && !conn[4]; // 우상-좌하

                if (diagonal14) {
                    // 대각선 1-4 (좌상-우하): road_tile_2x2_7 reversal 모델 사용
                    return { variant: 'straight_side_corner_reversed', rotY: Math.PI };
                } else if (diagonal23) {
                    // 대각선 2-3 (우상-좌하): road_tile_2x2_7 모델 사용
                    return { variant: 'straight_side_corner', rotY: Math.PI };
                } else {
                    // 평행 또는 복합 연결: road_tile_2x2_1 모델 사용
                    // 우측(2,4)에만 연결된 경우 180도 추가 회전 (가로 도로 기준)
                    const rightOnly = (conn[2] || conn[4]) && !conn[1] && !conn[3];
                    const baseRotY = Math.PI;
                    return { variant: 'straight_both_sides', rotY: rightOnly ? baseRotY + Math.PI : baseRotY };
                }
            } else if (southFull) {
                // 남쪽 양쪽 연결 (3,4): road_tile_2x2_1 기본 + 180도
                return { variant: 'straight_side_full', rotY: Math.PI +Math.PI /2};
            } else if (northFull) {
                // 북쪽 양쪽 연결 (1,2): road_tile_2x2_1 + 360도 (180+180)
                return { variant: 'straight_side_full', rotY: Math.PI * 2 +Math.PI /2};
            } else if (conn[4]) {
                // 위치4만: road_tile_2x2_3 기본 + 180도 + 180도 + 90도 + 180도 (가로, 반전)
                return { variant: 'straight_side_single', rotY: Math.PI + Math.PI /2 + Math.PI + Math.PI /2 + Math.PI};
            } else if (conn[3]) {
                // 위치3만: road_tile_2x2_3 reversal + 180도 + 180도 + 90도 (가로, 반전)
                return { variant: 'straight_side_single_reversed', rotY: Math.PI + Math.PI /2 + Math.PI + Math.PI /2};
            } else if (conn[2]) {
                // 위치2만: road_tile_2x2_3 reversal + 180도 + 90도 (가로, 반전)
                return { variant: 'straight_side_single_reversed', rotY: Math.PI + Math.PI /2 + Math.PI /2};
            } else if (conn[1]) {
                // 위치1만: road_tile_2x2_3 기본 + 180도 + 90도 + 180도 (가로, 반전)
                return { variant: 'straight_side_single', rotY: Math.PI + Math.PI /2 + Math.PI /2 + Math.PI};
            }
        }

        return null;
    }

    function rebuildRoadModels() {
        clearRoadGroup();

        // 2차선 도로 렌더링 (1x1 타일)
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (!is2LaneRoad(x, y)) continue;

                const mask = getRoadMask(x, y);
                let { key, rotY } = pickRoadVariant(mask);

                // 직선 도로: 가로등이 한쪽에만 있으므로 홀짝으로 번갈아 180도 회전
                if (key === 'straight' && (x + y) % 2 === 1) {
                    rotY += Math.PI;
                }

                addRoadModelAt(x, y, key, rotY, false);
            }
        }

        // 4차선 도로 렌더링 (2x2 타일, 원점에서만)
        for (const [key, data] of road4laneOrigins) {
            const [originX, originY] = key.split(',').map(Number);
            const mask = get4LaneRoadMask(originX, originY);
            let { key: variant, rotY } = pickRoadVariant(mask);

            // 4차선 코너는 90도 추가 회전
            if (variant === 'corner') {
                rotY += Math.PI / 2*3;
                // 북서(N+W, mask=9), 남동(S+E, mask=6) 코너는 추가 180도 회전
                if (mask === 9 || mask === 6) {
                    rotY += Math.PI;
                }
            }
            // 4차선 T자는 180도 추가 회전
            if (variant === 't') {
                rotY += 2*Math.PI;
                // 동쪽만 열린 T자(N+S+E, mask=7), 서쪽만 열린 T자(N+S+W, mask=13)는 추가 180도 회전
                if (mask === 7 || mask === 13) {
                    rotY += Math.PI;
                }
            }

            // 직선 또는 끝부분 도로일 때 2차선 연결 체크
            // mask: 5=남북직선, 10=동서직선, 1=북끝, 4=남끝, 2=동끝, 8=서끝
            const canHave2LaneConnection = (mask === 5 || mask === 10 || mask === 1 || mask === 4 || mask === 2 || mask === 8);
            if (canHave2LaneConnection) {
                const conn = get4Lane2LaneConnections(originX, originY, mask);
                const connModel = get4LaneModelFor2LaneConnection(mask, conn);
                if (connModel) {
                    variant = connModel.variant;
                    rotY = connModel.rotY;
                }
            }

            // 원점 데이터 업데이트
            data.variant = variant;
            data.rotY = rotY;

            addRoad4LaneModelAt(originX, originY, variant, rotY);
        }
    }

    function rebuildRoadInstances() {
        let playerCount = 0;
        let lockedCount = 0;

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const v = grid[x][y];
                // 도로만 처리 (2차선 + 4차선, 구역 제외)
                const is2Lane = v === CELL.ROAD || v === CELL.LOCKED_ROAD;
                const is4Lane = v === CELL.ROAD_4LANE || v === CELL.LOCKED_ROAD_4LANE;
                if (!is2Lane && !is4Lane) continue;

                const c = tileToWorldCenter(x, y);
                tmp.position.set(c.x, 0.04, c.z);
                tmp.rotation.set(0, 0, 0);
                tmp.updateMatrix();

                if (v === CELL.LOCKED_ROAD || v === CELL.LOCKED_ROAD_4LANE) {
                    lockedRoadMesh.setMatrixAt(lockedCount++, tmp.matrix);
                } else {
                    roadMesh.setMatrixAt(playerCount++, tmp.matrix);
                }
            }
        }

        roadMesh.count = playerCount;
        roadMesh.instanceMatrix.needsUpdate = true;
        lockedRoadMesh.count = lockedCount;
        lockedRoadMesh.instanceMatrix.needsUpdate = true;

        // 교통 시스템에 도로 변경 알림
        if (trafficManager.initialized) {
            trafficManager.onRoadChange();
        }

        // 도로 연결 상태 체크
        updateRoadConnectivity();
    }

    // rebuildBuildings: 건물 재구성 여부
    // restoreOnlyFromSaved: true면 저장된 건물만 복원 (로드 시), false면 모든 구역에 자동 생성
    function rebuildZoneInstances(rebuildBuildings = true, restoreOnlyFromSaved = false) {
        let residentialCount = 0;
        let commercialCount = 0;
        let industrialCount = 0;

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const v = grid[x][y];
                if (v !== CELL.ZONE_RESIDENTIAL && v !== CELL.ZONE_COMMERCIAL && v !== CELL.ZONE_INDUSTRIAL) continue;

                const c = tileToWorldCenter(x, y);
                tmp.position.set(c.x, 0.10, c.z);  // 구역 표시 높이 (z-fighting 방지)
                tmp.rotation.set(0, 0, 0);
                tmp.updateMatrix();

                if (v === CELL.ZONE_RESIDENTIAL) {
                    residentialMesh.setMatrixAt(residentialCount++, tmp.matrix);
                } else if (v === CELL.ZONE_COMMERCIAL) {
                    commercialMesh.setMatrixAt(commercialCount++, tmp.matrix);
                } else if (v === CELL.ZONE_INDUSTRIAL) {
                    industrialMesh.setMatrixAt(industrialCount++, tmp.matrix);
                }
            }
        }

        residentialMesh.count = residentialCount;
        residentialMesh.instanceMatrix.needsUpdate = true;
        commercialMesh.count = commercialCount;
        commercialMesh.instanceMatrix.needsUpdate = true;
        industrialMesh.count = industrialCount;
        industrialMesh.instanceMatrix.needsUpdate = true;

        // 구역 변경 시 건물 재구성 (삭제 모드에서는 건물 유지)
        if (rebuildBuildings) {
            rebuildAllBuildings(restoreOnlyFromSaved);
            // 수치 모드일 때 새 건물에도 흰색 효과 적용
            if (isZoneModeActive) {
                applyWhiteEffectToNewBuildings();
            }
            // 건물 재구성 후 도로 연결 체크
            updateRoadConnectivity();
        }
    }

    // 새로 생성된 건물에 흰색 효과 적용 (기존 효과가 적용되지 않은 건물만)
    function applyWhiteEffectToNewBuildings() {
        const whiteMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.35,
        });

        buildingGroup.traverse((child) => {
            if (child.isMesh && child.material && !originalMaterials.has(child.uuid)) {
                originalMaterials.set(child.uuid, child.material);
                child.material = whiteMat.clone();
            }
        });
    }

    /* =========================================================
     * BUILDING PLACEMENT SYSTEM
     * ========================================================= */

    // 현재 도시 계층 (추후 동적으로 변경 가능)
    let currentCityTier = TIER.MIDDLE;  // 기본값: 중산층

    // 구역 타입을 문자열로 변환
    function getZoneTypeString(zoneType) {
        if (zoneType === CELL.ZONE_RESIDENTIAL) return 'residential';
        if (zoneType === CELL.ZONE_COMMERCIAL) return 'commercial';
        if (zoneType === CELL.ZONE_INDUSTRIAL) return 'industrial';
        return null;
    }

    // 구역 타입, 계층, 크기에 맞는 건물 목록 가져오기
    function getBuildingsForZone(zoneType, tier, size) {
        // 문자열이면 그대로 사용, 아니면 변환
        const zoneStr = (typeof zoneType === 'string') ? zoneType : getZoneTypeString(zoneType);
        if (!zoneStr || !CIVIL_BUILDING_MODELS[zoneStr]) return [];

        const tierData = CIVIL_BUILDING_MODELS[zoneStr][tier];
        if (!tierData || !tierData[size]) return [];

        // 프리팹 이름 생성 및 필터링
        return tierData[size]
            .map(modelName => `${zoneStr}_${tier}_${size}_${modelName}`)
            .filter(name => buildingPrefabs[name] != null);
    }

    // 구역 타입에 맞는 전체 건물 목록 (2x2 먼저, 1x1 나중에)
    function getBuildingsForZoneType(zoneType) {
        const tier = currentCityTier;
        const buildings2x2 = getBuildingsForZone(zoneType, tier, "2x2");
        const buildings1x1 = getBuildingsForZone(zoneType, tier, "1x1");

        // 빈 경우 폴백 추가
        const result = [...buildings2x2, ...buildings1x1];

        // 건물이 없으면 Filler 추가
        if (result.length === 0) {
            if (zoneType === CELL.ZONE_RESIDENTIAL) result.push('Filler_Residential');
            else if (zoneType === CELL.ZONE_COMMERCIAL) result.push('Filler_Commercial');
            else if (zoneType === CELL.ZONE_INDUSTRIAL) result.push('Filler_Industrial');
        }

        return result;
    }

    // 연속된 구역 블록 찾기 (Flood Fill)
    function findZoneBlocks() {
        const visited = Array.from({ length: GRID_W }, () => Array(GRID_H).fill(false));
        const blocks = [];

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (visited[x][y]) continue;
                if (!isZone(x, y)) continue;

                const zoneType = grid[x][y];
                const block = {
                    zoneType,
                    tiles: [],
                    minX: x, maxX: x,
                    minY: y, maxY: y,
                };

                // BFS로 연속된 같은 타입의 구역 찾기
                const queue = [{ x, y }];
                visited[x][y] = true;

                while (queue.length > 0) {
                    const curr = queue.shift();

                    // 공공시설이 있는 타일은 건물 배치 대상에서 제외
                    if (!placedPublicBuildings.has(`${curr.x},${curr.y}`)) {
                        block.tiles.push(curr);
                    }

                    block.minX = Math.min(block.minX, curr.x);
                    block.maxX = Math.max(block.maxX, curr.x);
                    block.minY = Math.min(block.minY, curr.y);
                    block.maxY = Math.max(block.maxY, curr.y);

                    // 4방향 탐색
                    const neighbors = [
                        { x: curr.x - 1, y: curr.y },
                        { x: curr.x + 1, y: curr.y },
                        { x: curr.x, y: curr.y - 1 },
                        { x: curr.x, y: curr.y + 1 },
                    ];

                    for (const n of neighbors) {
                        if (!inBounds(n.x, n.y)) continue;
                        if (visited[n.x][n.y]) continue;
                        if (grid[n.x][n.y] !== zoneType) continue;

                        visited[n.x][n.y] = true;
                        queue.push(n);
                    }
                }

                blocks.push(block);
            }
        }

        return blocks;
    }

    // 2x2 건물 배치 가능 여부 확인 (기존 1x1 건물 흡수 가능)
    // 조건:
    // 1. 2x2 영역 내에 도로/수로가 없어야 함
    // 2. 도로 인접 2타일이 같은 구역
    // 3. 뒤쪽 2타일이 같은 구역 또는 빈 땅(잔디)
    // 모든 도로 방향(상/하/좌/우)을 시도하여 하나라도 조건 만족하면 배치 가능
    function canPlace2x2Building(x, y, zoneType, tileSet, placed2x2Set) {
        // 2x2 영역 확인
        const tiles2x2 = [
            { x: x, y: y }, { x: x + 1, y: y },
            { x: x, y: y + 1 }, { x: x + 1, y: y + 1 }
        ];

        // 모든 타일이 범위 내인지, 2x2로 이미 배치되었는지 확인
        for (const t of tiles2x2) {
            if (!inBounds(t.x, t.y)) return { canPlace: false };
            const key = `${t.x},${t.y}`;
            // 이미 2x2로 배치된 곳은 불가
            if (placed2x2Set && placed2x2Set.has(key)) return { canPlace: false };

            // 공공시설이 있으면 배치 불가
            if (placedPublicBuildings.has(key)) return { canPlace: false };

            // 2x2 영역 내에 도로, 수로, 다리가 있으면 배치 불가
            const cellValue = grid[t.x][t.y];
            if (cellValue === CELL.ROAD || cellValue === CELL.LOCKED_ROAD ||
                cellValue === CELL.WATER || cellValue === CELL.BRIDGE) {
                return { canPlace: false };
            }
        }

        // 도로가 있는 방향 찾기 (정면) - 2x2 경계 바로 바깥 확인
        const roadCounts = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };

        // 위쪽 (y - 1)
        if (inBounds(x, y - 1) && isRoad(x, y - 1)) roadCounts.top++;
        if (inBounds(x + 1, y - 1) && isRoad(x + 1, y - 1)) roadCounts.top++;

        // 아래쪽 (y + 2)
        if (inBounds(x, y + 2) && isRoad(x, y + 2)) roadCounts.bottom++;
        if (inBounds(x + 1, y + 2) && isRoad(x + 1, y + 2)) roadCounts.bottom++;

        // 왼쪽 (x - 1)
        if (inBounds(x - 1, y) && isRoad(x - 1, y)) roadCounts.left++;
        if (inBounds(x - 1, y + 1) && isRoad(x - 1, y + 1)) roadCounts.left++;

        // 오른쪽 (x + 2)
        if (inBounds(x + 2, y) && isRoad(x + 2, y)) roadCounts.right++;
        if (inBounds(x + 2, y + 1) && isRoad(x + 2, y + 1)) roadCounts.right++;

        // 도로가 있는 방향들 (도로 수가 많은 순으로 정렬)
        const directionsWithRoads = Object.entries(roadCounts)
            .filter(([dir, count]) => count > 0)
            .sort((a, b) => b[1] - a[1])
            .map(([dir]) => dir);

        // 도로가 없으면 배치 불가
        if (directionsWithRoads.length === 0) {
            return { canPlace: false };
        }

        // 각 도로 방향에 대해 front/back 조건 검사
        const directionConfigs = {
            top: {
                frontTiles: [{ x: x, y: y }, { x: x + 1, y: y }],
                backTiles: [{ x: x, y: y + 1 }, { x: x + 1, y: y + 1 }]
            },
            bottom: {
                frontTiles: [{ x: x, y: y + 1 }, { x: x + 1, y: y + 1 }],
                backTiles: [{ x: x, y: y }, { x: x + 1, y: y }]
            },
            left: {
                frontTiles: [{ x: x, y: y }, { x: x, y: y + 1 }],
                backTiles: [{ x: x + 1, y: y }, { x: x + 1, y: y + 1 }]
            },
            right: {
                frontTiles: [{ x: x + 1, y: y }, { x: x + 1, y: y + 1 }],
                backTiles: [{ x: x, y: y }, { x: x, y: y + 1 }]
            }
        };

        // 모든 도로 방향을 시도하여 조건을 만족하는 방향 찾기
        for (const roadDir of directionsWithRoads) {
            const { frontTiles, backTiles } = directionConfigs[roadDir];

            // 도로 인접 2타일(앞)이 같은 구역인지 확인
            let frontValid = true;
            for (const t of frontTiles) {
                const key = `${t.x},${t.y}`;
                if (!tileSet.has(key)) {
                    frontValid = false;
                    break;
                }
            }
            if (!frontValid) continue;

            // 뒤쪽 2타일이 같은 구역이거나 빈 땅(잔디)인지 확인
            // 도로, 수로, 다른 타입의 구역이면 불가
            let backValid = true;
            for (const t of backTiles) {
                const key = `${t.x},${t.y}`;
                const cellValue = grid[t.x][t.y];  // grid[x][y] 형식
                const isEmptyGrass = (cellValue === CELL.EMPTY);
                const isSameZone = tileSet.has(key);

                // 다른 타입의 구역인지 확인 (예: 주거구역에 상업/공업구역이 있으면 불가)
                const isOtherZone = (cellValue === CELL.ZONE_RESIDENTIAL ||
                                     cellValue === CELL.ZONE_COMMERCIAL ||
                                     cellValue === CELL.ZONE_INDUSTRIAL) && !isSameZone;

                if (isOtherZone || (!isEmptyGrass && !isSameZone)) {
                    backValid = false;
                    break;
                }
            }
            if (!backValid) continue;

            // 조건을 만족하는 방향을 찾음
            const existingBuildings = [];
            for (const t of tiles2x2) {
                const existingBuilding = findBuildingAt(t.x, t.y);
                if (existingBuilding && existingBuilding.width === 1 && existingBuilding.depth === 1) {
                    existingBuildings.push({ x: t.x, y: t.y });
                }
            }
            return { canPlace: true, roadDir, existingBuildings };
        }

        // 어떤 방향도 조건을 만족하지 않음
        return { canPlace: false };
    }

    // 블록 내 타일에 건물 배치 (2x2 우선, 그 다음 1x1)
    function placeBuildingsInBlock(block) {
        const zoneType = block.zoneType;
        const zoneStr = getZoneTypeString(zoneType);

        // 타일을 그리드로 변환 (배치 추적용)
        const placed = new Set();
        const placements = [];

        // 타일 집합 생성
        const tileSet = new Set(block.tiles.map(t => `${t.x},${t.y}`));

        // 티어별 건물 목록 캐시 (이름과 건물 객체 함께 반환)
        function getBuildingsByTier(tier, size) {
            let names = getBuildingsForZone(zoneType, tier, size);
            if (names.length === 0) {
                // 다른 계층에서 찾기
                const otherTier = tier === TIER.MIDDLE ? TIER.HIGH : TIER.MIDDLE;
                names = getBuildingsForZone(zoneType, otherTier, size);
            }
            return names
                .map(name => ({ name, building: buildingPrefabs[name] }))
                .filter(item => item.building != null);
        }

        // 2x2 건물 목록 (양쪽 티어)
        const buildings2x2High = getBuildingsByTier(TIER.HIGH, "2x2");
        const buildings2x2Middle = getBuildingsByTier(TIER.MIDDLE, "2x2");

        // 1x1 건물 목록 (양쪽 티어)
        const buildings1x1High = getBuildingsByTier(TIER.HIGH, "1x1");
        const buildings1x1Middle = getBuildingsByTier(TIER.MIDDLE, "1x1");

        console.log(`Zone ${zoneStr}: HIGH 2x2=${buildings2x2High.length}, 1x1=${buildings1x1High.length} | MIDDLE 2x2=${buildings2x2Middle.length}, 1x1=${buildings1x1Middle.length}`);

        // 폴백 건물
        let fillerName = null;
        if (zoneType === CELL.ZONE_RESIDENTIAL) fillerName = 'Filler_Residential';
        else if (zoneType === CELL.ZONE_COMMERCIAL) fillerName = 'Filler_Commercial';
        else if (zoneType === CELL.ZONE_INDUSTRIAL) fillerName = 'Filler_Industrial';
        const fillerBuilding = fillerName ? buildingPrefabs[fillerName] : null;

        // 왼쪽 위부터 순회
        const sortedTiles = [...block.tiles].sort((a, b) => {
            if (a.y !== b.y) return a.y - b.y;
            return a.x - b.x;
        });

        // 2x2로 배치된 타일 추적 (기존 건물 흡수용)
        const placed2x2 = new Set();

        // 1단계: 2x2 건물 배치 시도 (땅값 충족 시에만)
        // 레벨 1(TIER.MIDDLE)일 때는 2x2 건물을 배치하지 않음 - 업그레이드 시스템을 통해서만 2x2 생성
        for (const tile of sortedTiles) {
            const key = `${tile.x},${tile.y}`;
            if (placed2x2.has(key)) continue;

            // 해당 타일의 땅값으로 티어 결정
            const tileTier = getTierByLandValue(tile.x, tile.y);

            // 레벨 1 (TIER.MIDDLE)인 경우 2x2 건물 배치 안함
            // 2x2 건물은 레벨 2 (TIER.HIGH) 땅값 달성 후 업그레이드를 통해서만 생성됨
            if (tileTier !== TIER.HIGH) continue;

            const buildings2x2 = buildings2x2High;

            if (buildings2x2.length === 0) continue;

            // 4가지 가능한 2x2 시작 위치 (현재 타일이 각각 좌상, 우상, 좌하, 우하에 위치)
            const possibleStarts = [
                { x: tile.x, y: tile.y },         // 현재 타일이 좌상단
                { x: tile.x - 1, y: tile.y },     // 현재 타일이 우상단
                { x: tile.x, y: tile.y - 1 },     // 현재 타일이 좌하단
                { x: tile.x - 1, y: tile.y - 1 }  // 현재 타일이 우하단
            ];

            let placed2x2Success = false;
            for (const start of possibleStarts) {
                if (placed2x2Success) break;

                // 이 시작 위치의 4타일이 이미 배치되었는지 확인
                let anyPlaced = false;
                for (let dx = 0; dx < 2; dx++) {
                    for (let dy = 0; dy < 2; dy++) {
                        if (placed2x2.has(`${start.x + dx},${start.y + dy}`)) {
                            anyPlaced = true;
                            break;
                        }
                    }
                    if (anyPlaced) break;
                }
                if (anyPlaced) continue;

                const result = canPlace2x2Building(start.x, start.y, zoneType, tileSet, placed2x2);
                if (result.canPlace) {
                    // 기존 1x1 건물들 제거 (2x2로 흡수되므로 재건축 스킵)
                    if (result.existingBuildings && result.existingBuildings.length > 0) {
                        for (const eb of result.existingBuildings) {
                            removeBuildingAt(eb.x, eb.y, true);  // skipRebuild = true
                        }
                        console.log(`2x2 absorbed ${result.existingBuildings.length} existing buildings at (${start.x},${start.y})`);
                    }

                    // 위치 기반 랜덤 선택
                    const idx = (start.x * 7 + start.y * 13) % buildings2x2.length;
                    const { name: prefabName, building } = buildings2x2[idx];

                    // 2x2 타일 모두 배치 완료로 표시
                    for (let dx = 0; dx < 2; dx++) {
                        for (let dy = 0; dy < 2; dy++) {
                            placed.add(`${start.x + dx},${start.y + dy}`);
                            placed2x2.add(`${start.x + dx},${start.y + dy}`);
                        }
                    }

                    placements.push({
                        building,
                        prefabName,  // 건물 모델 이름 저장
                        displayName: getBuildingDisplayName(prefabName),  // 건물 표시 이름
                        x: start.x,
                        y: start.y,
                        width: 2,
                        depth: 2,
                        zoneStr: zoneStr,  // 인구 시스템용 구역 타입
                        size: "2x2",
                    });

                    placed2x2Success = true;
                }
            }
        }

        // 2단계: 남은 공간에 1x1 건물 배치
        for (const tile of sortedTiles) {
            const key = `${tile.x},${tile.y}`;
            if (placed.has(key)) continue;

            // 공공시설이 있으면 스킵
            if (placedPublicBuildings.has(key)) continue;

            // 해당 타일의 땅값으로 티어 결정
            const tileTier = getTierByLandValue(tile.x, tile.y);
            let buildings1x1 = tileTier === TIER.HIGH ? buildings1x1High : buildings1x1Middle;

            // 1x1이 없으면 filler 사용
            if (buildings1x1.length === 0 && fillerBuilding) {
                buildings1x1 = [{ name: fillerName, building: fillerBuilding }];
            }

            if (buildings1x1.length === 0) continue;

            // 위치 기반 랜덤 선택
            const idx = (tile.x * 11 + tile.y * 17) % buildings1x1.length;
            const { name: prefabName, building } = buildings1x1[idx];

            placed.add(key);

            placements.push({
                building,
                prefabName,  // 건물 모델 이름 저장
                displayName: getBuildingDisplayName(prefabName),  // 건물 표시 이름
                x: tile.x,
                y: tile.y,
                width: 1,
                depth: 1,
                zoneStr: zoneStr,  // 인구 시스템용 구역 타입
                size: "1x1",
            });
        }

        return placements;
    }

    // 건물 주변에서 도로 방향 찾기 (정면이 도로를 향하도록 회전값 반환)
    function findNearestRoadDirection(x, y, width, depth) {
        // 4방향 체크: 위(북), 오른쪽(동), 아래(남), 왼쪽(서)
        // 모델의 기본 정면이 어느 방향인지에 따라 회전값 조정 필요
        // 기본 정면이 -Z 방향(북쪽)이라고 가정

        // 각 방향에서 도로 타일 수 카운트
        let topRoads = 0, bottomRoads = 0, leftRoads = 0, rightRoads = 0;

        // 위쪽 (y - 1)
        for (let dx = 0; dx < width; dx++) {
            if (inBounds(x + dx, y - 1) && isRoad(x + dx, y - 1)) topRoads++;
        }
        // 아래쪽 (y + depth)
        for (let dx = 0; dx < width; dx++) {
            if (inBounds(x + dx, y + depth) && isRoad(x + dx, y + depth)) bottomRoads++;
        }
        // 왼쪽 (x - 1)
        for (let dy = 0; dy < depth; dy++) {
            if (inBounds(x - 1, y + dy) && isRoad(x - 1, y + dy)) leftRoads++;
        }
        // 오른쪽 (x + width)
        for (let dy = 0; dy < depth; dy++) {
            if (inBounds(x + width, y + dy) && isRoad(x + width, y + dy)) rightRoads++;
        }

        // 가장 많은 도로가 있는 방향으로 회전
        const max = Math.max(topRoads, bottomRoads, leftRoads, rightRoads);

        if (max === 0) {
            // 도로가 없으면 기본 방향 (위쪽)
            return 0;
        }

        // 정면이 도로를 향하도록 회전값 반환
        // 모델 기본 정면이 -Z (화면 위쪽)라고 가정
        if (topRoads === max) return 0;                    // 위쪽 도로 → 회전 없음
        if (bottomRoads === max) return Math.PI;           // 아래쪽 도로 → 180도
        if (leftRoads === max) return -Math.PI / 2;        // 왼쪽 도로 → -90도
        if (rightRoads === max) return Math.PI / 2;        // 오른쪽 도로 → 90도

        return 0;
    }

    // 건물 인스턴스 생성 및 배치
    function addBuildingInstance(placement) {
        const { building, x, y, width, depth, zoneStr, size, prefabName } = placement;
        const { prefab, minY, centerOffsetX = 0, centerOffsetZ = 0 } = building;

        // 건물이 차지하는 모든 타일에서 잔디 제거
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                removeGrassTileAt(x + dx, y + dy);
            }
        }

        const instance = prefab.clone(true);

        // 그림자 설정 및 머티리얼을 조명 반응형으로 강제 교체
        instance.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.receiveShadow = true;

                // 모든 material을 MeshLambertMaterial로 강제 교체 (조명 반응)
                const convertMaterial = (mat) => {
                    const newMat = new THREE.MeshLambertMaterial({
                        color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                        map: mat.map || null,
                        transparent: mat.transparent || false,
                        opacity: mat.opacity !== undefined ? mat.opacity : 1,
                        side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                    });
                    return newMat;
                };

                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => convertMaterial(m));
                } else {
                    child.material = convertMaterial(child.material);
                }
            }
        });

        // 건물 중심 위치 계산 (타일 그리드 기준)
        // 1x1: 타일 중심 (x+0.5, y+0.5)
        // 2x2: 4타일 교차점 (x+1, y+1) - 타일들이 만나는 모서리
        const worldX = (ORIGIN_X + x + width / 2) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + y + depth / 2) * TILE_SIZE;

        // 건물 위치 조정 (바닥에 맞춤 + 모델 중심 오프셋 보정)
        instance.position.set(
            worldX - centerOffsetX,
            -minY,
            worldZ - centerOffsetZ
        );

        // 도로 방향으로 건물 회전 (정면이 도로를 향하도록)
        const roadDirection = findNearestRoadDirection(x, y, width, depth);
        instance.rotation.y = roadDirection;

        // 1x1 상업 건물은 90도 시계방향 추가 회전
        const isCommercial1x1 = (zoneStr && zoneStr.includes('commercial')) && (width === 1 && depth === 1);
        if (isCommercial1x1) {
            instance.rotation.y += Math.PI / 2;  // 90도 시계방향
        }

        // 건물 레벨 결정 (2x2 = Level 2, 1x1 = Level 1)
        const buildingSize = size || (width === 2 ? "2x2" : "1x1");
        let buildingLevel = buildingSize === "2x2" ? 2 : 1;
        let buildingTier = buildingLevel === 2 ? TIER.HIGH : TIER.MIDDLE;
        let isAbandoned = false;
        const currentLandValue = getTotalLandValue(x, y);

        // 저장된 건물 데이터가 있으면 적용
        let abandonedReason = null;
        const savedData = findSavedBuildingData(x, y);
        if (savedData && savedData.x === x && savedData.y === y) {
            buildingLevel = savedData.level || buildingLevel;
            buildingTier = savedData.tier || buildingTier;
            isAbandoned = savedData.isAbandoned || false;
            abandonedReason = savedData.abandonedReason || null;
        }

        // 인구 시스템용 userData 저장
        instance.userData = {
            zoneType: zoneStr || 'residential',
            size: buildingSize,
            tileX: x,
            tileY: y,
            // 업그레이드 시스템 필드
            level: buildingLevel,
            tier: buildingTier,
            isAbandoned: isAbandoned,
            abandonedReason: abandonedReason,  // 폐건물 이유 저장
            originalMaterials: null,
            currentLandValue: currentLandValue,
        };

        buildingGroup.add(instance);

        // 구역 모드 중 추가된 건물은 원래 머티리얼 저장 후 회색으로 변경
        if (isZoneModeActive) {
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialBuilding.clone();
                }
            });
        }

        // 건물 위치 추적에 등록
        const tiles = [];
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                tiles.push(`${x + dx},${y + dy}`);
            }
        }
        const primaryKey = `${x},${y}`;
        const displayName = placement.displayName || getBuildingDisplayName(prefabName);
        const buildingEntry = {
            instance, tiles, x, y, width, depth,
            zoneType: zoneStr || 'residential',
            level: buildingLevel,
            tier: buildingTier,
            isAbandoned: isAbandoned,
            abandonedReason: abandonedReason,  // 폐건물 이유 저장
            prefabName: prefabName || null,  // 건물 모델 이름 저장
            displayName: displayName || null // 건물 표시 이름 저장
        };
        placedBuildings.set(primaryKey, buildingEntry);

        // 폐건물이면 텍스처 적용 및 아이콘 표시
        if (isAbandoned) {
            applyAbandonedMaterials(instance);
            showAbandonedIcon(buildingEntry, x, y);
        }

        // 모든 타일에서 이 건물을 찾을 수 있도록 추가 매핑
        for (const tileKey of tiles) {
            if (tileKey !== primaryKey) {
                placedBuildings.set(tileKey, { ref: primaryKey });
            }
        }

        // 건물 배열 캐시 무효화
        invalidateBuildingsCache();
    }

    // 특정 위치의 건물 찾기
    function findBuildingAt(gx, gy) {
        const key = `${gx},${gy}`;
        const entry = placedBuildings.get(key);
        if (!entry) return null;

        // 참조인 경우 실제 건물 데이터 반환
        if (entry.ref) {
            return placedBuildings.get(entry.ref);
        }
        return entry;
    }

    // 건물 삭제
    // 철거 애니메이션 진행 중인 건물 추적
    const demolishingBuildings = new Set();

    // 먼지 이펙트 생성 (철거용)
    function createDemolishDustEffect(x, y, width, depth, buildingHeight) {
        // 건물이 차지하는 영역의 정확한 중심 계산
        const firstTile = tileToWorldCenter(x, y);
        const lastTile = tileToWorldCenter(x + width - 1, y + depth - 1);
        const worldPos = {
            x: (firstTile.x + lastTile.x) / 2,
            z: (firstTile.z + lastTile.z) / 2
        };
        const dustGroup = new THREE.Group();

        // 건물 크기 기반 범위
        const baseRadius = Math.max(width, depth) * 0.6;

        // 먼지 파티클 (작고 많이)
        const dustCount = 60 + Math.floor(buildingHeight * 20);

        for (let i = 0; i < dustCount; i++) {
            // 다양한 크기의 먼지
            const size = 0.02 + Math.random() * 0.04;
            const dustGeometry = new THREE.PlaneGeometry(size, size);
            const dustMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.08, 0.2, 0.6 + Math.random() * 0.2),
                transparent: true,
                opacity: 0.4 + Math.random() * 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const dust = new THREE.Mesh(dustGeometry, dustMaterial);

            // 건물 중심에서 시작
            const angle = Math.random() * Math.PI * 2;
            const startRadius = Math.random() * baseRadius * 0.3;
            dust.position.set(
                worldPos.x + Math.cos(angle) * startRadius,
                0.1 + Math.random() * buildingHeight * 0.3,
                worldPos.z + Math.sin(angle) * startRadius
            );

            // 바깥으로 퍼지는 속도 (수평으로 더 강하게)
            const outwardSpeed = 0.3 + Math.random() * 0.5;
            dust.userData.velocity = {
                x: Math.cos(angle) * outwardSpeed + (Math.random() - 0.5) * 0.2,
                y: Math.random() * 0.8 + 0.2,  // 위로 천천히
                z: Math.sin(angle) * outwardSpeed + (Math.random() - 0.5) * 0.2
            };

            // 빌보드 회전
            dust.userData.billboardOffset = Math.random() * Math.PI * 2;

            // 부유 특성 (작은 파티클은 더 오래 떠있음)
            dust.userData.floatFactor = 1 - size / 0.06;
            dust.userData.initialOpacity = dust.material.opacity;

            dustGroup.add(dust);
        }

        // 큰 먼지 덩어리 (잔해 느낌)
        const debrisCount = 8 + Math.floor(buildingHeight * 3);
        for (let i = 0; i < debrisCount; i++) {
            const size = 0.06 + Math.random() * 0.08;
            const debrisGeometry = new THREE.BoxGeometry(size, size * 0.5, size);
            const debrisMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.08, 0.15, 0.5 + Math.random() * 0.1),
                transparent: true,
                opacity: 0.6
            });

            const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
            const angle = Math.random() * Math.PI * 2;
            debris.position.set(
                worldPos.x + Math.cos(angle) * baseRadius * 0.2,
                0.2,
                worldPos.z + Math.sin(angle) * baseRadius * 0.2
            );

            debris.userData.velocity = {
                x: Math.cos(angle) * (0.5 + Math.random() * 0.8),
                y: 0.8 + Math.random() * 1.2,
                z: Math.sin(angle) * (0.5 + Math.random() * 0.8)
            };
            debris.userData.rotSpeed = {
                x: (Math.random() - 0.5) * 8,
                z: (Math.random() - 0.5) * 8
            };
            debris.userData.isDebris = true;
            debris.userData.initialOpacity = 0.6;

            dustGroup.add(debris);
        }

        scene.add(dustGroup);

        // 먼지 애니메이션
        const startTime = Date.now();
        const duration = 2500;  // 2.5초 (먼지는 천천히 사라짐)

        function animateDust() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);

            dustGroup.children.forEach(dust => {
                const vel = dust.userData.velocity;

                if (dust.userData.isDebris) {
                    // 잔해: 중력 + 바닥 충돌
                    vel.y -= 0.08;
                    dust.position.x += vel.x * 0.016;
                    dust.position.y += vel.y * 0.016;
                    dust.position.z += vel.z * 0.016;
                    dust.rotation.x += dust.userData.rotSpeed.x * 0.016;
                    dust.rotation.z += dust.userData.rotSpeed.z * 0.016;

                    if (dust.position.y < 0.02) {
                        dust.position.y = 0.02;
                        vel.y = 0;
                        vel.x *= 0.9;
                        vel.z *= 0.9;
                    }
                } else {
                    // 먼지: 공기 저항 + 부유
                    const floatFactor = dust.userData.floatFactor;

                    // 공기 저항 (속도 감소)
                    vel.x *= 0.98;
                    vel.z *= 0.98;

                    // 부유 효과 (작은 파티클은 위로 떠오름)
                    vel.y += (floatFactor * 0.01 - 0.005);
                    vel.y *= 0.97;

                    dust.position.x += vel.x * 0.016;
                    dust.position.y += vel.y * 0.016;
                    dust.position.z += vel.z * 0.016;

                    // 빌보드 (항상 카메라를 향함)
                    dust.lookAt(camera.position);

                    // 최소 높이
                    if (dust.position.y < 0.05) {
                        dust.position.y = 0.05;
                        vel.y = Math.abs(vel.y) * 0.3;
                    }
                }

                // 페이드아웃 (후반에 더 빠르게)
                const fadeStart = dust.userData.isDebris ? 0.5 : 0.3;
                if (progress > fadeStart) {
                    const fadeProgress = (progress - fadeStart) / (1 - fadeStart);
                    dust.material.opacity = dust.userData.initialOpacity * (1 - fadeProgress);
                }
            });

            if (progress < 1) {
                requestAnimationFrame(animateDust);
            } else {
                // 정리
                dustGroup.children.forEach(dust => {
                    dust.geometry.dispose();
                    dust.material.dispose();
                });
                scene.remove(dustGroup);
            }
        }

        animateDust();
    }

    // 도로 타일 낙하 애니메이션
    function animateRoadTileDrop(tileX, tileY) {
        const worldPos = tileToWorldCenter(tileX, tileY);
        const dropHeight = 1.5;  // 낙하 시작 높이
        const duration = 250;    // 애니메이션 시간 (ms)

        // 해당 위치의 도로 메시 찾기
        const tolerance = TILE_SIZE * 0.6;
        const meshesToAnimate = [];

        roadGroup.children.forEach(child => {
            if (child.isMesh || child.isGroup) {
                const dx = Math.abs(child.position.x - worldPos.x);
                const dz = Math.abs(child.position.z - worldPos.z);
                if (dx < tolerance && dz < tolerance) {
                    meshesToAnimate.push({
                        mesh: child,
                        targetY: child.position.y
                    });
                }
            }
        });

        // 메시들을 위로 올리고 애니메이션
        meshesToAnimate.forEach(item => {
            item.mesh.position.y += dropHeight;
        });

        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            const eased = 1 - Math.pow(1 - progress, 3);  // easeOutCubic

            meshesToAnimate.forEach(item => {
                item.mesh.position.y = item.targetY + dropHeight * (1 - eased);
            });

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        }

        if (meshesToAnimate.length > 0) {
            animate();
        }
    }

    // 순차적 도로 설치 (시작점 → 끝점, 낙하 + 먼지 이펙트 포함)
    function placeRoadsSequentially(tiles) {
        if (!tiles || tiles.length === 0) return;

        const delayPerTile = 50;  // 타일당 딜레이 (ms)
        let hasZoneChange = false;

        // 1단계: 모든 타일의 그리드 데이터 먼저 업데이트 (시각적 업데이트 없이)
        tiles.forEach((tile) => {
            // 해당 위치에 건물이 있으면 먼저 파괴
            removeBuildingAt(tile.x, tile.y, true);
            // 해당 위치에 나무가 있으면 제거
            removeTreeAt(tile.x, tile.y);

            // 기존 구역 지정 확인
            const wasZone = grid[tile.x][tile.y] === CELL.ZONE_RESIDENTIAL ||
                           grid[tile.x][tile.y] === CELL.ZONE_COMMERCIAL ||
                           grid[tile.x][tile.y] === CELL.ZONE_INDUSTRIAL;
            if (wasZone) hasZoneChange = true;

            // 그리드에 도로/다리 설치
            if (tile.type === 'bridge') {
                grid[tile.x][tile.y] = CELL.BRIDGE;
            } else {
                grid[tile.x][tile.y] = CELL.ROAD;
            }
        });

        // 2단계: 시각적 업데이트 한 번만 (최적화)
        rebuildRoadInstances();
        rebuildRoadModels();
        rebuildAllTiles();
        if (hasZoneChange) {
            rebuildZoneInstances(false);
        }

        // 3단계: 애니메이션은 순차적으로 (시각 효과용)
        tiles.forEach((tile, index) => {
            setTimeout(() => {
                // 낙하 애니메이션
                animateRoadTileDrop(tile.x, tile.y);

                // 먼지 이펙트 (낙하 후)
                setTimeout(() => {
                    createSingleTileDustEffect(tile.x, tile.y);
                }, 200);
            }, index * delayPerTile);
        });
    }

    // 순차적 수로 설치 (2x2 블록 기반)
    function placeWaterSequentially(tiles) {
        if (!tiles || tiles.length === 0) return;

        // 2x2 그리드로 스냅하고 중복 제거
        const placedOrigins = new Set();
        const waterBlocks = [];

        tiles.forEach(tile => {
            // 2x2 그리드로 스냅 (짝수 좌표로)
            const originX = Math.floor(tile.x / 2) * 2;
            const originY = Math.floor(tile.y / 2) * 2;
            const key = `${originX},${originY}`;

            if (!placedOrigins.has(key) && originX + 1 < GRID_W && originY + 1 < GRID_H) {
                placedOrigins.add(key);
                waterBlocks.push({ x: originX, y: originY });
            }
        });

        const delayPerBlock = 100;  // 블록당 딜레이 (ms)
        let hasZoneChange = false;

        // 1단계: 모든 블록의 그리드 데이터 먼저 업데이트 (시각적 업데이트 없이)
        waterBlocks.forEach((block) => {
            // 2x2 영역의 4개 셀 처리
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const x = block.x + dx;
                    const y = block.y + dy;

                    // 잠긴 셀, 기존 수로, 도로는 스킵
                    if (isLocked(x, y) || isRoad(x, y)) continue;

                    // 해당 위치에 건물이 있으면 먼저 파괴
                    removeBuildingAt(x, y, true);
                    // 해당 위치에 나무가 있으면 제거
                    removeTreeAt(x, y);

                    // 기존 구역 지정 확인
                    if (grid[x][y] === CELL.ZONE_RESIDENTIAL ||
                        grid[x][y] === CELL.ZONE_COMMERCIAL ||
                        grid[x][y] === CELL.ZONE_INDUSTRIAL) {
                        hasZoneChange = true;
                    }

                    // 그리드에 수로 설치
                    grid[x][y] = CELL.WATER;
                }
            }
        });

        // 2단계: 시각적 업데이트 한 번만 (최적화)
        rebuildAllTiles();
        if (hasZoneChange) {
            rebuildZoneInstances(false);
        }

        // 3단계: 애니메이션은 순차적으로 (시각 효과용)
        waterBlocks.forEach((block, index) => {
            setTimeout(() => {
                // 낙하 애니메이션 (2x2 블록용)
                animateWaterTileDrop(block.x, block.y);

                // 먼지 이펙트 (낙하 후)
                setTimeout(() => {
                    createSingleTileDustEffect(block.x, block.y);
                    createSingleTileDustEffect(block.x + 1, block.y);
                    createSingleTileDustEffect(block.x, block.y + 1);
                    createSingleTileDustEffect(block.x + 1, block.y + 1);
                }, 200);
            }, index * delayPerBlock);
        });
    }

    // 수로 타일 낙하 애니메이션 (2x2 블록 기반)
    function animateWaterTileDrop(tileX, tileY) {
        // 2x2 모델의 중심 위치 계산
        const worldX = (ORIGIN_X + tileX + 1) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + tileY + 1) * TILE_SIZE;
        const dropHeight = 1.5;  // 낙하 시작 높이
        const duration = 250;    // 애니메이션 시간 (ms)

        // 해당 위치의 수로/다리 메시 찾기
        const tolerance = TILE_SIZE * 1.2;  // 2x2 모델을 위해 tolerance 증가
        const meshesToAnimate = [];

        // waterGroup과 bridgeGroup에서 찾기
        [waterGroup, bridgeGroup].forEach(group => {
            group.children.forEach(child => {
                if (child.isMesh || child.isGroup) {
                    const dx = Math.abs(child.position.x - worldX);
                    const dz = Math.abs(child.position.z - worldZ);
                    if (dx < tolerance && dz < tolerance) {
                        meshesToAnimate.push({
                            mesh: child,
                            targetY: child.position.y
                        });
                    }
                }
            });
        });

        // 메시들을 위로 올리고 애니메이션
        meshesToAnimate.forEach(item => {
            item.mesh.position.y += dropHeight;
        });

        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            const eased = 1 - Math.pow(1 - progress, 3);  // easeOutCubic

            meshesToAnimate.forEach(item => {
                item.mesh.position.y = item.targetY + dropHeight * (1 - eased);
            });

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        }

        if (meshesToAnimate.length > 0) {
            animate();
        }
    }

    // 도로 건설 먼지 이펙트 (순차적으로 퍼지는 효과)
    function createRoadConstructionDustEffect(tiles) {
        if (!tiles || tiles.length === 0) return;

        const delayPerTile = 80;  // 타일당 딜레이 (ms)
        const dustPerTile = 15;   // 타일당 먼지 파티클 수

        tiles.forEach((tile, index) => {
            setTimeout(() => {
                createSingleTileDustEffect(tile.x, tile.y);
            }, index * delayPerTile);
        });
    }

    // 단일 타일 먼지 이펙트
    function createSingleTileDustEffect(tileX, tileY) {
        const worldPos = tileToWorldCenter(tileX, tileY);
        const dustGroup = new THREE.Group();
        const dustCount = 12;

        for (let i = 0; i < dustCount; i++) {
            // 먼지 파티클 크기
            const size = 0.03 + Math.random() * 0.05;
            const dustGeometry = new THREE.PlaneGeometry(size, size);
            const dustMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.08, 0.15, 0.55 + Math.random() * 0.15),  // 황토색
                transparent: true,
                opacity: 0.5 + Math.random() * 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const dust = new THREE.Mesh(dustGeometry, dustMaterial);

            // 타일 중심 근처에서 시작
            const angle = Math.random() * Math.PI * 2;
            const startRadius = Math.random() * 0.2;
            dust.position.set(
                worldPos.x + Math.cos(angle) * startRadius,
                0.02 + Math.random() * 0.05,
                worldPos.z + Math.sin(angle) * startRadius
            );

            // 바깥으로 퍼지며 위로 올라가는 속도
            const outwardSpeed = 0.15 + Math.random() * 0.25;
            dust.userData.velocity = {
                x: Math.cos(angle) * outwardSpeed + (Math.random() - 0.5) * 0.1,
                y: 0.4 + Math.random() * 0.6,  // 위로 솟구침
                z: Math.sin(angle) * outwardSpeed + (Math.random() - 0.5) * 0.1
            };

            dust.userData.initialOpacity = dust.material.opacity;
            dust.userData.rotSpeed = (Math.random() - 0.5) * 3;

            dustGroup.add(dust);
        }

        scene.add(dustGroup);

        // 애니메이션
        const startTime = Date.now();
        const duration = 800;  // 0.8초

        function animateDust() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);

            dustGroup.children.forEach(dust => {
                const vel = dust.userData.velocity;

                // 중력 효과
                vel.y -= 0.04;

                // 공기 저항
                vel.x *= 0.96;
                vel.z *= 0.96;
                vel.y *= 0.96;

                dust.position.x += vel.x * 0.016;
                dust.position.y += vel.y * 0.016;
                dust.position.z += vel.z * 0.016;

                // 최소 높이
                if (dust.position.y < 0.02) {
                    dust.position.y = 0.02;
                    vel.y = 0;
                }

                // 빌보드 효과
                dust.lookAt(camera.position);

                // 페이드아웃
                if (progress > 0.3) {
                    const fadeProgress = (progress - 0.3) / 0.7;
                    dust.material.opacity = dust.userData.initialOpacity * (1 - fadeProgress);
                }
            });

            if (progress < 1) {
                requestAnimationFrame(animateDust);
            } else {
                // 정리
                dustGroup.children.forEach(dust => {
                    dust.geometry.dispose();
                    dust.material.dispose();
                });
                scene.remove(dustGroup);
            }
        }

        animateDust();
    }

    // 4차선 도로 건설 먼지 이펙트 (2x2 영역)
    function create4LaneConstructionDustEffect(origins) {
        if (!origins || origins.length === 0) return;

        const delayPerOrigin = 120;  // 원점당 딜레이 (ms)

        origins.forEach((origin, index) => {
            setTimeout(() => {
                // 2x2 영역의 중심에서 먼지 생성
                create4LaneSingleDustEffect(origin.x, origin.y);
            }, index * delayPerOrigin);
        });
    }

    // 4차선 도로 단일 원점 먼지 이펙트
    function create4LaneSingleDustEffect(originX, originY) {
        // 2x2 영역의 중심 계산
        const tile1 = tileToWorldCenter(originX, originY);
        const tile2 = tileToWorldCenter(originX + 1, originY + 1);
        const centerX = (tile1.x + tile2.x) / 2;
        const centerZ = (tile1.z + tile2.z) / 2;

        const dustGroup = new THREE.Group();
        const dustCount = 25;  // 4차선은 더 많은 먼지

        for (let i = 0; i < dustCount; i++) {
            const size = 0.04 + Math.random() * 0.06;
            const dustGeometry = new THREE.PlaneGeometry(size, size);
            const dustMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.08, 0.15, 0.55 + Math.random() * 0.15),
                transparent: true,
                opacity: 0.5 + Math.random() * 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const dust = new THREE.Mesh(dustGeometry, dustMaterial);

            // 2x2 영역 전체에서 랜덤 시작
            const angle = Math.random() * Math.PI * 2;
            const startRadius = Math.random() * 0.5;
            dust.position.set(
                centerX + Math.cos(angle) * startRadius,
                0.02 + Math.random() * 0.08,
                centerZ + Math.sin(angle) * startRadius
            );

            const outwardSpeed = 0.2 + Math.random() * 0.35;
            dust.userData.velocity = {
                x: Math.cos(angle) * outwardSpeed + (Math.random() - 0.5) * 0.15,
                y: 0.5 + Math.random() * 0.8,
                z: Math.sin(angle) * outwardSpeed + (Math.random() - 0.5) * 0.15
            };

            dust.userData.initialOpacity = dust.material.opacity;

            dustGroup.add(dust);
        }

        scene.add(dustGroup);

        const startTime = Date.now();
        const duration = 1000;  // 1초

        function animateDust() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);

            dustGroup.children.forEach(dust => {
                const vel = dust.userData.velocity;

                vel.y -= 0.035;
                vel.x *= 0.95;
                vel.z *= 0.95;
                vel.y *= 0.95;

                dust.position.x += vel.x * 0.016;
                dust.position.y += vel.y * 0.016;
                dust.position.z += vel.z * 0.016;

                if (dust.position.y < 0.02) {
                    dust.position.y = 0.02;
                    vel.y = 0;
                }

                dust.lookAt(camera.position);

                if (progress > 0.4) {
                    const fadeProgress = (progress - 0.4) / 0.6;
                    dust.material.opacity = dust.userData.initialOpacity * (1 - fadeProgress);
                }
            });

            if (progress < 1) {
                requestAnimationFrame(animateDust);
            } else {
                dustGroup.children.forEach(dust => {
                    dust.geometry.dispose();
                    dust.material.dispose();
                });
                scene.remove(dustGroup);
            }
        }

        animateDust();
    }

    // 철거 애니메이션 (건물이 아래로 꺼지며 무너짐)
    function animateDemolish(building, onComplete) {
        const instance = building.instance;
        if (!instance) {
            onComplete();
            return;
        }

        // 건물 높이 계산
        const bbox = new THREE.Box3().setFromObject(instance);
        const buildingHeight = bbox.max.y - bbox.min.y;

        // 먼지 이펙트 시작
        createDemolishDustEffect(building.x, building.y, building.width || 1, building.depth || 1, buildingHeight);

        // 카메라 흔들림
        if (typeof triggerCameraShake === 'function') {
            triggerCameraShake(0.1, 400);
        }

        const startY = instance.position.y;
        const targetY = startY - buildingHeight - 0.5;  // 지면 아래로
        const startTime = Date.now();
        const duration = 1500;  // 1.5초 (천천히 무너짐)

        // 초기 스케일 저장
        const startScaleX = instance.scale.x;
        const startScaleZ = instance.scale.z;

        // 기울어지는 방향 고정 (랜덤으로 한 번만 결정)
        const tiltDirX = Math.random() > 0.5 ? 1 : -1;
        const tiltDirZ = Math.random() > 0.5 ? 1 : -1;

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);

            // easeInQuad (가속)
            const eased = progress * progress;

            // 아래로 꺼짐
            instance.position.y = startY + (targetY - startY) * eased;

            // 약간 찌그러짐 (무너지는 느낌)
            instance.scale.x = startScaleX * (1 + eased * 0.1);
            instance.scale.z = startScaleZ * (1 + eased * 0.1);

            // 약간 기울어짐 (고정된 방향으로)
            instance.rotation.x = eased * 0.1 * tiltDirX;
            instance.rotation.z = eased * 0.1 * tiltDirZ;

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                onComplete();
            }
        }

        animate();
    }

    // 확장 모듈 (터빈/패널) 철거 애니메이션 (건물처럼 가라앉으며 먼지 효과)
    function animateExpansionDemolish(expansion, delay = 0) {
        const instance = expansion.instance;
        if (!instance) return;

        setTimeout(() => {
            // 건물 높이 계산
            const bbox = new THREE.Box3().setFromObject(instance);
            const height = bbox.max.y - bbox.min.y;

            // 먼지 이펙트 시작
            createDemolishDustEffect(expansion.x, expansion.y, expansion.width || 3, expansion.depth || 1, height);

            // 카메라 흔들림 (건물보다 약하게)
            if (typeof triggerCameraShake === 'function') {
                triggerCameraShake(0.08, 300);
            }

            const startY = instance.position.y;
            const targetY = startY - height - 0.5;  // 지면 아래로 완전히 가라앉음
            const startTime = Date.now();
            const duration = 1200;  // 1.2초 (건물처럼 천천히)

            const startScaleX = instance.scale.x;
            const startScaleZ = instance.scale.z;
            const tiltDirX = Math.random() > 0.5 ? 1 : -1;
            const tiltDirZ = Math.random() > 0.5 ? 1 : -1;

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / duration);

                // easeInQuad (가속하며 가라앉음)
                const eased = progress * progress;

                // 아래로 꺼짐
                instance.position.y = startY + (targetY - startY) * eased;

                // 약간 찌그러짐 (무너지는 느낌)
                instance.scale.x = startScaleX * (1 + eased * 0.1);
                instance.scale.z = startScaleZ * (1 + eased * 0.1);

                // 약간 기울어짐
                instance.rotation.x = eased * 0.1 * tiltDirX;
                instance.rotation.z = eased * 0.1 * tiltDirZ;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // 씬에서 제거 및 메모리 해제
                    scene.remove(instance);
                    disposeObject3D(instance);
                    // 잔디 타일 복구
                    for (let dx = 0; dx < (expansion.width || 3); dx++) {
                        for (let dy = 0; dy < (expansion.depth || 1); dy++) {
                            addGrassTileAt(expansion.x + dx, expansion.y + dy);
                        }
                    }
                }
            }
            animate();
        }, delay);
    }

    function removeBuildingAt(gx, gy, skipRebuild = false) {
        const building = findBuildingAt(gx, gy);
        if (!building || !building.instance) return false;

        // 이미 철거 중이면 무시
        const buildingKey = `${building.x},${building.y}`;
        if (demolishingBuildings.has(buildingKey)) return false;
        demolishingBuildings.add(buildingKey);

        // 업그레이드 대기 중이면 취소
        cancelUpgradeTimer(buildingKey);

        // 선택된 건물이면 팝업과 아웃라인 제거
        if (selectedBuilding === building.instance) {
            hideBuildingPopup();
            clearBuildingOutline();
            selectedBuilding = null;
        }
        // 철거 하이라이트 제거
        if (building.instance && demolishHighlightedObject === building.instance) {
            clearDemolishHighlight();
        }

        // 건물이 차지하던 모든 타일 정보 저장 (재건축용)
        const { x, y, width, depth, instance } = building;
        const zoneTiles = [];

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const tx = x + dx;
                const ty = y + dy;
                // 구역인 경우 재건축 대기 목록에 추가
                if (isZone(tx, ty)) {
                    zoneTiles.push({ x: tx, y: ty, zoneType: grid[tx][ty] });
                }
            }
        }

        // 모든 상태 아이콘 제거 (통합 시스템)
        clearAllBuildingStatuses(x, y);

        // 화재 제거 (있는 경우)
        if (burningBuildings.has(buildingKey)) {
            extinguishFire(buildingKey);
        }

        // 폐건물 목록에서 제거
        abandonedBuildings.delete(buildingKey);

        // 도로 끊김 목록 및 타이머 제거
        disconnectedBuildings.delete(buildingKey);
        buildingRoadDisconnectTime.delete(buildingKey);
        buildingRoadAbandonTime.delete(buildingKey);

        // 위치 추적에서 제거
        const primaryKey = `${building.x},${building.y}`;
        for (const tileKey of building.tiles) {
            placedBuildings.delete(tileKey);
        }
        placedBuildings.delete(primaryKey);
        invalidateBuildingsCache();  // 건물 배열 캐시 무효화

        // 철거 애니메이션 시작
        animateDemolish(building, () => {
            // 애니메이션 완료 후 씬에서 제거 및 메모리 해제
            buildingGroup.remove(instance);
            disposeObject3D(instance);

            // 잔디 타일 복구 (시각적)
            for (let dx = 0; dx < width; dx++) {
                for (let dy = 0; dy < depth; dy++) {
                    addGrassTileAt(x + dx, y + dy);
                }
            }

            // 철거 완료
            demolishingBuildings.delete(buildingKey);

            // 교통 시스템에 건물 변경 알림
            if (trafficManager.initialized) {
                trafficManager.onBuildingChange();
            }

            // 구역인 경우 새 건물 입주 예약 (1.5초 후)
            if (!skipRebuild && zoneTiles.length > 0) {
                setTimeout(() => {
                    scheduleZoneRebuild(zoneTiles);
                }, 1500);
            }
        });

        return true;
    }

    // 기존 removeBuildingAt 즉시 제거 버전 (내부용)
    function removeBuildingAtInstant(gx, gy, skipRebuild = false) {
        const building = findBuildingAt(gx, gy);
        if (!building || !building.instance) return false;

        // 업그레이드 대기 중이면 취소
        const buildingKey = `${building.x},${building.y}`;
        cancelUpgradeTimer(buildingKey);

        // 선택된 건물이면 팝업과 아웃라인 제거
        if (selectedBuilding === building.instance) {
            hideBuildingPopup();
            clearBuildingOutline();
            selectedBuilding = null;
        }
        // 철거 하이라이트 제거
        if (building.instance && demolishHighlightedObject === building.instance) {
            clearDemolishHighlight();
        }

        // 씬에서 즉시 제거 및 메모리 해제
        buildingGroup.remove(building.instance);
        disposeObject3D(building.instance);

        // 건물이 차지하던 모든 타일 정보 저장 (재건축용)
        const { x, y, width, depth } = building;
        const zoneTiles = [];

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const tx = x + dx;
                const ty = y + dy;
                // 잔디 타일 복구 (시각적)
                addGrassTileAt(tx, ty);
                // 구역인 경우 재건축 대기 목록에 추가
                if (isZone(tx, ty)) {
                    zoneTiles.push({ x: tx, y: ty, zoneType: grid[tx][ty] });
                }
            }
        }

        // 모든 상태 아이콘 제거 (통합 시스템)
        clearAllBuildingStatuses(x, y);

        // 화재 제거 (있는 경우)
        if (burningBuildings.has(buildingKey)) {
            extinguishFire(buildingKey);
        }

        // 폐건물 목록에서 제거
        abandonedBuildings.delete(buildingKey);

        // 도로 끊김 목록 및 타이머 제거
        disconnectedBuildings.delete(buildingKey);
        buildingRoadDisconnectTime.delete(buildingKey);
        buildingRoadAbandonTime.delete(buildingKey);

        // 위치 추적에서 제거
        const primaryKey = `${building.x},${building.y}`;
        for (const tileKey of building.tiles) {
            placedBuildings.delete(tileKey);
        }
        placedBuildings.delete(primaryKey);
        invalidateBuildingsCache();  // 건물 배열 캐시 무효화

        // 교통 시스템에 건물 변경 알림
        if (trafficManager.initialized) {
            trafficManager.onBuildingChange();
        }

        // 구역인 경우 새 건물 입주 예약 (1.5초 후)
        if (!skipRebuild && zoneTiles.length > 0) {
            setTimeout(() => {
                scheduleZoneRebuild(zoneTiles);
            }, 1500);
        }

        return true;
    }

    // 빈 구역 타일에 새 건물 건설 예약
    function scheduleZoneRebuild(zoneTiles) {
        for (const tile of zoneTiles) {
            const { x, y, zoneType } = tile;

            // 타일이 여전히 해당 구역인지 확인 (도로나 수로로 바뀌었을 수 있음)
            if (grid[x][y] !== zoneType) continue;

            // 이미 건물이 있으면 스킵 (민간 건물)
            if (hasBuildingAt(x, y)) continue;

            // 공공시설이 있으면 스킵
            if (placedPublicBuildings.has(`${x},${y}`)) continue;

            // 이미 공사 중이면 스킵
            if (constructionSites.has(`${x},${y}`)) continue;
            const tier = getTierByLandValue(x, y);
            let buildingNames = getBuildingsForZone(zoneType, tier, "1x1");

            // 건물이 없으면 다른 티어 시도
            if (buildingNames.length === 0) {
                const otherTier = tier === TIER.MIDDLE ? TIER.HIGH : TIER.MIDDLE;
                buildingNames = getBuildingsForZone(zoneType, otherTier, "1x1");
            }

            // 여전히 없으면 Filler 사용
            if (buildingNames.length === 0) {
                let fillerName = null;
                if (zoneType === CELL.ZONE_RESIDENTIAL) fillerName = 'Filler_Residential';
                else if (zoneType === CELL.ZONE_COMMERCIAL) fillerName = 'Filler_Commercial';
                else if (zoneType === CELL.ZONE_INDUSTRIAL) fillerName = 'Filler_Industrial';
                if (fillerName && buildingPrefabs[fillerName]) {
                    buildingNames = [fillerName];
                }
            }

            if (buildingNames.length === 0) continue;

            // 랜덤 건물 선택
            const idx = (x * 7 + y * 13) % buildingNames.length;
            const buildingName = buildingNames[idx];
            const building = buildingPrefabs[buildingName];
            if (!building) continue;

            // 잔디 타일 제거 (공사 시작 전)
            removeGrassTileAt(x, y);

            // 공사 예약 (정착 차량 + 건설 애니메이션)
            queueConstruction(x, y, zoneType, 1, 1, building, buildingName);
        }
    }

    // 특정 위치에 건물이 있는지 확인
    function hasBuildingAt(gx, gy) {
        return findBuildingAt(gx, gy) !== null;
    }

    // 모든 건물 재구성
    // restoreOnlyFromSaved = true: 저장된 건물만 복원 (로드 시)
    // restoreOnlyFromSaved = false: 모든 구역에 건물 자동 생성 (게임 중 구역 변경 시)
    function rebuildAllBuildings(restoreOnlyFromSaved = false) {
        // 기존 건물 제거
        while (buildingGroup.children.length > 0) {
            buildingGroup.remove(buildingGroup.children[0]);
        }
        // 위치 추적 초기화
        placedBuildings.clear();
        invalidateBuildingsCache();  // 건물 배열 캐시 무효화
        // 기존 인구 데이터 초기화 (건물이 삭제될 수 있으므로)
        buildingPopulations.clear();

        // 건물 모델이 로드되지 않았으면 스킵
        if (Object.keys(buildingPrefabs).length === 0) {
            console.warn('Building prefabs not loaded yet');
            return;
        }

        // === 저장된 건물만 복원 모드 ===
        if (restoreOnlyFromSaved && savedBuildingsData && savedBuildingsData.length > 0) {
            console.log(`Restoring ${savedBuildingsData.length} saved buildings...`);

            for (const savedBuilding of savedBuildingsData) {
                const { x, y, width, depth, zoneType: savedZoneType, level, tier, isAbandoned, population, prefabName: savedPrefabName, displayName: savedDisplayName } = savedBuilding;

                // 범위 확인
                if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) {
                    console.log(`Skipping building at (${x},${y}) - out of bounds`);
                    continue;
                }

                // 구역 타입 결정 (저장된 zoneType 우선 사용)
                let zoneStr = savedZoneType;
                const cellType = grid[x][y];

                // 저장된 zoneType이 없으면 현재 그리드에서 확인
                if (!zoneStr) {
                    if (cellType !== CELL.ZONE_RESIDENTIAL &&
                        cellType !== CELL.ZONE_COMMERCIAL &&
                        cellType !== CELL.ZONE_INDUSTRIAL) {
                        console.log(`Skipping building at (${x},${y}) - not a zone cell and no saved zoneType`);
                        continue;
                    }
                    zoneStr = getZoneTypeString(cellType);
                }

                const buildingTier = tier || (width === 2 ? TIER.HIGH : TIER.MIDDLE);
                const size = width === 2 ? "2x2" : "1x1";

                let buildingName = savedPrefabName;
                let building = savedPrefabName ? buildingPrefabs[savedPrefabName] : null;

                // 저장된 prefabName이 없거나 해당 건물이 없으면 폴백
                if (!building) {
                    // 해당 티어와 사이즈의 건물 목록 가져오기 (zoneStr 사용)
                    let buildingNames = getBuildingsForZone(zoneStr, buildingTier, size);
                    if (buildingNames.length === 0) {
                        // 다른 티어 시도
                        const otherTier = buildingTier === TIER.HIGH ? TIER.MIDDLE : TIER.HIGH;
                        buildingNames = getBuildingsForZone(zoneStr, otherTier, size);
                    }

                    if (buildingNames.length === 0) {
                        console.warn(`No building found for zone at (${x},${y})`);
                        continue;
                    }

                    // 위치 기반 선택 (일관된 결과를 위해)
                    const idx = (x * 11 + y * 17) % buildingNames.length;
                    buildingName = buildingNames[idx];
                    building = buildingPrefabs[buildingName];
                }

                if (!building) {
                    console.warn(`Building prefab not found: ${buildingName}`);
                    continue;
                }

                // placement 객체 생성
                const placement = {
                    building,
                    prefabName: buildingName,  // 건물 모델 이름 저장
                    displayName: savedDisplayName || getBuildingDisplayName(buildingName),  // 건물 표시 이름
                    x,
                    y,
                    width: width || 1,
                    depth: depth || 1,
                    zoneStr,
                    size
                };

                addBuildingInstance(placement);

                // 저장된 인구 복원 (주거 건물만)
                if (zoneStr && zoneStr.includes('residential') && population > 0) {
                    const key = getBuildingKey(x, y, size);
                    buildingPopulations.set(key, population);
                }
            }

            console.log(`Buildings restored: ${buildingGroup.children.length} buildings placed`);
        } else if (!restoreOnlyFromSaved) {
            // === 기존 동작: 모든 구역에 건물 자동 생성 ===
            // 구역 블록 찾기
            const blocks = findZoneBlocks();

            // 각 블록에 건물 배치
            for (const block of blocks) {
                const placements = placeBuildingsInBlock(block);

                for (const placement of placements) {
                    addBuildingInstance(placement);

                    // 주거 건물에 인구 배정
                    if (placement.zoneStr && placement.zoneStr.includes('residential')) {
                        const key = getBuildingKey(placement.x, placement.y, placement.size);
                        assignBuildingPopulation(key, placement.size);
                    }
                }
            }

            console.log(`Buildings rebuilt: ${buildingGroup.children.length} buildings placed`);
        }

        // 총 인구 계산 및 업데이트
        cityStats.population = calculateTotalPopulation();
        updateStatsDisplay();

        // 교통 시스템에 건물 변경 알림
        if (trafficManager.initialized) {
            trafficManager.onBuildingChange();
        }
    }

    /* =========================================================
     * CONSTRUCTION SYSTEM
     * ========================================================= */

    // 시외 스폰 지점 (하단 경계도로 양 끝)
    const cityEntryPoints = {
        left: null,   // 왼쪽 끝
        right: null   // 오른쪽 끝
    };

    // 시외 진입 지점 초기화 - 하단 경계도로 양 끝
    function initCityEntryPoints() {
        // 왼쪽 끝 (x=0, y=GRID_H-1)
        cityEntryPoints.left = { x: 0, y: GRID_H - 1 };
        // 오른쪽 끝 (x=GRID_W-1, y=GRID_H-1)
        cityEntryPoints.right = { x: GRID_W - 1, y: GRID_H - 1 };
        console.log(`City entry points set: left(${cityEntryPoints.left.x},${cityEntryPoints.left.y}), right(${cityEntryPoints.right.x},${cityEntryPoints.right.y})`);
    }

    // 랜덤 스폰 지점 반환 (양 끝 중 하나)
    function findCityEntryPoint() {
        if (!cityEntryPoints.left) initCityEntryPoints();
        return Math.random() < 0.5 ? cityEntryPoints.left : cityEntryPoints.right;
    }

    // 특정 방향 스폰 지점 반환
    function getCityEntryPoint(side = 'random') {
        if (!cityEntryPoints.left) initCityEntryPoints();
        if (side === 'left') return cityEntryPoints.left;
        if (side === 'right') return cityEntryPoints.right;
        return findCityEntryPoint();  // random
    }

    // 시외 스폰 지점 초기화 (도로 변경 시 호출)
    function resetCityEntryPoint() {
        cityEntryPoints.left = null;
        cityEntryPoints.right = null;
    }

    // 외곽 도로(LOCKED_ROAD) - 랜덤 시외 진입 지점 반환
    function findRandomLockedRoad() {
        return findCityEntryPoint();
    }

    // 건설 트럭 스폰 대기열 (동시 스폰 방지)
    const constructionTruckQueue = [];
    let isProcessingTruckQueue = false;
    const TRUCK_SPAWN_INTERVAL = 2000;  // 트럭 간 스폰 간격 (2초)

    // 공사 현장 대기열에 추가 (차량 도착 후 공사 시작)
    // 타일이 외곽 도로와 연결된 도로에 인접해 있는지 확인
    function isTileAdjacentToConnectedRoad(x, y, width = 1, depth = 1) {
        const directions = [ [0, 1], [0, -1], [1, 0], [-1, 0] ];

        // 건물이 차지할 모든 타일의 주변 체크
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const tx = x + dx;
                const ty = y + dy;

                for (const [ddx, ddy] of directions) {
                    const nx = tx + ddx;
                    const ny = ty + ddy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const roadKey = `${nx},${ny}`;
                    if (connectedRoads.has(roadKey)) {
                        return true;  // 외곽 도로와 연결된 도로에 인접
                    }
                }
            }
        }
        return false;
    }

    function queueConstruction(x, y, zoneType, width, depth, building, prefabName = null) {
        const key = `${x},${y}`;

        // 이미 공사 중인지 확인
        if (constructionSites.has(key)) {
            console.log(`Construction already queued at (${x},${y})`);
            return;
        }

        // 외곽 도로와 연결된 도로에 인접해 있는지 확인
        // connectedRoads가 아직 초기화되지 않았으면 먼저 업데이트
        if (connectedRoads.size === 0) {
            findConnectedRoads();
        }
        if (!isTileAdjacentToConnectedRoad(x, y, width, depth)) {
            console.log(`Construction blocked at (${x},${y}) - not adjacent to connected road`);
            return;
        }

        const constructionData = {
            x, y, width, depth,
            zoneType,
            state: CONSTRUCTION_STATE.WAITING_VEHICLE,
            vehicleId: null,
            startTime: null,
            duration: CONSTRUCTION_DURATION,
            building,  // 완성될 건물 prefab 정보
            prefabName,  // 건물 모델 이름 (저장용)
            constructionInstance: null,  // 공사 오브젝트 (3D)
            zoneStr: getZoneTypeString(zoneType),
            size: width === 2 ? "2x2" : "1x1",
            scheduledSpawnTime: Date.now()
        };

        constructionSites.set(key, constructionData);
        console.log(`Construction queued at (${x},${y}) - ${constructionData.zoneStr}, waiting for vehicle`);

        // 건설 트럭 대기열에 추가
        constructionTruckQueue.push(constructionData);
        processConstructionTruckQueue();
    }

    // 건설 트럭 스폰 대기열 처리 (순차적으로 스폰)
    function processConstructionTruckQueue() {
        if (isProcessingTruckQueue || constructionTruckQueue.length === 0) return;

        isProcessingTruckQueue = true;
        const constructionData = constructionTruckQueue.shift();

        // 공사 현장이 여전히 존재하는지 확인
        const key = `${constructionData.x},${constructionData.y}`;
        if (!constructionSites.has(key)) {
            isProcessingTruckQueue = false;
            processConstructionTruckQueue();
            return;
        }

        spawnConstructionTruck(constructionData);

        // 다음 트럭 스폰까지 대기
        setTimeout(() => {
            isProcessingTruckQueue = false;
            processConstructionTruckQueue();
        }, TRUCK_SPAWN_INTERVAL);
    }

    // 공사 자재 트럭 스폰 (시외 → 공사 현장)
    function spawnConstructionTruck(constructionData) {
        // 교통 시스템 초기화 대기
        if (!trafficManager.initialized) {
            console.log('Traffic not initialized, retrying truck spawn...');
            setTimeout(() => spawnConstructionTruck(constructionData), 1000);
            return;
        }

        // 1. 시외(외곽 도로)에서 스폰 위치 선택
        const spawnRoad = findRandomLockedRoad();
        if (!spawnRoad) {
            console.warn('No locked road found for truck spawn');
            startConstruction(constructionData);
            return;
        }

        // 스폰 위치에 다른 차량이 있으면 재시도 (큐에 다시 추가)
        if (trafficManager.isSpawnBlocked(spawnRoad.x, spawnRoad.y)) {
            setTimeout(() => spawnConstructionTruck(constructionData), 500);
            return;
        }

        // 2. 공사 현장 인접 도로 찾기
        const destRoad = trafficManager.findNearestRoad(constructionData.x, constructionData.y);
        if (!destRoad) {
            console.warn('No road near construction site');
            startConstruction(constructionData);
            return;
        }

        // 3. 경로 찾기
        const path = trafficManager.findPath(spawnRoad.x, spawnRoad.y, destRoad.x, destRoad.y);
        if (!path || path.length < 2) {
            console.warn('No path to construction site');
            startConstruction(constructionData);
            return;
        }

        // 4. 트럭 스폰
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) {
            console.warn('No vehicle available for construction truck');
            startConstruction(constructionData);
            return;
        }

        // 이전 사용에서 남은 속성 초기화
        vehicle.isFiretruck = false;
        vehicle.isMoveInVehicle = false;
        vehicle.fireTarget = null;
        vehicle.isReturning = false;
        vehicle.originStation = null;
        vehicle.stationKey = null;
        vehicle.workStartTime = null;
        vehicle.isParked = false;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 트럭 타입으로 설정
        vehicle.vehicleTypeKey = 'truck';
        vehicle.type = 'truck';
        const vehicleTypeConfig = VEHICLE_TYPES['truck'];

        // 트럭 메쉬로 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh('truck');
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 공사 트럭 특수 속성
        vehicle.isConstructionTruck = true;
        vehicle.constructionSite = constructionData;
        vehicle.originBuilding = null;
        vehicle.destBuilding = null;
        vehicle.activity = '🚚 공사 자재를 운반 중...';
        vehicle.originTypeName = '시외';
        vehicle.destTypeName = '건설현장';

        // 속도 설정
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * (vehicleTypeConfig?.speedMultiplier || 0.8);
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        // 공사 데이터에 차량 ID 연결
        constructionData.vehicleId = vehicle.id;

        console.log(`Construction truck ${vehicle.id} spawned for site at (${constructionData.x},${constructionData.y})`);
    }

    // 입주 차량 스폰 대기열 (동시 스폰 방지)
    const moveInVehicleQueue = [];
    let isProcessingMoveInQueue = false;
    const MOVE_IN_SPAWN_INTERVAL = 1500;  // 입주 차량 간 스폰 간격 (1.5초)

    // 입주 차량 대기열에 추가
    function queueMoveInVehicle(buildingX, buildingY, buildingSize) {
        // 랜덤 딜레이 추가 (1초 ~ 5초)
        const randomDelay = 1000 + Math.random() * 4000;
        setTimeout(() => {
            moveInVehicleQueue.push({ buildingX, buildingY, buildingSize });
            processMoveInVehicleQueue();
        }, randomDelay);
    }

    // 입주 차량 대기열 처리
    function processMoveInVehicleQueue() {
        if (isProcessingMoveInQueue || moveInVehicleQueue.length === 0) return;

        isProcessingMoveInQueue = true;
        const data = moveInVehicleQueue.shift();

        spawnMoveInVehicleImmediate(data.buildingX, data.buildingY, data.buildingSize);

        // 다음 차량 스폰까지 대기
        setTimeout(() => {
            isProcessingMoveInQueue = false;
            processMoveInVehicleQueue();
        }, MOVE_IN_SPAWN_INTERVAL);
    }

    // 입주 차량 스폰 (시외 → 완공된 주거지) - 대기열용
    function spawnMoveInVehicle(buildingX, buildingY, buildingSize) {
        queueMoveInVehicle(buildingX, buildingY, buildingSize);
    }

    // 입주 차량 즉시 스폰 (내부 함수)
    function spawnMoveInVehicleImmediate(buildingX, buildingY, buildingSize) {
        if (!trafficManager.initialized) {
            console.log('Traffic not initialized, retrying move-in vehicle spawn...');
            setTimeout(() => spawnMoveInVehicleImmediate(buildingX, buildingY, buildingSize), 1000);
            return;
        }

        // 1. 시외(외곽 도로)에서 스폰
        const spawnRoad = findRandomLockedRoad();
        if (!spawnRoad) return;

        // 스폰 위치에 다른 차량이 있으면 재시도
        if (trafficManager.isSpawnBlocked(spawnRoad.x, spawnRoad.y)) {
            setTimeout(() => spawnMoveInVehicleImmediate(buildingX, buildingY, buildingSize), 500);
            return;
        }

        // 2. 건물 인접 도로 찾기
        const destRoad = trafficManager.findNearestRoad(buildingX, buildingY);
        if (!destRoad) return;

        // 3. 경로 찾기
        const path = trafficManager.findPath(spawnRoad.x, spawnRoad.y, destRoad.x, destRoad.y);
        if (!path || path.length < 2) return;

        // 4. 승용차 스폰 (패밀리카 또는 SUV)
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) return;

        // 이전 사용에서 남은 속성 초기화
        vehicle.isFiretruck = false;
        vehicle.isConstructionTruck = false;
        vehicle.constructionSite = null;
        vehicle.fireTarget = null;
        vehicle.isReturning = false;
        vehicle.originStation = null;
        vehicle.stationKey = null;
        vehicle.workStartTime = null;
        vehicle.isParked = false;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 승용차 타입 랜덤 선택 (패밀리카, SUV, 캠핑카 중)
        const passengerTypes = ['old', 'jeep', 'camper'];
        const vehicleTypeKey = passengerTypes[Math.floor(Math.random() * passengerTypes.length)];
        vehicle.vehicleTypeKey = vehicleTypeKey;
        vehicle.type = vehicleTypeKey;
        const vehicleTypeConfig = VEHICLE_TYPES[vehicleTypeKey];

        // 메쉬 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh(vehicleTypeKey);
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 헤드라이트 재연결 (있으면)
        if (vehicle.headlight) {
            newMesh.add(vehicle.headlight);
            const hour = (timeState.gameTime / 3600) % 24;
            vehicle.headlight.visible = (hour >= 19 || hour < 6);
        }

        // 입주 차량 속성
        vehicle.isMoveInVehicle = true;
        vehicle.originBuilding = null;
        vehicle.destBuilding = { x: buildingX, y: buildingY };
        vehicle.activity = '🏠 새 집으로 이사 가는 중!';
        vehicle.originTypeName = '시외';
        vehicle.destTypeName = '새 집';

        // 속도 설정
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * (vehicleTypeConfig?.speedMultiplier || 1.0);
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        console.log(`Move-in vehicle (${vehicleTypeKey}) spawned for new home at (${buildingX},${buildingY})`);
    }

    // 입주 프로세스 시작 (건물 완성 후 호출)
    function startMoveInProcess(buildingX, buildingY, buildingSize, buildingTier) {
        const key = `${buildingX},${buildingY}`;

        // 건물 레벨 키 생성 (예: "2x2_mid")
        const tierStr = buildingTier || 'low';
        const capacityKey = `${buildingSize}_${tierStr}`;
        const capacity = BUILDING_CAPACITY[capacityKey] || 2;

        pendingMoveIns.set(key, {
            capacity: capacity,
            movedIn: 0,
            buildingX: buildingX,
            buildingY: buildingY,
            size: buildingSize,
            tier: tierStr
        });

        console.log(`Move-in process started at (${buildingX},${buildingY}) - capacity: ${capacity} families`);
    }

    // 입주 차량 도착 시 호출
    function onMoveInArrival(buildingX, buildingY) {
        const key = `${buildingX},${buildingY}`;
        const moveInData = pendingMoveIns.get(key);

        if (!moveInData) return;

        moveInData.movedIn++;
        console.log(`Family moved in at (${buildingX},${buildingY}) - ${moveInData.movedIn}/${moveInData.capacity}`);

        // 모든 가구 입주 완료
        if (moveInData.movedIn >= moveInData.capacity) {
            pendingMoveIns.delete(key);
            console.log(`Building at (${buildingX},${buildingY}) fully occupied!`);

            // 인구 통계 업데이트
            cityStats.population = calculateTotalPopulation();
            updateStatsDisplay();
        }
    }

    // 입주 시스템 업데이트 (행복도에 따른 스폰 속도)
    function updateMoveInSystem() {
        if (pendingMoveIns.size === 0) return;

        const now = Date.now();

        // 행복도에 따른 스폰 간격 계산 (행복도 높을수록 빠름)
        // 행복도 0 = 5초, 행복도 100 = 0.5초
        const happiness = cityStats.happiness || 50;
        const minInterval = 500;   // 최소 0.5초
        const maxInterval = 5000;  // 최대 5초
        const spawnInterval = maxInterval - (happiness / 100) * (maxInterval - minInterval);

        if (now - lastMoveInSpawnTime < spawnInterval) return;

        // 입주 대기 중인 건물에서 랜덤 선택하여 차량 스폰
        const pendingList = Array.from(pendingMoveIns.values());
        if (pendingList.length === 0) return;

        // 랜덤으로 하나 선택
        const target = pendingList[Math.floor(Math.random() * pendingList.length)];

        // 아직 입주 여유가 있으면 차량 스폰
        if (target.movedIn < target.capacity) {
            spawnMoveInVehicle(target.buildingX, target.buildingY, target.size);
        }

        lastMoveInSpawnTime = now;
    }

    // 공사 시작
    function startConstruction(constructionData) {
        const key = `${constructionData.x},${constructionData.y}`;

        constructionData.state = CONSTRUCTION_STATE.UNDER_CONSTRUCTION;
        constructionData.startTime = Date.now();
        constructionData.vehicleId = null;

        // 해당 위치의 잔디 제거
        for (let dx = 0; dx < constructionData.width; dx++) {
            for (let dy = 0; dy < constructionData.depth; dy++) {
                removeGrassTileAt(constructionData.x + dx, constructionData.y + dy);
            }
        }

        // 공사 오브젝트 배치 (공원 모델 사용)
        const parkPrefab = buildingPrefabs['park'];
        if (parkPrefab && parkPrefab.prefab) {
            const instance = parkPrefab.prefab.clone(true);
            const worldPos = tileToWorldCenter(constructionData.x, constructionData.y);

            // 2x2인 경우 중앙 위치 조정
            const offsetX = (constructionData.width - 1) * TILE_SIZE / 2;
            const offsetZ = (constructionData.depth - 1) * TILE_SIZE / 2;

            instance.position.set(worldPos.x + offsetX, 0, worldPos.z + offsetZ);

            // 공사 중 느낌을 위해 약간 투명하게
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    const mat = child.material.clone();
                    mat.transparent = true;
                    mat.opacity = 0.7;
                    child.material = mat;
                }
            });

            buildingGroup.add(instance);
            constructionData.constructionInstance = instance;
        }

        console.log(`Construction started at (${constructionData.x},${constructionData.y})`);
    }

    // 공사 완료
    function completeConstruction(constructionData, key) {
        constructionData.state = CONSTRUCTION_STATE.COMPLETED;

        // 공사 오브젝트 제거
        if (constructionData.constructionInstance) {
            buildingGroup.remove(constructionData.constructionInstance);
            constructionData.constructionInstance = null;
        }

        // 실제 건물 배치
        const placement = {
            building: constructionData.building,
            prefabName: constructionData.prefabName,  // 건물 모델 이름 저장
            x: constructionData.x,
            y: constructionData.y,
            width: constructionData.width,
            depth: constructionData.depth,
            zoneStr: constructionData.zoneStr,
            size: constructionData.size
        };

        addBuildingInstance(placement);

        // 주거 건물: 입주 프로세스 시작 (행복도에 따라 점진적 입주)
        if (placement.zoneStr && placement.zoneStr.includes('residential')) {
            const popKey = getBuildingKey(placement.x, placement.y, placement.size);
            assignBuildingPopulation(popKey, placement.size);

            // 건물 등급 추출 (low/mid/high)
            let tier = 'low';
            if (placement.zoneStr.includes('mid') || placement.zoneStr.includes('middle')) {
                tier = 'mid';
            } else if (placement.zoneStr.includes('high')) {
                tier = 'high';
            }

            // 입주 프로세스 시작 (행복도에 따라 차량이 점진적으로 스폰)
            startMoveInProcess(placement.x, placement.y, placement.size, tier);
        }

        // 공사 현장 맵에서 제거
        constructionSites.delete(key);

        // 통계 업데이트
        cityStats.population = calculateTotalPopulation();
        updateStatsDisplay();

        // 교통 시스템에 건물 변경 알림
        if (trafficManager.initialized) {
            trafficManager.onBuildingChange();
        }

        // 도로 연결 상태 체크
        updateRoadConnectivity();

        console.log(`Construction completed at (${constructionData.x},${constructionData.y})`);
    }

    // 공사 진행 체크 (animate 루프에서 호출)
    function updateConstructions() {
        const now = Date.now();

        constructionSites.forEach((site, key) => {
            if (site.state !== CONSTRUCTION_STATE.UNDER_CONSTRUCTION) return;

            const elapsed = now - site.startTime;
            const progress = Math.min(elapsed / site.duration, 1);

            if (progress >= 1) {
                completeConstruction(site, key);
            }
        });
    }

    // 현재 선택된 공사 현장
    let selectedConstruction = null;

    // 공사 현장 팝업 표시
    function showConstructionPopup(constructionData) {
        selectedConstruction = constructionData;
        updateConstructionPopupContent();
        constructionPopup.style.display = 'block';
        updateConstructionPopupPosition();
    }

    // 공사 팝업 내용 업데이트
    function updateConstructionPopupContent() {
        if (!selectedConstruction) return;

        const zoneName = ZONE_NAMES[selectedConstruction.zoneType] || '건설';
        constructionTitle.textContent = `${zoneName} 공사`;

        // 총 소요시간 표시
        const totalMinutes = Math.floor(selectedConstruction.duration / 60000);
        const totalSeconds = Math.floor((selectedConstruction.duration % 60000) / 1000);
        constructionTotalTime.textContent = `${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;

        if (selectedConstruction.state === CONSTRUCTION_STATE.WAITING_VEHICLE) {
            constructionStatus.textContent = '🚗 입주민 대기 중...';
            constructionTimeLeft.textContent = '--:--';
            constructionProgress.style.width = '0%';
        } else if (selectedConstruction.state === CONSTRUCTION_STATE.UNDER_CONSTRUCTION) {
            constructionStatus.textContent = '🏗️ 공사 진행 중';

            const elapsed = Date.now() - selectedConstruction.startTime;
            const remaining = Math.max(0, selectedConstruction.duration - elapsed);
            const progress = Math.min(elapsed / selectedConstruction.duration, 1);

            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            constructionTimeLeft.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            constructionProgress.style.width = (progress * 100) + '%';
        }
    }

    // 공사 팝업 위치 업데이트용 재사용 객체
    const _constPopupScreen = new THREE.Vector3();

    // 공사 팝업 위치 업데이트
    function updateConstructionPopupPosition() {
        if (!selectedConstruction || constructionPopup.style.display === 'none') return;

        const worldPos = tileToWorldCenter(
            selectedConstruction.x + (selectedConstruction.width - 1) / 2,
            selectedConstruction.y + (selectedConstruction.depth - 1) / 2
        );
        _constPopupScreen.set(worldPos.x, 1.5, worldPos.z).project(camera);

        const x = (_constPopupScreen.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-_constPopupScreen.y * 0.5 + 0.5) * window.innerHeight;

        const popupWidth = constructionPopup.offsetWidth || 260;
        const popupHeight = constructionPopup.offsetHeight || 150;

        let posX = x - popupWidth / 2;
        let posY = y - popupHeight - 30;

        posX = Math.max(10, Math.min(window.innerWidth - popupWidth - 10, posX));
        posY = Math.max(50, Math.min(window.innerHeight - popupHeight - 50, posY));

        constructionPopup.style.left = posX + 'px';
        constructionPopup.style.top = posY + 'px';
    }

    // 공사 팝업 닫기
    function closeConstructionPopup() {
        constructionPopup.style.display = 'none';
        selectedConstruction = null;
    }

    // 공사 팝업 닫기 버튼 이벤트
    if (constructionPopupClose) {
        constructionPopupClose.addEventListener('click', closeConstructionPopup);
    }

    // 공사 현장인지 확인
    function getConstructionAt(x, y) {
        // 해당 좌표가 공사 현장에 포함되어 있는지 확인
        for (const [key, site] of constructionSites) {
            const sx = site.x, sy = site.y;
            const sw = site.width, sd = site.depth;
            if (x >= sx && x < sx + sw && y >= sy && y < sy + sd) {
                return site;
            }
        }
        return null;
    }

    // 새로 배치된 구역 타일 처리 - 건물 배치 결정 후 공사 대기열에 추가
    function processNewZoneTiles(tilesSet, zoneType) {
        // 타일 목록을 배열로 변환
        const tiles = [];
        for (const key of tilesSet) {
            const [x, y] = key.split(',').map(Number);
            tiles.push({ x, y });
        }

        if (tiles.length === 0) return;

        // 이 타일들로 블록 구성
        const block = {
            zoneType,
            tiles,
            minX: Math.min(...tiles.map(t => t.x)),
            maxX: Math.max(...tiles.map(t => t.x)),
            minY: Math.min(...tiles.map(t => t.y)),
            maxY: Math.max(...tiles.map(t => t.y)),
        };

        // placeBuildingsInBlock 로직을 사용하여 건물 배치 결정
        const placements = placeBuildingsInBlock(block);

        // 각 건물에 대해 공사 대기열 추가
        for (const placement of placements) {
            queueConstruction(
                placement.x,
                placement.y,
                zoneType,
                placement.width,
                placement.depth,
                placement.building,
                placement.prefabName
            );
        }

        console.log(`Queued ${placements.length} constructions for ${tiles.length} tiles`);
    }

    function setZone(x, y, zoneType) {
        if (isLocked(x, y)) return false;
        if (isRoad(x, y)) return false;
        if (isWaterOrBridge(x, y)) return false;  // 수로/다리 위 구역지정 금지
        if (placedPublicBuildings.has(`${x},${y}`)) return false;  // 공공시설 위 구역지정 금지
        if (findExpansionTurbineAt(x, y)) return false;  // 확장 터빈 위 구역지정 금지
        if (!isAdjacentToRoad(x, y) && zoneType !== CELL.EMPTY) return false;

        grid[x][y] = zoneType;
        // 구역 지정 시 나무 제거
        if (zoneType !== CELL.EMPTY) {
            checkAndRemoveTreeAtTile(x, y);
        }
        return true;
    }

    function setRoad(x, y, place) {
        if (isLocked(x, y)) return;
        if (isBlocked(x, y)) return;
        // 공공시설 위에는 도로 설치 불가
        if (place && placedPublicBuildings.has(`${x},${y}`)) return;
        // 확장 터빈/패널 위에는 도로 설치 불가
        if (place && findExpansionTurbineAt(x, y)) return;
        if (place && findExpansionSolarAt(x, y)) return;
        // 바다 위에는 도로 설치 불가
        if (place && grid[x]?.[y] === CELL.OCEAN) return;
        grid[x][y] = place ? CELL.ROAD : CELL.EMPTY;
        // 도로 설치 시 나무 제거
        if (place) {
            checkAndRemoveTreeAtTile(x, y);
        }
    }

    // 프리뷰 그룹 클리어
    function clearPreviewGroup() {
        while (previewGroup.children.length > 0) {
            previewGroup.remove(previewGroup.children[0]);
        }
    }

    // 프리뷰용 단색 반투명 머티리얼 (텍스쳐 없음)
    const previewMaterialOk = new THREE.MeshBasicMaterial({
        color: 0x44ff66,
        transparent: true,
        opacity: 0.5,
        depthWrite: false,
    });
    const previewMaterialFail = new THREE.MeshBasicMaterial({
        color: 0xff4444,
        transparent: true,
        opacity: 0.5,
        depthWrite: false,
    });

    // 모델에 프리뷰 머티리얼 적용 (텍스쳐 제거, 단색)
    function applyPreviewMaterial(model, ok = true) {
        const mat = ok ? previewMaterialOk : previewMaterialFail;
        model.traverse((child) => {
            if (child.isMesh) {
                child.material = mat;
            }
        });
    }

    function setPreviewPath(path, ok = true) {
        clearPreviewGroup();

        if (!path || path.length === 0) {
            return;
        }

        const isWaterMode = currentMode === MODE.WATER;
        const is4LaneMode = currentMode === MODE.BUILD_4LANE;

        // 수로는 2x2 블록으로 처리
        if (isWaterMode) {
            const placedOrigins = new Set();
            for (const t of path) {
                // 2x2 그리드로 스냅
                const originX = Math.floor(t.x / 2) * 2;
                const originY = Math.floor(t.y / 2) * 2;
                const key = `${originX},${originY}`;

                if (!placedOrigins.has(key) && originX + 1 < GRID_W && originY + 1 < GRID_H) {
                    placedOrigins.add(key);

                    const prefab = tilePrefabs.water;
                    if (!prefab) continue;

                    // 그룹 래퍼 사용
                    const group = new THREE.Group();
                    const tile = prefab.clone(true);
                    applyPreviewMaterial(tile, ok);

                    tile.position.set(
                        -waterCenterOffset.x,
                        -waterMinY + WATER_HEIGHT_OFFSET + 0.02,
                        -waterCenterOffset.z
                    );
                    group.add(tile);
                    group.rotation.y = -Math.PI / 2;

                    const worldX = (ORIGIN_X + originX + 1) * TILE_SIZE;
                    const worldZ = (ORIGIN_Z + originY + 1) * TILE_SIZE;
                    group.position.set(worldX, 0, worldZ);

                    previewGroup.add(group);
                }
            }
            return;
        }

        let prefabs, minYRef;
        if (is4LaneMode) {
            prefabs = tilePrefabs.road4lane;
            minYRef = tileMinY.road4lane;
        } else {
            prefabs = tilePrefabs.road;
            minYRef = tileMinY.road;
        }
        const pickVariant = pickRoadVariant;
        const heightOffset = 0;

        // 임시로 경로에 타일을 설정해서 마스크 계산
        const tempGrid = {};
        for (const t of path) {
            tempGrid[`${t.x},${t.y}`] = true;
        }

        for (const t of path) {
            // 마스크 계산 (임시 그리드 포함)
            let mask = 0;
            for (const [, d] of Object.entries(DIR)) {
                const nx = t.x + d.dx;
                const ny = t.y + d.dy;
                const key = `${nx},${ny}`;
                // 기존 도로 또는 임시 경로에 있으면 연결
                const existingTile = isRoad(nx, ny);
                if (existingTile || tempGrid[key]) {
                    mask |= d.bit;
                }
            }

            const { key, rotY } = pickVariant(mask);
            const prefab = prefabs[key];
            if (!prefab) continue;

            const tile = prefab.clone(true);
            const c = tileToWorldCenter(t.x, t.y);

            // 단색 반투명 머티리얼 적용 (텍스쳐 없음)
            applyPreviewMaterial(tile, ok);

            tile.position.set(c.x, -(minYRef[key] || 0) + heightOffset + 0.02, c.z);
            tile.rotation.y = rotY;
            previewGroup.add(tile);
        }
    }

    // 4차선 도로 2x2 프리뷰 표시
    function set4LanePreview(originX, originY, canPlace = true) {
        clearPreviewGroup();

        // 2x2 타일 중앙 위치 계산
        const worldX = (ORIGIN_X + originX + 1) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + originY + 1) * TILE_SIZE;

        const prefab = road4lanePrefabs['straight'];  // 기본 직선 모델 사용
        if (!prefab) {
            // 모델이 없으면 단순 박스로 프리뷰
            const geometry = new THREE.BoxGeometry(2, 0.1, 2);
            const material = canPlace ? previewMaterialOk.clone() : previewMaterialFail.clone();
            const box = new THREE.Mesh(geometry, material);
            box.position.set(worldX, 0.1, worldZ);
            previewGroup.add(box);
            return;
        }

        const tile = prefab.clone(true);

        applyPreviewMaterial(tile, canPlace);

        // 센터 오프셋 적용
        const offset = road4laneCenterOffset['straight'].clone();
        const posX = worldX - offset.x;
        const posZ = worldZ - offset.z;

        // minY 적용
        tile.position.set(posX, -(tileMinY.road4lane['straight'] || 0) + 0.02, posZ);
        previewGroup.add(tile);
    }

    /* =========================================================
     * L-PATH BUILDING
     * ========================================================= */
    function buildLPath(a, b, xThenY = true) {
        const path = [];
        const ax = a.x, ay = a.y, bx = b.x, by = b.y;

        if (xThenY) {
            const sx = bx >= ax ? 1 : -1;
            for (let x = ax; x !== bx + sx; x += sx) path.push({ x, y: ay });
            const sy = by >= ay ? 1 : -1;
            for (let y = ay + sy; y !== by + sy; y += sy) path.push({ x: bx, y });
        } else {
            const sy = by >= ay ? 1 : -1;
            for (let y = ay; y !== by + sy; y += sy) path.push({ x: ax, y });
            const sx = bx >= ax ? 1 : -1;
            for (let x = ax + sx; x !== bx + sx; x += sx) path.push({ x, y: by });
        }
        return path;
    }

    function isPathBuildable(path) {
        for (const t of path) {
            if (t.x < 0 || t.y < 0 || t.x >= GRID_W || t.y >= GRID_H) return false;
            if (isBlocked(t.x, t.y)) return false;
        }
        return true;
    }

    function pickBestLPath(a, b) {
        const p1 = buildLPath(a, b, true);
        if (isPathBuildable(p1)) return p1;
        const p2 = buildLPath(a, b, false);
        if (isPathBuildable(p2)) return p2;
        return null;
    }

    /* =========================================================
     * 4-LANE ROAD PATH BUILDING (2x2 타일 경로)
     * ========================================================= */

    // 4차선 L자 경로 생성 (2타일 단위로 이동)
    function build4LaneLPath(a, b, xThenY = true) {
        const path = [];
        // 시작점을 2타일 그리드에 맞춤
        const ax = Math.floor(a.x / 2) * 2;
        const ay = Math.floor(a.y / 2) * 2;
        const bx = Math.floor(b.x / 2) * 2;
        const by = Math.floor(b.y / 2) * 2;

        if (xThenY) {
            const sx = bx >= ax ? 2 : -2;
            for (let x = ax; sx > 0 ? x <= bx : x >= bx; x += sx) {
                path.push({ x, y: ay });
            }
            const sy = by >= ay ? 2 : -2;
            for (let y = ay + sy; sy > 0 ? y <= by : y >= by; y += sy) {
                path.push({ x: bx, y });
            }
        } else {
            const sy = by >= ay ? 2 : -2;
            for (let y = ay; sy > 0 ? y <= by : y >= by; y += sy) {
                path.push({ x: ax, y });
            }
            const sx = bx >= ax ? 2 : -2;
            for (let x = ax + sx; sx > 0 ? x <= bx : x >= bx; x += sx) {
                path.push({ x, y: by });
            }
        }

        // 중복 제거
        const unique = [];
        const seen = new Set();
        for (const p of path) {
            const key = `${p.x},${p.y}`;
            if (!seen.has(key)) {
                seen.add(key);
                unique.push(p);
            }
        }
        return unique;
    }

    // 4차선 경로 배치 가능 여부 확인
    function is4LanePathBuildable(path) {
        for (const origin of path) {
            if (!canPlace4LaneRoad(origin.x, origin.y)) return false;
        }
        return true;
    }

    // 최적의 4차선 L자 경로 선택
    function pickBest4LaneLPath(a, b) {
        const p1 = build4LaneLPath(a, b, true);
        if (is4LanePathBuildable(p1)) return p1;
        const p2 = build4LaneLPath(a, b, false);
        if (is4LanePathBuildable(p2)) return p2;
        return null;
    }

    // 4차선 경로 프리뷰 표시
    function set4LanePathPreview(path, canBuild = true) {
        clearPreviewGroup();
        if (!path || path.length === 0) return;

        for (const origin of path) {
            const canPlace = canPlace4LaneRoad(origin.x, origin.y);
            const worldX = (ORIGIN_X + origin.x + 1) * TILE_SIZE;
            const worldZ = (ORIGIN_Z + origin.y + 1) * TILE_SIZE;

            const prefab = road4lanePrefabs['straight'];
            if (!prefab) {
                // 모델이 없으면 박스로 표시
                const geometry = new THREE.BoxGeometry(2, 0.1, 2);
                const material = (canBuild && canPlace) ? previewMaterialOk.clone() : previewMaterialFail.clone();
                const box = new THREE.Mesh(geometry, material);
                box.position.set(worldX, 0.1, worldZ);
                previewGroup.add(box);
            } else {
                const tile = prefab.clone(true);
                applyPreviewMaterial(tile, canBuild && canPlace);
                const offset = road4laneCenterOffset['straight'].clone();
                tile.position.set(worldX - offset.x, -(tileMinY.road4lane['straight'] || 0) + 0.02, worldZ - offset.z);
                previewGroup.add(tile);
            }
        }
    }

    /* =========================================================
     * INPUT HANDLING
     * ========================================================= */
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    let hovered = null;
    let buildStart = null;
    let currentPath = null;
    let current4LanePath = null;  // 4차선 도로 경로
    let isBuildDragging = false;  // 도로/수로 드래그 중인지 여부

    function updateMouseFromEvent(e) {
        // 캐시된 rect 사용
        const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function updateHovered(e) {
        updateMouseFromEvent(e);
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(ground, false);
        if (!hits.length) return null;
        const p = hits[0].point;
        return worldToTile(p.x, p.z);
    }

    // 월드 좌표를 직접 반환하는 함수
    function getWorldPositionFromEvent(e) {
        updateMouseFromEvent(e);
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(ground, false);
        if (!hits.length) return null;
        return hits[0].point;
    }

    // 구역 지정 모드 확인
    function isZoneMode() {
        return currentMode === MODE.ZONE_RESIDENTIAL ||
               currentMode === MODE.ZONE_COMMERCIAL ||
               currentMode === MODE.ZONE_INDUSTRIAL;
    }

    /**
     * Ctrl+클릭 시 BFS로 같은 구역 타입의 연결된 타일 모두 선택 (삭제용)
     * @param {number} startX - 시작 X 좌표
     * @param {number} startY - 시작 Y 좌표
     * @returns {Array} 선택된 타일 좌표 배열 [{x, y}, ...]
     */
    function findSameZoneTiles(startX, startY) {
        const tiles = [];
        const visited = new Set();
        const queue = [];

        // 시작 타일의 구역 타입 확인
        const startZoneType = grid[startX]?.[startY];
        if (!isZone(startX, startY)) return tiles;

        // BFS 시작
        const startKey = `${startX},${startY}`;
        queue.push({ x: startX, y: startY });
        visited.add(startKey);

        const directions = [
            { dx: 1, dy: 0 },   // 오른쪽
            { dx: -1, dy: 0 },  // 왼쪽
            { dx: 0, dy: 1 },   // 아래
            { dx: 0, dy: -1 }   // 위
        ];

        // BFS 탐색
        while (queue.length > 0) {
            const current = queue.shift();
            tiles.push(current);

            // 4방향 탐색
            for (const dir of directions) {
                const nx = current.x + dir.dx;
                const ny = current.y + dir.dy;
                const key = `${nx},${ny}`;

                // 이미 방문했거나 범위 밖이면 스킵
                if (visited.has(key) || !inBounds(nx, ny)) continue;

                // 같은 구역 타입인지 확인
                if (grid[nx]?.[ny] === startZoneType) {
                    visited.add(key);
                    queue.push({ x: nx, y: ny });
                }
            }
        }

        return tiles;
    }

    /**
     * Ctrl+클릭 시 BFS로 배치 가능한 모든 인접 타일 선택
     * @param {number} startX - 시작 X 좌표
     * @param {number} startY - 시작 Y 좌표
     * @returns {Array} 선택된 타일 좌표 배열 [{x, y}, ...]
     */
    function findLineTilesAlongRoad(startX, startY) {
        const tiles = [];
        const visited = new Set();
        const queue = [];

        // 시작 타일이 구역 배치 가능한지 확인
        if (!canPlaceZone(startX, startY)) return tiles;

        // BFS 시작
        const startKey = `${startX},${startY}`;
        queue.push({ x: startX, y: startY });
        visited.add(startKey);

        const directions = [
            { dx: 1, dy: 0 },   // 오른쪽
            { dx: -1, dy: 0 },  // 왼쪽
            { dx: 0, dy: 1 },   // 아래
            { dx: 0, dy: -1 }   // 위
        ];

        // BFS 탐색
        while (queue.length > 0) {
            const current = queue.shift();
            tiles.push(current);

            // 4방향 탐색
            for (const dir of directions) {
                const nx = current.x + dir.dx;
                const ny = current.y + dir.dy;
                const key = `${nx},${ny}`;

                // 이미 방문했거나 범위 밖이면 스킵
                if (visited.has(key) || !inBounds(nx, ny)) continue;

                // 배치 가능한 타일인지 확인
                if (canPlaceZone(nx, ny)) {
                    visited.add(key);
                    queue.push({ x: nx, y: ny });
                }
            }
        }

        return tiles;
    }

    // 구역 드래그 상태
    let isZoneDragging = false;
    let zonePlacedTiles = new Set();

    // 방파제 드래그 상태
    let isBreakwaterDragging = false;
    let breakwaterPlacedTiles = new Set();

    // 철거 드래그 상태
    let isDemolishDragging = false;
    let demolishedTiles = new Set();

    // Ctrl 키 직선 프리뷰 상태
    let linePreviewMeshes = [];
    let linePreviewGroup = new THREE.Group();
    linePreviewGroup.name = 'linePreviewGroup';
    scene.add(linePreviewGroup);

    // 직선 프리뷰 표시 함수
    function showLinePreview(tiles, zoneType) {
        clearLinePreview();
        if (!tiles || tiles.length === 0) return;

        const color = ZONE_COLORS[zoneType] || 0x00ff00;
        const geometry = new THREE.BoxGeometry(TILE_SIZE, 0.15, TILE_SIZE);

        tiles.forEach(tile => {
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            const pos = tileToWorldCenter(tile.x, tile.y);
            mesh.position.set(pos.x, 0.075, pos.z);
            linePreviewGroup.add(mesh);
            linePreviewMeshes.push(mesh);
        });
    }

    // 삭제 프리뷰 표시 함수 (빨간색)
    function showDeletePreview(tiles) {
        clearLinePreview();
        if (!tiles || tiles.length === 0) return;

        const deleteColor = 0xff4444;
        const geometry = new THREE.BoxGeometry(TILE_SIZE, 0.15, TILE_SIZE);

        tiles.forEach(tile => {
            const material = new THREE.MeshStandardMaterial({
                color: deleteColor,
                emissive: deleteColor,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            const pos = tileToWorldCenter(tile.x, tile.y);
            mesh.position.set(pos.x, 0.075, pos.z);
            linePreviewGroup.add(mesh);
            linePreviewMeshes.push(mesh);
        });
    }

    // 직선 프리뷰 제거 함수
    function clearLinePreview() {
        linePreviewMeshes.forEach(mesh => {
            linePreviewGroup.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        });
        linePreviewMeshes = [];
    }

    // 연결된 직선 도로 찾기 (Ctrl+철거용)
    // 해당 타일에서 상하좌우 4방향으로 연결된 직선 도로 타일 목록 반환
    function findConnectedStraightRoads(startX, startY) {
        const cellType = grid[startX][startY];
        // 도로 타입만 처리
        if (cellType !== CELL.ROAD && cellType !== CELL.BRIDGE) return [];

        const result = [{ x: startX, y: startY }];
        const directions = [
            { dx: 1, dy: 0 },   // 오른쪽
            { dx: -1, dy: 0 },  // 왼쪽
            { dx: 0, dy: 1 },   // 아래
            { dx: 0, dy: -1 }   // 위
        ];

        // 각 방향으로 직선 탐색
        for (const dir of directions) {
            let x = startX + dir.dx;
            let y = startY + dir.dy;

            // 해당 방향으로 계속 탐색
            while (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                const type = grid[x][y];
                // 도로 또는 다리만 연결
                if (type === CELL.ROAD || type === CELL.BRIDGE) {
                    result.push({ x, y });
                    x += dir.dx;
                    y += dir.dy;
                } else {
                    break;
                }
            }
        }

        return result;
    }

    // Ctrl+철거 선택된 도로 타일 저장
    let ctrlDemolishSelectedRoads = [];

    renderer.domElement.addEventListener("pointermove", (e) => {
        // 인구/땅값 뷰 모드일 때 그래프 호버 감지
        if (currentMode === MODE.POPULATION_VIEW || currentMode === MODE.LAND_VALUE_VIEW) {
            handleGraphHover(e);
            return;
        }

        // 그래프 툴팁 숨기기 (다른 모드)
        if (graphTooltip) graphTooltip.style.display = 'none';

        // 카메라 모드면 무시 (단, 철거 모드는 독립 토글이므로 예외)
        if ((currentMode === MODE.CAMERA && !isDemolishModeActive) || !MAP_CONFIG.isOwner) {
            hovered = null;
            ghost.visible = false;
            hideBuildingPreview();
            hideBreakwaterPreview();
            clearServiceEffects();
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            clearLinePreview();
            clearDemolishHighlight();
            return;
        }

        const t = updateHovered(e);
        if (!t) {
            hovered = null;
            ghost.visible = false;
            hideBuildingPreview();
            hideBreakwaterPreview();
            clearServiceEffects();
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            clearLinePreview();
            clearDemolishHighlight();
            return;
        }

        hovered = t;

        const c = tileToWorldCenter(t.x, t.y);
        ghost.position.set(c.x, 0.04, c.z);
        ghost.visible = true;

        // 철거 모드일 때 (독립 토글 - 다른 모드보다 우선 처리)
        if (isDemolishModeActive) {
            const cellType = grid[t.x][t.y];
            const hasBuilding = hasBuildingAt(t.x, t.y);
            const hasPublicBuilding = findPublicBuildingAt(t.x, t.y);

            // Ctrl 키 + 도로 위: 연결된 직선 도로 프리뷰
            if ((e.ctrlKey || e.metaKey) && !isDemolishDragging &&
                (cellType === CELL.ROAD || cellType === CELL.BRIDGE)) {
                const straightRoads = findConnectedStraightRoads(t.x, t.y);
                if (straightRoads.length > 0) {
                    ctrlDemolishSelectedRoads = straightRoads;
                    showDeletePreview(straightRoads);
                    ghost.visible = false;
                    clearDemolishHighlight();
                    return;
                }
            } else if (!isDemolishDragging) {
                // Ctrl 키 떼면 프리뷰 제거
                if (ctrlDemolishSelectedRoads.length > 0) {
                    ctrlDemolishSelectedRoads = [];
                    clearLinePreview();
                }
            }

            // 확장 터빈/패널 확인
            const hasExpansionTurbine = findExpansionTurbineAt(t.x, t.y);
            const hasExpansionSolar = findExpansionSolarAt(t.x, t.y);

            // 철거 가능한 오브젝트 빨간색 하이라이트
            const canDemolish = cellType === CELL.ROAD || cellType === CELL.WATER ||
                               cellType === CELL.BRIDGE || cellType === CELL.ROAD_4LANE ||
                               cellType === CELL.BREAKWATER ||
                               hasPublicBuilding || hasBuilding || hasExpansionTurbine || hasExpansionSolar;

            if (canDemolish) {
                const objectToHighlight = findObjectAtTile(t.x, t.y);
                if (objectToHighlight) {
                    highlightForDemolish(objectToHighlight);
                } else {
                    clearDemolishHighlight();
                }
            } else {
                clearDemolishHighlight();
            }

            if (cellType === CELL.ROAD || cellType === CELL.WATER || cellType === CELL.BRIDGE || cellType === CELL.ROAD_4LANE || cellType === CELL.BREAKWATER) {
                ghost.material.color.set(0xff4444);  // 빨간색 - 철거 가능
                ghost.material.opacity = 0.6;
            } else if (cellType === CELL.LOCKED_ROAD) {
                ghost.material.color.set(0xffcc00);  // 노란색 - 잠긴 도로
                ghost.material.opacity = 0.4;
            } else if (hasPublicBuilding || hasBuilding || hasExpansionTurbine) {
                ghost.material.color.set(0xff6600);  // 주황색 - 건물 철거 가능
                ghost.material.opacity = 0.6;
            } else {
                ghost.material.color.set(0x666666);  // 회색 - 철거 불가
                ghost.material.opacity = 0.2;
            }

            // 드래그 중이면 철거 실행
            if (isDemolishDragging) {
                const key = `${t.x},${t.y}`;
                if (!demolishedTiles.has(key)) {
                    // 철거 전 하이라이트 제거 (오브젝트가 제거되므로)
                    clearDemolishHighlight();

                    // 도로/수로/다리 철거
                    if (cellType === CELL.ROAD || cellType === CELL.WATER || cellType === CELL.BRIDGE) {
                        grid[t.x][t.y] = CELL.EMPTY;
                        demolishedTiles.add(key);
                        rebuildRoadInstances();
                        rebuildRoadModels();
                        rebuildAllTiles();
                        markDirty();
                    }
                    // 4차선 도로 철거
                    else if (cellType === CELL.ROAD_4LANE) {
                        if (remove4LaneRoad(t.x, t.y)) {
                            demolishedTiles.add(key);
                            rebuildRoadInstances();
                            rebuildRoadModels();
                            rebuildAllTiles();
                            markDirty();
                        }
                    }
                    // 방파제 철거
                    else if (cellType === CELL.BREAKWATER) {
                        if (removeBreakwaterAt(t.x, t.y)) {
                            demolishedTiles.add(key);
                        }
                    }
                    // 확장 터빈 철거 (공공시설보다 먼저 체크)
                    else if (findExpansionTurbineAt(t.x, t.y)) {
                        if (removeExpansionTurbine(t.x, t.y)) {
                            demolishedTiles.add(key);
                        }
                    }
                    // 확장 태양광 패널 철거 (공공시설보다 먼저 체크)
                    else if (findExpansionSolarAt(t.x, t.y)) {
                        if (removeExpansionSolar(t.x, t.y)) {
                            demolishedTiles.add(key);
                        }
                    }
                    // 공공시설 철거
                    else if (hasPublicBuilding) {
                        if (removePublicBuilding(t.x, t.y)) {
                            demolishedTiles.add(key);
                        }
                    }
                    // 일반 건물 철거
                    else if (hasBuilding) {
                        if (removeBuildingAt(t.x, t.y)) {
                            demolishedTiles.add(key);
                            markDirty();
                        }
                    }
                }
            }
            return;  // 철거 모드는 다른 모드와 공존하지만, 처리 후 바로 리턴
        }

        // 구역 삭제 모드일 때
        if (currentMode === MODE.ZONE_DELETE) {
            // Ctrl 키 눌림 상태에서 같은 구역 타입 모두 선택 프리뷰
            if ((e.ctrlKey || e.metaKey) && !isZoneDragging && isZone(t.x, t.y)) {
                const sameZoneTiles = findSameZoneTiles(t.x, t.y);
                if (sameZoneTiles.length > 0) {
                    showDeletePreview(sameZoneTiles);
                    ghost.visible = false;
                } else {
                    clearLinePreview();
                }
            } else {
                clearLinePreview();
                ghost.visible = true;
            }

            if (isZone(t.x, t.y)) {
                ghost.material.color.set(0xff4444);
                ghost.material.emissive.set(0x000000);
                ghost.material.emissiveIntensity = 0;
                ghost.material.opacity = 0.5;
            } else {
                ghost.material.color.set(0x666666);
                ghost.material.emissive.set(0x000000);
                ghost.material.emissiveIntensity = 0;
                ghost.material.opacity = 0.2;
            }

            // 드래그 중이면 구역 삭제 (건물은 유지)
            if (isZoneDragging) {
                const key = `${t.x},${t.y}`;
                if (!zonePlacedTiles.has(key) && isZone(t.x, t.y)) {
                    setZone(t.x, t.y, CELL.EMPTY);
                    zonePlacedTiles.add(key);
                    rebuildZoneInstances(false);  // 건물 유지
                    markDirty();
                }
            }
        }
        // 구역 배치 모드일 때
        else if (isZoneMode()) {
            // 드래그 중이 아닐 때만 가장 가까운 설치 가능 타일 찾기
            // 드래그 중에는 실제 커서 위치만 사용 (반대편 칠해지는 버그 방지)
            let targetTile = t;  // 기본값은 커서 아래 타일

            if (!isZoneDragging) {
                const worldPos = getWorldPositionFromEvent(e);
                if (worldPos) {
                    const nearestPlaceable = findNearestPlaceableZoneTile(worldPos.x, worldPos.z, 5);
                    if (nearestPlaceable) {
                        targetTile = { x: nearestPlaceable.x, y: nearestPlaceable.y };
                        // 프리뷰 위치를 가장 가까운 설치 가능 타일로 이동
                        const nearestWorldPos = tileToWorldCenter(targetTile.x, targetTile.y);
                        ghost.position.set(nearestWorldPos.x, 0.04, nearestWorldPos.z);
                    }
                }
            }

            // Ctrl 키 눌림 상태에서 직선 프리뷰 표시
            if ((e.ctrlKey || e.metaKey) && !isZoneDragging) {
                const lineTiles = findLineTilesAlongRoad(targetTile.x, targetTile.y);
                if (lineTiles.length > 0) {
                    showLinePreview(lineTiles, currentZoneType);
                    ghost.visible = false; // 단일 ghost 숨김
                } else {
                    clearLinePreview();
                }
            } else {
                clearLinePreview();
            }

            if (canPlaceZone(targetTile.x, targetTile.y)) {
                ghost.material.color.set(ZONE_COLORS[currentZoneType]);
                ghost.material.emissive.set(ZONE_COLORS[currentZoneType]);
                ghost.material.emissiveIntensity = 0.5;
                ghost.material.transparent = false;  // 투명도 완전 제거
                ghost.material.opacity = 1.0;
            } else if (isZone(targetTile.x, targetTile.y)) {
                // 이미 구역이 있으면 배치 불가 표시 (회색)
                ghost.material.transparent = true;
                ghost.material.color.set(0x888888);
                ghost.material.emissive.set(0x000000);
                ghost.material.emissiveIntensity = 0;
                ghost.material.opacity = 0.3;
            } else {
                ghost.material.transparent = true;
                ghost.material.color.set(0xff3366);
                ghost.material.emissive.set(0x000000);
                ghost.material.emissiveIntensity = 0;
                ghost.material.opacity = 0.3;
            }

            // Ctrl 키가 눌려있지 않으면 ghost 표시
            if (!(e.ctrlKey || e.metaKey) || isZoneDragging) {
                ghost.visible = true;
            }

            // 드래그 중이면 구역 배치 (이미 있는 구역은 덮어쓰지 않음)
            if (isZoneDragging) {
                const key = `${targetTile.x},${targetTile.y}`;
                if (!zonePlacedTiles.has(key) && canPlaceZone(targetTile.x, targetTile.y)) {
                    setZone(targetTile.x, targetTile.y, currentZoneType);
                    zonePlacedTiles.add(key);
                    rebuildZoneInstances(false);  // 드래그 중에는 건물 생성 안함
                    markDirty();
                }
            }

            // hovered도 targetTile로 업데이트 (클릭 시 사용)
            hovered = targetTile;
        }
        // 도로 모드일 때 (2차선)
        else if (currentMode === MODE.BUILD) {
            // 2차선 도로 배치 규칙 검사
            const lane4Validation = validate2LaneNear4Lane(t.x, t.y);
            const block2x2Validation = validate2LaneNo2x2Block(t.x, t.y);

            if (isLocked(t.x, t.y)) ghost.material.color.set(0xffcc00);
            else if (isBlocked(t.x, t.y)) ghost.material.color.set(0xff3366);
            else if (!lane4Validation.valid) ghost.material.color.set(0xff6600);  // 4차선 규칙 위반 - 주황색
            else if (!block2x2Validation.valid) ghost.material.color.set(0xff6600);  // 2x2 블록 규칙 위반 - 주황색
            else if (isRoad(t.x, t.y)) ghost.material.color.set(0xcc3333);
            else if (isWater(t.x, t.y)) ghost.material.color.set(0x00aaff);  // 수로 위 (다리 가능)
            else ghost.material.color.set(0x00aa88);

            if (isBuildDragging && buildStart) {
                currentPath = pickBestLPath(buildStart, hovered);

                // 경로 내 2차선 규칙 위반 체크 (4차선 연결 규칙 + 2x2 블록 규칙 + 경로 내 연속 배치 + 평행 배치)
                let pathHasRuleError = false;
                let errorReason = '';
                if (currentPath) {
                    // 경로 내에서 4차선 한 면에 연속 배치 체크
                    const v3 = validatePathNo4LaneConsecutive(currentPath);
                    if (!v3.valid) {
                        pathHasRuleError = true;
                        errorReason = v3.reason;
                    }

                    // 기존 도로 옆에 2칸 이상 연속 배치 체크
                    if (!pathHasRuleError) {
                        const v4 = validatePathNoParallelToRoad(currentPath);
                        if (!v4.valid) {
                            pathHasRuleError = true;
                            errorReason = v4.reason;
                        }
                    }

                    // 개별 셀 검증
                    if (!pathHasRuleError) {
                        for (const pt of currentPath) {
                            const v1 = validate2LaneNear4Lane(pt.x, pt.y);
                            if (!v1.valid) {
                                pathHasRuleError = true;
                                errorReason = v1.reason;
                                break;
                            }
                            const v2 = validate2LaneNo2x2Block(pt.x, pt.y);
                            if (!v2.valid) {
                                pathHasRuleError = true;
                                errorReason = v2.reason;
                                break;
                            }
                            // 확장 터빈/패널 위에는 도로 설치 불가
                            if (findExpansionTurbineAt(pt.x, pt.y)) {
                                pathHasRuleError = true;
                                errorReason = '확장 터빈 위에는 도로 설치 불가';
                                break;
                            }
                            if (findExpansionSolarAt(pt.x, pt.y)) {
                                pathHasRuleError = true;
                                errorReason = '확장 패널 위에는 도로 설치 불가';
                                break;
                            }
                        }
                    }
                }

                setPreviewPath(currentPath, !!currentPath && !pathHasRuleError);

                // 비용 표시 또는 오류 메시지
                if (currentPath && currentPath.length > 0) {
                    if (pathHasRuleError) {
                        costTooltip.textContent = errorReason;
                        costTooltip.className = 'insufficient';
                    } else {
                        const cost = calcPathCost(currentPath);
                        const canAfford = TEST_MODE || economy.money >= cost;
                        costTooltip.textContent = canAfford ? `₩${cost.toLocaleString()}` : '자금 부족';
                        costTooltip.className = canAfford ? '' : 'insufficient';
                    }
                    costTooltip.style.display = 'block';
                    costTooltip.style.left = (e.clientX + 15) + 'px';
                    costTooltip.style.top = (e.clientY + 15) + 'px';
                } else {
                    costTooltip.style.display = 'none';
                }
            } else {
                setPreviewPath(null);
                costTooltip.style.display = 'none';
            }
        }
        // 4차선 도로 모드일 때 (2x2 드래그 배치)
        else if (currentMode === MODE.BUILD_4LANE) {
            // 2타일 그리드에 맞춘 원점 계산
            const originX = Math.floor(t.x / 2) * 2;
            const originY = Math.floor(t.y / 2) * 2;
            const canPlace = canPlace4LaneRoad(originX, originY);

            if (canPlace) {
                ghost.material.color.set(0x00aa88);  // 설치 가능 - 초록색
            } else {
                ghost.material.color.set(0xff3366);  // 설치 불가 - 빨간색
            }

            // 드래그 중이면 경로 프리뷰 표시
            if (isBuildDragging && buildStart) {
                current4LanePath = pickBest4LaneLPath(buildStart, hovered);
                set4LanePathPreview(current4LanePath, !!current4LanePath);

                // 비용 표시
                if (current4LanePath && current4LanePath.length > 0) {
                    const cost = current4LanePath.length * 500;  // 4차선 도로 비용
                    const canAfford = TEST_MODE || economy.money >= cost;
                    costTooltip.textContent = canAfford ? `₩${cost.toLocaleString()}` : '자금 부족';
                    costTooltip.className = canAfford ? '' : 'insufficient';
                    costTooltip.style.display = 'block';
                    costTooltip.style.left = (e.clientX + 15) + 'px';
                    costTooltip.style.top = (e.clientY + 15) + 'px';
                } else {
                    costTooltip.style.display = 'none';
                }
            } else {
                // 드래그 전에는 단일 2x2 프리뷰
                set4LanePreview(originX, originY, canPlace);
                costTooltip.style.display = 'none';
            }
        }
        // 수로 모드일 때
        else if (currentMode === MODE.WATER) {
            if (isLocked(t.x, t.y)) ghost.material.color.set(0xffcc00);
            else if (isBridge(t.x, t.y)) ghost.material.color.set(0xff3366);  // 다리 위는 설치 불가
            else if (isRoad(t.x, t.y)) ghost.material.color.set(0x00aaff);  // 도로 위 → 다리 가능
            else if (isWater(t.x, t.y)) ghost.material.color.set(0x2266ff);  // 이미 수로
            else ghost.material.color.set(0x4488ff);  // 설치 가능

            if (isBuildDragging && buildStart) {
                currentPath = pickBestLPath(buildStart, hovered);
                setPreviewPath(currentPath, !!currentPath);

                // 비용 표시
                if (currentPath && currentPath.length > 0) {
                    const cost = calcPathCost(currentPath);
                    const canAfford = TEST_MODE || economy.money >= cost;
                    costTooltip.textContent = canAfford ? `₩${cost.toLocaleString()}` : '자금 부족';
                    costTooltip.className = canAfford ? '' : 'insufficient';
                    costTooltip.style.display = 'block';
                    costTooltip.style.left = (e.clientX + 15) + 'px';
                    costTooltip.style.top = (e.clientY + 15) + 'px';
                } else {
                    costTooltip.style.display = 'none';
                }
            } else {
                setPreviewPath(null);
                costTooltip.style.display = 'none';
            }
        }
        // 건물 설치 모드일 때 - 미리보기 표시 + 서비스 효과 범위 표시
        else if (isPlacementMode(currentMode)) {
            hideBreakwaterPreview();  // 방파제 프리뷰 숨기기
            const placementType = getCurrentPlacementType();
            if (placementType) {
                // 고스트 타일 숨기고 건물 미리보기 표시
                ghost.visible = false;
                updateBuildingPreview(placementType, t.x, t.y);

                // 서비스 효과 범위 시각화 (발전소/수도시설은 제외 - 전력/수도 뷰 사용)
                const isPowerPlacement = currentMode === MODE.PLACE_POWER_COAL || currentMode === MODE.PLACE_POWER_WIND || currentMode === MODE.PLACE_POWER_SOLAR;
                const isWaterPlacement = currentMode === MODE.PLACE_WASTEWATER || currentMode === MODE.PLACE_WATER_PUMP_COAST;
                if (!isPowerPlacement && !isWaterPlacement) {
                    updateServiceEffectVisualization(placementType, t.x, t.y);
                }

                // 비용 툴팁 표시
                const cost = PUBLIC_BUILDING_MODELS[placementType]?.cost || 1000;
                const canAfford = TEST_MODE || economy.money >= cost;
                const placeResult = canPlacePublicBuildingWithReason(t.x, t.y, placementType);
                if (placeResult.canPlace) {
                    costTooltip.textContent = canAfford ? `₩${cost.toLocaleString()}` : '자금 부족';
                    costTooltip.className = canAfford ? '' : 'insufficient';
                } else {
                    // 배치 불가 이유 표시
                    costTooltip.textContent = placeResult.reason || '배치 불가';
                    costTooltip.className = 'insufficient';
                }
                costTooltip.style.display = 'block';
                costTooltip.style.left = (e.clientX + 15) + 'px';
                costTooltip.style.top = (e.clientY + 15) + 'px';
            }
        }
        // 방파제 설치 모드일 때 - 2x2 프리뷰 표시 + 드래그 설치
        else if (currentMode === MODE.PLACE_BREAKWATER) {
            ghost.visible = false;
            hideBuildingPreview();
            updateBreakwaterPreview(t.x, t.y);

            // 드래그 중이면 연속 설치 (토스트 메시지 없이)
            if (isBreakwaterDragging && lastBreakwaterX >= 0 && lastBreakwaterY >= 0) {
                const key = `${lastBreakwaterX},${lastBreakwaterY}`;
                if (!breakwaterPlacedTiles.has(key)) {
                    if (placeBreakwater(lastBreakwaterX, lastBreakwaterY, true)) {
                        breakwaterPlacedTiles.add(key);
                    }
                }
            }

            // 배치 가능 여부 체크
            const canPlace = canPlaceBreakwater(lastBreakwaterX, lastBreakwaterY);

            // 디버깅: 2x2 영역의 셀 타입 표시
            let debugInfo = '';
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const x = lastBreakwaterX + dx;
                    const y = lastBreakwaterY + dy;
                    if (inBounds(x, y)) {
                        const cellVal = grid[x][y];
                        const cellName = Object.keys(CELL).find(k => CELL[k] === cellVal) || cellVal;
                        debugInfo += `[${x},${y}]=${cellName} `;
                    }
                }
            }
            console.log('방파제 위치:', lastBreakwaterX, lastBreakwaterY, debugInfo, 'canPlace:', canPlace);

            if (canPlace) {
                costTooltip.textContent = '설치 가능';
                costTooltip.className = '';
            } else {
                costTooltip.textContent = `해변가 필요 (${debugInfo.trim()})`;
                costTooltip.className = 'insufficient';
            }
            costTooltip.style.display = 'block';
            costTooltip.style.left = (e.clientX + 15) + 'px';
            costTooltip.style.top = (e.clientY + 15) + 'px';
        }
        // 다른 모드일 때 미리보기 및 서비스 효과 숨기기
        else {
            hideBuildingPreview();
            hideBreakwaterPreview();
            clearServiceEffects();
        }
    });

    renderer.domElement.addEventListener("pointerdown", (e) => {
        if (!MAP_CONFIG.isOwner) return;
        if (e.button !== 0) return;
        if (!hovered) return;

        // 철거 모드 (클릭 & 드래그로 삭제 - 도로/수로/건물/공공시설) - 독립 토글
        if (isDemolishModeActive) {
            const cellType = grid[hovered.x][hovered.y];

            // Ctrl+클릭: 연결된 직선 도로 일괄 철거
            if ((e.ctrlKey || e.metaKey) && ctrlDemolishSelectedRoads.length > 0) {
                let demolishedCount = 0;
                for (const tile of ctrlDemolishSelectedRoads) {
                    const type = grid[tile.x][tile.y];
                    if (type === CELL.ROAD || type === CELL.BRIDGE) {
                        grid[tile.x][tile.y] = CELL.EMPTY;
                        demolishedCount++;
                    }
                }
                if (demolishedCount > 0) {
                    rebuildRoadInstances();
                    rebuildRoadModels();
                    rebuildAllTiles();
                    markDirty();
                    toast({
                        title: '도로 철거',
                        desc: `${demolishedCount}개의 도로 타일이 철거되었습니다.`,
                        success: true
                    });
                }
                ctrlDemolishSelectedRoads = [];
                clearLinePreview();
                return;
            }

            isDemolishDragging = true;
            demolishedTiles.clear();

            // 철거 전 하이라이트 제거 (오브젝트가 제거되므로)
            clearDemolishHighlight();

            const key = `${hovered.x},${hovered.y}`;
            const hasBuilding = hasBuildingAt(hovered.x, hovered.y);
            const hasPublicBuilding = findPublicBuildingAt(hovered.x, hovered.y);

            // 4차선 도로 철거 (2x2 전체 철거)
            if (cellType === CELL.ROAD_4LANE || cellType === CELL.LOCKED_ROAD_4LANE) {
                if (remove4LaneRoad(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                    rebuildRoadInstances();
                    rebuildRoadModels();
                    rebuildAllTiles();
                    markDirty();
                }
            }
            // 도로/수로/다리 철거
            else if (cellType === CELL.ROAD || cellType === CELL.WATER || cellType === CELL.BRIDGE) {
                grid[hovered.x][hovered.y] = CELL.EMPTY;
                demolishedTiles.add(key);
                rebuildRoadInstances();
                rebuildRoadModels();
                rebuildAllTiles();
                markDirty();
            }
            // 방파제 철거
            else if (cellType === CELL.BREAKWATER) {
                if (removeBreakwaterAt(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                }
            }
            // 확장 터빈 철거 (공공시설보다 먼저 체크)
            else if (findExpansionTurbineAt(hovered.x, hovered.y)) {
                if (removeExpansionTurbine(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                }
            }
            // 확장 태양광 패널 철거 (공공시설보다 먼저 체크)
            else if (findExpansionSolarAt(hovered.x, hovered.y)) {
                if (removeExpansionSolar(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                }
            }
            // 공공시설 철거
            else if (hasPublicBuilding) {
                if (removePublicBuilding(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                }
            }
            // 일반 건물 철거
            else if (hasBuilding) {
                if (removeBuildingAt(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                    markDirty();
                }
            }
            return;
        }

        // 공공시설 설치 모드
        if (isPlacementMode(currentMode)) {
            const placementType = getCurrentPlacementType();
            if (placementType) {
                // 배치 가능 여부 먼저 확인 (상세 이유 포함)
                const placeResult = canPlacePublicBuildingWithReason(hovered.x, hovered.y, placementType);
                if (!placeResult.canPlace) {
                    toast({ title: '배치 불가', desc: placeResult.reason });
                    return;
                }
                placePublicBuilding(hovered.x, hovered.y, placementType, e.clientX, e.clientY);
            }
            return;
        }

        // 방파제 설치 모드 (드래그로 연속 설치)
        if (currentMode === MODE.PLACE_BREAKWATER) {
            isBreakwaterDragging = true;
            breakwaterPlacedTiles.clear();

            if (lastBreakwaterX >= 0 && lastBreakwaterY >= 0) {
                if (placeBreakwater(lastBreakwaterX, lastBreakwaterY, true)) {
                    const key = `${lastBreakwaterX},${lastBreakwaterY}`;
                    breakwaterPlacedTiles.add(key);
                }
            }
            return;
        }

        // 구역 삭제 모드 (건물은 유지, 구역 마스크만 삭제)
        if (currentMode === MODE.ZONE_DELETE) {
            // Ctrl+클릭: 같은 구역 타입 전체 삭제
            if ((e.ctrlKey || e.metaKey) && isZone(hovered.x, hovered.y)) {
                const sameZoneTiles = findSameZoneTiles(hovered.x, hovered.y);
                if (sameZoneTiles.length > 0) {
                    const zoneTypeName = ZONE_NAMES[grid[hovered.x][hovered.y]] || '구역';
                    for (const tile of sameZoneTiles) {
                        setZone(tile.x, tile.y, CELL.EMPTY);
                    }
                    rebuildZoneInstances(false);
                    markDirty();
                    clearLinePreview();
                    toast({
                        title: '구역 삭제',
                        desc: `${sameZoneTiles.length}개의 ${zoneTypeName} 타일이 삭제되었습니다.`,
                        success: true
                    });
                }
                return;
            }

            isZoneDragging = true;
            zonePlacedTiles.clear();

            const key = `${hovered.x},${hovered.y}`;
            if (isZone(hovered.x, hovered.y)) {
                setZone(hovered.x, hovered.y, CELL.EMPTY);
                zonePlacedTiles.add(key);
                rebuildZoneInstances(false);  // 건물 유지
                markDirty();
            }
            return;
        }

        // 구역 배치 모드 (드래그 칠하기)
        if (isZoneMode()) {
            // Ctrl+클릭: 도로를 따라 BFS 범위 선택
            if (e.ctrlKey || e.metaKey) {
                zonePlacedTiles.clear();
                const lineTiles = findLineTilesAlongRoad(hovered.x, hovered.y);
                if (lineTiles.length > 0) {
                    for (const tile of lineTiles) {
                        setZone(tile.x, tile.y, currentZoneType);
                        zonePlacedTiles.add(`${tile.x},${tile.y}`);
                    }
                    rebuildZoneInstances(false);
                    markDirty();

                    processNewZoneTiles(zonePlacedTiles, currentZoneType);
                    const zoneTypeName = ZONE_NAMES[currentZoneType] || '구역';
                    toast({
                        title: '구역 지정 완료',
                        desc: `${zonePlacedTiles.size}개 ${zoneTypeName} 타일이 지정되었습니다.`,
                        success: true
                    });
                    zonePlacedTiles.clear();
                }
                return;
            }

            // 일반 클릭: 드래그 칠하기 시작
            isZoneDragging = true;
            zonePlacedTiles.clear();

            if (canPlaceZone(hovered.x, hovered.y)) {
                const key = `${hovered.x},${hovered.y}`;
                setZone(hovered.x, hovered.y, currentZoneType);
                zonePlacedTiles.add(key);
                rebuildZoneInstances(false);
                markDirty();
            }
            return;
        }

        // 수로 모드 (도로 모드와 동일하게 드래그)
        if (currentMode === MODE.WATER) {
            isBuildDragging = true;
            buildStart = { x: hovered.x, y: hovered.y };
            currentPath = pickBestLPath(buildStart, hovered);
            setPreviewPath(currentPath, !!currentPath);
            return;
        }

        // 도로 모드 (2차선)
        if (currentMode === MODE.BUILD) {
            isBuildDragging = true;
            buildStart = { x: hovered.x, y: hovered.y };
            currentPath = pickBestLPath(buildStart, hovered);
            setPreviewPath(currentPath, !!currentPath);
            return;
        }

        // 4차선 도로 모드 (2x2 드래그 배치)
        if (currentMode === MODE.BUILD_4LANE) {
            isBuildDragging = true;
            buildStart = { x: hovered.x, y: hovered.y };
            current4LanePath = pickBest4LaneLPath(buildStart, hovered);
            set4LanePathPreview(current4LanePath, !!current4LanePath);
            return;
        }
    });

    renderer.domElement.addEventListener("pointerup", (e) => {
        if (!MAP_CONFIG.isOwner) return;

        // 철거 모드 드래그 종료 (독립 토글)
        if (isDemolishModeActive) {
            if (isDemolishDragging && demolishedTiles.size > 0) {
                toast({
                    title: '철거 완료',
                    desc: `${demolishedTiles.size}개 타일이 철거되었습니다.`,
                    success: true
                });
            }
            isDemolishDragging = false;
            demolishedTiles.clear();
            return;
        }

        // 구역 삭제 모드 드래그 종료
        if (currentMode === MODE.ZONE_DELETE) {
            if (isZoneDragging && zonePlacedTiles.size > 0) {
                toast({
                    title: '구역 삭제 완료',
                    desc: `${zonePlacedTiles.size}개 타일이 삭제되었습니다.`,
                    success: true
                });
            }
            isZoneDragging = false;
            zonePlacedTiles.clear();
            return;
        }

        // 구역 배치 모드 드래그 종료
        if (isZoneMode()) {
            if (isZoneDragging && zonePlacedTiles.size > 0) {
                // 새로 배치된 타일들에 대해 공사 대기열 추가
                processNewZoneTiles(zonePlacedTiles, currentZoneType);

                const zoneTypeName = ZONE_NAMES[currentZoneType] || '구역';
                toast({
                    title: `${zoneTypeName} 지정 완료`,
                    desc: `${zonePlacedTiles.size}개 타일이 지정되었습니다. 입주민 대기 중...`,
                    success: true
                });
            }
            isZoneDragging = false;
            zonePlacedTiles.clear();
            return;
        }

        // 방파제 설치 모드 드래그 종료
        if (currentMode === MODE.PLACE_BREAKWATER) {
            if (isBreakwaterDragging && breakwaterPlacedTiles.size > 0) {
                toast({
                    title: '방파제 설치 완료',
                    desc: `${breakwaterPlacedTiles.size}개 방파제가 설치되었습니다.`,
                    success: true
                });
            }
            isBreakwaterDragging = false;
            breakwaterPlacedTiles.clear();
            return;
        }

        // 수로 모드
        if (currentMode === MODE.WATER) {
            if (!buildStart) {
                isBuildDragging = false;
                costTooltip.style.display = 'none';
                return;
            }

            if (!hovered) {
                isBuildDragging = false;
                buildStart = null;
                currentPath = null;
                setPreviewPath(null);
                costTooltip.style.display = 'none';
                return;
            }

            currentPath = pickBestLPath(buildStart, hovered);

            if (!currentPath) {
                isBuildDragging = false;
                buildStart = null;
                currentPath = null;
                setPreviewPath(null);
                costTooltip.style.display = 'none';
                return;
            }

            // 설치할 타일 목록 수집 (아직 실제로 설치하지 않음)
            const tilesToPlace = [];
            for (const t of currentPath) {
                if (isRoad(t.x, t.y)) {
                    tilesToPlace.push({ x: t.x, y: t.y, type: 'bridge' });
                } else if (!isBridge(t.x, t.y)) {
                    tilesToPlace.push({ x: t.x, y: t.y, type: 'water' });
                }
            }

            // 순차적으로 수로 설치 + 먼지 이펙트
            if (tilesToPlace.length > 0) {
                placeWaterSequentially(tilesToPlace);
            }
            markDirty();

            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 4차선 도로 모드 (2x2 타일, 드래그 배치)
        if (currentMode === MODE.BUILD_4LANE) {
            if (!buildStart) {
                isBuildDragging = false;
                costTooltip.style.display = 'none';
                return;
            }

            if (!hovered) {
                isBuildDragging = false;
                buildStart = null;
                current4LanePath = null;
                set4LanePathPreview(null);
                costTooltip.style.display = 'none';
                return;
            }

            current4LanePath = pickBest4LaneLPath(buildStart, hovered);

            if (!current4LanePath || current4LanePath.length === 0) {
                isBuildDragging = false;
                buildStart = null;
                current4LanePath = null;
                set4LanePathPreview(null);
                costTooltip.style.display = 'none';
                return;
            }

            // 4차선 도로 경로 배치
            let placedCount = 0;
            const placedOrigins = [];
            for (const origin of current4LanePath) {
                if (place4LaneRoad(origin.x, origin.y)) {
                    placedCount++;
                    placedOrigins.push({ x: origin.x, y: origin.y });
                }
            }

            if (placedCount > 0) {
                rebuildRoadInstances();
                rebuildRoadModels();
                rebuildAllTiles();
                markDirty();

                // 4차선 도로 건설 먼지 이펙트 (순차적으로 퍼짐)
                create4LaneConstructionDustEffect(placedOrigins);

                toast({
                    title: '4차선 도로 설치',
                    desc: `${placedCount}개의 2x2 도로가 설치되었습니다.`,
                    success: true
                });
            }

            isBuildDragging = false;
            buildStart = null;
            current4LanePath = null;
            set4LanePathPreview(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 2차선 도로 모드
        if (currentMode !== MODE.BUILD) {
            isBuildDragging = false;
            costTooltip.style.display = 'none';
            return;
        }
        if (!buildStart) {
            isBuildDragging = false;
            costTooltip.style.display = 'none';
            return;
        }

        if (!hovered) {
            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        currentPath = pickBestLPath(buildStart, hovered);

        if (!currentPath) {
            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 2차선 도로 설치 (테스트 모드: 비용 무시)
        // 수로 위에 도로를 놓으면 다리가 됨

        // 2차선 도로 배치 규칙 검사 (4차선 연결 규칙 + 2x2 블록 규칙 + 경로 내 연속 배치 + 평행 배치)
        // 경로 전체에서 4차선 한 면에 연속 배치 체크
        const v3 = validatePathNo4LaneConsecutive(currentPath);
        if (!v3.valid) {
            toast({
                title: '도로 설치 불가',
                desc: v3.reason,
                success: false
            });
            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 기존 도로 옆에 2칸 이상 연속 배치 체크
        const v4 = validatePathNoParallelToRoad(currentPath);
        if (!v4.valid) {
            toast({
                title: '도로 설치 불가',
                desc: v4.reason,
                success: false
            });
            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 설치할 타일 목록 수집 (개별 셀 검증 후 유효한 타일만)
        const tilesToPlace = [];
        let skippedCount = 0;

        for (const t of currentPath) {
            // 개별 셀 검증 - 실패 시 해당 타일만 스킵
            const v1 = validate2LaneNear4Lane(t.x, t.y);
            if (!v1.valid) {
                skippedCount++;
                continue;
            }
            const v2 = validate2LaneNo2x2Block(t.x, t.y);
            if (!v2.valid) {
                skippedCount++;
                continue;
            }

            // 기본 조건 체크
            if (isWater(t.x, t.y)) {
                tilesToPlace.push({ x: t.x, y: t.y, type: 'bridge' });
            } else if (!isLocked(t.x, t.y) && !isBlocked(t.x, t.y)) {
                if (is4LaneRoad(t.x, t.y)) continue;
                if (placedPublicBuildings.has(`${t.x},${t.y}`)) continue;
                // 확장 터빈/패널 위에는 도로 설치 불가
                if (findExpansionTurbineAt(t.x, t.y)) continue;
                if (findExpansionSolarAt(t.x, t.y)) continue;
                tilesToPlace.push({ x: t.x, y: t.y, type: 'road' });
            } else {
                skippedCount++;
            }
        }

        // 순차적으로 도로 설치 + 먼지 이펙트
        if (tilesToPlace.length > 0) {
            placeRoadsSequentially(tilesToPlace);
        }

        // 변경사항 표시
        markDirty();

        isBuildDragging = false;
        buildStart = null;
        currentPath = null;
        setPreviewPath(null);
        costTooltip.style.display = 'none';
    });

    renderer.domElement.addEventListener("contextmenu", (e) => {
        if (currentMode === MODE.BUILD || currentMode === MODE.BUILD_4LANE || currentMode === MODE.WATER || isDemolishModeActive || isZoneMode() || currentMode === MODE.ZONE_DELETE) e.preventDefault();
    });

    /* =========================================================
     * BUILDING INFO POPUP SYSTEM
     * ========================================================= */

    // 선택된 건물 참조 (팝업 위치 추적용)
    let selectedBuilding = null;
    let selectedBuildingWorldPos = new THREE.Vector3();

    // 팝업 닫기 버튼
    if (popupClose) {
        popupClose.addEventListener('click', (e) => {
            e.stopPropagation();
            hideBuildingPopup();
        });
    }

    // 팝업 표시 함수
    function showBuildingPopup(building) {
        if (!buildingPopup) return;

        selectedBuilding = building;

        const userData = building.userData || {};
        const zoneType = userData.zoneType || 'residential';
        const size = userData.size || '1x1';
        const x = userData.tileX;
        const y = userData.tileY;

        // 건물 키 생성
        const key = getBuildingKey(x, y, size);

        // 건물 이름 가져오기 (displayName 우선, 없으면 생성)
        const placedBuilding = placedBuildings.get(`${x},${y}`);
        const displayName = placedBuilding?.displayName;
        const buildingName = displayName || assignBuildingName(key, zoneType);

        // 타입 정보
        const isResidential = zoneType.includes('residential');
        const isCommercial = zoneType.includes('commercial');
        const isIndustrial = zoneType.includes('industrial');

        let typeClass, typeIcon, typeText;
        if (isResidential) {
            typeClass = 'residential';
            typeIcon = '🏠';
            typeText = '주거';
        } else if (isCommercial) {
            typeClass = 'commercial';
            typeIcon = '🏪';
            typeText = '상업';
        } else {
            typeClass = 'industrial';
            typeIcon = '🏭';
            typeText = '공업';
        }

        // 땅값 계산
        const rawLandValue = typeof getLandValue === 'function' ? getLandValue(x, y) : 100;
        const serviceBonus = typeof getServiceBonus === 'function' ? getServiceBonus(x, y) : 0;

        // 인구 (주거 건물만)
        let population = 0;
        if (isResidential) {
            population = assignBuildingPopulation(key, size);
        }

        // 총 땅값 계산 (레벨 진행도용)
        const totalRawLandValue = rawLandValue + serviceBonus;

        // 행복도 계산 (땅값 기반 + 세금 패널티)
        const happiness = calculateBuildingHappiness(x, y);
        const happinessColor = getHappinessColor(happiness);

        // 팝업 내용 업데이트
        popupIcon.textContent = typeIcon;
        popupTitle.textContent = buildingName;

        popupType.className = 'popup-type ' + typeClass;
        popupTypeIcon.textContent = typeIcon;
        popupTypeText.textContent = typeText;

        // 인구 행 (주거만 표시)
        if (isResidential) {
            popupPopulationRow.style.display = 'flex';
            popupPopulation.textContent = population + '명';
            // 연령 분포 섹션 업데이트 (주거 건물만)
            updateAgeDistributionSection(key, population, true);
        } else {
            popupPopulationRow.style.display = 'none';
            // 연령 분포 숨기기
            updateAgeDistributionSection(key, 0, false);
        }

        // 행복도 바 업데이트 (정확한 수치 표시)
        if (happinessBarFill) {
            happinessBarFill.style.width = happiness + '%';
            happinessBarFill.style.background = happinessColor;
            happinessBarFill.style.boxShadow = `0 0 8px ${happinessColor}`;
        }

        // 행복도 수치 표시
        if (happinessValue) {
            happinessValue.textContent = happiness;
            happinessValue.style.color = happinessColor;
        }

        // 행복도 이모지 업데이트 (수치 기반)
        if (happinessEmoji) {
            if (happiness < 30) {
                happinessEmoji.textContent = '😢';
            } else if (happiness < 60) {
                happinessEmoji.textContent = '😐';
            } else {
                happinessEmoji.textContent = '😊';
            }
        }

        // 시민 한마디 업데이트 (요구사항 > 이벤트 > 효과 원인 기반)
        if (citizenQuote && citizenQuoteText) {
            // 건물 상태/요구사항 확인 (최우선)
            const buildingKey = `${x},${y}`;
            const requirementMessage = getBuildingRequirementMessage(x, y);

            // 이벤트 상태 확인 (화재 등)
            const isBurning = typeof burningBuildings !== 'undefined' && burningBuildings.has(buildingKey);

            // 업그레이드 공간 부족 확인 (1x1 건물이 땅값 충족했지만 공간 부족)
            const currentBuildingData = placedBuildings.get(buildingKey);
            const buildingWidth = currentBuildingData?.width || 1;
            const currentLevel = userData.level || 1;
            const currentTotalLandValue = getTotalLandValue(x, y);
            const cannotUpgradeDueToSpace = buildingWidth === 1 && currentLevel === 1 &&
                currentTotalLandValue >= LAND_VALUE_THRESHOLD &&
                !check2x2MergeEligibility(x, y, zoneType).canMerge;

            // 우선순위: 요구사항 메시지 > 화재 > 공간 부족 > 일반
            if (requirementMessage) {
                // 건물 요구사항 메시지 표시 (최우선)
                citizenQuoteText.textContent = requirementMessage;
                const highestStatus = getHighestPriorityStatus(buildingKey);
                // 치명적 문제(priority <= 4)는 negative, 서비스 요구사항은 mid
                const statusConfig = BUILDING_STATUS[highestStatus];
                if (statusConfig && statusConfig.priority <= 4) {
                    citizenQuote.className = 'citizen-quote negative';
                } else {
                    citizenQuote.className = 'citizen-quote mid';
                }
            } else if (isBurning) {
                // 화재 이벤트 문구 표시
                const fireQuotes = [
                    '🔥 불이야! 소방차가 필요해요!',
                    '🔥 도와주세요! 집에 불이 났어요!',
                    '🔥 빨리 대피해야 해요!',
                    '🔥 소방서에 연락해주세요!',
                ];
                citizenQuoteText.textContent = fireQuotes[Math.floor(Math.random() * fireQuotes.length)];
                citizenQuote.className = 'citizen-quote mid';  // 이벤트는 mid 스타일
            } else if (cannotUpgradeDueToSpace) {
                // 업그레이드 공간 부족 문구 표시
                const spaceQuotes = isResidential ? [
                    '📦 이 동네 땅값 올랐는데... 집이 너무 좁아요!',
                    '🏗️ 확장하고 싶은데 옆에 자리가 없네요...',
                    '😤 돈은 모았는데 확장할 공간이 없어요!',
                    '🏠 더 큰 집으로 이사가고 싶어요...',
                ] : isCommercial ? [
                    '📦 가게 확장하고 싶은데 자리가 없어요!',
                    '🏗️ 장사 잘 되는데 매장이 너무 좁네요...',
                    '😤 옆 가게가 비켜주면 확장할 텐데!',
                    '🏪 더 큰 매장이 필요해요...',
                ] : [
                    '📦 공장 확장이 필요한데 부지가 부족해요!',
                    '🏗️ 생산량 늘리고 싶은데 공간이 없네요...',
                    '😤 옆 부지를 사고 싶어요!',
                    '🏭 더 넓은 공장이 필요합니다...',
                ];
                citizenQuoteText.textContent = spaceQuotes[Math.floor(Math.random() * spaceQuotes.length)];
                citizenQuote.className = 'citizen-quote mid';
            } else {
                // 일반 시민 한마디 (행복도 기반)
                const happinessLevelForQuote = happiness < 30 ? 'low' : happiness < 60 ? 'mid' : 'high';
                const quote = getCitizenQuote(zoneType, happinessLevelForQuote, x, y);
                citizenQuoteText.textContent = quote;

                // 효과에 따른 스타일 변경
                const effect = analyzeBuildingEffect(x, y);
                if (effect) {
                    if (effect.isPositive) {
                        citizenQuote.className = 'citizen-quote positive';
                    } else {
                        citizenQuote.className = 'citizen-quote negative';
                    }
                } else {
                    citizenQuote.className = 'citizen-quote ' + happinessLevelForQuote;
                }
            }
        }

        // ===== 레벨 진행도 UI (땅값 통합) =====
        const levelProgressContainer = document.getElementById('levelProgressContainer');
        const levelProgressValue = document.getElementById('levelProgressValue');
        const levelProgressMarker = document.getElementById('levelProgressMarker');
        const levelSection2 = document.getElementById('levelSection2');
        const levelBadgeCurrent = document.getElementById('levelBadgeCurrent');
        const levelBadgeNext = document.getElementById('levelBadgeNext');
        const demolishInfoContainer = document.getElementById('demolishInfoContainer');

        const level = userData.level || 1;
        const currentLandVal = userData.currentLandValue || totalRawLandValue;
        const maxDisplayValue = LAND_VALUE_THRESHOLD * 2;  // 최대 표시 값 (100)

        // 마커 위치 계산 (0% ~ 100%)
        const markerPercent = Math.min((currentLandVal / maxDisplayValue) * 100, 100);

        // 폐건물인 경우
        if (userData.isAbandoned) {
            // 팝업 스타일 변경
            popupIcon.textContent = '🏚️';
            popupTitle.textContent = '폐건물';
            popupType.className = 'popup-type abandoned';
            popupTypeIcon.textContent = '⚠️';
            popupTypeText.textContent = '방치됨';

            // 레벨 진행도 숨김
            if (levelProgressContainer) {
                levelProgressContainer.style.display = 'none';
            }

            // 철거 안내 표시
            if (demolishInfoContainer) {
                demolishInfoContainer.style.display = 'block';
            }

            // 인구 숨김
            popupPopulationRow.style.display = 'none';

            // 연령 분포 숨김
            updateAgeDistributionSection(key, 0, false);

            // 행복도 전체 숨김
            if (happinessBarContainer) {
                happinessBarContainer.parentElement.parentElement.style.display = 'none';
            }
            const happinessRow = document.querySelector('.building-popup .popup-row.happiness');
            if (happinessRow) {
                happinessRow.style.display = 'none';
            }

            // 시민 한마디에 철거 이유 표시
            if (citizenQuote && citizenQuoteText) {
                const reason = userData.abandonedReason || '알 수 없는 이유로 방치되었습니다.';
                citizenQuoteText.textContent = reason;
                citizenQuote.className = 'citizen-quote abandoned';
            }
        } else {
            // 철거 안내 숨김
            if (demolishInfoContainer) {
                demolishInfoContainer.style.display = 'none';
            }
            if (levelProgressContainer) {
                levelProgressContainer.style.display = 'block';
                levelProgressContainer.classList.remove('abandoned');
            }
            if (happinessBarContainer) {
                happinessBarContainer.parentElement.parentElement.style.display = 'flex';
            }
            // 행복도 행 다시 표시
            const happinessRow = document.querySelector('.building-popup .popup-row.happiness');
            if (happinessRow) {
                happinessRow.style.display = 'flex';
            }
        }

        // 레벨 진행도 바 업데이트
        if (levelProgressValue) {
            levelProgressValue.textContent = `${Math.round(currentLandVal)} / ${LAND_VALUE_THRESHOLD}`;
        }

        // 마커 위치 업데이트
        if (levelProgressMarker) {
            levelProgressMarker.style.left = markerPercent + '%';

            // 마커 아이콘 업데이트
            const markerIcon = levelProgressMarker.querySelector('.marker-icon');
            if (markerIcon) {
                if (level === 2 || currentLandVal >= LAND_VALUE_THRESHOLD) {
                    markerIcon.textContent = '🏢';
                } else {
                    markerIcon.textContent = typeIcon;
                }
            }

            // eligible 클래스 토글
            if (currentLandVal >= LAND_VALUE_THRESHOLD) {
                levelProgressMarker.classList.add('eligible');
            } else {
                levelProgressMarker.classList.remove('eligible');
            }
        }

        // 레벨 2 섹션 활성화
        if (levelSection2) {
            if (currentLandVal >= LAND_VALUE_THRESHOLD) {
                levelSection2.classList.add('active');
            } else {
                levelSection2.classList.remove('active');
            }
        }

        // 레벨 뱃지 업데이트
        if (levelBadgeCurrent) {
            const currentBadgeIcon = levelBadgeCurrent.querySelector('.badge-icon');
            if (currentBadgeIcon) {
                currentBadgeIcon.textContent = level === 2 ? '🏢' : '🏠';
            }
            levelBadgeCurrent.querySelector('span:last-child').textContent = level === 2 ? 'LV.2' : 'LV.1';
        }

        if (levelBadgeNext) {
            if (level === 2) {
                levelBadgeNext.style.display = 'none';  // 이미 최고 레벨
            } else {
                levelBadgeNext.style.display = 'flex';
            }
        }

        buildingPopup.style.display = 'block';
        updatePopupPosition();
    }

    // 팝업 위치 업데이트용 재사용 객체 (매 프레임 new 방지)
    const _popupBox = new THREE.Box3();
    const _popupCenter = new THREE.Vector3();
    const _popupTop = new THREE.Vector3();
    const _popupScreenPos = new THREE.Vector3();

    // 건물 월드 좌표를 화면 좌표로 변환하여 팝업 위치 업데이트
    function updatePopupPosition() {
        if (!selectedBuilding || !buildingPopup || buildingPopup.style.display === 'none') return;

        // 건물의 바운딩 박스 중심점 계산 - 재사용 객체 사용
        _popupBox.setFromObject(selectedBuilding);
        _popupBox.getCenter(_popupCenter);
        _popupTop.copy(_popupCenter);
        _popupTop.y = _popupBox.max.y + 0.5;  // 건물 상단 위로 약간 띄움

        // 3D 좌표를 화면 좌표로 변환 - 재사용 객체 사용
        _popupScreenPos.copy(_popupTop).project(camera);

        // 캐시된 rect 사용
        const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
        const screenX = (_popupScreenPos.x * 0.5 + 0.5) * rect.width + rect.left;
        const screenY = (-_popupScreenPos.y * 0.5 + 0.5) * rect.height + rect.top;

        // 화면 밖으로 나갔는지 체크 (카메라 뒤쪽 또는 화면 경계 밖)
        const margin = 50;
        if (_popupScreenPos.z > 1 ||
            screenX < -margin || screenX > window.innerWidth + margin ||
            screenY < -margin || screenY > window.innerHeight + margin) {
            hideBuildingPopup();
            return;
        }

        // 팝업 위치 설정 (건물 위, 중앙 정렬)
        const popupWidth = 280;
        const popupHeight = buildingPopup.offsetHeight || 220;

        let posX = screenX - popupWidth / 2;
        let posY = screenY - popupHeight - 10;

        // 화면 경계 체크
        if (posX < 10) posX = 10;
        if (posX + popupWidth > window.innerWidth - 10) posX = window.innerWidth - popupWidth - 10;
        if (posY < 50) posY = screenY + 10;  // 위에 공간 없으면 아래로
        if (posY + popupHeight > window.innerHeight - 10) posY = window.innerHeight - popupHeight - 10;

        buildingPopup.style.left = posX + 'px';
        buildingPopup.style.top = posY + 'px';
    }

    // 팝업 숨기기
    function hideBuildingPopup() {
        if (buildingPopup) {
            buildingPopup.style.display = 'none';
        }
        selectedBuilding = null;
        // 선택 아웃라인도 제거
        clearBuildingOutline();
    }

    // ===== 공공시설 팝업 시스템 =====
    let selectedPublicBuilding = null;

    function showPublicBuildingPopup(building) {
        if (!publicBuildingPopup) return;

        selectedPublicBuilding = building;
        const userData = building.userData || {};
        const type = userData.publicBuildingType;
        const config = PUBLIC_BUILDING_MODELS[type];

        if (!config) return;

        // 아이콘과 타이틀
        publicPopupIcon.textContent = config.icon || '🏛️';
        publicPopupTitle.textContent = userData.name || config.name || '공공시설';

        // 타입 정보
        publicPopupTypeIcon.textContent = config.icon || '🏛️';
        publicPopupTypeText.textContent = config.name || type;

        // 소방서인 경우 소방차 현황 표시
        if (type === 'fire') {
            firetruckStatusSection.style.display = 'block';
            updateFiretruckStatus(userData.tileX, userData.tileY);
        } else {
            firetruckStatusSection.style.display = 'none';
        }

        // 경찰서인 경우 경찰차/감옥 현황 표시
        if (type === 'police') {
            policeStatusSection.style.display = 'block';
            updatePoliceStatus(userData.tileX, userData.tileY);
        } else {
            policeStatusSection.style.display = 'none';
        }

        // 병원인 경우 구급차/환자 현황 표시
        if (type === 'hospital') {
            hospitalStatusSection.style.display = 'block';
            updateHospitalStatus(userData.tileX, userData.tileY);
        } else {
            hospitalStatusSection.style.display = 'none';
        }

        // 하수처리장인 경우 시설 상태 표시
        if (type === 'wastewater') {
            wastewaterStatusSection.style.display = 'block';
            updateWastewaterStatus(userData.tileX, userData.tileY);
        } else {
            wastewaterStatusSection.style.display = 'none';
        }

        // 취수장인 경우 시설 상태 표시
        if (type === 'water_pump_coast') {
            waterPumpStatusSection.style.display = 'block';
            updateWaterPumpStatus(userData.tileX, userData.tileY);
        } else {
            waterPumpStatusSection.style.display = 'none';
        }

        // 풍력발전기인 경우 확장 섹션 표시
        if (type === 'powerplant_wind') {
            windTurbineExpansionSection.style.display = 'block';
            updateWindTurbineExpansionStatus(userData.tileX, userData.tileY);
        } else {
            windTurbineExpansionSection.style.display = 'none';
        }

        // 태양광발전기인 경우 확장 섹션 표시
        if (type === 'powerplant_solar') {
            solarPanelExpansionSection.style.display = 'block';
            updateSolarPanelExpansionStatus(userData.tileX, userData.tileY);
        } else {
            solarPanelExpansionSection.style.display = 'none';
        }

        publicBuildingPopup.style.display = 'block';
        updatePublicBuildingPopupPosition();
    }

    function updateFiretruckStatus(stationX, stationY) {
        const stationKey = `${stationX},${stationY}`;
        const maxTrucks = MAX_FIRETRUCKS_PER_STATION;

        // 해당 소방서에서 출동한 소방차 수 계산
        let dispatchedCount = 0;
        if (trafficManager && trafficManager.vehicles) {
            dispatchedCount = trafficManager.vehicles.filter(v =>
                v.isActive &&
                v.type === 'firetruck' &&
                v.stationKey === stationKey
            ).length;
        }

        const availableCount = Math.max(0, maxTrucks - dispatchedCount);
        const totalCount = maxTrucks;

        // 숫자 업데이트
        firetruckDispatched.textContent = dispatchedCount;
        firetruckAvailable.textContent = availableCount;
        firetruckTotal.textContent = totalCount;
        firetruckMax.textContent = maxTrucks;

        // 막대 그래프 업데이트
        const dispatchedPercent = (dispatchedCount / maxTrucks) * 100;
        const availablePercent = (availableCount / maxTrucks) * 100;

        firetruckBarDispatched.style.width = dispatchedPercent + '%';
        firetruckBarAvailable.style.width = availablePercent + '%';
    }

    function updatePoliceStatus(stationX, stationY) {
        const stationKey = `${stationX},${stationY}`;
        const maxCars = MAX_POLICE_PER_STATION;
        const maxPrisoners = MAX_PRISONERS_PER_STATION;

        // 해당 경찰서에서 출동한 경찰차 수 계산
        let dispatchedCount = 0;
        if (trafficManager && trafficManager.vehicles) {
            dispatchedCount = trafficManager.vehicles.filter(v =>
                v.isActive &&
                v.type === 'police' &&
                v.stationKey === stationKey
            ).length;
        }

        const availableCount = Math.max(0, maxCars - dispatchedCount);

        // 경찰차 숫자 업데이트
        policeDispatched.textContent = dispatchedCount;
        policeAvailable.textContent = availableCount;
        policeTotal.textContent = maxCars;
        policeMax.textContent = maxCars;

        // 경찰차 막대 그래프 업데이트
        const dispatchedPercent = (dispatchedCount / maxCars) * 100;
        const availablePercent = (availableCount / maxCars) * 100;
        policeBarDispatched.style.width = dispatchedPercent + '%';
        policeBarAvailable.style.width = availablePercent + '%';

        // 감옥 현황 업데이트
        const prisoners = stationPrisoners.get(stationKey) || [];
        const occupiedCount = prisoners.length;
        const emptyCount = maxPrisoners - occupiedCount;

        prisonOccupied.textContent = occupiedCount;
        prisonEmpty.textContent = emptyCount;
        prisonTotal.textContent = maxPrisoners;
        prisonMax.textContent = maxPrisoners;

        // 감옥 막대 그래프 업데이트
        const occupiedPercent = (occupiedCount / maxPrisoners) * 100;
        const emptyPercent = (emptyCount / maxPrisoners) * 100;
        prisonBarOccupied.style.width = occupiedPercent + '%';
        prisonBarEmpty.style.width = emptyPercent + '%';
    }

    function updateHospitalStatus(hospitalX, hospitalY) {
        const hospitalKey = `${hospitalX},${hospitalY}`;
        const maxAmbulances = MAX_AMBULANCES_PER_HOSPITAL;
        const maxPatients = MAX_PATIENTS_PER_HOSPITAL;

        // 해당 병원에서 출동한 구급차 수 계산
        let dispatchedCount = 0;
        if (trafficManager && trafficManager.vehicles) {
            dispatchedCount = trafficManager.vehicles.filter(v =>
                v.isActive &&
                v.type === 'ambulance' &&
                v.hospitalKey === hospitalKey
            ).length;
        }

        const availableCount = Math.max(0, maxAmbulances - dispatchedCount);

        // 구급차 숫자 업데이트
        ambulanceDispatched.textContent = dispatchedCount;
        ambulanceAvailable.textContent = availableCount;
        ambulanceTotal.textContent = maxAmbulances;
        ambulanceMax.textContent = maxAmbulances;

        // 구급차 막대 그래프 업데이트
        const dispatchedPercent = (dispatchedCount / maxAmbulances) * 100;
        const availablePercent = (availableCount / maxAmbulances) * 100;
        ambulanceBarDispatched.style.width = dispatchedPercent + '%';
        ambulanceBarAvailable.style.width = availablePercent + '%';

        // 환자 현황 업데이트
        const patients = hospitalPatients.get(hospitalKey) || [];
        const occupiedCount = patients.length;
        const emptyCount = maxPatients - occupiedCount;

        patientOccupied.textContent = occupiedCount;
        patientEmpty.textContent = emptyCount;
        patientTotal.textContent = maxPatients;
        patientMax.textContent = maxPatients;

        // 환자 막대 그래프 업데이트
        const occupiedPercent = (occupiedCount / maxPatients) * 100;
        const emptyPercent = (emptyCount / maxPatients) * 100;
        patientBarOccupied.style.width = occupiedPercent + '%';
        patientBarEmpty.style.width = emptyPercent + '%';
    }

    function updateWastewaterStatus(x, y) {
        const key = `${x},${y}`;
        const facility = placedPublicBuildings.get(key);

        if (!facility) return;

        // 작동 여부 확인
        const isOperational = typeof serviceBuildingManager !== 'undefined' &&
            serviceBuildingManager.isOperational(x, y);

        // 작동 여부 표시
        if (isOperational) {
            wastewaterOperational.textContent = '✅ 작동 중';
            wastewaterOperational.style.color = '#22c55e';
        } else {
            // 작동 안 되는 이유 확인
            const status = serviceBuildingManager.statusMap.get(key);
            let reason = '❌ 정지';
            if (status) {
                if (!status.hasRoad) reason = '❌ 도로 미연결';
                else if (!status.hasPower) reason = '❌ 전력 부족';
            }
            wastewaterOperational.textContent = reason;
            wastewaterOperational.style.color = '#ef4444';
        }

        // 처리 용량 표시
        const config = PUBLIC_BUILDING_MODELS['wastewater'];
        const capacity = facility.capacity || config?.sewageCapacity || 500;
        wastewaterCapacity.textContent = capacity + ' L/일';
    }

    function updateWaterPumpStatus(x, y) {
        const key = `${x},${y}`;
        const facility = placedPublicBuildings.get(key);

        if (!facility) return;

        // 작동 여부 확인
        const isOperational = typeof serviceBuildingManager !== 'undefined' &&
            serviceBuildingManager.isOperational(x, y);

        // 작동 여부 표시
        if (isOperational) {
            waterPumpOperational.textContent = '✅ 작동 중';
            waterPumpOperational.style.color = '#22c55e';
        } else {
            // 작동 안 되는 이유 확인
            const status = serviceBuildingManager.statusMap.get(key);
            let reason = '❌ 정지';
            if (status) {
                if (!status.hasRoad) reason = '❌ 도로 미연결';
                else if (!status.hasPower) reason = '❌ 전력 부족';
            }
            waterPumpOperational.textContent = reason;
            waterPumpOperational.style.color = '#ef4444';
        }

        // 취수량 표시
        const config = PUBLIC_BUILDING_MODELS['water_pump_coast'];
        const output = facility.waterOutput || config?.waterOutput || 600;
        waterPumpOutput.textContent = output + ' L/일';
    }

    /* =========================================================
     * WIND TURBINE EXPANSION SYSTEM
     * ========================================================= */

    function updateWindTurbineExpansionStatus(x, y) {
        const key = `${x},${y}`;
        const building = placedPublicBuildings.get(key);
        if (!building) return;

        const config = PUBLIC_BUILDING_MODELS['powerplant_wind'];
        const expansions = building.expansions || 0;
        const maxExpansions = config.maxExpansions || 5;

        // 터빈 수 (메인 1개 + 확장)
        const totalTurbines = 1 + expansions;
        windTurbineCount.textContent = totalTurbines;
        windTurbineMax.textContent = 1 + maxExpansions;

        // 총 발전량 (풍량에 비례)
        const basePower = config.powerOutput || 100;
        const expansionPower = config.expansionPowerOutput || 80;
        const { actualPower, windStrength, totalBasePower } = calculateWindTurbinePower(
            x, y, basePower, expansions, expansionPower
        );
        const windPercent = Math.round(windStrength * 100);
        windTurbinePower.textContent = `${actualPower} kW (풍량 ${windPercent}%)`;

        // 유지비
        const baseMaintenance = config.maintenanceCost || 30;
        const expansionMaintenance = config.expansionMaintenanceCost || 20;
        const totalMaintenance = baseMaintenance + (expansions * expansionMaintenance);
        windTurbineMaintenance.textContent = '₩' + totalMaintenance + '/h';

        // 시각적 슬롯 업데이트
        const slots = windExpansionVisual.querySelectorAll('.turbine-slot');
        slots.forEach((slot, index) => {
            if (index === 0) return; // 메인 터빈은 항상 표시

            const slotNum = parseInt(slot.dataset.slot);
            if (slotNum <= expansions) {
                slot.className = 'turbine-slot filled';
                slot.textContent = '💨';
            } else if (slotNum === expansions + 1) {
                // 다음 확장 가능 슬롯
                slot.className = 'turbine-slot empty';
                slot.textContent = '+';
            } else {
                // 아직 확장 불가 슬롯
                slot.className = 'turbine-slot empty disabled';
                slot.textContent = '+';
            }
        });

        // 확장 버튼 상태
        const expansionCost = config.expansionCost || 2000;
        expansionCostText.textContent = '₩' + expansionCost.toLocaleString();

        if (expansions >= maxExpansions) {
            btnExpandWindTurbine.disabled = true;
            btnExpandWindTurbine.querySelector('.btn-text').textContent = '최대 확장';
            expansionInfo.textContent = '최대 확장에 도달했습니다';
        } else {
            // 확장 가능 여부 확인 (공간, 자금) - 이유도 함께 반환
            const expansionCheck = checkWindTurbineExpansionSpace(x, y, building, expansions + 1, true);
            const canExpand = expansionCheck.valid;
            const hasMoney = economy.money >= expansionCost;

            btnExpandWindTurbine.disabled = !canExpand || !hasMoney;

            if (!canExpand) {
                // 구체적인 이유에 따른 메시지 표시
                const reasonMessages = {
                    'out_of_bounds': '❌ 맵 범위를 벗어납니다',
                    'not_grass': '❌ 잔디 위에만 확장할 수 있습니다',
                    'road': '❌ 도로 위에는 확장할 수 없습니다',
                    'water': '❌ 수로/다리 위에는 확장할 수 없습니다',
                    'zone': '❌ 구역이 지정된 곳에는 확장할 수 없습니다',
                    'beach': '❌ 해변/바다 위에는 확장할 수 없습니다',
                    'breakwater': '❌ 방파제 위에는 확장할 수 없습니다',
                    'building': '❌ 다른 건물이 있습니다'
                };
                expansionInfo.textContent = reasonMessages[expansionCheck.reason] || '❌ 확장할 공간이 부족합니다';
            } else if (!hasMoney) {
                expansionInfo.textContent = '❌ 자금이 부족합니다';
            } else {
                expansionInfo.textContent = `확장 시 +${expansionPower} kW, 유지비 +₩${expansionMaintenance}/h`;
            }
        }
    }

    // 풍력발전기 확장 공간 확인 - 이유 반환 버전
    function checkWindTurbineExpansionSpace(x, y, building, expansionNum, returnReason = false) {
        const config = PUBLIC_BUILDING_MODELS['powerplant_wind'];
        const expSize = config.expansionSize || { width: 3, depth: 1 };

        // 건물의 방향에 따라 뒤쪽 방향 결정
        const roadSide = building.roadSide || 'bottom';

        // 확장 위치 계산 (메인 건물 뒤쪽으로 확장)
        let expX = x, expY = y;

        // 도로 방향에 따라 메인 건물의 깊이(확장 방향) 결정
        // 상/하 도로: depth 방향으로 확장, 좌/우 도로: width 방향으로 확장
        const isVerticalRoad = (roadSide === 'left' || roadSide === 'right');
        const mainLength = isVerticalRoad ? (building.width || 4) : (building.depth || 4);

        // 현재 확장까지의 깊이 계산
        const prevExpansionDepth = (expansionNum - 1) * expSize.depth;

        // 터빈이 바라보는 방향의 반대쪽(뒤쪽)으로 확장
        switch (roadSide) {
            case 'bottom':  // 도로가 아래 → 터빈이 남쪽을 봄 → 북쪽(뒤)으로 확장
                expY = y - expSize.depth - prevExpansionDepth;
                break;
            case 'top':     // 도로가 위 → 터빈이 북쪽을 봄 → 남쪽(뒤)으로 확장
                expY = y + mainLength + prevExpansionDepth;
                break;
            case 'left':    // 도로가 왼쪽 → 터빈이 서쪽을 봄 → 동쪽(뒤)으로 확장
                expX = x + mainLength + prevExpansionDepth;
                break;
            case 'right':   // 도로가 오른쪽 → 터빈이 동쪽을 봄 → 서쪽(뒤)으로 확장
                expX = x - expSize.depth - prevExpansionDepth;
                break;
        }

        // 해당 영역이 건설 가능한지 확인
        // 좌/우 도로: 확장이 Y방향으로 3칸, X방향으로 1칸
        // 상/하 도로: 확장이 X방향으로 3칸, Y방향으로 1칸
        const width = isVerticalRoad ? expSize.depth : expSize.width;
        const depth = isVerticalRoad ? expSize.width : expSize.depth;

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const checkX = expX + dx;
                const checkY = expY + dy;

                // 맵 범위 확인
                if (checkX < 0 || checkX >= GRID_W || checkY < 0 || checkY >= GRID_H) {
                    return returnReason ? { valid: false, reason: 'out_of_bounds' } : false;
                }

                // 잔디/빈 타일인지 확인 (CELL.EMPTY = 0)
                const cell = grid[checkX]?.[checkY];
                if (cell === undefined || cell !== CELL.EMPTY) {
                    // 구체적인 이유 파악
                    let reason = 'not_grass';
                    if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD || cell === CELL.ROAD_4LANE || cell === CELL.LOCKED_ROAD_4LANE) {
                        reason = 'road';
                    } else if (cell === CELL.WATER || cell === CELL.BRIDGE) {
                        reason = 'water';
                    } else if (cell === CELL.ZONE_RESIDENTIAL || cell === CELL.ZONE_COMMERCIAL || cell === CELL.ZONE_INDUSTRIAL) {
                        reason = 'zone';
                    } else if (cell === CELL.BEACH || cell === CELL.OCEAN) {
                        reason = 'beach';
                    } else if (cell === CELL.BREAKWATER) {
                        reason = 'breakwater';
                    }
                    return returnReason ? { valid: false, reason: reason } : false;
                }

                // 다른 건물이 없는지 확인
                if (placedBuildings.has(`${checkX},${checkY}`) ||
                    placedPublicBuildings.has(`${checkX},${checkY}`)) {
                    return returnReason ? { valid: false, reason: 'building' } : false;
                }
            }
        }

        return returnReason ? { valid: true, reason: null } : true;
    }

    // 풍력발전기 확장 실행
    function expandWindTurbine(x, y) {
        const key = `${x},${y}`;
        const building = placedPublicBuildings.get(key);
        if (!building) return;

        const config = PUBLIC_BUILDING_MODELS['powerplant_wind'];
        const expansions = building.expansions || 0;
        const maxExpansions = config.maxExpansions || 5;
        const expansionCost = config.expansionCost || 2000;

        if (expansions >= maxExpansions) {
            toast({ title: '최대 확장', desc: '최대 확장에 도달했습니다' });
            return;
        }

        if (economy.money < expansionCost) {
            toast({ title: '자금 부족', desc: '자금이 부족합니다' });
            return;
        }

        const expansionCheck = checkWindTurbineExpansionSpace(x, y, building, expansions + 1, true);
        if (!expansionCheck.valid) {
            // 구체적인 이유에 따른 토스트 메시지
            const reasonMessages = {
                'out_of_bounds': '맵 범위를 벗어납니다',
                'not_grass': '잔디 위에만 확장할 수 있습니다',
                'road': '도로 위에는 확장할 수 없습니다',
                'water': '수로/다리 위에는 확장할 수 없습니다',
                'zone': '구역이 지정된 곳에는 확장할 수 없습니다',
                'beach': '해변/바다 위에는 확장할 수 없습니다',
                'breakwater': '방파제 위에는 확장할 수 없습니다',
                'building': '다른 건물이 있습니다'
            };
            toast({ title: '확장 불가', desc: reasonMessages[expansionCheck.reason] || '확장할 공간이 부족합니다' });
            return;
        }

        // 비용 차감
        economy.money -= expansionCost;
        updateBudgetDisplay();
        markDirty();

        // 확장 터빈 배치
        placeWindTurbineExpansion(x, y, building, expansions + 1);

        // 확장 수 증가
        building.expansions = expansions + 1;

        // 전력망 업데이트 (풍량에 비례한 전력 계산)
        if (powerManager && powerManager.initialized) {
            const { actualPower } = calculateWindTurbinePower(
                x, y,
                config.powerOutput,
                building.expansions,
                config.expansionPowerOutput
            );
            powerManager.updatePowerPlantOutput(x, y, actualPower);
            powerManager.recalculatePowerGrid();
        }

        // UI 업데이트
        updateWindTurbineExpansionStatus(x, y);

        toast({ title: '확장 완료', desc: '터빈이 확장되었습니다!', success: true });
    }

    // 확장 터빈 3D 모델 배치
    function placeWindTurbineExpansion(x, y, building, expansionNum) {
        const config = PUBLIC_BUILDING_MODELS['powerplant_wind'];
        const expSize = config.expansionSize || { width: 3, depth: 1 };
        const roadSide = building.roadSide || 'bottom';

        // 확장 위치 계산
        let expX = x, expY = y;
        // 도로 방향에 따라 메인 건물의 깊이(확장 방향) 결정
        const isVerticalRoad = (roadSide === 'left' || roadSide === 'right');
        const mainLength = isVerticalRoad ? (building.width || 4) : (building.depth || 4);
        const prevExpansionDepth = (expansionNum - 1) * expSize.depth;

        // 터빈이 바라보는 방향의 반대쪽(뒤쪽)으로 확장
        switch (roadSide) {
            case 'bottom':  // 도로가 아래 → 터빈이 남쪽을 봄 → 북쪽(뒤)으로 확장
                expY = y - expSize.depth - prevExpansionDepth;
                break;
            case 'top':     // 도로가 위 → 터빈이 북쪽을 봄 → 남쪽(뒤)으로 확장
                expY = y + mainLength + prevExpansionDepth;
                break;
            case 'left':    // 도로가 왼쪽 → 터빈이 서쪽을 봄 → 동쪽(뒤)으로 확장
                expX = x + mainLength + prevExpansionDepth;
                break;
            case 'right':   // 도로가 오른쪽 → 터빈이 동쪽을 봄 → 서쪽(뒤)으로 확장
                expX = x - expSize.depth - prevExpansionDepth;
                break;
        }

        // 확장 터빈 모델 로드 및 배치
        const width = (roadSide === 'left' || roadSide === 'right') ? expSize.depth : expSize.width;
        const depth = (roadSide === 'left' || roadSide === 'right') ? expSize.width : expSize.depth;

        const worldX = ORIGIN_X + expX + width / 2;
        const worldZ = ORIGIN_Z + expY + depth / 2;

        // 터빈 기준 왼쪽 방향 오프셋 (1칸)
        let leftOffsetX = 0, leftOffsetZ = 0;
        switch (roadSide) {
            case 'bottom': leftOffsetX = -1; break;  // 터빈이 남쪽을 봄 → 오른쪽(-X)
            case 'top': leftOffsetX = 1; break;      // 터빈이 북쪽을 봄 → 오른쪽(+X)
            case 'left': leftOffsetZ = -1; break;    // 터빈이 서쪽을 봄 → 왼쪽은 북쪽(-Z)
            case 'right': leftOffsetZ = 1; break;    // 터빈이 동쪽을 봄 → 왼쪽은 남쪽(+Z)
        }

        // 확장 터빈 정보를 모델 로드 전에 먼저 추가 (도로 설치 차단을 위해)
        if (!building.expansionInstances) {
            building.expansionInstances = [];
        }
        const expansionInfo = {
            instance: null,  // 모델 로드 후 설정
            x: expX,
            y: expY,
            width: width,
            depth: depth
        };
        building.expansionInstances.push(expansionInfo);
        const expansionIndex = building.expansionInstances.length - 1;

        // 타일 점유 표시 (모델 로드 전에 미리)
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const tileKey = `${expX + dx},${expY + dy}`;
                if (building.tiles instanceof Set) {
                    building.tiles.add(tileKey);
                } else if (Array.isArray(building.tiles)) {
                    if (!building.tiles.includes(tileKey)) {
                        building.tiles.push(tileKey);
                    }
                }
                // 나무 제거
                removeTreeAt(expX + dx, expY + dy);
            }
        }

        // 확장 모듈 모델 로드 (turbin_module.glb)
        const expLoader = new GLTFLoader();
        expLoader.load('/models/turbin_module.glb', (gltf) => {
            const instance = gltf.scene;

            instance.position.set(worldX + leftOffsetX, 0.02, worldZ + leftOffsetZ);

            // 메인 터빈과 같은 회전 적용
            instance.rotation.y = building.instance?.rotation.y || 0;

            // 스케일 조정 (3x1 타일에 맞게 축소)
            instance.scale.setScalar(0.132);

            // 그림자 설정 및 머티리얼을 조명 반응형으로 교체
            instance.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;

                    // MeshLambertMaterial로 교체 (조명 반응)
                    const oldMat = child.material;
                    child.material = new THREE.MeshLambertMaterial({
                        color: oldMat.color ? oldMat.color.clone() : new THREE.Color(0xffffff),
                        map: oldMat.map || null,
                        transparent: oldMat.transparent || false,
                        opacity: oldMat.opacity !== undefined ? oldMat.opacity : 1,
                        side: oldMat.side || THREE.FrontSide
                    });
                }
            });

            scene.add(instance);

            // 모델 로드 완료 후 인스턴스 참조 업데이트
            building.expansionInstances[expansionIndex].instance = instance;

            // 프로펠러 회전 등록 (turbin_module.glb의 프로펠러 이름 검색)
            instance.traverse((child) => {
                // 'Helice_Eolienne' 또는 'propeller'가 포함된 이름 모두 검색
                const nameLower = (child.name || '').toLowerCase();
                if (child.name === 'Helice_Eolienne' || nameLower.includes('propeller') || nameLower.includes('helice')) {
                    child.rotation.x = Math.random() * Math.PI * 2;
                    windTurbinePropellers.push({
                        propeller: child,
                        key: `${x},${y}_exp${expansionNum}`,
                        speed: 1.33  // 메인 터빈과 동일한 속도
                    });
                    console.log(`[풍력 확장] 프로펠러 등록: ${child.name}`);
                }
            });

            console.log(`[풍력 확장] 모듈 배치 완료: (${expX}, ${expY})`);
        }, undefined, (error) => {
            console.error('[풍력 확장] 모델 로드 실패:', error);
        });
    }

    // 확장 버튼 이벤트 리스너
    if (btnExpandWindTurbine) {
        btnExpandWindTurbine.addEventListener('click', () => {
            if (!selectedPublicBuilding) return;
            const userData = selectedPublicBuilding.userData || {};
            expandWindTurbine(userData.tileX, userData.tileY);
        });
    }

    // 확장 슬롯 hover 시 프리뷰 표시
    if (windExpansionVisual) {
        const slots = windExpansionVisual.querySelectorAll('.turbine-slot[data-slot]');
        slots.forEach(slot => {
            slot.addEventListener('mouseenter', () => {
                if (!selectedPublicBuilding) return;
                const userData = selectedPublicBuilding.userData || {};
                const key = `${userData.tileX},${userData.tileY}`;
                const building = placedPublicBuildings.get(key);
                if (!building) return;

                const slotNum = parseInt(slot.dataset.slot, 10);
                const existingExpansions = building.expansions || 0;

                // 아직 설치되지 않은 슬롯만 프리뷰 표시
                if (slotNum > existingExpansions) {
                    showExpansionPreview(building, slotNum);
                }
            });

            slot.addEventListener('mouseleave', () => {
                hideExpansionPreview();
            });
        });
    }

    // 확장 버튼 hover 시 다음 확장 위치 프리뷰 표시
    if (btnExpandWindTurbine) {
        btnExpandWindTurbine.addEventListener('mouseenter', () => {
            if (!selectedPublicBuilding) return;
            const userData = selectedPublicBuilding.userData || {};
            const key = `${userData.tileX},${userData.tileY}`;
            const building = placedPublicBuildings.get(key);
            if (!building) return;

            const existingExpansions = building.expansions || 0;
            const config = PUBLIC_BUILDING_MODELS['powerplant_wind'];
            const maxExpansions = config.maxExpansions || 5;

            // 다음 확장 위치 프리뷰 표시
            if (existingExpansions < maxExpansions) {
                showExpansionPreview(building, existingExpansions + 1);
            }
        });

        btnExpandWindTurbine.addEventListener('mouseleave', () => {
            hideExpansionPreview();
        });
    }

    /* =========================================================
     * SOLAR PANEL EXPANSION SYSTEM
     * ========================================================= */

    function updateSolarPanelExpansionStatus(x, y) {
        const key = `${x},${y}`;
        const building = placedPublicBuildings.get(key);
        if (!building) return;

        const config = PUBLIC_BUILDING_MODELS['powerplant_solar'];
        const expansions = building.expansions || 0;
        const maxExpansions = config.maxExpansions || 5;

        // 패널 수 (메인 1개 + 확장)
        const totalPanels = 1 + expansions;
        solarPanelCount.textContent = totalPanels;
        solarPanelMax.textContent = 1 + maxExpansions;

        // 총 발전량
        const basePower = config.powerOutput || 150;
        const expansionPower = config.expansionPowerOutput || 100;
        const totalPower = basePower + (expansions * expansionPower);
        solarPanelPower.textContent = `${totalPower} kW`;

        // 유지비
        const baseMaintenance = config.maintenanceCost || 40;
        const expansionMaintenance = config.expansionMaintenanceCost || 25;
        const totalMaintenance = baseMaintenance + (expansions * expansionMaintenance);
        solarPanelMaintenance.textContent = '₩' + totalMaintenance + '/h';

        // 시각적 슬롯 업데이트
        const slots = solarExpansionVisual.querySelectorAll('.solar-slot');
        slots.forEach((slot, index) => {
            if (index === 0) return; // 메인 패널은 항상 표시

            const slotNum = parseInt(slot.dataset.slot);
            if (slotNum <= expansions) {
                slot.className = 'solar-slot filled';
                slot.textContent = '☀️';
            } else if (slotNum === expansions + 1) {
                slot.className = 'solar-slot empty';
                slot.textContent = '+';
            } else {
                slot.className = 'solar-slot empty disabled';
                slot.textContent = '+';
            }
        });

        // 확장 버튼 상태
        const expansionCost = config.expansionCost || 2500;
        solarExpansionCostText.textContent = '₩' + expansionCost.toLocaleString();

        if (expansions >= maxExpansions) {
            btnExpandSolarPanel.disabled = true;
            btnExpandSolarPanel.querySelector('.btn-text').textContent = '최대 확장';
            solarExpansionInfo.textContent = '최대 확장에 도달했습니다';
        } else {
            const expansionCheck = checkSolarPanelExpansionSpace(x, y, building, expansions + 1, true);
            const canExpand = expansionCheck.valid;
            const hasMoney = economy.money >= expansionCost;

            btnExpandSolarPanel.disabled = !canExpand || !hasMoney;

            if (!canExpand) {
                const reasonMessages = {
                    'out_of_bounds': '❌ 맵 범위를 벗어납니다',
                    'not_grass': '❌ 잔디 위에만 확장할 수 있습니다',
                    'road': '❌ 도로 위에는 확장할 수 없습니다',
                    'water': '❌ 수로/다리 위에는 확장할 수 없습니다',
                    'zone': '❌ 구역이 지정된 곳에는 확장할 수 없습니다',
                    'beach': '❌ 해변/바다 위에는 확장할 수 없습니다',
                    'breakwater': '❌ 방파제 위에는 확장할 수 없습니다',
                    'building': '❌ 다른 건물이 있습니다'
                };
                solarExpansionInfo.textContent = reasonMessages[expansionCheck.reason] || '❌ 확장할 공간이 부족합니다';
            } else if (!hasMoney) {
                solarExpansionInfo.textContent = '❌ 자금이 부족합니다';
            } else {
                solarExpansionInfo.textContent = `확장 시 +${expansionPower} kW, 유지비 +₩${expansionMaintenance}/h`;
            }
        }
    }

    // 태양광 패널 확장 공간 확인 (풍력과 동일한 방식)
    function checkSolarPanelExpansionSpace(x, y, building, expansionNum, returnReason = false) {
        const config = PUBLIC_BUILDING_MODELS['powerplant_solar'];
        const expSize = config.expansionSize || { width: 3, depth: 1 };
        const roadSide = building.roadSide || 'bottom';

        let expX = x, expY = y;
        const isVerticalRoad = (roadSide === 'left' || roadSide === 'right');
        const mainLength = isVerticalRoad ? (building.width || 4) : (building.depth || 4);
        const prevExpansionDepth = (expansionNum - 1) * expSize.depth;

        switch (roadSide) {
            case 'bottom': expY = y - expSize.depth - prevExpansionDepth; break;
            case 'top': expY = y + mainLength + prevExpansionDepth; break;
            case 'left': expX = x + mainLength + prevExpansionDepth; break;
            case 'right': expX = x - expSize.depth - prevExpansionDepth; break;
        }

        const width = isVerticalRoad ? expSize.depth : expSize.width;
        const depth = isVerticalRoad ? expSize.width : expSize.depth;

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const checkX = expX + dx;
                const checkY = expY + dy;

                if (checkX < 0 || checkX >= GRID_W || checkY < 0 || checkY >= GRID_H) {
                    return returnReason ? { valid: false, reason: 'out_of_bounds' } : false;
                }

                const cell = grid[checkX]?.[checkY];
                if (cell === undefined || cell !== CELL.EMPTY) {
                    let reason = 'not_grass';
                    if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD || cell === CELL.ROAD_4LANE || cell === CELL.LOCKED_ROAD_4LANE) {
                        reason = 'road';
                    } else if (cell === CELL.WATER || cell === CELL.BRIDGE) {
                        reason = 'water';
                    } else if (cell === CELL.ZONE_RESIDENTIAL || cell === CELL.ZONE_COMMERCIAL || cell === CELL.ZONE_INDUSTRIAL) {
                        reason = 'zone';
                    } else if (cell === CELL.BEACH || cell === CELL.OCEAN) {
                        reason = 'beach';
                    } else if (cell === CELL.BREAKWATER) {
                        reason = 'breakwater';
                    }
                    return returnReason ? { valid: false, reason: reason } : false;
                }

                if (placedBuildings.has(`${checkX},${checkY}`) ||
                    placedPublicBuildings.has(`${checkX},${checkY}`)) {
                    return returnReason ? { valid: false, reason: 'building' } : false;
                }
            }
        }

        return returnReason ? { valid: true, reason: null } : true;
    }

    // 태양광 패널 확장 실행
    function expandSolarPanel(x, y) {
        const key = `${x},${y}`;
        const building = placedPublicBuildings.get(key);
        if (!building) return;

        const config = PUBLIC_BUILDING_MODELS['powerplant_solar'];
        const expansions = building.expansions || 0;
        const maxExpansions = config.maxExpansions || 5;
        const expansionCost = config.expansionCost || 2500;

        if (expansions >= maxExpansions) {
            toast({ title: '최대 확장', desc: '최대 확장에 도달했습니다' });
            return;
        }

        if (economy.money < expansionCost) {
            toast({ title: '자금 부족', desc: '자금이 부족합니다' });
            return;
        }

        const expansionCheck = checkSolarPanelExpansionSpace(x, y, building, expansions + 1, true);
        if (!expansionCheck.valid) {
            const reasonMessages = {
                'out_of_bounds': '맵 범위를 벗어납니다',
                'not_grass': '잔디 위에만 확장할 수 있습니다',
                'road': '도로 위에는 확장할 수 없습니다',
                'water': '수로/다리 위에는 확장할 수 없습니다',
                'zone': '구역이 지정된 곳에는 확장할 수 없습니다',
                'beach': '해변/바다 위에는 확장할 수 없습니다',
                'breakwater': '방파제 위에는 확장할 수 없습니다',
                'building': '다른 건물이 있습니다'
            };
            toast({ title: '확장 불가', desc: reasonMessages[expansionCheck.reason] || '확장할 공간이 부족합니다' });
            return;
        }

        // 비용 차감
        economy.money -= expansionCost;
        updateBudgetDisplay();
        markDirty();

        // 확장 패널 배치
        placeSolarPanelExpansion(x, y, building, expansions + 1);

        // 확장 수 증가
        building.expansions = expansions + 1;

        // 전력망 업데이트
        if (powerManager && powerManager.initialized) {
            const totalPower = config.powerOutput + (building.expansions * config.expansionPowerOutput);
            powerManager.updatePowerPlantOutput(x, y, totalPower);
            powerManager.recalculatePowerGrid();
        }

        // UI 업데이트
        updateSolarPanelExpansionStatus(x, y);

        toast({ title: '확장 완료', desc: '태양광 패널이 확장되었습니다!', success: true });
    }

    // 확장 패널 3D 모델 배치 (풍력과 동일한 방식)
    function placeSolarPanelExpansion(x, y, building, expansionNum) {
        const config = PUBLIC_BUILDING_MODELS['powerplant_solar'];
        const expSize = config.expansionSize || { width: 3, depth: 1 };
        const roadSide = building.roadSide || 'bottom';

        let expX = x, expY = y;
        const isVerticalRoad = (roadSide === 'left' || roadSide === 'right');
        const mainLength = isVerticalRoad ? (building.width || 4) : (building.depth || 4);
        const prevExpansionDepth = (expansionNum - 1) * expSize.depth;

        // 패널이 바라보는 방향의 반대쪽(뒤쪽)으로 확장
        switch (roadSide) {
            case 'bottom': expY = y - expSize.depth - prevExpansionDepth; break;
            case 'top': expY = y + mainLength + prevExpansionDepth; break;
            case 'left': expX = x + mainLength + prevExpansionDepth; break;
            case 'right': expX = x - expSize.depth - prevExpansionDepth; break;
        }

        const width = isVerticalRoad ? expSize.depth : expSize.width;
        const depth = isVerticalRoad ? expSize.width : expSize.depth;

        const worldX = ORIGIN_X + expX + width / 2;
        const worldZ = ORIGIN_Z + expY + depth / 2;

        // 패널 기준 왼쪽 방향 오프셋 (풍력과 동일)
        let leftOffsetX = 0, leftOffsetZ = 0;
        switch (roadSide) {
            case 'bottom': leftOffsetX = -1; break;
            case 'top': leftOffsetX = 1; break;
            case 'left': leftOffsetZ = -1; break;
            case 'right': leftOffsetZ = 1; break;
        }

        // 확장 정보를 모델 로드 전에 먼저 추가
        if (!building.expansionInstances) {
            building.expansionInstances = [];
        }
        const expansionInfo = {
            instance: null,
            x: expX,
            y: expY,
            width: width,
            depth: depth
        };
        building.expansionInstances.push(expansionInfo);
        const expansionIndex = building.expansionInstances.length - 1;

        // 타일 점유 표시
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const tileKey = `${expX + dx},${expY + dy}`;
                if (building.tiles instanceof Set) {
                    building.tiles.add(tileKey);
                } else if (Array.isArray(building.tiles)) {
                    if (!building.tiles.includes(tileKey)) {
                        building.tiles.push(tileKey);
                    }
                }
                // 나무 제거
                removeTreeAt(expX + dx, expY + dy);
            }
        }

        // 확장 모듈 모델 로드 (풍력과 동일한 방식)
        const expLoader = new GLTFLoader();
        const modelPath = config.expansionModelPath || '/models/solarpanel_addon.glb';
        expLoader.load(modelPath, (gltf) => {
            const instance = gltf.scene;

            // 풍력과 동일하게 오프셋 적용
            instance.position.set(worldX + leftOffsetX, 0.02, worldZ + leftOffsetZ);
            instance.rotation.y = building.instance?.rotation.y || 0;
            instance.scale.setScalar(0.132);  // 풍력과 동일한 스케일

            // 그림자 설정 및 머티리얼을 조명 반응형으로 교체
            instance.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    const oldMat = child.material;
                    child.material = new THREE.MeshLambertMaterial({
                        color: oldMat.color ? oldMat.color.clone() : new THREE.Color(0xffffff),
                        map: oldMat.map || null,
                        transparent: oldMat.transparent || false,
                        opacity: oldMat.opacity !== undefined ? oldMat.opacity : 1,
                        side: oldMat.side || THREE.FrontSide
                    });
                }
            });

            scene.add(instance);
            building.expansionInstances[expansionIndex].instance = instance;

            console.log(`Solar panel expansion ${expansionNum} placed at (${expX}, ${expY})`);
        }, undefined, (error) => {
            console.error('Failed to load solar panel expansion model:', error);
        });
    }

    // 확장 패널 버튼 이벤트
    if (btnExpandSolarPanel) {
        btnExpandSolarPanel.addEventListener('click', () => {
            if (!selectedPublicBuilding) return;
            const userData = selectedPublicBuilding.userData || {};
            expandSolarPanel(userData.tileX, userData.tileY);
        });
    }

    // 태양광 슬롯 hover 시 프리뷰 표시
    if (solarExpansionVisual) {
        const slots = solarExpansionVisual.querySelectorAll('.solar-slot[data-slot]');
        slots.forEach(slot => {
            slot.addEventListener('mouseenter', () => {
                if (!selectedPublicBuilding) return;
                const userData = selectedPublicBuilding.userData || {};
                const key = `${userData.tileX},${userData.tileY}`;
                const building = placedPublicBuildings.get(key);
                if (!building) return;

                const slotNum = parseInt(slot.dataset.slot, 10);
                const existingExpansions = building.expansions || 0;

                if (slotNum > existingExpansions) {
                    showSolarExpansionPreview(building, slotNum);
                }
            });

            slot.addEventListener('mouseleave', () => {
                hideSolarExpansionPreview();
            });
        });
    }

    // 확장 버튼 hover 시 다음 확장 위치 프리뷰 표시
    if (btnExpandSolarPanel) {
        btnExpandSolarPanel.addEventListener('mouseenter', () => {
            if (!selectedPublicBuilding) return;
            const userData = selectedPublicBuilding.userData || {};
            const key = `${userData.tileX},${userData.tileY}`;
            const building = placedPublicBuildings.get(key);
            if (!building) return;

            const existingExpansions = building.expansions || 0;
            const config = PUBLIC_BUILDING_MODELS['powerplant_solar'];
            const maxExpansions = config.maxExpansions || 5;

            if (existingExpansions < maxExpansions) {
                showSolarExpansionPreview(building, existingExpansions + 1);
            }
        });

        btnExpandSolarPanel.addEventListener('mouseleave', () => {
            hideSolarExpansionPreview();
        });
    }

    // 태양광 확장 프리뷰 표시 (풍력과 동일한 방식)
    let solarExpansionPreviewMesh = null;
    function showSolarExpansionPreview(building, slotNum) {
        hideSolarExpansionPreview();

        const config = PUBLIC_BUILDING_MODELS['powerplant_solar'];
        const expSize = config.expansionSize || { width: 3, depth: 1 };
        const roadSide = building.roadSide || 'bottom';

        let expX = building.x, expY = building.y;
        const isVerticalRoad = (roadSide === 'left' || roadSide === 'right');
        const mainLength = isVerticalRoad ? (building.width || 4) : (building.depth || 4);
        const prevExpansionDepth = (slotNum - 1) * expSize.depth;

        switch (roadSide) {
            case 'bottom': expY = building.y - expSize.depth - prevExpansionDepth; break;
            case 'top': expY = building.y + mainLength + prevExpansionDepth; break;
            case 'left': expX = building.x + mainLength + prevExpansionDepth; break;
            case 'right': expX = building.x - expSize.depth - prevExpansionDepth; break;
        }

        const width = isVerticalRoad ? expSize.depth : expSize.width;
        const depth = isVerticalRoad ? expSize.width : expSize.depth;

        const worldX = ORIGIN_X + expX + width / 2;
        const worldZ = ORIGIN_Z + expY + depth / 2;

        const canPlace = checkSolarPanelExpansionSpace(building.x, building.y, building, slotNum);
        const color = canPlace ? 0x00ff00 : 0xff0000;

        const geometry = new THREE.BoxGeometry(width * TILE_SIZE, 0.1, depth * TILE_SIZE);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.5
        });
        solarExpansionPreviewMesh = new THREE.Mesh(geometry, material);
        solarExpansionPreviewMesh.position.set(worldX, 0.1, worldZ);
        scene.add(solarExpansionPreviewMesh);
    }

    function hideSolarExpansionPreview() {
        if (solarExpansionPreviewMesh) {
            scene.remove(solarExpansionPreviewMesh);
            solarExpansionPreviewMesh.geometry.dispose();
            solarExpansionPreviewMesh.material.dispose();
            solarExpansionPreviewMesh = null;
        }
    }

    let lastFiretruckUpdate = 0;
    const FIRETRUCK_UPDATE_INTERVAL = 1000;  // 1초마다 업데이트 (최적화)

    // 공공시설 팝업 위치 업데이트용 재사용 객체
    const _pubPopupBox = new THREE.Box3();
    const _pubPopupCenter = new THREE.Vector3();
    const _pubPopupTop = new THREE.Vector3();
    const _pubPopupScreen = new THREE.Vector3();

    function updatePublicBuildingPopupPosition() {
        if (!selectedPublicBuilding || !publicBuildingPopup || publicBuildingPopup.style.display === 'none') return;

        const userData = selectedPublicBuilding.userData || {};
        const type = userData.publicBuildingType;

        // 풍력발전기는 고정 위치 사용 (프로펠러 회전 영향 방지)
        if (type === 'powerplant_wind') {
            const config = PUBLIC_BUILDING_MODELS[type];
            const buildingWidth = config?.displayWidth || userData.width || 3;
            const buildingDepth = config?.displayDepth || userData.depth || 4;
            const buildingHeight = 5;  // 풍력발전기 고정 높이

            const centerX = ORIGIN_X + userData.tileX + buildingWidth / 2;
            const centerZ = ORIGIN_Z + userData.tileY + buildingDepth / 2;

            _pubPopupTop.set(centerX, buildingHeight + 0.5, centerZ);
        } else {
            _pubPopupBox.setFromObject(selectedPublicBuilding);
            _pubPopupBox.getCenter(_pubPopupCenter);
            _pubPopupTop.copy(_pubPopupCenter);
            _pubPopupTop.y = _pubPopupBox.max.y + 0.5;
        }

        _pubPopupScreen.copy(_pubPopupTop).project(camera);
        // 캐시된 rect 사용
        const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
        const screenX = (_pubPopupScreen.x * 0.5 + 0.5) * rect.width + rect.left;
        const screenY = (-_pubPopupScreen.y * 0.5 + 0.5) * rect.height + rect.top;

        const margin = 50;
        if (_pubPopupScreen.z > 1 ||
            screenX < -margin || screenX > window.innerWidth + margin ||
            screenY < -margin || screenY > window.innerHeight + margin) {
            hidePublicBuildingPopup();
            return;
        }

        const popupWidth = 280;
        const popupHeight = publicBuildingPopup.offsetHeight || 220;

        let posX = screenX - popupWidth / 2;
        let posY = screenY - popupHeight - 10;

        if (posX < 10) posX = 10;
        if (posX + popupWidth > window.innerWidth - 10) posX = window.innerWidth - popupWidth - 10;
        if (posY < 50) posY = screenY + 10;
        if (posY + popupHeight > window.innerHeight - 10) posY = window.innerHeight - popupHeight - 10;

        publicBuildingPopup.style.left = posX + 'px';
        publicBuildingPopup.style.top = posY + 'px';

        // 소방서인 경우 소방차 현황 주기적 업데이트
        if (userData && userData.publicBuildingType === 'fire') {
            const now = Date.now();
            if (now - lastFiretruckUpdate > FIRETRUCK_UPDATE_INTERVAL) {
                updateFiretruckStatus(userData.tileX, userData.tileY);
                lastFiretruckUpdate = now;
            }
        }

        // 경찰서인 경우 주기적으로 상태 업데이트
        if (userData && userData.publicBuildingType === 'police') {
            const now = Date.now();
            if (now - lastFiretruckUpdate > FIRETRUCK_UPDATE_INTERVAL) {
                updatePoliceStatus(userData.tileX, userData.tileY);
                lastFiretruckUpdate = now;
            }
        }
    }

    function hidePublicBuildingPopup() {
        if (publicBuildingPopup) {
            publicBuildingPopup.style.display = 'none';
        }
        selectedPublicBuilding = null;
        clearBuildingOutline();
        hideExpansionPreview();  // 확장 프리뷰도 숨김
    }

    // 공공시설 팝업 닫기 버튼
    if (publicPopupClose) {
        publicPopupClose.addEventListener('click', hidePublicBuildingPopup);
    }

    /* =========================================================
     * BUILDING OUTLINE SYSTEM (호버/선택 시 아웃라인)
     * ========================================================= */

    // 아웃라인용 메쉬들
    let outlineMeshes = [];
    let hoveredBuilding = null;

    // 아웃라인 머티리얼 (뒷면만 렌더링하여 외곽선 효과)
    const outlineMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        side: THREE.BackSide
    });

    const selectedOutlineMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        side: THREE.BackSide
    });

    // 건물에 아웃라인 생성
    function createBuildingOutline(building, isSelected = false) {
        clearBuildingOutline();
        if (!building) return;

        const material = isSelected ? selectedOutlineMaterial : outlineMaterial;

        building.traverse((child) => {
            if (child.isMesh && child.geometry) {
                // 프로펠러(Helice_Eolienne)는 아웃라인 제외
                if (child.name === 'Helice_Eolienne') return;

                const outlineMesh = new THREE.Mesh(child.geometry.clone(), material.clone());

                // 월드 매트릭스를 직접 복사하여 정확한 위치/회전/스케일 적용
                child.updateWorldMatrix(true, false);
                outlineMesh.applyMatrix4(child.matrixWorld);

                // 약간 확대하여 아웃라인 효과
                const scaleUp = 1.03;
                outlineMesh.scale.multiplyScalar(scaleUp);

                outlineMesh.renderOrder = -1;
                scene.add(outlineMesh);
                outlineMeshes.push(outlineMesh);
            }
        });
    }

    // 아웃라인 제거
    function clearBuildingOutline() {
        outlineMeshes.forEach(mesh => {
            scene.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        });
        outlineMeshes = [];
    }

    /* =========================================================
     * DEMOLISH MODE HIGHLIGHT SYSTEM (철거 모드 빨간색 하이라이트)
     * ========================================================= */

    let demolishHighlightedObject = null;  // 현재 하이라이트된 오브젝트
    const demolishOriginalMaterials = new Map();  // 원본 머티리얼 저장

    // 철거 모드용 빨간색 머티리얼
    const demolishHighlightMaterial = new THREE.MeshStandardMaterial({
        color: 0xff3333,
        emissive: 0xff0000,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.9
    });

    // 오브젝트를 빨간색으로 하이라이트
    function highlightForDemolish(object) {
        if (!object || object === demolishHighlightedObject) return;

        // 이전 하이라이트 해제
        clearDemolishHighlight();

        demolishHighlightedObject = object;

        // 모든 메쉬의 원본 머티리얼 저장 후 빨간색으로 변경
        object.traverse((child) => {
            if (child.isMesh && child.material) {
                // 원본 머티리얼 저장 (배열인 경우 복사)
                const originalMat = Array.isArray(child.material)
                    ? child.material.map(m => m)
                    : child.material;
                demolishOriginalMaterials.set(child, originalMat);

                // 빨간색 머티리얼로 교체
                if (Array.isArray(child.material)) {
                    child.material = child.material.map(() => demolishHighlightMaterial.clone());
                } else {
                    child.material = demolishHighlightMaterial.clone();
                }
            }
        });
    }

    // 철거 하이라이트 해제
    function clearDemolishHighlight() {
        if (!demolishHighlightedObject) return;

        // 원본 머티리얼 복원
        demolishOriginalMaterials.forEach((originalMat, mesh) => {
            if (mesh && mesh.material) {
                mesh.material = originalMat;
            }
        });

        demolishOriginalMaterials.clear();
        demolishHighlightedObject = null;
    }

    // 좌표로 오브젝트 찾기 (건물, 공공시설, 도로, 수로, 다리)
    function findObjectAtTile(gx, gy) {
        // 0. 확장 터빈/패널 확인 (공공시설보다 먼저 체크)
        const expansionTurbine = findExpansionTurbineAt(gx, gy);
        if (expansionTurbine && expansionTurbine.expansion && expansionTurbine.expansion.instance) {
            return expansionTurbine.expansion.instance;
        }
        const expansionSolar = findExpansionSolarAt(gx, gy);
        if (expansionSolar && expansionSolar.expansion && expansionSolar.expansion.instance) {
            return expansionSolar.expansion.instance;
        }

        // 1. 공공시설 확인
        const publicBuilding = findPublicBuildingAt(gx, gy);
        if (publicBuilding && publicBuilding.instance) {
            return publicBuilding.instance;
        }

        // 2. 일반 건물 확인
        const building = findBuildingAt(gx, gy);
        if (building && building.instance) {
            return building.instance;
        }

        // 3. 도로/수로/다리 - roadGroup, waterGroup, bridgeGroup에서 찾기
        const cellType = grid[gx][gy];
        const worldCenter = tileToWorldCenter(gx, gy);
        const searchRadius = TILE_SIZE * 0.6;

        // 4차선 도로인 경우 - userData로 검색
        if (cellType === CELL.ROAD_4LANE) {
            for (const child of roadGroup.children) {
                if (child.userData.is4Lane && child.userData.tiles) {
                    // 4차선 도로가 차지하는 타일 중에 현재 타일이 있는지 확인
                    const found = child.userData.tiles.some(t => t.x === gx && t.y === gy);
                    if (found) {
                        return child;
                    }
                }
            }
        }

        // 일반 도로 (2차선) - userData로 검색
        if (cellType === CELL.ROAD || cellType === CELL.LOCKED_ROAD) {
            for (const child of roadGroup.children) {
                if (child.userData.isRoad && !child.userData.is4Lane) {
                    if (child.userData.tileX === gx && child.userData.tileY === gy) {
                        return child;
                    }
                }
            }
            // userData가 없는 경우 위치 기반 검색 (폴백)
            for (const child of roadGroup.children) {
                if (!child.userData.isRoad) {
                    const dist = Math.sqrt(
                        Math.pow(child.position.x - worldCenter.x, 2) +
                        Math.pow(child.position.z - worldCenter.z, 2)
                    );
                    if (dist < searchRadius) {
                        return child;
                    }
                }
            }
        }

        // 수로
        if (cellType === CELL.WATER) {
            for (const child of waterGroup.children) {
                const dist = Math.sqrt(
                    Math.pow(child.position.x - worldCenter.x, 2) +
                    Math.pow(child.position.z - worldCenter.z, 2)
                );
                if (dist < searchRadius) {
                    return child;
                }
            }
        }

        // 다리
        if (cellType === CELL.BRIDGE) {
            for (const child of bridgeGroup.children) {
                const dist = Math.sqrt(
                    Math.pow(child.position.x - worldCenter.x, 2) +
                    Math.pow(child.position.z - worldCenter.z, 2)
                );
                if (dist < searchRadius) {
                    return child;
                }
            }
        }

        return null;
    }

    // 카메라 모드에서 건물 클릭/호버 감지
    const buildingRaycaster = new THREE.Raycaster();
    const buildingMouse = new THREE.Vector2();

    // 마우스 이동 시 건물 호버 감지 (throttle 적용 - 16ms = ~60fps)
    function handleBuildingHover(e) {
        // 카메라 모드일 때만 호버 감지 (철거 모드일 때는 제외)
        if (currentMode !== MODE.CAMERA || isDemolishModeActive) {
            if (hoveredBuilding) {
                hoveredBuilding = null;
                if (!selectedBuilding) clearBuildingOutline();
            }
            return;
        }

        // 캐시된 rect 사용 (getBoundingClientRect 호출 최소화)
        const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
        buildingMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        buildingMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        buildingRaycaster.setFromCamera(buildingMouse, camera);
        const intersects = buildingRaycaster.intersectObjects(buildingGroup.children, true);

        if (intersects.length > 0) {
            let buildingObj = intersects[0].object;

            // 부모를 따라 올라가서 userData가 있는 건물 그룹 찾기 (민간건물 또는 공공시설)
            while (buildingObj && (!buildingObj.userData || (!buildingObj.userData.zoneType && !buildingObj.userData.isPublicBuilding))) {
                buildingObj = buildingObj.parent;
            }

            if (buildingObj && buildingObj.userData && (buildingObj.userData.zoneType || buildingObj.userData.isPublicBuilding)) {
                if (hoveredBuilding !== buildingObj) {
                    hoveredBuilding = buildingObj;
                    // 선택된 건물이 있으면 선택 아웃라인 유지, 아니면 호버 아웃라인
                    if (!selectedBuilding && !selectedPublicBuilding) {
                        createBuildingOutline(buildingObj, false);
                    }
                }
                renderer.domElement.style.cursor = 'pointer';
            } else {
                if (hoveredBuilding) {
                    hoveredBuilding = null;
                    if (!selectedBuilding && !selectedPublicBuilding) clearBuildingOutline();
                }
                renderer.domElement.style.cursor = 'default';
            }
        } else {
            if (hoveredBuilding) {
                hoveredBuilding = null;
                if (!selectedBuilding && !selectedPublicBuilding) clearBuildingOutline();
            }
            renderer.domElement.style.cursor = 'default';
        }
    }
    // throttle 적용된 호버 핸들러 등록 (16ms = ~60fps)
    renderer.domElement.addEventListener('mousemove', throttle(handleBuildingHover, 16));

    // 건물 클릭 시 팝업 표시
    renderer.domElement.addEventListener('click', (e) => {
        // 카메라 모드일 때만 건물 클릭 감지 (철거 모드일 때는 제외)
        if (currentMode !== MODE.CAMERA || isDemolishModeActive) return;

        // 캐시된 rect 사용 (getBoundingClientRect 호출 최소화)
        const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
        buildingMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        buildingMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        buildingRaycaster.setFromCamera(buildingMouse, camera);

        // 먼저 그라운드 평면과의 교차로 타일 좌표 확인
        const groundIntersects = buildingRaycaster.intersectObject(ground, false);
        if (groundIntersects.length > 0) {
            const point = groundIntersects[0].point;
            const tile = worldToTile(point.x, point.z);

            if (tile) {
                // 공사 현장인지 확인
                const construction = getConstructionAt(tile.x, tile.y);
                if (construction) {
                    hideBuildingPopup();
                    showConstructionPopup(construction);
                    return;
                }
            }
        }

        // 공사 현장이 아니면 일반 건물 확인
        const intersects = buildingRaycaster.intersectObjects(buildingGroup.children, true);

        if (intersects.length > 0) {
            let buildingObj = intersects[0].object;

            // 부모를 따라 올라가서 userData가 있는 건물 그룹 찾기
            while (buildingObj && (!buildingObj.userData || (!buildingObj.userData.zoneType && !buildingObj.userData.isPublicBuilding))) {
                buildingObj = buildingObj.parent;
            }

            if (buildingObj && buildingObj.userData) {
                closeConstructionPopup();  // 공사 팝업 닫기

                // 공공시설인 경우
                if (buildingObj.userData.isPublicBuilding) {
                    hideBuildingPopup();  // 일반 건물 팝업 닫기
                    showPublicBuildingPopup(buildingObj);
                    createBuildingOutline(buildingObj, true);
                }
                // 민간 건물인 경우
                else if (buildingObj.userData.zoneType) {
                    hidePublicBuildingPopup();  // 공공시설 팝업 닫기
                    showBuildingPopup(buildingObj);
                    createBuildingOutline(buildingObj, true);  // 선택 아웃라인 (노란색)
                }
            }
        } else {
            // 건물이 아닌 곳 클릭시 팝업 닫기
            hideBuildingPopup();
            hidePublicBuildingPopup();
            closeConstructionPopup();
        }
    });

    // 더블클릭용 재사용 객체
    const _dblClickRaycaster = new THREE.Raycaster();
    const _dblClickMouse = new THREE.Vector2();

    // 땅 더블클릭 시 카메라 중심 이동
    renderer.domElement.addEventListener('dblclick', (e) => {
        // 카메라 모드일 때만 작동
        if (currentMode !== MODE.CAMERA) return;

        // 캐시된 rect 사용
        const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
        _dblClickMouse.set(
            ((e.clientX - rect.left) / rect.width) * 2 - 1,
            -((e.clientY - rect.top) / rect.height) * 2 + 1
        );

        _dblClickRaycaster.setFromCamera(_dblClickMouse, camera);

        // 그라운드 평면과 교차점 찾기
        const groundIntersects = _dblClickRaycaster.intersectObject(ground, false);
        if (groundIntersects.length > 0) {
            const point = groundIntersects[0].point;

            // 맵 범위 내인지 확인
            const halfW = (GRID_W * TILE_SIZE) / 2;
            const halfH = (GRID_H * TILE_SIZE) / 2;
            const clampedX = Math.max(-halfW, Math.min(halfW, point.x));
            const clampedZ = Math.max(-halfH, Math.min(halfH, point.z));

            // 부드러운 카메라 이동을 위한 애니메이션 (회전 고정)
            // 애니메이션은 일회성이므로 객체 생성 허용
            const startTarget = controls.target.clone();
            const startPosition = camera.position.clone();
            const endTarget = new THREE.Vector3(clampedX, 0, clampedZ);

            // 카메라-타겟 오프셋 유지 (회전 고정을 위해)
            const cameraOffset = new THREE.Vector3().subVectors(startPosition, startTarget);
            const endPosition = new THREE.Vector3().addVectors(endTarget, cameraOffset);

            const startTime = performance.now();
            const duration = 500; // 0.5초

            function animateCameraMove() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                // easeOutCubic
                const eased = 1 - Math.pow(1 - progress, 3);

                controls.target.lerpVectors(startTarget, endTarget, eased);
                camera.position.lerpVectors(startPosition, endPosition, eased);

                if (progress < 1) {
                    requestAnimationFrame(animateCameraMove);
                }
            }
            animateCameraMove();
        }
    });

    /* =========================================================
     * TRAFFIC SYSTEM - 교통 시뮬레이션
     * ========================================================= */

    // ===== 교통 시스템 설정 =====
    const TRAFFIC_CONFIG = {
        maxVehiclesBase: 30,       // 기본 차량 수 (최적화: 100→30)
        maxVehiclesCap: 300,       // 최대 차량 수 상한 (최적화: 2500→300)
        vehiclesPerPopulation: 25, // 인구 N명당 차량 1대 (최적화: 10→25)
        spawnInterval: 2.0,        // 초 (최적화: 1.5→2.0)
        vehicleSpeed: 1.2,         // 타일/초 (1.5배 속도)
        laneOffset: 0.1,           // 2차선 도로 차선 오프셋
        laneOffset4Lane: 0.35,     // 4차선 도로 차선 오프셋 (더 넓음)
        speed4LaneMultiplier: 1.3, // 4차선 도로 속도 배율 (30% 빠름)
        stopDistance: 0.7,         // 정차 거리 (더 증가)
        minVehicleGap: 0.35,       // 최소 차간 거리 (증가)
    };

    // ===== 차량 종류 설정 =====
    const VEHICLE_TYPES = {
        // 트럭 - 공업지구 전용 (공장↔공장, 시외↔공장)
        truck: {
            name: '수송 트럭',
            icon: '🚚',
            models: [
                '/models/transport_truck.glb',
                '/models/transport_truck.001.glb',
                '/models/transport_truck.002.glb',
                '/models/transport_truck.003.glb',
                '/models/transport_truck.004.glb',
                '/models/transport_truck.005.glb',
                '/models/transport_truck.006.glb',
                '/models/transport_truck.007.glb',
                '/models/transport_truck.008.glb',
                '/models/transport_truck.009.glb',
            ],
            activities: [
                '공장으로 자재를 운송 중 🏭',
                '공장 간 물자 이동 중 📦',
                '시외에서 원자재 운반 중 🚚',
                '완제품을 출하하는 중 📮',
                '산업단지로 배송 중 🔧',
            ],
            routes: ['industrial_only'],  // 공업지구 전용
            weight: 1.5,
            speedMultiplier: 0.8,
            hasHeadlight: false,
            length: 0.4,  // 차량 길이 (타일 단위)
        },
        // 버스 - 대중교통
        bus: {
            name: '시내버스',
            icon: '🚌',
            models: [
                '/models/transport_bus.006.glb',
            ],
            activities: [
                '승객을 태우고 가요 🚌',
                '다음 정류장으로 이동 중 🚏',
                '시내 순환 노선 운행 중 🛤️',
                '출퇴근 승객을 태우는 중 👥',
            ],
            routes: ['any'],
            weight: 0,  // 상시 스폰 비활성화
            speedMultiplier: 0.7,
            hasHeadlight: false,
            length: 0.5,  // 차량 길이 (타일 단위)
        },
        // 스쿨버스
        schoolbus: {
            name: '스쿨버스',
            icon: '🚐',
            models: [
                '/models/transport_bus.001.glb',
            ],
            activities: [
                '등교하는 학생들을 태우고 가요 📚',
                '하교하는 학생들을 데려다줘요 🎒',
                '학교로 가는 중이에요 🏫',
            ],
            routes: ['residential'],
            weight: 0,  // 상시 스폰 비활성화
            speedMultiplier: 0.6,
            hasHeadlight: false,
            length: 0.45,  // 차량 길이 (타일 단위)
        },
        // 캠핑카 - 승용차 계열
        camper: {
            name: '캠핑카',
            icon: '🚐',
            models: [
                '/models/transport_bus.glb',
                '/models/transport_bus.002.glb',
                '/models/transport_bus.003.glb',
                '/models/transport_bus.004.glb',
                '/models/transport_bus.005.glb',
            ],
            activities: [
                '가족과 캠핑 여행 중! ⛺',
                '주말 여행 가는 길 🏕️',
                '자연 속으로 떠나요 🌲',
                '캠핑장으로 가는 중 🔥',
            ],
            routes: ['residential'],
            weight: 0.15,
            speedMultiplier: 0.75,
            hasHeadlight: true,
            length: 0.4,  // 차량 길이 (타일 단위)
        },
        // 고급 세단 - 승용차
        cool: {
            name: '고급 세단',
            icon: '🚗',
            models: [
                '/models/transport_cool.glb',
                '/models/transport_cool.001.glb',
                '/models/transport_cool.002.glb',
                '/models/transport_cool.003.glb',
                '/models/transport_cool.004.glb',
                '/models/transport_cool.005.glb',
                '/models/transport_cool.006.glb',
                '/models/transport_cool.007.glb',
                '/models/transport_cool.008.glb',
                '/models/transport_cool.009.glb',
            ],
            activities: [
                '비즈니스 미팅에 가요 💼',
                'VIP 고객 방문 중 👔',
                '중요한 약속이 있어요 📋',
                '골프장으로 가는 길 ⛳',
            ],
            routes: ['commercial'],
            weight: 0.4,
            speedMultiplier: 1.0,
            hasHeadlight: true,
            length: 0.25,  // 차량 길이 (타일 단위)
        },
        // SUV - 승용차
        jeep: {
            name: 'SUV',
            icon: '🚙',
            models: [
                '/models/transport_jeep.glb',
                '/models/transport_jeep.001.glb',
                '/models/transport_jeep.002.glb',
                '/models/transport_jeep.003.glb',
                '/models/transport_jeep.004.glb',
                '/models/transport_jeep.005.glb',
                '/models/transport_jeep.006.glb',
                '/models/transport_jeep.007.glb',
                '/models/transport_jeep.008.glb',
                '/models/transport_jeep.009.glb',
            ],
            activities: [
                '드라이브 중이에요 🛣️',
                '아이들을 학교에 데려다줘요 🏫',
                '대형마트에 장보러 가요 🛒',
                '주말 나들이 가는 중 🌳',
            ],
            routes: ['any'],
            weight: 0.8,
            speedMultiplier: 0.9,
            hasHeadlight: true,
            length: 0.3,  // 차량 길이 (타일 단위)
        },
        // 패밀리카 - 승용차
        old: {
            name: '패밀리카',
            icon: '🚗',
            models: [
                '/models/transport_old.glb',
                '/models/transport_old.001.glb',
                '/models/transport_old.002.glb',
                '/models/transport_old.003.glb',
                '/models/transport_old.004.glb',
                '/models/transport_old.005.glb',
                '/models/transport_old.006.glb',
                '/models/transport_old.007.glb',
                '/models/transport_old.008.glb',
                '/models/transport_old.009.glb',
            ],
            activities: [
                '가족과 외출 중 👨‍👩‍👧‍👦',
                '아이들 학원 데려다주는 중 📖',
                '마트에 장보러 가요 🥬',
                '친척집 방문 가는 길 🏠',
                '주말 가족 나들이 🌸',
            ],
            routes: ['residential'],
            weight: 1.0,
            speedMultiplier: 0.85,
            hasHeadlight: true,
            length: 0.25,  // 차량 길이 (타일 단위)
        },
        // 스포츠카 - 승용차
        sport: {
            name: '스포츠카',
            icon: '🏎️',
            models: [
                '/models/transport_sport.glb',
                '/models/transport_sport.001.glb',
                '/models/transport_sport.002.glb',
                '/models/transport_sport.003.glb',
                '/models/transport_sport.004.glb',
                '/models/transport_sport.005.glb',
                '/models/transport_sport.006.glb',
                '/models/transport_sport.007.glb',
                '/models/transport_sport.008.glb',
                '/models/transport_sport.009.glb',
            ],
            activities: [
                '드라이브 즐기는 중 🏎️',
                '달리기 좋은 날이에요! 🌤️',
                '클럽 미팅 가는 길 🎵',
                '차 좀 굴리러 나왔어요 😎',
            ],
            routes: ['any'],
            weight: 0.25,
            speedMultiplier: 1.2,
            hasHeadlight: true,
            length: 0.22,  // 차량 길이 (타일 단위)
        },
        // 택시 - 승용차
        taxi: {
            name: '택시',
            icon: '🚕',
            models: [
                '/models/transport_purpose.003.glb',
                '/models/transport_purpose.004.glb',
            ],
            activities: [
                '승객을 목적지로 모시는 중 🚕',
                '콜을 받고 이동 중 📱',
                '손님을 기다리며 이동 중 🚖',
            ],
            routes: ['any'],
            weight: 0.5,
            speedMultiplier: 1.0,
            hasHeadlight: true,
            length: 0.25,  // 차량 길이 (타일 단위)
        },
        // 경찰차
        police: {
            name: '경찰차',
            icon: '🚓',
            models: [
                '/models/transport_purpose.002.glb',
            ],
            activities: [
                '순찰 중이에요 🚔',
                '시내를 순찰하고 있어요 👮',
                '출동 중입니다 🚨',
            ],
            routes: ['any'],
            weight: 0,  // 상시 스폰 비활성화 (출동 시에만 스폰)
            speedMultiplier: 1.1,
            hasHeadlight: false,
            length: 0.28,  // 차량 길이 (타일 단위)
        },
        // 소방차
        firetruck: {
            name: '소방차',
            icon: '🚒',
            models: [
                '/models/transport_purpose.005.glb',
            ],
            activities: [
                '출동 중입니다! 🚒',
                '화재 현장으로 가는 중 🔥',
                '안전 점검 순찰 중 🧯',
            ],
            routes: ['any'],
            weight: 0,  // 상시 스폰 비활성화 (화재 출동 시에만 스폰)
            speedMultiplier: 1.15,
            hasHeadlight: false,
            length: 0.45,  // 차량 길이 (타일 단위)
        },
        // 구급차
        ambulance: {
            name: '구급차',
            icon: '🚑',
            models: [
                '/models/transport_purpose.006.glb',
            ],
            activities: [
                '환자를 이송 중입니다 🚑',
                '응급 출동 중! 🏥',
                '병원으로 가는 중 💉',
            ],
            routes: ['any'],
            weight: 0,  // 상시 스폰 비활성화 (응급 출동 시에만 스폰)
            speedMultiplier: 1.15,
            hasHeadlight: false,
            length: 0.35,  // 차량 길이 (타일 단위)
        },
        // 견인차
        wrecker: {
            name: '견인차',
            icon: '🚗',
            models: [
                '/models/transport_purpose.007.glb',
            ],
            activities: [
                '고장 차량 견인 중 🔧',
                '사고 현장으로 출동 중 🚨',
                '차량 이송 중이에요 🚛',
            ],
            routes: ['any'],
            weight: 0.08,
            speedMultiplier: 0.8,
            hasHeadlight: false,
            length: 0.38,  // 차량 길이 (타일 단위)
        },
    };

    // 시간대별 교통량 배수 계산
    function getTrafficMultiplier() {
        const hour = (timeState.gameTime / 3600) % 24;

        // 시간대별 교통량 (0.0 ~ 1.0)
        // 출근시간(7-9): 100%, 점심(12-13): 80%, 퇴근시간(17-19): 100%
        // 밤(22-5): 20%, 새벽(5-7): 40%
        if (hour >= 7 && hour < 9) return 1.0;      // 출근 러시아워
        if (hour >= 9 && hour < 12) return 0.7;     // 오전
        if (hour >= 12 && hour < 13) return 0.8;    // 점심
        if (hour >= 13 && hour < 17) return 0.7;    // 오후
        if (hour >= 17 && hour < 19) return 1.0;    // 퇴근 러시아워
        if (hour >= 19 && hour < 22) return 0.5;    // 저녁
        if (hour >= 22 || hour < 5) return 0.2;     // 심야
        if (hour >= 5 && hour < 7) return 0.4;      // 새벽
        return 0.6;
    }

    // 인구 기반 최대 차량 수 계산 (시간대별 변동 적용)
    function getMaxVehicles() {
        const pop = cityStats.population || 0;
        const calculated = TRAFFIC_CONFIG.maxVehiclesBase + Math.floor(pop / TRAFFIC_CONFIG.vehiclesPerPopulation);
        const base = Math.min(TRAFFIC_CONFIG.maxVehiclesCap, calculated);
        // 시간대별 배수 적용
        return Math.max(5, Math.floor(base * getTrafficMultiplier()));
    }

    // ===== 차량 클래스 =====
    class Vehicle {
        constructor(type = 'car') {
            this.id = Math.random().toString(36).substr(2, 9);
            this.type = type;
            this.mesh = null;
            this.headlight = null;  // 헤드라이트 그룹
            this.spotLight = null;  // 헤드라이트 SpotLight
            this.position = new THREE.Vector3();
            this.visualPosition = new THREE.Vector3();  // 시각적 위치 (부드러운 보간용)
            this.visualRotation = 0;  // 시각적 회전 (부드러운 보간용)
            this.rotation = 0;
            this.currentTile = { x: 0, y: 0 };
            this.targetTile = { x: 0, y: 0 };
            this.progress = 0;
            this.path = [];
            this.pathIndex = 0;
            this.speed = TRAFFIC_CONFIG.vehicleSpeed;
            this.currentSpeed = 0;  // 현재 속도 (부드러운 가감속용)
            this.targetSpeed = TRAFFIC_CONFIG.vehicleSpeed;  // 목표 속도
            this.length = 0.25;  // 차량 길이 (기본값, 타일 단위)
            this.state = 'idle';  // idle, moving, waiting, despawning
            this.stopReason = '';  // 정차 이유: '', 'signal', 'vehicle'
            this.waitTimer = 0;
            this.isActive = false;
            this.visualInitialized = false;  // 시각적 위치 초기화 여부
        }

        reset() {
            this.path = [];
            this.pathIndex = 0;
            this.progress = 0;
            this.currentSpeed = 0;
            this.targetSpeed = TRAFFIC_CONFIG.vehicleSpeed;
            this.state = 'idle';
            this.stopReason = '';
            this.waitTimer = 0;
            this.isActive = false;
            this.visualInitialized = false;
            this.enterProgress = 0;
            this.enterTarget = null;
            this.enterStart = null;
            this.enterStartScale = null;

            // 사이렌 라이트 제거 (긴급차량용)
            if (this.sirenLights && this.mesh) {
                this.mesh.remove(this.sirenLights);
                // 사이렌 라이트 머티리얼 정리
                this.sirenLights.traverse((child) => {
                    if (child.isLight) {
                        // PointLight는 dispose 불필요
                    } else if (child.isMesh && child.material) {
                        // MeshBasicMaterial/MeshStandardMaterial은 dispose
                        child.material.dispose();
                    }
                    if (child.geometry) {
                        child.geometry.dispose();
                    }
                });
                this.sirenLights = null;
            }

            if (this.mesh) {
                this.mesh.visible = false;
                this.mesh.scale.setScalar(1.0);  // 스케일 복구
            }
            if (this.headlight) this.headlight.visible = false;
        }
    }

    // ===== 도로 노드 클래스 =====
    class RoadNode {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.key = `${x},${y}`;
            this.neighbors = [];
            this.intersectionType = 'none';  // none, t, cross
            this.hasSignal = false;
            this.congestion = 0;
        }
    }

    // ===== 신호등 클래스 =====
    class TrafficSignal {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.phases = [];
            this.currentPhase = 0;
            this.timer = 0;
            this.greenDirections = [];
            this.mesh = null;
            this.setupPhases(type);
        }

        setupPhases(type) {
            const greenTime = TRAFFIC_CONFIG.signalGreenTime;
            const yellowTime = TRAFFIC_CONFIG.signalYellowTime;
            if (type === 'cross') {
                this.phases = [
                    { directions: ['N', 'S'], duration: greenTime, yellow: yellowTime },
                    { directions: ['E', 'W'], duration: greenTime, yellow: yellowTime }
                ];
            } else {
                this.phases = [
                    { directions: ['N', 'S'], duration: greenTime, yellow: yellowTime },
                    { directions: ['E', 'W'], duration: greenTime / 2, yellow: yellowTime }
                ];
            }
            this.greenDirections = this.phases[0].directions;
        }

        update(dt) {
            this.timer += dt;
            const phase = this.phases[this.currentPhase];
            if (this.timer >= phase.duration + phase.yellow) {
                this.timer = 0;
                this.currentPhase = (this.currentPhase + 1) % this.phases.length;
                this.greenDirections = this.phases[this.currentPhase].directions;
            }
        }

        isGreen(direction) {
            return this.greenDirections.includes(direction);
        }
    }

    // ===== 우선순위 큐 (A* 용) =====
    class PriorityQueue {
        constructor() {
            this.heap = [];
        }
        push(item) {
            this.heap.push(item);
            this._bubbleUp(this.heap.length - 1);
        }
        pop() {
            if (this.heap.length === 0) return null;
            const result = this.heap[0];
            const end = this.heap.pop();
            if (this.heap.length > 0) {
                this.heap[0] = end;
                this._sinkDown(0);
            }
            return result;
        }
        isEmpty() { return this.heap.length === 0; }
        _bubbleUp(idx) {
            while (idx > 0) {
                const parent = Math.floor((idx - 1) / 2);
                if (this.heap[idx].f >= this.heap[parent].f) break;
                [this.heap[idx], this.heap[parent]] = [this.heap[parent], this.heap[idx]];
                idx = parent;
            }
        }
        _sinkDown(idx) {
            const len = this.heap.length;
            while (true) {
                const left = 2 * idx + 1, right = 2 * idx + 2;
                let smallest = idx;
                if (left < len && this.heap[left].f < this.heap[smallest].f) smallest = left;
                if (right < len && this.heap[right].f < this.heap[smallest].f) smallest = right;
                if (smallest === idx) break;
                [this.heap[idx], this.heap[smallest]] = [this.heap[smallest], this.heap[idx]];
                idx = smallest;
            }
        }
    }

    // ===== 교통 관리자 =====
    const trafficManager = {
        // 상태
        initialized: false,
        roadNetwork: new Map(),
        vehicles: [],
        vehiclePool: [],
        activeCount: 0,
        signals: new Map(),
        congestionMap: new Map(),
        pathCache: new Map(),

        // 공간 분할 시스템 (충돌 검사 최적화)
        spatialGrid: new Map(),  // "cellX,cellY" -> Set of vehicles
        SPATIAL_CELL_SIZE: 2.0,  // 셀 크기 (타일 단위)

        // Three.js 그룹
        vehicleGroup: new THREE.Group(),
        signalGroup: new THREE.Group(),

        // 차량 프리팹
        vehiclePrefabs: [],

        // 건물 분류
        residentialBuildings: [],
        commercialBuildings: [],
        industrialBuildings: [],

        // 타이머
        spawnTimer: 0,
        lastUpdate: 0,

        // 스폰 대기열 시스템 (외곽 진입점 차량 겹침 방지)
        spawnQueue: [],
        isProcessingSpawnQueue: false,
        SPAWN_QUEUE_INTERVAL: 800,  // 차량 간 스폰 간격 (0.8초)

        // 초기화
        async init() {
            if (this.initialized) return;

            try {
                scene.add(this.vehicleGroup);

                await this.loadVehicleModels();
                this.buildRoadNetwork();
                this.categorizeBuildings();
                this.initVehiclePool();

                // lastUpdate 초기화 (첫 프레임 dt 정상화)
                this.lastUpdate = performance.now();

                this.initialized = true;
                console.log('Traffic system initialized');
                console.log(`Buildings - Residential: ${this.residentialBuildings.length}, Commercial: ${this.commercialBuildings.length}, Industrial: ${this.industrialBuildings.length}`);

                // 초기 차량 스폰 (즉시 몇 대 배치)
                this.spawnInitialVehicles();
            } catch (e) {
                console.error('Traffic system init failed:', e);
            }
        },

        // 차량 모델 로드 (타임아웃 포함) - 종류별로 로드
        async loadVehicleModels() {
            // 차량 종류별 프리팹 저장소
            this.vehiclePrefabsByType = {};

            const loadWithTimeout = (path, timeout = 5000) => {
                return new Promise((resolve, reject) => {
                    const timer = setTimeout(() => reject(new Error('Timeout')), timeout);
                    loader.load(path,
                        (gltf) => { clearTimeout(timer); resolve(gltf); },
                        undefined,
                        (err) => { clearTimeout(timer); reject(err); }
                    );
                });
            };

            const createVehiclePrefab = (gltf, scale = 0.12) => {
                const wrapper = new THREE.Group();
                const inner = gltf.scene.clone();
                inner.scale.setScalar(scale);
                inner.rotation.set(0, Math.PI, 0);
                inner.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        const convertMaterial = (mat) => {
                            return new THREE.MeshLambertMaterial({
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                                map: mat.map || null,
                                transparent: mat.transparent || false,
                                opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                            });
                        };
                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(m => convertMaterial(m));
                        } else {
                            child.material = convertMaterial(child.material);
                        }
                    }
                });
                wrapper.add(inner);
                return wrapper;
            };

            // 각 차량 종류별로 모델 로드
            for (const [typeKey, typeConfig] of Object.entries(VEHICLE_TYPES)) {
                this.vehiclePrefabsByType[typeKey] = [];

                // 차량 크기 설정 (모든 차량 승용차 크기로 통일)
                const scale = 0.12;

                for (const path of typeConfig.models) {
                    try {
                        const gltf = await loadWithTimeout(path);
                        const prefab = createVehiclePrefab(gltf, scale);
                        this.vehiclePrefabsByType[typeKey].push(prefab);
                        // 하위 호환을 위해 기존 배열에도 추가
                        this.vehiclePrefabs.push(prefab);
                    } catch (e) {
                        console.warn(`Failed to load vehicle ${typeKey}:`, path);
                    }
                }

                if (this.vehiclePrefabsByType[typeKey].length > 0) {
                    console.log(`Loaded ${this.vehiclePrefabsByType[typeKey].length} models for ${typeKey}`);
                }
            }

            // 폴백 박스 모델
            if (this.vehiclePrefabs.length === 0) {
                const geo = new THREE.BoxGeometry(0.3, 0.15, 0.5);
                const mat = new THREE.MeshStandardMaterial({ color: 0x3366cc });
                const box = new THREE.Mesh(geo, mat);
                box.position.y = 0.075;
                const group = new THREE.Group();
                group.add(box);
                this.vehiclePrefabs.push(group);
                this.vehiclePrefabsByType['fallback'] = [group];
            }

            console.log(`Loaded ${this.vehiclePrefabs.length} vehicle models`);
        },

        // 도로 네트워크 구축
        buildRoadNetwork() {
            this.roadNetwork.clear();

            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    if (!isRoad(x, y)) continue;

                    const node = new RoadNode(x, y);
                    const directions = [
                        { dir: 'N', dx: 0, dy: -1 },
                        { dir: 'E', dx: 1, dy: 0 },
                        { dir: 'S', dx: 0, dy: 1 },
                        { dir: 'W', dx: -1, dy: 0 }
                    ];

                    for (const { dir, dx, dy } of directions) {
                        const nx = x + dx, ny = y + dy;
                        if (inBounds(nx, ny) && isRoad(nx, ny)) {
                            node.neighbors.push({ x: nx, y: ny, dir });
                        }
                    }

                    // 교차로 타입 결정
                    const count = node.neighbors.length;
                    if (count === 4) node.intersectionType = 'cross';
                    else if (count === 3) node.intersectionType = 't';

                    this.roadNetwork.set(node.key, node);
                }
            }

            console.log(`Road network built: ${this.roadNetwork.size} nodes`);
        },

        // === 공간 분할 시스템 (충돌 검사 최적화) ===
        // 월드 좌표를 공간 분할 셀 키로 변환
        getSpatialCellKey(x, z) {
            const cellX = Math.floor(x / this.SPATIAL_CELL_SIZE);
            const cellZ = Math.floor(z / this.SPATIAL_CELL_SIZE);
            return `${cellX},${cellZ}`;
        },

        // 차량을 공간 분할 그리드에 등록
        addToSpatialGrid(vehicle) {
            const key = this.getSpatialCellKey(vehicle.position.x, vehicle.position.z);
            if (!this.spatialGrid.has(key)) {
                this.spatialGrid.set(key, new Set());
            }
            this.spatialGrid.get(key).add(vehicle);
            vehicle._spatialKey = key;
        },

        // 차량을 공간 분할 그리드에서 제거
        removeFromSpatialGrid(vehicle) {
            if (vehicle._spatialKey && this.spatialGrid.has(vehicle._spatialKey)) {
                this.spatialGrid.get(vehicle._spatialKey).delete(vehicle);
            }
            vehicle._spatialKey = null;
        },

        // 차량 위치 업데이트 시 공간 분할 그리드 갱신
        updateSpatialGrid(vehicle) {
            const newKey = this.getSpatialCellKey(vehicle.position.x, vehicle.position.z);
            if (vehicle._spatialKey !== newKey) {
                this.removeFromSpatialGrid(vehicle);
                this.addToSpatialGrid(vehicle);
            }
        },

        // 주변 셀의 차량들 가져오기 (9개 셀: 현재 + 8방향 인접)
        getNearbyVehicles(x, z) {
            const cellX = Math.floor(x / this.SPATIAL_CELL_SIZE);
            const cellZ = Math.floor(z / this.SPATIAL_CELL_SIZE);
            const nearby = [];

            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const key = `${cellX + dx},${cellZ + dz}`;
                    if (this.spatialGrid.has(key)) {
                        for (const v of this.spatialGrid.get(key)) {
                            nearby.push(v);
                        }
                    }
                }
            }
            return nearby;
        },

        // 신호등 설치
        setupSignals() {
            this.signals.clear();
            while (this.signalGroup.children.length > 0) {
                this.signalGroup.remove(this.signalGroup.children[0]);
            }

            for (const [key, node] of this.roadNetwork) {
                if (node.intersectionType !== 'none') {
                    node.hasSignal = true;
                    const signal = new TrafficSignal(node.x, node.y, node.intersectionType);
                    // 신호등 메쉬는 설정에 따라 표시
                    if (TRAFFIC_CONFIG.showSignals) {
                        signal.mesh = this.createSignalMesh(node.x, node.y);
                        this.signalGroup.add(signal.mesh);
                    }
                    this.signals.set(key, signal);
                }
            }

            console.log(`Traffic signals: ${this.signals.size}`);
        },

        // 신호등 메쉬 생성 (교차로 4방향에 신호등 배치)
        createSignalMesh(x, y) {
            const group = new THREE.Group();
            const worldPos = tileToWorldCenter(x, y);

            // 신호등 하나 생성 함수
            const createSingleSignal = (offsetX, offsetZ, rotation, dirName) => {
                const signalGroup = new THREE.Group();

                // 기둥
                const postGeo = new THREE.CylinderGeometry(0.015, 0.02, 0.5, 6);
                const postMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5 });
                const post = new THREE.Mesh(postGeo, postMat);
                post.position.y = 0.25;
                post.castShadow = true;
                signalGroup.add(post);

                // 신호등 박스
                const boxGeo = new THREE.BoxGeometry(0.05, 0.1, 0.03);
                const boxMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.3 });
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.y = 0.55;
                box.castShadow = true;
                signalGroup.add(box);

                // 빨간불
                const lightGeo = new THREE.SphereGeometry(0.015, 8, 8);
                const redMat = new THREE.MeshStandardMaterial({
                    color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3
                });
                const redLight = new THREE.Mesh(lightGeo, redMat);
                redLight.position.set(0, 0.58, 0.018);
                redLight.name = 'red_' + dirName;
                signalGroup.add(redLight);

                // 초록불
                const greenMat = new THREE.MeshStandardMaterial({
                    color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.8
                });
                const greenLight = new THREE.Mesh(lightGeo, greenMat);
                greenLight.position.set(0, 0.52, 0.018);
                greenLight.name = 'green_' + dirName;
                signalGroup.add(greenLight);

                signalGroup.position.set(offsetX, 0, offsetZ);
                signalGroup.rotation.y = rotation;
                return signalGroup;
            };

            // 교차로 각 코너에 신호등 배치 (도로 진행 방향을 바라보도록)
            // 북쪽에서 오는 차량용 (남쪽 코너에 배치, 북쪽을 바라봄)
            group.add(createSingleSignal(0.35, 0.35, 0, 'S'));
            // 남쪽에서 오는 차량용 (북쪽 코너에 배치, 남쪽을 바라봄)
            group.add(createSingleSignal(-0.35, -0.35, Math.PI, 'N'));
            // 동쪽에서 오는 차량용 (서쪽 코너에 배치, 동쪽을 바라봄)
            group.add(createSingleSignal(-0.35, 0.35, Math.PI / 2, 'W'));
            // 서쪽에서 오는 차량용 (동쪽 코너에 배치, 서쪽을 바라봄)
            group.add(createSingleSignal(0.35, -0.35, -Math.PI / 2, 'E'));

            group.position.set(worldPos.x, 0, worldPos.z);

            // 방향별 신호등 참조 저장
            group.userData.signalLights = {
                N: { red: group.getObjectByName('red_N'), green: group.getObjectByName('green_N') },
                S: { red: group.getObjectByName('red_S'), green: group.getObjectByName('green_S') },
                E: { red: group.getObjectByName('red_E'), green: group.getObjectByName('green_E') },
                W: { red: group.getObjectByName('red_W'), green: group.getObjectByName('green_W') }
            };

            return group;
        },

        // 건물 분류
        categorizeBuildings() {
            this.residentialBuildings = [];
            this.commercialBuildings = [];
            this.industrialBuildings = [];

            buildingGroup.children.forEach(building => {
                if (!building.userData?.zoneType) return;
                const data = {
                    x: building.userData.tileX,
                    y: building.userData.tileY,
                    obj: building,
                    type: building.userData.zoneType
                };
                if (building.userData.zoneType.includes('residential')) {
                    this.residentialBuildings.push(data);
                } else if (building.userData.zoneType.includes('commercial')) {
                    this.commercialBuildings.push(data);
                } else if (building.userData.zoneType.includes('industrial')) {
                    this.industrialBuildings.push(data);
                }
            });
        },

        // 시민 활동 메시지 생성 (출발지/목적지 기반)
        generateActivity(originType, destType) {
            const activities = {
                // 주거 → 상업
                'residential_commercial': [
                    '쇼핑하러 가요! 🛒',
                    '마트에 장보러 가는 중 🥬',
                    '카페에서 친구 만나요 ☕',
                    '맛집 탐방 중! 🍽️',
                    '영화 보러 가요 🎬',
                    '백화점 구경 가요 🏬',
                ],
                // 주거 → 공업
                'residential_industrial': [
                    '출근 중이에요 💼',
                    '회사 가는 길이에요 🏢',
                    '열심히 일하러! 💪',
                    '오늘도 화이팅! 🔧',
                    '야근하러 가요... 😅',
                ],
                // 주거 → 주거
                'residential_residential': [
                    '친구 집에 놀러가요! 🏠',
                    '가족 방문 중 👨‍👩‍👧',
                    '이웃집에 심부름 📦',
                    '집들이 가는 길 🎁',
                    '반려동물 산책 중 🐕',
                ],
                // 상업 → 주거
                'commercial_residential': [
                    '쇼핑 끝! 집에 가요 🏡',
                    '퇴근하고 집으로~ 🚗',
                    '장 봤어요, 귀가 중 🛍️',
                ],
                // 공업 → 주거
                'industrial_residential': [
                    '퇴근이다! 🎉',
                    '오늘 하루도 수고! 🌙',
                    '집에 가서 쉬어야지 😴',
                    '야근 끝! 빨리 집에... 🏃',
                ],
                // 상업 → 상업
                'commercial_commercial': [
                    '다른 가게 구경 가요 🏪',
                    '배달 중이에요 📦',
                    '비즈니스 미팅 중 💼',
                ],
                // 공업 → 공업
                'industrial_industrial': [
                    '다른 공장으로 출장 🏭',
                    '자재 운반 중 🚚',
                    '현장 점검 가요 🔍',
                ],
                // 상업 → 공업
                'commercial_industrial': [
                    '납품하러 가는 중 📦',
                    '거래처 방문 중 🤝',
                ],
                // 공업 → 상업
                'industrial_commercial': [
                    '점심 먹으러! 🍱',
                    '잠깐 휴식~ ☕',
                    '업무용품 사러 가요 📎',
                ],
            };

            const key = `${originType}_${destType}`;
            const messages = activities[key] || ['드라이브 중 🚗'];
            return messages[Math.floor(Math.random() * messages.length)];
        },

        // 건물 타입 문자열 반환
        getBuildingTypeName(type) {
            if (!type) return '도로';
            if (type.includes('residential')) return '주거지';
            if (type.includes('commercial')) return '상업지구';
            if (type.includes('industrial')) return '공업지구';
            return '건물';
        },

        // 경로 유형에 맞는 차량 종류 선택
        selectVehicleType(originType, destType) {
            const candidates = [];

            // 경로 유형에 맞는 차량 종류 추가
            for (const [typeKey, typeConfig] of Object.entries(VEHICLE_TYPES)) {
                const routes = typeConfig.routes;
                let weight = typeConfig.weight;

                // industrial_only: 출발/도착 모두 공업지구일 때만
                if (routes.includes('industrial_only')) {
                    if (originType === 'industrial' && destType === 'industrial') {
                        candidates.push({ type: typeKey, weight: weight * 3.0 });  // 높은 가중치
                    }
                    continue;  // 다른 조건은 체크하지 않음
                }

                // 일반 경로 적합성 체크
                if (routes.includes('any')) {
                    candidates.push({ type: typeKey, weight });
                } else if (routes.includes(originType) || routes.includes(destType)) {
                    candidates.push({ type: typeKey, weight: weight * 1.5 });
                }
            }

            // 기본 폴백
            if (candidates.length === 0) {
                candidates.push({ type: 'old', weight: 1.0 });
            }

            // 가중치 기반 랜덤 선택
            const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
            let random = Math.random() * totalWeight;

            for (const candidate of candidates) {
                random -= candidate.weight;
                if (random <= 0) {
                    return candidate.type;
                }
            }

            return candidates[0].type;
        },

        // 차량 종류에 맞는 메쉬 생성
        createVehicleMesh(vehicleType) {
            const prefabs = this.vehiclePrefabsByType[vehicleType];
            if (!prefabs || prefabs.length === 0) {
                // 폴백: 기존 프리팹 사용
                const idx = Math.floor(Math.random() * this.vehiclePrefabs.length);
                return this.vehiclePrefabs[idx].clone();
            }

            const idx = Math.floor(Math.random() * prefabs.length);
            return prefabs[idx].clone();
        },

        // 헤드라이트용 공유 지오메트리/머티리얼 (성능 최적화 - 메모리 절약)
        // SpotLight 추가 - 실제 조명 효과
        headlightSharedResources: null,
        getHeadlightResources() {
            if (!this.headlightSharedResources) {
                this.headlightSharedResources = {
                    bulbGeo: new THREE.SphereGeometry(0.025, 6, 6),
                    // emissive 머티리얼로 발광 효과 구현
                    bulbMat: new THREE.MeshStandardMaterial({
                        color: 0xffffcc,
                        emissive: 0xffffaa,
                        emissiveIntensity: 3.0
                    })
                };
            }
            return this.headlightSharedResources;
        },

        // 차량 풀 초기화
        initVehiclePool() {
            // 공유 리소스 미리 생성
            const hlRes = this.getHeadlightResources();

            for (let i = 0; i < TRAFFIC_CONFIG.maxVehiclesCap; i++) {
                const vehicle = new Vehicle('car');

                // 초기 메쉬는 기본 차량으로 (스폰 시 교체됨)
                const prefabIdx = Math.floor(Math.random() * this.vehiclePrefabs.length);
                vehicle.mesh = this.vehiclePrefabs[prefabIdx].clone();
                vehicle.mesh.visible = false;
                vehicle.vehicleTypeKey = 'old';  // 기본 타입

                // 헤드라이트 추가 (SpotLight + emissive 구체)
                const headlightGroup = new THREE.Group();

                // 헤드라이트 발광 구체 (공유 리소스 - emissive 머티리얼)
                const leftBulb = new THREE.Mesh(hlRes.bulbGeo, hlRes.bulbMat);
                leftBulb.position.set(-0.03, 0.03, 0.08);
                const rightBulb = new THREE.Mesh(hlRes.bulbGeo, hlRes.bulbMat);
                rightBulb.position.set(0.03, 0.03, 0.08);
                headlightGroup.add(leftBulb);
                headlightGroup.add(rightBulb);

                // SpotLight 추가 (중앙 하나만 - 성능 최적화)
                const spotLight = new THREE.SpotLight(0xffffcc, 0.6, 2.5, Math.PI / 6, 0.3, 1);
                spotLight.position.set(0, 0.04, 0.1);
                spotLight.target.position.set(0, 0, 1);  // 전방 조준
                spotLight.castShadow = false;  // 그림자 비활성화 (성능)
                headlightGroup.add(spotLight);
                headlightGroup.add(spotLight.target);
                vehicle.spotLight = spotLight;  // 참조 저장

                headlightGroup.visible = false;  // 낮에는 끔
                vehicle.mesh.add(headlightGroup);
                vehicle.headlight = headlightGroup;

                // 원본 머티리얼 저장 (zone 모드 복구용)
                vehicle.originalMaterials = new Map();
                vehicle.mesh.traverse((child) => {
                    if (child.isMesh && child.material) {
                        vehicle.originalMaterials.set(child.uuid, child.material);
                    }
                });

                this.vehicleGroup.add(vehicle.mesh);
                this.vehiclePool.push(vehicle);
                this.vehicles.push(vehicle);
            }
            console.log(`Vehicle pool initialized: ${this.vehiclePool.length}`);
        },

        // 풀에서 차량 가져오기
        getFromPool() {
            for (const v of this.vehiclePool) {
                if (!v.isActive) return v;
            }
            return null;
        },

        // A* 경로탐색 (최적화)
        findPath(startX, startY, endX, endY) {
            const cacheKey = `${startX},${startY}-${endX},${endY}`;
            // 캐시 사용 안 함 (다양한 경로 위해)
            // 대신 간단한 5초 캐시
            const cached = this.pathCache.get(cacheKey);
            if (cached && Date.now() - cached.time < 5000) {
                return [...cached.path];
            }

            const startKey = `${startX},${startY}`;
            const endKey = `${endX},${endY}`;
            if (!this.roadNetwork.has(startKey) || !this.roadNetwork.has(endKey)) {
                return null;
            }

            const openSet = new PriorityQueue();
            const closedSet = new Set();  // 방문 완료 노드
            const gScore = new Map();
            const cameFrom = new Map();

            // 랜덤 시드 (같은 출발/도착이어도 다른 경로)
            const randomSeed = Math.random() * 0.5;

            gScore.set(startKey, 0);
            openSet.push({ key: startKey, x: startX, y: startY, f: this.heuristic(startX, startY, endX, endY) });

            let iterations = 0;
            const maxIterations = 1000;  // 무한루프 방지

            while (!openSet.isEmpty() && iterations < maxIterations) {
                iterations++;
                const current = openSet.pop();

                // 이미 방문한 노드면 스킵
                if (closedSet.has(current.key)) continue;
                closedSet.add(current.key);

                if (current.key === endKey) {
                    const path = this.reconstructPath(cameFrom, current);
                    this.pathCache.set(cacheKey, { path: [...path], time: Date.now() });
                    return path;
                }

                const node = this.roadNetwork.get(current.key);
                if (!node) continue;

                for (const neighbor of node.neighbors) {
                    const nKey = `${neighbor.x},${neighbor.y}`;
                    if (closedSet.has(nKey)) continue;  // 이미 방문한 노드 스킵

                    // 혼잡도 기반 비용 + 약간의 랜덤
                    const congestion = this.congestionMap.get(nKey) || 0;
                    const moveCost = 1 + congestion * 2 + Math.random() * randomSeed;
                    const tentativeG = gScore.get(current.key) + moveCost;

                    if (tentativeG < (gScore.get(nKey) || Infinity)) {
                        cameFrom.set(nKey, current.key);
                        gScore.set(nKey, tentativeG);
                        const f = tentativeG + this.heuristic(neighbor.x, neighbor.y, endX, endY);
                        openSet.push({ key: nKey, x: neighbor.x, y: neighbor.y, f });
                    }
                }
            }
            return null;
        },

        heuristic(x1, y1, x2, y2) {
            return Math.abs(x2 - x1) + Math.abs(y2 - y1);
        },

        reconstructPath(cameFrom, current) {
            const path = [];
            let key = current.key;
            while (key) {
                const [x, y] = key.split(',').map(Number);
                path.unshift({ x, y });
                key = cameFrom.get(key);
            }
            return path;
        },

        // 가장 가까운 도로 찾기
        findNearestRoad(tileX, tileY) {
            const queue = [{ x: tileX, y: tileY }];
            const visited = new Set([`${tileX},${tileY}`]);

            while (queue.length > 0) {
                const curr = queue.shift();
                if (isRoad(curr.x, curr.y)) {
                    return curr;
                }
                const neighbors = [
                    { x: curr.x - 1, y: curr.y },
                    { x: curr.x + 1, y: curr.y },
                    { x: curr.x, y: curr.y - 1 },
                    { x: curr.x, y: curr.y + 1 }
                ];
                for (const n of neighbors) {
                    const key = `${n.x},${n.y}`;
                    if (!visited.has(key) && inBounds(n.x, n.y)) {
                        visited.add(key);
                        queue.push(n);
                    }
                }
            }
            return null;
        },

        // 스폰 위치에 차량이 있는지 체크
        isSpawnBlocked(x, y) {
            for (const v of this.vehicles) {
                if (!v.isActive) continue;
                if (v.currentTile.x === x && v.currentTile.y === y) return true;
                if (v.targetTile.x === x && v.targetTile.y === y && v.progress < 0.3) return true;
            }
            return false;
        },

        // 차량 스폰 시도
        trySpawnVehicle() {
            // 스폰 비활성화 체크
            if (typeof vehicleSpawnEnabled !== 'undefined' && !vehicleSpawnEnabled) {
                return;
            }
            if (this.activeCount >= getMaxVehicles()) {
                return;
            }

            // 50% 확률로 랜덤 스폰 (다양성 증가)
            if (Math.random() < 0.5 || this.residentialBuildings.length === 0) {
                if (this.roadNetwork.size > 5) {
                    this.tryRandomSpawn();
                }
                return;
            }

            // 여러 번 시도
            for (let attempt = 0; attempt < 5; attempt++) {
                // 모든 건물 중에서 출발지 선택
                const allBuildings = [
                    ...this.residentialBuildings,
                    ...this.commercialBuildings,
                    ...this.industrialBuildings
                ];
                if (allBuildings.length < 2) continue;

                const originIdx = Math.floor(Math.random() * allBuildings.length);
                const origin = allBuildings[originIdx];

                // 목적지 선택 (다른 건물)
                let destination;
                const roll = Math.random();

                // 출발지 타입에 따른 목적지 선택 확률 조정
                const isOriginResidential = origin.type?.includes('residential');
                const isOriginCommercial = origin.type?.includes('commercial');
                const isOriginIndustrial = origin.type?.includes('industrial');

                if (isOriginResidential) {
                    // 주거 → 상업(40%) / 공업(40%) / 다른 주거(20%)
                    if (roll < 0.4 && this.commercialBuildings.length > 0) {
                        destination = this.commercialBuildings[
                            Math.floor(Math.random() * this.commercialBuildings.length)
                        ];
                    } else if (roll < 0.8 && this.industrialBuildings.length > 0) {
                        destination = this.industrialBuildings[
                            Math.floor(Math.random() * this.industrialBuildings.length)
                        ];
                    } else if (this.residentialBuildings.length > 1) {
                        let destIdx = Math.floor(Math.random() * this.residentialBuildings.length);
                        if (this.residentialBuildings[destIdx] === origin) {
                            destIdx = (destIdx + 1) % this.residentialBuildings.length;
                        }
                        destination = this.residentialBuildings[destIdx];
                    }
                } else if (isOriginCommercial || isOriginIndustrial) {
                    // 상업/공업 → 주거(70%) / 같은 타입(30%)
                    if (roll < 0.7 && this.residentialBuildings.length > 0) {
                        destination = this.residentialBuildings[
                            Math.floor(Math.random() * this.residentialBuildings.length)
                        ];
                    } else if (isOriginCommercial && this.commercialBuildings.length > 1) {
                        let destIdx = Math.floor(Math.random() * this.commercialBuildings.length);
                        if (this.commercialBuildings[destIdx] === origin) {
                            destIdx = (destIdx + 1) % this.commercialBuildings.length;
                        }
                        destination = this.commercialBuildings[destIdx];
                    } else if (isOriginIndustrial && this.industrialBuildings.length > 1) {
                        let destIdx = Math.floor(Math.random() * this.industrialBuildings.length);
                        if (this.industrialBuildings[destIdx] === origin) {
                            destIdx = (destIdx + 1) % this.industrialBuildings.length;
                        }
                        destination = this.industrialBuildings[destIdx];
                    }
                }

                // 목적지를 못 찾으면 아무 건물이나 선택
                if (!destination) {
                    let destIdx = Math.floor(Math.random() * allBuildings.length);
                    if (destIdx === originIdx) destIdx = (destIdx + 1) % allBuildings.length;
                    destination = allBuildings[destIdx];
                }
                if (!destination || destination === origin) continue;

                const originRoad = this.findNearestRoad(origin.x, origin.y);
                const destRoad = this.findNearestRoad(destination.x, destination.y);
                if (!originRoad || !destRoad) continue;
                if (originRoad.x === destRoad.x && originRoad.y === destRoad.y) continue;

                // 스폰 위치 혼잡도 및 차량 체크
                if (this.isSpawnBlocked(originRoad.x, originRoad.y)) continue;
                const spawnCongestion = this.congestionMap.get(`${originRoad.x},${originRoad.y}`) || 0;
                if (spawnCongestion > 0.6) continue;

                const path = this.findPath(originRoad.x, originRoad.y, destRoad.x, destRoad.y);
                if (!path || path.length < 3) continue;

                // 출발/도착 건물 정보와 함께 스폰
                this.spawnVehicle(path, origin, destination);
                return;
            }
        },

        // 초기 차량 스폰 (게임 시작 시 즉시 배치) - 건물 기반
        spawnInitialVehicles() {
            const maxVehicles = getMaxVehicles();
            const initialCount = Math.max(5, Math.floor(maxVehicles * 0.3));

            const allBuildings = [
                ...this.residentialBuildings,
                ...this.commercialBuildings,
                ...this.industrialBuildings
            ];

            if (allBuildings.length < 2) {
                console.log('Not enough buildings for initial spawn');
                return;
            }

            console.log(`Spawning ${initialCount} initial vehicles (building-based, staggered)...`);

            // 유효한 스폰 데이터 미리 수집
            const validSpawns = [];
            let attempts = 0;
            const maxAttempts = initialCount * 20;

            while (validSpawns.length < initialCount && attempts < maxAttempts) {
                attempts++;

                // 랜덤 출발/도착 건물 선택
                const originIdx = Math.floor(Math.random() * allBuildings.length);
                let destIdx = originIdx;

                for (let i = 0; i < 10; i++) {
                    destIdx = Math.floor(Math.random() * allBuildings.length);
                    if (destIdx !== originIdx) break;
                }

                if (originIdx === destIdx) continue;

                const origin = allBuildings[originIdx];
                const destination = allBuildings[destIdx];

                const originRoad = this.findNearestRoad(origin.x, origin.y);
                const destRoad = this.findNearestRoad(destination.x, destination.y);
                if (!originRoad || !destRoad) continue;
                if (originRoad.x === destRoad.x && originRoad.y === destRoad.y) continue;

                const path = this.findPath(originRoad.x, originRoad.y, destRoad.x, destRoad.y);
                if (!path || path.length < 2) continue;

                validSpawns.push({ path, origin, destination, originRoad });
            }

            // 스폰 데이터를 스태거드 방식으로 처리
            validSpawns.forEach((spawnData, index) => {
                const delay = index * 300;  // 각 차량 0.3초 간격
                setTimeout(() => {
                    // 스폰 비활성화 체크
                    if (typeof vehicleSpawnEnabled !== 'undefined' && !vehicleSpawnEnabled) return;
                    // 스폰 전 다시 블록 체크
                    if (!this.isSpawnBlocked(spawnData.originRoad.x, spawnData.originRoad.y)) {
                        this.spawnVehicle(spawnData.path, spawnData.origin, spawnData.destination);
                    }
                }, delay);
            });

            console.log(`Initial spawn queued: ${validSpawns.length} vehicles (staggered over ${validSpawns.length * 0.3}s)`);
        },

        // 랜덤 건물 간 스폰 (다양한 위치에서)
        tryRandomSpawn() {
            const allBuildings = [
                ...this.residentialBuildings,
                ...this.commercialBuildings,
                ...this.industrialBuildings
            ];
            if (allBuildings.length < 2) return;

            // 여러 번 시도
            for (let attempt = 0; attempt < 5; attempt++) {
                // 랜덤 출발/도착 건물 선택
                const originIdx = Math.floor(Math.random() * allBuildings.length);
                let destIdx = originIdx;

                for (let i = 0; i < 10; i++) {
                    destIdx = Math.floor(Math.random() * allBuildings.length);
                    if (destIdx !== originIdx) break;
                }

                if (originIdx === destIdx) continue;

                const origin = allBuildings[originIdx];
                const destination = allBuildings[destIdx];

                const originRoad = this.findNearestRoad(origin.x, origin.y);
                const destRoad = this.findNearestRoad(destination.x, destination.y);
                if (!originRoad || !destRoad) continue;
                if (originRoad.x === destRoad.x && originRoad.y === destRoad.y) continue;

                // 스폰 위치에 차량이 있는지 체크
                if (this.isSpawnBlocked(originRoad.x, originRoad.y)) continue;

                const path = this.findPath(originRoad.x, originRoad.y, destRoad.x, destRoad.y);
                if (!path || path.length < 3) continue;

                // 스폰 위치 혼잡도 체크
                const spawnCongestion = this.congestionMap.get(`${originRoad.x},${originRoad.y}`) || 0;
                if (spawnCongestion > 0.5) continue;

                this.spawnVehicle(path, origin, destination);
                return;
            }
        },

        // 차량 스폰 (출발/도착 건물 정보 포함)
        spawnVehicle(path, originBuilding = null, destBuilding = null) {
            const vehicle = this.getFromPool();
            if (!vehicle) {
                console.warn('No vehicle available in pool');
                return;
            }
            if (!vehicle.mesh) {
                console.warn('Vehicle has no mesh');
                return;
            }

            // 이전 사용에서 남은 특수 차량 속성 초기화
            vehicle.isFiretruck = false;
            vehicle.isPoliceCar = false;
            vehicle.isAmbulance = false;
            vehicle.isConstructionTruck = false;
            vehicle.isMoveInVehicle = false;
            vehicle.constructionSite = null;
            vehicle.fireTarget = null;
            vehicle.crimeTarget = null;
            vehicle.emergencyTarget = null;
            vehicle.isReturning = false;
            vehicle.originStation = null;
            vehicle.originHospital = null;
            vehicle.stationKey = null;
            vehicle.hospitalKey = null;
            vehicle.workStartTime = null;
            vehicle.isParked = false;

            vehicle.path = path;
            vehicle.pathIndex = 0;
            vehicle.progress = 0;
            vehicle.currentTile = { x: path[0].x, y: path[0].y };
            vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

            // 출발/도착 건물 정보 저장
            vehicle.originBuilding = originBuilding;
            vehicle.destBuilding = destBuilding;

            // 출발지/목적지 타입 판별
            const originType = originBuilding?.type?.includes('residential') ? 'residential' :
                               originBuilding?.type?.includes('commercial') ? 'commercial' :
                               originBuilding?.type?.includes('industrial') ? 'industrial' : 'residential';
            const destType = destBuilding?.type?.includes('residential') ? 'residential' :
                             destBuilding?.type?.includes('commercial') ? 'commercial' :
                             destBuilding?.type?.includes('industrial') ? 'industrial' : 'residential';

            // 차량 종류 선택 (경로 유형 기반)
            const vehicleTypeKey = this.selectVehicleType(originType, destType);
            const vehicleTypeConfig = VEHICLE_TYPES[vehicleTypeKey];
            vehicle.vehicleTypeKey = vehicleTypeKey;
            vehicle.type = vehicleTypeKey;
            vehicle.length = vehicleTypeConfig?.length || 0.25;  // 차량 길이 저장

            // 차량 메쉬 교체 (종류에 맞게)
            const oldMesh = vehicle.mesh;
            const oldPosition = oldMesh.position.clone();
            const oldRotation = oldMesh.rotation.y;
            const headlight = vehicle.headlight;

            // 기존 메쉬 제거
            this.vehicleGroup.remove(oldMesh);

            // 새 메쉬 생성
            const newMesh = this.createVehicleMesh(vehicleTypeKey);
            newMesh.visible = false;
            newMesh.position.copy(oldPosition);
            newMesh.rotation.y = oldRotation;

            // 헤드라이트 재부착
            if (headlight) {
                newMesh.add(headlight);
            }

            vehicle.mesh = newMesh;

            // 새 원본 머티리얼 저장
            vehicle.originalMaterials = new Map();
            newMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    vehicle.originalMaterials.set(child.uuid, child.material);
                }
            });

            this.vehicleGroup.add(newMesh);

            // 차량 종류에 따른 활동 메시지 설정
            if (vehicleTypeConfig && vehicleTypeConfig.activities) {
                const activities = vehicleTypeConfig.activities;
                vehicle.activity = activities[Math.floor(Math.random() * activities.length)];
            } else {
                vehicle.activity = this.generateActivity(originType, destType);
            }

            // 출발지/목적지 이름 설정
            vehicle.originTypeName = this.getBuildingTypeName(originBuilding?.type);
            vehicle.destTypeName = this.getBuildingTypeName(destBuilding?.type);

            // 속도 배율 적용
            const speedMultiplier = vehicleTypeConfig?.speedMultiplier || 1.0;
            vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * speedMultiplier;
            vehicle.targetSpeed = vehicle.speed;

            // 4차선 도로 차선 번호 할당 (0 = 외부, 1 = 내부)
            // 랜덤하게 차선 배정하여 도로 활용도 증가
            vehicle.laneNumber = Math.random() < 0.6 ? 0 : 1;  // 60% 외부 차선, 40% 내부 차선

            // 초기 위치 설정 (차선 오프셋 적용)
            const worldPos = this.getTileWorldPos(vehicle.currentTile, vehicle.targetTile, vehicle);
            vehicle.position.set(worldPos.x, 0.05, worldPos.z);
            vehicle.rotation = this.calcRotation(vehicle.currentTile, vehicle.targetTile);

            vehicle.mesh.position.copy(vehicle.position);
            vehicle.mesh.position.y = 0.02;  // 도로 위 높이
            vehicle.mesh.rotation.y = vehicle.rotation;
            vehicle.mesh.scale.setScalar(1.0);  // 스케일 초기화 (진입 애니메이션 후 복구)
            vehicle.mesh.visible = true;

            // 초기 속도 설정
            vehicle.currentSpeed = vehicle.speed * 0.5;  // 절반 속도로 시작

            vehicle.state = 'moving';
            vehicle.isActive = true;
            this.activeCount++;

            // 공간 분할 그리드에 등록 (충돌 검사 최적화)
            this.addToSpatialGrid(vehicle);

            // 밤이면 헤드라이트 켜기 (승용차만)
            if (vehicle.headlight) {
                const hasHeadlight = vehicleTypeConfig?.hasHeadlight === true;
                if (hasHeadlight) {
                    const hour = (timeState.gameTime / 3600) % 24;
                    vehicle.headlight.visible = (hour >= 19 || hour < 6);
                } else {
                    vehicle.headlight.visible = false;  // 비승용차는 헤드라이트 끔
                }
            }

            // 수치 모드 중이면 회색 머티리얼 적용
            if (isZoneModeActive) {
                vehicle.mesh.traverse((child) => {
                    if (child.isMesh && child.material) {
                        originalMaterials.set(child.uuid, child.material);
                        child.material = grayMaterialBuilding.clone();
                    }
                });
            } else {
                // 수치 모드가 아니면 원본 머티리얼로 복구 (이전 zone 모드에서 흰색으로 남은 경우)
                if (vehicle.originalMaterials && vehicle.originalMaterials.size > 0) {
                    vehicle.mesh.traverse((child) => {
                        if (child.isMesh && vehicle.originalMaterials.has(child.uuid)) {
                            const originalMat = vehicle.originalMaterials.get(child.uuid);
                            safeAssignMaterial(child, originalMat);
                        }
                    });
                }
            }
        },

        // 중심선 월드 좌표 (차선 오프셋 없이)
        getTileWorldPosCenter(current) {
            return tileToWorldCenter(current.x, current.y);
        },

        // 차선 적용된 월드 좌표 (4차선: 1,2차선 같은방향 / 3,4차선 반대방향)
        getTileWorldPos(current, next, vehicle = null, useCenterOnly = false) {
            const dx = next.x - current.x;
            const dy = next.y - current.y;

            // 4차선 도로 여부 확인
            const is4Lane = is4LaneRoad(current.x, current.y);

            // 개별 타일 중심 좌표 (2차선/4차선 모두 동일)
            const center = tileToWorldCenter(current.x, current.y);

            // 4차선 도로에서 중심선만 반환 (updateVehiclePosition에서 별도 오프셋 적용)
            if (is4Lane && useCenterOnly) {
                return { x: center.x, z: center.z };
            }

            let ox = 0, oz = 0;

            if (is4Lane) {
                // 4차선: 2차선과 동일한 우측통행
                const outerOffset = TRAFFIC_CONFIG.laneOffset4Lane;      // 0.35
                const innerOffset = TRAFFIC_CONFIG.laneOffset4Lane * 0.55;  // 0.19
                const isInnerLane = vehicle && vehicle.laneNumber === 1;
                const offset = isInnerLane ? innerOffset : outerOffset;

                // 2차선과 동일한 방향
                if (dy !== 0) {  // N/S 방향
                    ox = dy * offset;
                } else if (dx !== 0) {  // E/W 방향
                    oz = -dx * offset;
                }
            } else {
                // 2차선: 기존 로직
                const offset = TRAFFIC_CONFIG.laneOffset;
                if (dy !== 0) {
                    ox = dy * offset;
                } else if (dx !== 0) {
                    oz = -dx * offset;
                }
            }

            return { x: center.x + ox, z: center.z + oz };
        },

        // 회전 계산
        calcRotation(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            return Math.atan2(dx, dy);
        },

        // 이동 방향
        getDirection(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            if (dy < 0) return 'N';
            if (dx > 0) return 'E';
            if (dy > 0) return 'S';
            if (dx < 0) return 'W';
            return 'N';
        },

        // 메인 업데이트
        update(currentTime) {
            if (!this.initialized) return;

            try {
                const dt = Math.min((currentTime - this.lastUpdate) / 1000, 0.1);
                this.lastUpdate = currentTime;

                // 밤/낮 체크 (헤드라이트용)
                const hour = (timeState.gameTime / 3600) % 24;
                const isNight = hour >= 19 || hour < 6;
                this.updateHeadlights(isNight);

                // 차량 업데이트
                this.updateVehicles(dt);

                // 스폰 타이머
                this.spawnTimer += dt;
                if (this.spawnTimer >= TRAFFIC_CONFIG.spawnInterval) {
                    this.spawnTimer = 0;
                    this.trySpawnVehicle();
                }

                // 혼잡도 업데이트 (매 10프레임마다)
                if (Math.random() < 0.1) {
                    this.updateCongestion();
                }
            } catch (e) {
                console.error('Traffic update error:', e);
            }
        },

        // 헤드라이트 업데이트 (자연스러운 깜빡임 효과 포함)
        headlightPhase: 0,  // 헤드라이트 애니메이션 페이즈

        updateHeadlights(isNight) {
            // 상태 변경 시 차량 헤드라이트 켜기/끄기 처리
            if (this._lastNightState !== isNight) {
                this._lastNightState = isNight;

                let headlightCount = 0;
                for (const vehicle of this.vehicles) {
                    if (vehicle.headlight) {
                        headlightCount++;
                        // 승용차만 헤드라이트 활성화
                        const vehicleTypeConfig = VEHICLE_TYPES[vehicle.vehicleTypeKey];
                        const hasHeadlight = vehicleTypeConfig?.hasHeadlight === true;

                        if (isNight && vehicle.isActive && hasHeadlight) {
                            // 밤: 랜덤 딜레이 후 켜기 (0~2초)
                            const delay = Math.random() * 2000;
                            setTimeout(() => {
                                if (vehicle.headlight && vehicle.isActive) {
                                    vehicle.headlight.visible = true;
                                }
                            }, delay);
                        } else {
                            // 낮: 즉시 끄기
                            vehicle.headlight.visible = false;
                        }
                    }
                }
                console.log(`[Headlights] isNight: ${isNight}, vehiclesWithHeadlight: ${headlightCount}`);
            }

            // 밤이면 자연스러운 헤드라이트 깜빡임 효과 (공유 머티리얼 업데이트)
            if (isNight && this.headlightSharedResources) {
                this.updateNaturalHeadlightGlow();
            }
        },

        // 자연스러운 헤드라이트 불빛 효과 (사이렌처럼 부드러운 변화)
        updateNaturalHeadlightGlow() {
            this.headlightPhase += 0.05;  // 느린 변화 속도

            const hlRes = this.headlightSharedResources;
            if (!hlRes) return;

            // 여러 주파수의 사인파 조합으로 자연스러운 깜빡임 생성
            const flicker1 = Math.sin(this.headlightPhase * 2.3) * 0.03;    // 느린 호흡
            const flicker2 = Math.sin(this.headlightPhase * 5.7) * 0.02;    // 중간 속도
            const flicker3 = Math.sin(this.headlightPhase * 13.1) * 0.01;   // 빠른 미세 떨림

            // 총 변화량 (0.94 ~ 1.06 범위)
            const totalFlicker = 1 + flicker1 + flicker2 + flicker3;

            // 전구 색상 및 emissive 밝기 업데이트 (공유 머티리얼)
            if (hlRes.bulbMat) {
                // 기본색 0xffffdd에서 약간 변화 (노란빛 ~ 흰빛)
                const warmth = 0.86 + Math.sin(this.headlightPhase * 1.5) * 0.02;
                hlRes.bulbMat.color.setRGB(1.0, 1.0, warmth);
                hlRes.bulbMat.emissive.setRGB(1.0, 1.0, warmth);
                hlRes.bulbMat.emissiveIntensity = 3.0 * totalFlicker;
            }

            // SpotLight 강도 업데이트 (활성 차량만)
            const baseIntensity = 0.6;
            for (const vehicle of this.vehicles) {
                if (vehicle.spotLight && vehicle.headlight && vehicle.headlight.visible) {
                    vehicle.spotLight.intensity = baseIntensity * totalFlicker;
                }
            }
        },

        // 신호등 업데이트
        updateSignals(dt) {
            for (const [, signal] of this.signals) {
                signal.update(dt);

                // 시각적 업데이트 (각 방향별 신호등)
                if (signal.mesh && signal.mesh.userData.signalLights) {
                    const lights = signal.mesh.userData.signalLights;

                    // 각 방향별로 신호등 색상 업데이트
                    for (const dir of ['N', 'S', 'E', 'W']) {
                        const light = lights[dir];
                        if (!light) continue;

                        const isGreen = signal.isGreen(dir);
                        if (light.red && light.red.material) {
                            light.red.material.emissiveIntensity = isGreen ? 0.1 : 1.0;
                        }
                        if (light.green && light.green.material) {
                            light.green.material.emissiveIntensity = isGreen ? 1.0 : 0.1;
                        }
                    }
                }
            }
        },

        // 차량 업데이트
        updateVehicles(dt) {
            const maxVehicles = getMaxVehicles();

            for (const vehicle of this.vehicles) {
                if (!vehicle.isActive) continue;

                // 긴급차량 사이렌 라이트 업데이트
                if (vehicle.sirenLights && (vehicle.isFiretruck || vehicle.isPoliceCar || vehicle.isAmbulance)) {
                    // 구급차는 복귀 중에도 사이렌 유지 (환자 이송 완료 후 다음 출동 대비)
                    if (vehicle.isReturning && !vehicle.isAmbulance) {
                        // 복귀 중: 사이렌 끄기 (구급차 제외)
                        vehicle.sirenLights.visible = false;
                    } else {
                        // 임무 중 또는 구급차 복귀 중: 사이렌 켜기 및 애니메이션
                        vehicle.sirenLights.visible = true;
                        updateSirenLights(vehicle.sirenLights, dt);
                    }
                }

                if (vehicle.state === 'moving') {
                    this.updateMovingVehicle(vehicle, dt);
                } else if (vehicle.state === 'waiting') {
                    this.updateWaitingVehicle(vehicle, dt);
                } else if (vehicle.state === 'entering') {
                    this.updateEnteringVehicle(vehicle, dt);
                } else if (vehicle.state === 'despawning') {
                    this.despawnVehicle(vehicle);
                } else if (vehicle.state === 'working') {
                    // 소방차 잔화 작업 중
                    this.updateWorkingVehicle(vehicle, dt);
                }
            }

            // 인구 감소 시 초과 차량 제거 (소방차, 공사트럭 등 특수 차량 제외)
            if (this.activeCount > maxVehicles) {
                let toRemove = this.activeCount - maxVehicles;
                for (const vehicle of this.vehicles) {
                    if (toRemove <= 0) break;
                    // 특수 차량은 제거하지 않음
                    if (vehicle.isActive && !vehicle.isFiretruck && !vehicle.isPoliceCar && !vehicle.isConstructionTruck && !vehicle.isMoveInVehicle) {
                        this.despawnVehicle(vehicle);
                        toRemove--;
                    }
                }
            }
        },

        // 이동 중인 차량 업데이트
        updateMovingVehicle(vehicle, dt) {
            // 목표 속도 계산 (4차선 도로에서는 더 빠르게)
            const is4Lane = is4LaneRoad(vehicle.currentTile.x, vehicle.currentTile.y);
            const speedMultiplier = is4Lane ? TRAFFIC_CONFIG.speed4LaneMultiplier : 1.0;
            vehicle.targetSpeed = vehicle.speed * speedMultiplier;
            vehicle.stopReason = '';  // 초기화

            // 전방 차량 체크 - 부드러운 감속
            const aheadDist = this.getDistanceToVehicleAhead(vehicle);
            const stopDist = TRAFFIC_CONFIG.stopDistance;
            const minGap = TRAFFIC_CONFIG.minVehicleGap;

            if (aheadDist < stopDist) {
                // 최소 간격 이하면 완전 정지
                if (aheadDist < minGap) {
                    vehicle.targetSpeed = 0;
                    vehicle.stopReason = 'vehicle';
                } else {
                    // 거리에 비례해서 감속
                    const ratio = (aheadDist - minGap) / (stopDist - minGap);
                    vehicle.targetSpeed = Math.min(vehicle.targetSpeed, vehicle.speed * ratio);
                    if (vehicle.targetSpeed < vehicle.speed * 0.3) {
                        vehicle.stopReason = 'vehicle';  // 감속 중
                    }
                }
            }

            // 부드러운 가감속 (현재 속도를 목표 속도로 보간)
            const accel = vehicle.targetSpeed > vehicle.currentSpeed ? 3.0 : 4.0;  // 더 부드러운 가감속
            vehicle.currentSpeed += (vehicle.targetSpeed - vehicle.currentSpeed) * Math.min(1, accel * dt);

            // 아주 느리면 0으로 처리
            if (vehicle.currentSpeed < 0.005) vehicle.currentSpeed = 0;

            // 진행
            if (vehicle.currentSpeed > 0) {
                vehicle.progress += vehicle.currentSpeed * dt;
            }

            if (vehicle.progress >= 1.0) {
                vehicle.progress = 0;
                vehicle.pathIndex++;

                if (vehicle.pathIndex >= vehicle.path.length - 1) {
                    // 공사 트럭인 경우 - 도착 시 공사 시작 후 디스폰
                    if (vehicle.isConstructionTruck && vehicle.constructionSite) {
                        const site = vehicle.constructionSite;
                        const siteX = site.x;
                        const siteY = site.y;
                        const siteKey = `${siteX},${siteY}`;

                        // 건설 가능 여부 체크 (도로로 변경됨, 서비스 건물 설치됨 등)
                        let canBuild = true;

                        for (let dx = 0; dx < site.width && canBuild; dx++) {
                            for (let dy = 0; dy < site.depth && canBuild; dy++) {
                                const checkX = siteX + dx;
                                const checkY = siteY + dy;

                                // 도로인지 체크
                                if (isRoad(checkX, checkY) || isBridge(checkX, checkY)) {
                                    canBuild = false;
                                    console.log(`[Construction] Cancelled - road at (${checkX},${checkY})`);
                                }

                                // 서비스 건물인지 체크
                                if (placedPublicBuildings.has(`${checkX},${checkY}`)) {
                                    canBuild = false;
                                    console.log(`[Construction] Cancelled - public building at (${checkX},${checkY})`);
                                }

                                // 이미 다른 건물이 있는지 체크
                                const existingBuilding = placedBuildings.get(`${checkX},${checkY}`);
                                if (existingBuilding && !existingBuilding.ref) {
                                    canBuild = false;
                                    console.log(`[Construction] Cancelled - building exists at (${checkX},${checkY})`);
                                }
                            }
                        }

                        if (canBuild) {
                            startConstruction(site);
                        } else {
                            // 공사 취소 - constructionSites에서 제거
                            constructionSites.delete(siteKey);
                            toast({ title: '공사 취소', desc: '건설 현장이 변경되어 공사가 취소되었습니다.' });
                        }

                        this.despawnVehicle(vehicle);
                        return;
                    }

                    // 입주 차량인 경우 - 빠르게 디스폰
                    if (vehicle.isMoveInVehicle) {
                        // 입주 완료 처리
                        if (vehicle.destBuilding) {
                            onMoveInArrival(vehicle.destBuilding.x, vehicle.destBuilding.y);
                        }
                        this.despawnVehicle(vehicle);
                        return;
                    }

                    // 소방차인 경우 - 화재 현장 도착 또는 소방서 복귀
                    if (vehicle.isFiretruck) {
                        // 소방서로 복귀 완료
                        if (vehicle.isReturning) {
                            console.log(`[Fire] Firetruck returned to station`);
                            this.despawnVehicle(vehicle);
                            return;
                        }

                        // 화재 현장 도착 - 잔화 작업 시작
                        if (vehicle.fireTarget) {
                            console.log(`[Fire] Firetruck arrived at fire location (${vehicle.fireTarget.x}, ${vehicle.fireTarget.y})`);
                            onFiretruckArrival(vehicle.fireTarget.x, vehicle.fireTarget.y, vehicle);
                            return;
                        }

                        // fireTarget이 없는 경우 (비정상) - 소방서로 복귀
                        console.warn(`[Fire] Firetruck has no fireTarget, returning to station`);
                        startFiretruckReturn(vehicle);
                        return;
                    }

                    // 경찰차인 경우 - 범죄 현장 도착 또는 경찰서 복귀
                    if (vehicle.isPoliceCar) {
                        // 경찰서로 복귀 완료
                        if (vehicle.isReturning) {
                            console.log(`[Crime] Police car returned to station`);
                            this.despawnVehicle(vehicle);
                            return;
                        }

                        // 범죄 현장 도착 - 현장 조사 시작
                        if (vehicle.crimeTarget) {
                            console.log(`[Crime] Police car arrived at crime location (${vehicle.crimeTarget.x}, ${vehicle.crimeTarget.y})`);
                            onPoliceCarArrival(vehicle.crimeTarget.x, vehicle.crimeTarget.y, vehicle);
                            return;
                        }

                        // crimeTarget이 없는 경우 (비정상) - 경찰서로 복귀
                        console.warn(`[Crime] Police car has no crimeTarget, returning to station`);
                        startPoliceCarReturn(vehicle);
                        return;
                    }

                    // 구급차인 경우 - 응급 현장 도착 또는 병원 복귀
                    if (vehicle.isAmbulance) {
                        // 병원으로 복귀 완료
                        if (vehicle.isReturning) {
                            console.log(`[Medical] Ambulance returned to hospital`);
                            this.despawnVehicle(vehicle);
                            return;
                        }

                        // 응급 현장 도착 - 환자 이송 준비 시작
                        if (vehicle.emergencyTarget) {
                            console.log(`[Medical] Ambulance arrived at emergency location (${vehicle.emergencyTarget.x}, ${vehicle.emergencyTarget.y})`);
                            onAmbulanceArrival(vehicle.emergencyTarget.x, vehicle.emergencyTarget.y, vehicle);
                            return;
                        }

                        // emergencyTarget이 없는 경우 (비정상) - 병원으로 복귀
                        console.warn(`[Medical] Ambulance has no emergencyTarget, returning to hospital`);
                        startAmbulanceReturn(vehicle);
                        return;
                    }

                    // 목적지 도착 - 바로 차량 제거 (건물 진입 애니메이션 없음)
                    this.despawnVehicle(vehicle);
                    return;
                }

                vehicle.currentTile = { ...vehicle.targetTile };
                vehicle.targetTile = {
                    x: vehicle.path[vehicle.pathIndex + 1].x,
                    y: vehicle.path[vehicle.pathIndex + 1].y
                };
                vehicle.rotation = this.calcRotation(vehicle.currentTile, vehicle.targetTile);
            }

            // 교착상태 체크 및 해제
            this.checkAndResolveStuck(vehicle);

            this.updateVehiclePosition(vehicle);
        },

        // 대기 중인 차량 업데이트 (사용 안 함 - 부드러운 감속 방식으로 변경)
        updateWaitingVehicle(vehicle, dt) {
            // 이제 moving 상태에서 speedMultiplier로 처리하므로 사용 안 함
            vehicle.state = 'moving';
        },

        // 소방차 잔화 작업 중 업데이트
        updateWorkingVehicle(vehicle, dt) {
            if (!vehicle.workStartTime) {
                vehicle.workStartTime = Date.now();
            }

            const elapsed = Date.now() - vehicle.workStartTime;

            // 작업 시간 완료 체크 (소방차, 경찰차, 또는 구급차)
            let workTime;
            if (vehicle.isPoliceCar) {
                workTime = CRIME_POLICE_WORK_TIME;
            } else if (vehicle.isAmbulance) {
                workTime = MEDICAL_AMBULANCE_WORK_TIME;
            } else {
                workTime = FIRETRUCK_WORK_TIME;
            }

            if (elapsed >= workTime) {
                // 복귀 시작
                if (vehicle.isPoliceCar) {
                    startPoliceCarReturn(vehicle);
                    toast({
                        title: '🏠 복귀 시작',
                        desc: '현장 조사 완료! 경찰차가 경찰서로 복귀합니다.',
                        ms: 3000
                    });
                } else if (vehicle.isAmbulance) {
                    startAmbulanceReturn(vehicle);
                    toast({
                        title: '🏠 복귀 시작',
                        desc: '환자 이송 완료! 구급차가 병원으로 복귀합니다.',
                        ms: 3000
                    });
                } else {
                    startFiretruckReturn(vehicle);
                    toast({
                        title: '🏠 복귀 시작',
                        desc: '잔화 작업 완료! 소방차가 소방서로 복귀합니다.',
                        ms: 3000
                    });
                }
            }
        },

        // 교차로인지 확인
        isIntersection(x, y) {
            const node = this.roadNetwork.get(`${x},${y}`);
            return node && (node.intersectionType === 't' || node.intersectionType === 'cross');
        },

        // 전방 차량까지 거리 계산 (공간 분할 최적화, 교차로 우선권 적용, 차량 길이 고려)
        getDistanceToVehicleAhead(vehicle) {
            let minDist = Infinity;

            // 내 진행 방향 벡터
            const myForwardX = Math.sin(vehicle.rotation);
            const myForwardZ = Math.cos(vehicle.rotation);

            // 내 차량 길이
            const myLength = vehicle.length || 0.25;

            // 현재 교차로에 있는지 확인
            const atIntersection = this.isIntersection(vehicle.currentTile.x, vehicle.currentTile.y) ||
                                   this.isIntersection(vehicle.targetTile.x, vehicle.targetTile.y);

            // 공간 분할을 이용해 주변 차량만 검사 (O(n²) → O(n*k) 최적화)
            const nearbyVehicles = this.getNearbyVehicles(vehicle.position.x, vehicle.position.z);

            for (const other of nearbyVehicles) {
                if (!other.isActive || other === vehicle) continue;

                const dx = other.position.x - vehicle.position.x;
                const dz = other.position.z - vehicle.position.z;
                const centerDist = Math.sqrt(dx * dx + dz * dz);

                if (centerDist > 1.5) continue;  // 검색 범위 확장 (긴 차량 고려)

                // 1. 전방인지 확인
                const dotAhead = dx * myForwardX + dz * myForwardZ;
                if (dotAhead <= 0.08) continue;  // 전방 아님

                // 2. 방향 체크
                const otherForwardX = Math.sin(other.rotation);
                const otherForwardZ = Math.cos(other.rotation);
                const dotDirection = myForwardX * otherForwardX + myForwardZ * otherForwardZ;

                // 반대 방향은 무시
                if (dotDirection < -0.3) continue;

                // 3. 앞차 길이를 고려한 실제 간격 계산
                // 중심간 거리에서 내 앞부분과 상대 뒷부분까지의 거리를 계산
                const otherLength = other.length || 0.25;
                const actualGap = centerDist - (myLength / 2) - (otherLength / 2);

                // 4. 교차로에서 수직 방향 차량 처리 (우선권)
                if (atIntersection && Math.abs(dotDirection) < 0.5) {
                    // 수직 방향 차량 (교차로에서 교차)
                    // ID가 작은 차량이 우선권 (간단한 우선권 규칙)
                    if (vehicle.id > other.id) {
                        // 내가 양보해야 함
                        if (actualGap < minDist) minDist = actualGap;
                    }
                    // 내가 우선권이면 무시하고 통과
                    continue;
                }

                // 5. 같은 방향/비슷한 방향 차량
                const lateralDist = Math.abs(-dx * myForwardZ + dz * myForwardX);
                if (lateralDist > 0.4) continue;  // 다른 차선

                if (actualGap < minDist) {
                    minDist = actualGap;
                }
            }
            return minDist;
        },

        // 교착상태 감지 및 해제
        stuckTimers: new Map(),

        checkAndResolveStuck(vehicle) {
            const key = vehicle.id;
            const atIntersection = this.isIntersection(vehicle.currentTile.x, vehicle.currentTile.y);

            if (vehicle.currentSpeed < 0.02 && vehicle.targetSpeed === 0) {
                const timer = this.stuckTimers.get(key) || 0;
                this.stuckTimers.set(key, timer + 1);

                // 교차로에서는 더 빨리 해제 (2초), 일반 도로는 4초
                const threshold = atIntersection ? 60 : 120;

                if (timer > threshold) {
                    vehicle.progress += 0.15;  // 강제 전진
                    this.stuckTimers.set(key, 0);
                    vehicle.stopReason = '';
                }
            } else {
                this.stuckTimers.set(key, 0);
            }
        },


        // 좌회전 감지 (cross product로 회전 방향 판별)
        isLeftTurn(from, current, to) {
            const dx1 = current.x - from.x;
            const dy1 = current.y - from.y;
            const dx2 = to.x - current.x;
            const dy2 = to.y - current.y;
            // cross product: 음수면 좌회전 (반시계방향)
            return (dx1 * dy2 - dy1 * dx2) < 0;
        },

        // U-턴 감지 (180도 회전 - 반대 방향으로 진행)
        isUTurn(from, current, to) {
            const dx1 = current.x - from.x;
            const dy1 = current.y - from.y;
            const dx2 = to.x - current.x;
            const dy2 = to.y - current.y;
            // dot product: 음수면 반대 방향 (U-턴)
            // 정확히 -1이면 완전 U-턴, 0보다 작으면 90도 이상 회전
            const dot = dx1 * dx2 + dy1 * dy2;
            return dot < 0;
        },

        // 차량 위치 업데이트 (자연스러운 곡선 이동 + 시각적 보간)
        updateVehiclePosition(vehicle) {
            // 4차선 도로 여부 확인
            const is4Lane = is4LaneRoad(vehicle.currentTile.x, vehicle.currentTile.y);

            // 4차선 도로: 중심선 위치로 보간 후 방향 기반 차선 오프셋 적용
            // 2차선 도로: 기존 로직 (각 포인트에 차선 오프셋 포함)
            const useCenterOnly = is4Lane;

            // 현재, 다음, 그 다음 타일 위치
            const p0 = vehicle.pathIndex > 0
                ? this.getTileWorldPos(vehicle.path[vehicle.pathIndex - 1], vehicle.currentTile, vehicle, useCenterOnly)
                : this.getTileWorldPos(vehicle.currentTile, vehicle.targetTile, vehicle, useCenterOnly);
            const p1 = this.getTileWorldPos(vehicle.currentTile, vehicle.targetTile, vehicle, useCenterOnly);
            const p2 = this.getTileWorldPos(vehicle.targetTile,
                vehicle.pathIndex + 2 < vehicle.path.length
                    ? vehicle.path[vehicle.pathIndex + 2]
                    : vehicle.targetTile,
                vehicle,
                useCenterOnly
            );
            const p3 = vehicle.pathIndex + 3 < vehicle.path.length
                ? this.getTileWorldPos(vehicle.path[vehicle.pathIndex + 2], vehicle.path[vehicle.pathIndex + 3], vehicle, useCenterOnly)
                : p2;

            // Catmull-Rom 스플라인으로 목표 위치 계산
            const t = vehicle.progress;
            let posX = this.catmullRom(p0.x, p1.x, p2.x, p3.x, t);
            let posZ = this.catmullRom(p0.z, p1.z, p2.z, p3.z, t);

            // 4차선 도로: 2차선과 동일한 우측통행
            if (is4Lane) {
                // 보간된 방향 계산 (Catmull-Rom 미분)
                const dx = this.catmullRomDerivative(p0.x, p1.x, p2.x, p3.x, t);
                const dz = this.catmullRomDerivative(p0.z, p1.z, p2.z, p3.z, t);
                const dirLen = Math.sqrt(dx * dx + dz * dz);

                if (dirLen > 0.001) {
                    // 정규화된 방향 벡터
                    const dirX = dx / dirLen;
                    const dirZ = dz / dirLen;

                    // 차선 오프셋 계산
                    const outerOffset = TRAFFIC_CONFIG.laneOffset4Lane;  // 0.35
                    const innerOffset = outerOffset * 0.55;  // 0.19
                    const isInnerLane = vehicle.laneNumber === 1;
                    const laneOffset = isInnerLane ? innerOffset : outerOffset;

                    // 오른쪽 벡터 (90도 시계방향): (dx, dz) -> (-dz, dx)
                    const perpX = -dirZ;
                    const perpZ = dirX;

                    posX += perpX * laneOffset;
                    posZ += perpZ * laneOffset;
                }
            }

            // 좌회전 시 안쪽(왼쪽)으로 오프셋 적용
            if (vehicle.pathIndex + 2 < vehicle.path.length) {
                const prevTile = vehicle.pathIndex > 0 ? vehicle.path[vehicle.pathIndex - 1] : vehicle.currentTile;
                const nextTile = vehicle.path[vehicle.pathIndex + 2];

                if (this.isLeftTurn(prevTile, vehicle.targetTile, nextTile)) {
                    // 좌회전 중 - 진행 방향의 왼쪽(안쪽)으로 오프셋
                    const dirX = p2.x - p1.x;
                    const dirZ = p2.z - p1.z;
                    const dirLen = Math.sqrt(dirX * dirX + dirZ * dirZ);

                    if (dirLen > 0.01) {
                        // 왼쪽 수직 벡터 (90도 반시계방향)
                        const perpX = -dirZ / dirLen;
                        const perpZ = dirX / dirLen;

                        // sin 곡선으로 부드러운 오프셋 (0 → max → 0)
                        const inwardOffset = 0.12 * Math.sin(t * Math.PI);
                        posX += perpX * inwardOffset;
                        posZ += perpZ * inwardOffset;
                    }
                }
                // U-턴 시 중앙선 통과 처리 (교차로에서만)
                else if (this.isUTurn(prevTile, vehicle.targetTile, nextTile) &&
                         this.isIntersection(vehicle.targetTile.x, vehicle.targetTile.y)) {
                    // U-턴 중 - 현재 차선에서 반대 차선으로 중앙선을 통해 이동
                    const dirX = p2.x - p1.x;
                    const dirZ = p2.z - p1.z;
                    const dirLen = Math.sqrt(dirX * dirX + dirZ * dirZ);

                    if (dirLen > 0.01) {
                        // 왼쪽 수직 벡터 (U-턴은 항상 왼쪽으로 회전)
                        const perpX = -dirZ / dirLen;
                        const perpZ = dirX / dirLen;

                        // 차선 오프셋 (현재 도로 타입에 따라)
                        const is4Lane = is4LaneRoad(vehicle.targetTile.x, vehicle.targetTile.y);
                        const laneOffset = is4Lane ? TRAFFIC_CONFIG.laneOffset4Lane : TRAFFIC_CONFIG.laneOffset;

                        // sin 곡선으로 중앙선까지 이동 후 반대 차선으로
                        // t=0: 원래 차선 (+laneOffset)
                        // t=0.5: 중앙선 (0)
                        // t=1: 반대 차선 (-laneOffset 방향, 하지만 회전 후이므로 실제로는 올바른 위치)
                        // U-턴이므로 더 넓게 회전 (차선 2개 폭만큼)
                        const uTurnOffset = laneOffset * 2 * Math.sin(t * Math.PI);
                        posX += perpX * uTurnOffset;
                        posZ += perpZ * uTurnOffset;
                    }
                }
            }

            vehicle.position.x = posX;
            vehicle.position.z = posZ;

            // 공간 분할 그리드 업데이트 (셀 변경 시에만)
            this.updateSpatialGrid(vehicle);

            // 시각적 위치 보간 (부드러운 이동)
            if (!vehicle.visualInitialized) {
                vehicle.visualPosition.copy(vehicle.position);
                vehicle.visualInitialized = true;
            } else {
                // 부드러운 보간 (0.4 = 빠르지만 부드럽게)
                vehicle.visualPosition.lerp(vehicle.position, 0.4);
            }

            vehicle.mesh.position.copy(vehicle.visualPosition);
            vehicle.mesh.position.y = 0.02;  // 도로 위 높이

            // 진행 방향 계산 (미분)
            const dx = this.catmullRomDerivative(p0.x, p1.x, p2.x, p3.x, t);
            const dz = this.catmullRomDerivative(p0.z, p1.z, p2.z, p3.z, t);
            if (Math.abs(dx) > 0.001 || Math.abs(dz) > 0.001) {
                vehicle.rotation = Math.atan2(dx, dz);
            }

            // 시각적 회전 보간 (부드러운 회전)
            if (vehicle.visualRotation === undefined) {
                vehicle.visualRotation = vehicle.rotation;
            }
            vehicle.visualRotation = this.lerpAngle(vehicle.visualRotation, vehicle.rotation, 0.3);
            vehicle.mesh.rotation.set(0, vehicle.visualRotation, 0);
        },

        // Catmull-Rom 스플라인 보간
        catmullRom(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return 0.5 * (
                (2 * p1) +
                (-p0 + p2) * t +
                (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
                (-p0 + 3 * p1 - 3 * p2 + p3) * t3
            );
        },

        // Catmull-Rom 미분 (방향 계산용)
        catmullRomDerivative(p0, p1, p2, p3, t) {
            const t2 = t * t;
            return 0.5 * (
                (-p0 + p2) +
                2 * (2 * p0 - 5 * p1 + 4 * p2 - p3) * t +
                3 * (-p0 + 3 * p1 - 3 * p2 + p3) * t2
            );
        },

        smoothstep(t) {
            return t * t * (3 - 2 * t);
        },

        lerpAngle(from, to, t) {
            let diff = to - from;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return from + diff * t;
        },

        // 건물 진입 중인 차량 업데이트
        updateEnteringVehicle(vehicle, dt) {
            const enterDuration = 0.15;  // 진입 애니메이션 시간 (초) - 거의 즉시
            vehicle.enterProgress += dt / enterDuration;

            if (vehicle.enterProgress >= 1.0) {
                // 애니메이션 완료 - 차량 제거
                this.despawnVehicle(vehicle);
                return;
            }

            // easeInOutQuad로 부드럽게 가감속
            const t = vehicle.enterProgress;
            const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

            // 위치 보간 (시작점 → 건물 중심)
            const x = vehicle.enterStart.x + (vehicle.enterTarget.x - vehicle.enterStart.x) * eased;
            const z = vehicle.enterStart.z + (vehicle.enterTarget.z - vehicle.enterStart.z) * eased;

            vehicle.mesh.position.x = x;
            vehicle.mesh.position.z = z;
            // 높이를 약간 낮춰서 건물 안으로 들어가는 느낌
            vehicle.mesh.position.y = 0.02 * (1 - eased * 0.5);

            // 회전 보간 (건물 방향으로 회전)
            if (vehicle.enterStartRotation !== undefined && vehicle.enterTargetRotation !== undefined) {
                const rotationT = Math.min(t * 2, 1);  // 전반부에서 회전 완료
                const rotEased = rotationT < 0.5 ? 2 * rotationT * rotationT : 1 - Math.pow(-2 * rotationT + 2, 2) / 2;
                vehicle.mesh.rotation.y = this.lerpAngle(vehicle.enterStartRotation, vehicle.enterTargetRotation, rotEased);
            }

            // 스케일 축소 (점점 작아짐)
            const scale = (vehicle.enterStartScale || 1.0) * (1 - eased * 0.7);
            vehicle.mesh.scale.setScalar(scale);
        },

        // 차량 제거
        despawnVehicle(vehicle) {
            // 소방차인 경우 소방서 카운트 감소
            if (vehicle.isFiretruck && vehicle.stationKey) {
                const currentCount = stationFiretruckCount.get(vehicle.stationKey) || 0;
                if (currentCount > 0) {
                    stationFiretruckCount.set(vehicle.stationKey, currentCount - 1);
                }
                // 소방차 관련 속성 초기화
                vehicle.isFiretruck = false;
                vehicle.stationKey = null;
                vehicle.fireTarget = null;
                vehicle.isReturning = false;
            }
            // 경찰차인 경우 경찰서 카운트 감소
            if (vehicle.isPoliceCar && vehicle.stationKey) {
                const currentCount = stationPoliceCount.get(vehicle.stationKey) || 0;
                if (currentCount > 0) {
                    stationPoliceCount.set(vehicle.stationKey, currentCount - 1);
                }
                // 경찰차 관련 속성 초기화
                vehicle.isPoliceCar = false;
                vehicle.stationKey = null;
                vehicle.crimeTarget = null;
                vehicle.isReturning = false;
            }
            // 구급차인 경우 병원 카운트 감소
            if (vehicle.isAmbulance && vehicle.hospitalKey) {
                const currentCount = hospitalAmbulanceCount.get(vehicle.hospitalKey) || 0;
                if (currentCount > 0) {
                    hospitalAmbulanceCount.set(vehicle.hospitalKey, currentCount - 1);
                }
                // 구급차 관련 속성 초기화
                vehicle.isAmbulance = false;
                vehicle.hospitalKey = null;
                vehicle.emergencyTarget = null;
                vehicle.isReturning = false;
            }
            // 공간 분할 그리드에서 제거
            this.removeFromSpatialGrid(vehicle);
            vehicle.reset();
            this.activeCount--;
        },

        // 모든 차량 제거
        removeAllVehicles() {
            // 활성 차량 모두 despawn
            const toRemove = this.vehicles.filter(v => v.isActive);
            for (const vehicle of toRemove) {
                this.despawnVehicle(vehicle);
            }
            // 스폰 대기열 초기화
            this.spawnQueue = [];
            // 공간 분할 그리드 초기화
            this.spatialGrid.clear();
            // 혼잡도 맵 초기화
            this.congestionMap.clear();
            console.log('All vehicles removed');
        },

        // 혼잡도 업데이트 (지수 이동 평균 - EMA)
        // RAM 추가 없이 시간 평균 계산
        updateCongestion() {
            const alpha = 0.15;  // 평활 계수 (낮을수록 과거 데이터 더 반영)
            const decayThreshold = 0.01;  // 이 값 이하면 삭제 (메모리 절약)

            // 현재 프레임의 차량 수 집계
            const counts = new Map();
            for (const v of this.vehicles) {
                if (!v.isActive) continue;
                const key = `${v.currentTile.x},${v.currentTile.y}`;
                counts.set(key, (counts.get(key) || 0) + 1);
            }

            // 기존 타일들 EMA 업데이트 + 감쇠
            for (const [key, oldValue] of this.congestionMap) {
                const currentCount = counts.get(key) || 0;
                const instantaneous = Math.min(currentCount / 3, 1);
                const smoothed = alpha * instantaneous + (1 - alpha) * oldValue;

                if (smoothed < decayThreshold) {
                    this.congestionMap.delete(key);  // 메모리 정리
                } else {
                    this.congestionMap.set(key, smoothed);
                }
                counts.delete(key);  // 처리 완료 표시
            }

            // 새로운 타일 추가 (기존 맵에 없던 타일)
            for (const [key, count] of counts) {
                const instantaneous = Math.min(count / 3, 1);
                if (instantaneous >= decayThreshold) {
                    this.congestionMap.set(key, instantaneous * alpha);
                }
            }
        },

        // 도로 변경 시 재구축
        onRoadChange() {
            // 도로가 없어진 곳의 차량 제거
            this.removeVehiclesOnInvalidRoads();
            this.buildRoadNetwork();
            this.pathCache.clear();
        },

        // 유효하지 않은 도로 위 차량 제거
        removeVehiclesOnInvalidRoads() {
            for (const vehicle of this.vehicles) {
                if (!vehicle.isActive) continue;

                // 현재 타일이나 목표 타일이 도로가 아니면 제거
                const currIsRoad = isRoad(vehicle.currentTile.x, vehicle.currentTile.y);
                const targetIsRoad = isRoad(vehicle.targetTile.x, vehicle.targetTile.y);

                if (!currIsRoad || !targetIsRoad) {
                    this.despawnVehicle(vehicle);
                    continue;
                }

                // 남은 경로에 유효하지 않은 도로가 있으면 제거
                if (vehicle.path && vehicle.pathIndex < vehicle.path.length) {
                    let pathInvalid = false;
                    for (let i = vehicle.pathIndex; i < vehicle.path.length; i++) {
                        const tile = vehicle.path[i];
                        if (!isRoad(tile.x, tile.y)) {
                            pathInvalid = true;
                            break;
                        }
                    }
                    if (pathInvalid) {
                        this.despawnVehicle(vehicle);
                    }
                }
            }
        },

        // 건물 변경 시 재분류
        onBuildingChange() {
            // 철거된 건물로 향하는 차량 제거
            this.removeVehiclesWithInvalidDestination();
            // 건물 목록 재분류
            this.categorizeBuildings();
        },

        // 유효하지 않은 목적지로 향하는 차량 제거
        removeVehiclesWithInvalidDestination() {
            for (const vehicle of this.vehicles) {
                if (!vehicle.isActive) continue;

                // 목적지 건물이 존재하는지 확인
                if (vehicle.destBuilding) {
                    const { x, y } = vehicle.destBuilding;
                    // 해당 위치에 건물이 더 이상 없으면 차량 제거
                    if (!findBuildingAt(x, y)) {
                        this.despawnVehicle(vehicle);
                    }
                }
            }
        },

        // 통계 정보
        getStats() {
            return {
                activeVehicles: this.activeCount,
                maxVehicles: getMaxVehicles(),
                roadNodes: this.roadNetwork.size,
                signals: this.signals.size,
                pathCacheSize: this.pathCache.size,
                residential: this.residentialBuildings.length,
                commercial: this.commercialBuildings.length,
                industrial: this.industrialBuildings.length
            };
        },

        // === 차량 선택 시스템 ===
        selectedVehicle: null,
        followingVehicle: null,
        vehicleOutlineMeshes: [],

        // 차량 선택
        selectVehicle(vehicle) {
            this.clearVehicleOutline();
            this.selectedVehicle = vehicle;
            if (vehicle && vehicle.mesh) {
                this.createVehicleOutline(vehicle);
                this.showVehiclePopup(vehicle);
            }
        },

        // 차량 선택 해제
        deselectVehicle() {
            this.clearVehicleOutline();
            this.selectedVehicle = null;
            this.stopFollowing();
            this.hideVehiclePopup();
        },

        // 차량 아웃라인 생성
        createVehicleOutline(vehicle) {
            this.clearVehicleOutline();
            if (!vehicle || !vehicle.mesh) return;

            const outlineMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                side: THREE.BackSide
            });

            vehicle.mesh.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const outline = new THREE.Mesh(child.geometry.clone(), outlineMat.clone());
                    child.updateWorldMatrix(true, false);
                    outline.applyMatrix4(child.matrixWorld);
                    outline.scale.multiplyScalar(1.06);
                    outline.renderOrder = -1;
                    scene.add(outline);
                    this.vehicleOutlineMeshes.push(outline);
                }
            });
        },

        // 차량 아웃라인 업데이트 (따라다니는 중일 때)
        updateVehicleOutline() {
            if (!this.selectedVehicle || !this.selectedVehicle.isActive) {
                this.deselectVehicle();
                return;
            }

            // 아웃라인 위치 업데이트
            if (this.vehicleOutlineMeshes.length > 0 && this.selectedVehicle.mesh) {
                this.clearVehicleOutline();
                this.createVehicleOutline(this.selectedVehicle);
            }
        },

        // 차량 아웃라인 제거
        clearVehicleOutline() {
            this.vehicleOutlineMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            this.vehicleOutlineMeshes = [];
        },

        // 카메라 따라가기 시작
        startFollowing(vehicle) {
            this.followingVehicle = vehicle;
        },

        // 카메라 따라가기 중지
        stopFollowing() {
            this.followingVehicle = null;
        },

        // 카메라 따라가기 업데이트 (animate에서 호출)
        updateCameraFollow() {
            if (!this.followingVehicle || !this.followingVehicle.isActive) {
                if (this.followingVehicle) this.stopFollowing();
                return;
            }

            const v = this.followingVehicle;
            const targetPos = v.position.clone();

            // 카메라 회전은 차량 회전과 독립적
            // 현재 카메라 오프셋 유지하면서 차량 위치만 따라감
            const currentOffset = camera.position.clone().sub(controls.target);

            // 타겟(차량 위치)을 부드럽게 따라감
            controls.target.lerp(targetPos, 0.08);

            // 카메라 위치 = 타겟 + 현재 오프셋 (회전 유지)
            const newCamPos = controls.target.clone().add(currentOffset);
            camera.position.copy(newCamPos);
        },

        // 차량 정보 팝업 표시
        showVehiclePopup(vehicle) {
            const popup = document.getElementById('vehiclePopup');
            if (!popup || !vehicle) return;

            // 차량 타입에 따른 정보 (VEHICLE_TYPES에서 가져옴)
            const vehicleTypeKey = vehicle.vehicleTypeKey || vehicle.type || 'old';
            const vehicleTypeConfig = VEHICLE_TYPES[vehicleTypeKey];

            let typeName = '차량';
            let typeIcon = '🚗';

            if (vehicleTypeConfig) {
                typeName = vehicleTypeConfig.name;
                typeIcon = vehicleTypeConfig.icon;
            } else {
                // 폴백: 기존 방식
                const typeNames = {
                    'car': '승용차',
                    'truck': '트럭',
                    'bus': '버스',
                    'taxi': '택시'
                };
                typeName = typeNames[vehicle.type] || '차량';
            }

            // 경로 정보
            const pathLength = vehicle.path ? vehicle.path.length : 0;
            const progress = vehicle.pathIndex ? Math.round((vehicle.pathIndex / pathLength) * 100) : 0;

            // 속도 정보
            const speedKmh = Math.round(vehicle.currentSpeed * 50);  // 임의 변환

            document.getElementById('vehiclePopupTitle').textContent = `${typeIcon} ${typeName}`;
            document.getElementById('vehiclePopupSpeed').textContent = speedKmh + ' km/h';
            document.getElementById('vehiclePopupProgress').style.width = progress + '%';
            document.getElementById('vehiclePopupProgressText').textContent = progress + '%';

            // 활동 정보 표시
            const activityEl = document.getElementById('vehiclePopupActivity');
            if (activityEl) {
                activityEl.textContent = vehicle.activity || '드라이브 중 🚗';
            }

            // 출발지/목적지 정보 표시
            const originEl = document.getElementById('vehiclePopupOrigin');
            const destEl = document.getElementById('vehiclePopupDest');

            if (originEl) {
                originEl.textContent = vehicle.originTypeName || '알 수 없음';
            }
            if (destEl) {
                destEl.textContent = vehicle.destTypeName || '알 수 없음';
            }

            popup.style.display = 'block';
        },

        // 차량 상태 표시 업데이트 (테스트용 상세)
        updateVehicleStatusDisplay(vehicle, statusEl) {
            if (!statusEl) return;

            let statusText = '';
            let statusClass = 'moving';

            const speed = vehicle.currentSpeed.toFixed(2);
            const targetSpeed = vehicle.targetSpeed.toFixed(2);
            const progress = (vehicle.progress * 100).toFixed(0);

            if (vehicle.stopReason === 'signal') {
                const signalKey = `${vehicle.targetTile.x},${vehicle.targetTile.y}`;
                const dir = this.getDirection(vehicle.currentTile, vehicle.targetTile);
                statusText = `신호대기 | 타일(${vehicle.targetTile.x},${vehicle.targetTile.y}) | 방향:${dir} | prog:${progress}%`;
                statusClass = 'signal';
            } else if (vehicle.stopReason === 'vehicle') {
                const dist = this.getDistanceToVehicleAhead(vehicle);
                statusText = `전방차량 | 거리:${dist.toFixed(2)} | 속도:${speed}/${targetSpeed}`;
                statusClass = 'vehicle';
            } else if (vehicle.currentSpeed < 0.05) {
                statusText = `정차 | 속도:${speed} | target:${targetSpeed}`;
                statusClass = 'vehicle';
            } else {
                statusText = `주행 | 속도:${speed}/${targetSpeed} | prog:${progress}%`;
                statusClass = 'moving';
            }

            statusEl.textContent = statusText;
            statusEl.className = 'vehicle-popup-value vehicle-status ' + statusClass;
        },

        // 차량 정보 팝업 숨기기
        hideVehiclePopup() {
            const popup = document.getElementById('vehiclePopup');
            if (popup) popup.style.display = 'none';
        },

        // 차량 팝업 위치 업데이트
        updateVehiclePopupPosition() {
            if (!this.selectedVehicle || !this.selectedVehicle.isActive) return;

            const popup = document.getElementById('vehiclePopup');
            if (!popup || popup.style.display === 'none') return;

            const pos = this.selectedVehicle.position.clone();
            pos.y += 0.3;

            const screenPos = pos.project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

            popup.style.left = (x + 20) + 'px';
            popup.style.top = (y - 50) + 'px';

            // 속도 실시간 업데이트
            const speedKmh = Math.round(this.selectedVehicle.currentSpeed * 50);
            const speedEl = document.getElementById('vehiclePopupSpeed');
            if (speedEl) speedEl.textContent = speedKmh + ' km/h';

            // 진행률 실시간 업데이트
            const vehicle = this.selectedVehicle;
            const pathLength = vehicle.path ? vehicle.path.length : 0;
            const progress = vehicle.pathIndex ? Math.round((vehicle.pathIndex / pathLength) * 100) : 0;
            const progressEl = document.getElementById('vehiclePopupProgress');
            const progressTextEl = document.getElementById('vehiclePopupProgressText');
            if (progressEl) progressEl.style.width = progress + '%';
            if (progressTextEl) progressTextEl.textContent = progress + '%';
        }
    };

    // ===== 개발자 테스트 패널 (통합) =====
    const devPanelEl = document.createElement('div');
    devPanelEl.id = 'devPanel';
    devPanelEl.style.cssText = `
        position: fixed;
        top: 50px;
        right: 10px;
        background: rgba(15, 15, 20, 0.95);
        color: #fff;
        font-family: 'Segoe UI', sans-serif;
        font-size: 12px;
        padding: 0;
        border-radius: 8px;
        z-index: 1001;
        min-width: 280px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        border: 1px solid rgba(255,255,255,0.1);
        display: flex;
        flex-direction: column;
        max-height: calc(100vh - 160px);
        overflow: hidden;
    `;
    devPanelEl.innerHTML = `
        <div id="devPanelHeader" style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: linear-gradient(180deg, #2a2a35, #1a1a25);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            cursor: move;
            user-select: none;
        ">
            <span style="font-weight: 600; color: #4ade80;">🛠️ Developer Panel</span>
            <button id="devPanelToggle" style="
                background: none;
                border: none;
                color: #888;
                font-size: 16px;
                cursor: pointer;
                padding: 0 4px;
            ">+</button>
        </div>
        <div id="devPanelContent" style="
            padding: 10px;
            display: none;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        ">
            <!-- Traffic System Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #60a5fa; margin-bottom: 6px; font-size: 11px;">🚗 TRAFFIC SYSTEM</div>
                <div id="trafficDebugContent" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #4ade80;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                    margin-bottom: 6px;
                ">Initializing...</div>
                <div style="display: flex; gap: 4px; flex-wrap: wrap; align-items: center;">
                    <button id="devBtnDeleteAllVehicles" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #ef4444, #b91c1c);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🗑️ 모든 차량 삭제</button>
                    <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; color: #aaa;">
                        <input type="checkbox" id="devChkVehicleSpawn" checked style="
                            width: 14px;
                            height: 14px;
                            cursor: pointer;
                        ">
                        <span>스폰 ON</span>
                    </label>
                </div>
            </div>

            <!-- Fire System Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #f97316; margin-bottom: 6px; font-size: 11px;">🔥 FIRE SYSTEM</div>
                <div id="fireDebugContent" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #fbbf24;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                    margin-bottom: 6px;
                ">Active Fires: 0</div>
                <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                    <button id="devBtnStartFire" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #ef4444, #b91c1c);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🔥 선택 건물 화재</button>
                    <button id="devBtnExtinguishAll" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #3b82f6, #1d4ed8);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">💧 전체 진압</button>
                </div>
            </div>

            <!-- Crime System Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #3b82f6; margin-bottom: 6px; font-size: 11px;">🚔 CRIME SYSTEM</div>
                <div id="crimeDebugContent" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #60a5fa;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                    margin-bottom: 6px;
                ">Active Crimes: 0</div>
                <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                    <button id="devBtnStartCrime" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #3b82f6, #1d4ed8);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🚨 선택 건물 강도</button>
                    <button id="devBtnResolveAll" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #22c55e, #16a34a);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">✅ 전체 해결</button>
                </div>
            </div>

            <!-- Medical System Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #ec4899; margin-bottom: 6px; font-size: 11px;">🏥 MEDICAL SYSTEM</div>
                <div id="medicalDebugContent" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #f472b6;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                    margin-bottom: 6px;
                ">Active Emergencies: 0</div>
                <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                    <button id="devBtnStartMedical" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #ec4899, #be185d);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">💔 선택 건물 환자</button>
                    <button id="devBtnResolveAllMedical" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #22c55e, #16a34a);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">✅ 전체 해결</button>
                </div>
            </div>

            <!-- Time Control Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #fbbf24; margin-bottom: 6px; font-size: 11px;">⏰ TIME CONTROL</div>
                <div style="display: flex; gap: 4px; margin-bottom: 6px;">
                    <button id="devBtnDay" style="
                        flex: 1;
                        padding: 5px 8px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #fbbf24, #d97706);
                        color: #000;
                        font-size: 11px;
                        font-weight: 500;
                    ">☀️ 낮</button>
                    <button id="devBtnNight" style="
                        flex: 1;
                        padding: 5px 8px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #3b4a6a, #1e293b);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🌙 밤</button>
                </div>
                <div style="display: flex; gap: 4px; margin-bottom: 8px;">
                    <button id="devBtnSunrise" style="
                        flex: 1;
                        padding: 5px 8px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #fb923c, #ea580c);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🌅 일출</button>
                    <button id="devBtnSunset" style="
                        flex: 1;
                        padding: 5px 8px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #f87171, #dc2626);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🌇 일몰</button>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input id="devTimeSlider" type="range" min="0" max="24" step="0.5" value="12" style="
                        flex: 1;
                        height: 4px;
                        -webkit-appearance: none;
                        background: linear-gradient(90deg, #1e293b 0%, #fbbf24 50%, #1e293b 100%);
                        border-radius: 2px;
                        cursor: pointer;
                    ">
                    <span id="devTimeDisplay" style="
                        min-width: 45px;
                        font-family: monospace;
                        font-size: 11px;
                        color: #fbbf24;
                    ">12:00</span>
                </div>
            </div>

            <!-- Selected Building Info -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #a78bfa; margin-bottom: 6px; font-size: 11px;">🏠 SELECTED BUILDING</div>
                <div id="devSelectedBuilding" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #c4b5fd;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                ">None selected</div>
            </div>

            <!-- Mountain Background Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #a78bfa; margin-bottom: 6px; font-size: 11px;">⛰️ MOUNTAIN BACKGROUND</div>
                <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px;">
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>Scale</span>
                            <span id="mountainScaleValue" style="font-family: monospace; color: #a78bfa;">1.0</span>
                        </label>
                        <input type="range" id="mountainScaleSlider" min="0.1" max="100" step="0.1" value="1" style="width: 100%; cursor: pointer;">
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>Height (Y)</span>
                            <span id="mountainHeightValue" style="font-family: monospace; color: #a78bfa;">0</span>
                        </label>
                        <input type="range" id="mountainHeightSlider" min="-50" max="50" step="0.5" value="0" style="width: 100%; cursor: pointer;">
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>Position X</span>
                            <span id="mountainPosXValue" style="font-family: monospace; color: #a78bfa;">0</span>
                        </label>
                        <input type="range" id="mountainPosXSlider" min="-100" max="100" step="1" value="0" style="width: 100%; cursor: pointer;">
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>Position Z</span>
                            <span id="mountainPosZValue" style="font-family: monospace; color: #a78bfa;">0</span>
                        </label>
                        <input type="range" id="mountainPosZSlider" min="-100" max="100" step="1" value="0" style="width: 100%; cursor: pointer;">
                    </div>
                    <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                        <button id="devBtnMountainReset" style="
                            padding: 5px 10px;
                            cursor: pointer;
                            border: none;
                            border-radius: 4px;
                            background: linear-gradient(180deg, #6366f1, #4f46e5);
                            color: #fff;
                            font-size: 11px;
                            font-weight: 500;
                        ">🔄 Reset</button>
                        <button id="devBtnMountainLog" style="
                            padding: 5px 10px;
                            cursor: pointer;
                            border: none;
                            border-radius: 4px;
                            background: linear-gradient(180deg, #22c55e, #16a34a);
                            color: #fff;
                            font-size: 11px;
                            font-weight: 500;
                        ">📋 Log Values</button>
                    </div>
                </div>
            </div>

            <!-- Performance Monitor Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #10b981; margin-bottom: 6px; font-size: 11px;">📊 PERFORMANCE</div>
                <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px;">
                    <!-- FPS Graph -->
                    <div style="margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 10px; color: #4ade80;">🖥️ CPU (FPS)</span>
                            <span id="perfFpsValue" style="font-family: monospace; font-size: 10px; color: #4ade80;">-- fps</span>
                        </div>
                        <canvas id="perfFpsGraph" width="240" height="40" style="width: 100%; height: 40px; background: rgba(0,0,0,0.4); border-radius: 3px;"></canvas>
                    </div>
                    <!-- Memory Graph -->
                    <div style="margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 10px; color: #60a5fa;">💾 RAM (MB)</span>
                            <span id="perfMemValue" style="font-family: monospace; font-size: 10px; color: #60a5fa;">-- MB</span>
                        </div>
                        <canvas id="perfMemGraph" width="240" height="40" style="width: 100%; height: 40px; background: rgba(0,0,0,0.4); border-radius: 3px;"></canvas>
                    </div>
                    <!-- GPU Graph -->
                    <div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 10px; color: #f472b6;">🎮 GPU (Draws)</span>
                            <span id="perfGpuValue" style="font-family: monospace; font-size: 10px; color: #f472b6;">-- calls</span>
                        </div>
                        <canvas id="perfGpuGraph" width="240" height="40" style="width: 100%; height: 40px; background: rgba(0,0,0,0.4); border-radius: 3px;"></canvas>
                    </div>
                    <!-- GPU Details -->
                    <div id="perfGpuDetails" style="
                        margin-top: 8px;
                        font-family: monospace;
                        font-size: 9px;
                        color: #888;
                        line-height: 1.4;
                    ">Triangles: -- | Textures: --</div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(devPanelEl);

    // Performance Monitor 초기화
    const perfMonitor = {
        // 데이터 히스토리 (최근 60개 샘플)
        fpsHistory: [],
        memHistory: [],
        gpuHistory: [],
        maxSamples: 60,

        // FPS 계산용
        lastTime: performance.now(),
        frameCount: 0,
        currentFps: 0,

        // GPU 통계 캐시 (렌더링 직후 저장됨)
        cachedDrawCalls: 0,
        cachedTriangles: 0,
        cachedTextures: 0,

        // 그래프 캔버스
        fpsCanvas: null,
        memCanvas: null,
        gpuCanvas: null,
        fpsCtx: null,
        memCtx: null,
        gpuCtx: null,

        init() {
            this.fpsCanvas = document.getElementById('perfFpsGraph');
            this.memCanvas = document.getElementById('perfMemGraph');
            this.gpuCanvas = document.getElementById('perfGpuGraph');

            if (this.fpsCanvas) this.fpsCtx = this.fpsCanvas.getContext('2d');
            if (this.memCanvas) this.memCtx = this.memCanvas.getContext('2d');
            if (this.gpuCanvas) this.gpuCtx = this.gpuCanvas.getContext('2d');

            // 히스토리 초기화
            for (let i = 0; i < this.maxSamples; i++) {
                this.fpsHistory.push(0);
                this.memHistory.push(0);
                this.gpuHistory.push(0);
            }
        },

        // 프레임마다 호출 (FPS 계산)
        tick() {
            this.frameCount++;
            const now = performance.now();
            const elapsed = now - this.lastTime;

            if (elapsed >= 1000) {
                this.currentFps = Math.round((this.frameCount * 1000) / elapsed);
                this.frameCount = 0;
                this.lastTime = now;

                // 히스토리 업데이트
                this.fpsHistory.push(this.currentFps);
                if (this.fpsHistory.length > this.maxSamples) {
                    this.fpsHistory.shift();
                }
            }
        },

        // 렌더링 직후 GPU 통계 캡처 (renderer.info는 렌더 후 리셋됨)
        captureGpuStats() {
            if (renderer && renderer.info) {
                this.cachedDrawCalls = renderer.info.render.calls || 0;
                this.cachedTriangles = renderer.info.render.triangles || 0;
                this.cachedTextures = renderer.info.memory.textures || 0;
            }
        },

        // 1초마다 호출 (메모리, GPU 업데이트)
        update() {
            // Memory (Chrome only)
            let memMB = 0;
            if (performance.memory) {
                memMB = Math.round(performance.memory.usedJSHeapSize / (1024 * 1024));
            }
            this.memHistory.push(memMB);
            if (this.memHistory.length > this.maxSamples) {
                this.memHistory.shift();
            }

            // GPU (캐시된 값 사용 - 렌더링 직후 captureGpuStats()에서 저장됨)
            const drawCalls = this.cachedDrawCalls;
            const triangles = this.cachedTriangles;
            const textures = this.cachedTextures;
            this.gpuHistory.push(drawCalls);
            if (this.gpuHistory.length > this.maxSamples) {
                this.gpuHistory.shift();
            }

            // UI 업데이트
            const fpsVal = document.getElementById('perfFpsValue');
            const memVal = document.getElementById('perfMemValue');
            const gpuVal = document.getElementById('perfGpuValue');
            const gpuDetails = document.getElementById('perfGpuDetails');

            if (fpsVal) fpsVal.textContent = `${this.currentFps} fps`;
            if (memVal) memVal.textContent = `${memMB} MB`;
            if (gpuVal) gpuVal.textContent = `${drawCalls} calls`;
            if (gpuDetails) {
                gpuDetails.textContent = `Triangles: ${(triangles/1000).toFixed(1)}K | Textures: ${textures}`;
            }

            // 그래프 그리기
            this.drawGraph(this.fpsCtx, this.fpsHistory, '#4ade80', 120);  // max 120 fps
            this.drawGraph(this.memCtx, this.memHistory, '#60a5fa', 500);  // max 500 MB
            this.drawGraph(this.gpuCtx, this.gpuHistory, '#f472b6', 1000); // max 1000 calls
        },

        drawGraph(ctx, data, color, maxValue) {
            if (!ctx) return;

            const canvas = ctx.canvas;
            const w = canvas.width;
            const h = canvas.height;

            // 클리어
            ctx.clearRect(0, 0, w, h);

            // 그리드 라인
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 4; i++) {
                const y = (h / 4) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // 데이터 라인
            if (data.length < 2) return;

            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();

            const step = w / (this.maxSamples - 1);
            for (let i = 0; i < data.length; i++) {
                const x = i * step;
                const normalizedValue = Math.min(data[i] / maxValue, 1);
                const y = h - (normalizedValue * (h - 4)) - 2;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // 영역 채우기
            ctx.lineTo((data.length - 1) * step, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fillStyle = color.replace(')', ', 0.2)').replace('rgb', 'rgba');
            ctx.fill();
        }
    };

    // 초기화
    perfMonitor.init();

    // 패널 접기/펼치기
    let devPanelCollapsed = true;
    document.getElementById('devPanelToggle').addEventListener('click', () => {
        devPanelCollapsed = !devPanelCollapsed;
        document.getElementById('devPanelContent').style.display = devPanelCollapsed ? 'none' : 'flex';
        document.getElementById('devPanelToggle').textContent = devPanelCollapsed ? '+' : '−';
    });

    // 패널 드래그 이동
    let isDraggingPanel = false;
    let panelDragOffset = { x: 0, y: 0 };
    const devPanelHeader = document.getElementById('devPanelHeader');

    devPanelHeader.addEventListener('mousedown', (e) => {
        isDraggingPanel = true;
        const rect = devPanelEl.getBoundingClientRect();
        panelDragOffset.x = e.clientX - rect.left;
        panelDragOffset.y = e.clientY - rect.top;
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDraggingPanel) return;
        devPanelEl.style.left = (e.clientX - panelDragOffset.x) + 'px';
        devPanelEl.style.top = (e.clientY - panelDragOffset.y) + 'px';
        devPanelEl.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
        isDraggingPanel = false;
    });

    // 시간 조절 버튼 이벤트
    document.getElementById('devBtnDay').addEventListener('click', () => {
        timeState.gameTime = 12 * 3600;
        updateEnvironment();
    });
    document.getElementById('devBtnNight').addEventListener('click', () => {
        timeState.gameTime = 22 * 3600;
        updateEnvironment();
    });
    document.getElementById('devBtnSunrise').addEventListener('click', () => {
        timeState.gameTime = 6 * 3600;
        updateEnvironment();
    });
    document.getElementById('devBtnSunset').addEventListener('click', () => {
        timeState.gameTime = 18.5 * 3600;
        updateEnvironment();
    });

    // 시간 슬라이더
    const devTimeSlider = document.getElementById('devTimeSlider');
    const devTimeDisplay = document.getElementById('devTimeDisplay');
    devTimeSlider.addEventListener('input', () => {
        const hour = parseFloat(devTimeSlider.value);
        timeState.gameTime = hour * 3600;
        const h = Math.floor(hour);
        const m = Math.floor((hour - h) * 60);
        devTimeDisplay.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
        updateEnvironment();
    });

    // 차량 스폰 온오프 상태
    let vehicleSpawnEnabled = true;

    // 모든 차량 삭제 버튼 이벤트
    document.getElementById('devBtnDeleteAllVehicles').addEventListener('click', () => {
        if (trafficManager.initialized) {
            const count = trafficManager.vehicles.length;
            trafficManager.removeAllVehicles();
            toast({ title: '차량 삭제', desc: `${count}대의 차량을 삭제했습니다.`, success: true });
        } else {
            toast({ title: '트래픽 미초기화', desc: '트래픽 시스템이 아직 초기화되지 않았습니다.' });
        }
    });

    // 차량 스폰 온오프 체크박스 이벤트
    document.getElementById('devChkVehicleSpawn').addEventListener('change', (e) => {
        vehicleSpawnEnabled = e.target.checked;
        const label = e.target.nextElementSibling;
        label.textContent = vehicleSpawnEnabled ? '스폰 ON' : '스폰 OFF';
        label.style.color = vehicleSpawnEnabled ? '#4ade80' : '#ef4444';
        toast({ title: vehicleSpawnEnabled ? '스폰 활성화' : '스폰 비활성화', desc: vehicleSpawnEnabled ? '차량이 자동으로 생성됩니다.' : '차량이 더 이상 생성되지 않습니다.', success: vehicleSpawnEnabled });
    });

    // 화재 버튼 이벤트
    document.getElementById('devBtnStartFire').addEventListener('click', () => {
        if (selectedBuilding && selectedBuilding.userData) {
            const x = selectedBuilding.userData.tileX;
            const y = selectedBuilding.userData.tileY;
            const key = `${x},${y}`;
            if (!burningBuildings.has(key)) {
                startFire(x, y);
                toast({ title: '화재 발생', desc: `(${x}, ${y}) 건물에 화재가 발생했습니다.`, success: true });
            } else {
                toast({ title: '이미 화재 중', desc: '해당 건물은 이미 화재 중입니다.' });
            }
        } else {
            toast({ title: '건물 선택 필요', desc: '먼저 건물을 클릭하여 선택하세요.' });
        }
    });

    document.getElementById('devBtnExtinguishAll').addEventListener('click', () => {
        const keys = [...burningBuildings.keys()];
        keys.forEach(key => extinguishFire(key, true));
        toast({ title: '전체 진압', desc: `${keys.length}건의 화재를 진압했습니다.`, success: true });
    });

    // 강도 사건 버튼 이벤트
    document.getElementById('devBtnStartCrime').addEventListener('click', () => {
        if (selectedBuilding && selectedBuilding.userData) {
            const x = selectedBuilding.userData.tileX;
            const y = selectedBuilding.userData.tileY;
            const key = `${x},${y}`;
            const zoneType = selectedBuilding.userData.zoneType || '';
            const isCommercial = zoneType.includes('commercial');
            if (!activeCrimes.has(key)) {
                startCrime(x, y, isCommercial);
                toast({ title: '강도 사건 발생', desc: `(${x}, ${y}) 건물에서 강도 사건이 발생했습니다.`, success: true });
            } else {
                toast({ title: '이미 사건 진행 중', desc: '해당 건물에서 이미 사건이 진행 중입니다.' });
            }
        } else {
            toast({ title: '건물 선택 필요', desc: '먼저 건물을 클릭하여 선택하세요.' });
        }
    });

    document.getElementById('devBtnResolveAll').addEventListener('click', () => {
        const keys = [...activeCrimes.keys()];
        keys.forEach(key => resolveCrime(key, true));
        toast({ title: '전체 해결', desc: `${keys.length}건의 사건을 해결했습니다.`, success: true });
    });

    // 의료 응급 버튼 이벤트
    document.getElementById('devBtnStartMedical').addEventListener('click', () => {
        if (selectedBuilding && selectedBuilding.userData) {
            const x = selectedBuilding.userData.tileX;
            const y = selectedBuilding.userData.tileY;
            const key = `${x},${y}`;
            if (!activeMedicalEmergencies.has(key)) {
                startMedicalEmergency(x, y);
                toast({ title: '환자 발생', desc: `(${x}, ${y}) 건물에서 환자가 발생했습니다.`, success: true });
            } else {
                toast({ title: '이미 응급 상황', desc: '해당 건물에서 이미 응급 상황이 진행 중입니다.' });
            }
        } else {
            toast({ title: '건물 선택 필요', desc: '먼저 건물을 클릭하여 선택하세요.' });
        }
    });

    document.getElementById('devBtnResolveAllMedical').addEventListener('click', () => {
        const keys = [...activeMedicalEmergencies.keys()];
        keys.forEach(key => resolveMedicalEmergency(key, true));
        toast({ title: '전체 해결', desc: `${keys.length}건의 응급 상황을 해결했습니다.`, success: true });
    });

    // ========== Mountain Background 컨트롤 ==========
    document.getElementById('mountainScaleSlider').addEventListener('input', (e) => {
        if (mountainModel) {
            const scale = parseFloat(e.target.value);
            mountainModel.scale.setScalar(scale);
            updateMountainSliderLabels();
        }
    });

    document.getElementById('mountainHeightSlider').addEventListener('input', (e) => {
        if (mountainModel) {
            mountainModel.position.y = parseFloat(e.target.value);
            updateMountainSliderLabels();
        }
    });

    document.getElementById('mountainPosXSlider').addEventListener('input', (e) => {
        if (mountainModel) {
            mountainModel.position.x = parseFloat(e.target.value);
            updateMountainSliderLabels();
        }
    });

    document.getElementById('mountainPosZSlider').addEventListener('input', (e) => {
        if (mountainModel) {
            mountainModel.position.z = parseFloat(e.target.value);
            updateMountainSliderLabels();
        }
    });

    document.getElementById('devBtnMountainReset').addEventListener('click', () => {
        if (mountainModel) {
            mountainModel.scale.setScalar(mountainDefaults.scale);
            mountainModel.position.set(mountainDefaults.x, mountainDefaults.y, mountainDefaults.z);
            document.getElementById('mountainScaleSlider').value = mountainDefaults.scale;
            document.getElementById('mountainHeightSlider').value = mountainDefaults.y;
            document.getElementById('mountainPosXSlider').value = mountainDefaults.x;
            document.getElementById('mountainPosZSlider').value = mountainDefaults.z;
            updateMountainSliderLabels();
            toast({ title: '⛰️ Mountain Reset', desc: '기본값으로 초기화되었습니다.', success: true });
        }
    });

    document.getElementById('devBtnMountainLog').addEventListener('click', () => {
        if (mountainModel) {
            const scale = mountainModel.scale.x;
            const pos = mountainModel.position;
            console.log(`[Mountain] Scale: ${scale.toFixed(2)}, Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
            toast({
                title: '⛰️ Mountain Values',
                desc: `Scale: ${scale.toFixed(2)}, X: ${pos.x.toFixed(1)}, Y: ${pos.y.toFixed(1)}, Z: ${pos.z.toFixed(1)}`,
                success: true,
                ms: 5000
            });
        }
    });

    // 개발자 패널 업데이트 함수
    function updateDevPanel() {
        // Traffic System 정보
        const trafficContent = document.getElementById('trafficDebugContent');
        if (trafficManager.initialized) {
            const s = trafficManager.getStats();
            trafficContent.innerHTML = `
                Vehicles: ${s.activeVehicles}/${s.maxVehicles}<br>
                Roads: ${s.roadNodes} | Signals: ${s.signals}<br>
                Buildings: R${s.residential} C${s.commercial} I${s.industrial}<br>
                PathCache: ${s.pathCacheSize}
            `;
        } else {
            trafficContent.textContent = 'Initializing...';
        }

        // Fire System 정보
        const fireContent = document.getElementById('fireDebugContent');
        const fireCount = burningBuildings.size;
        const firetruckCount = dispatchedFiretrucks.size;
        fireContent.innerHTML = `
            Active Fires: ${fireCount}<br>
            Dispatched Trucks: ${firetruckCount}
        `;

        // Crime System 정보
        const crimeContent = document.getElementById('crimeDebugContent');
        const crimeCount = activeCrimes.size;
        const policeCarCount = dispatchedPoliceCars.size;
        const totalPrisoners = getTotalPrisoners();
        const totalCapacity = getTotalPrisonCapacity();
        crimeContent.innerHTML = `
            Active Crimes: ${crimeCount}<br>
            Dispatched Police: ${policeCarCount}<br>
            Prisoners: ${totalPrisoners}/${totalCapacity}
        `;

        // Medical System 정보
        const medicalContent = document.getElementById('medicalDebugContent');
        const medicalCount = activeMedicalEmergencies ? activeMedicalEmergencies.size : 0;
        const ambulanceCount = dispatchedAmbulances ? dispatchedAmbulances.size : 0;
        const totalPatients = getTotalPatients ? getTotalPatients() : 0;
        const totalBeds = getTotalHospitalCapacity ? getTotalHospitalCapacity() : 0;
        medicalContent.innerHTML = `
            Active Emergencies: ${medicalCount}<br>
            Dispatched Ambulances: ${ambulanceCount}<br>
            Patients: ${totalPatients}/${totalBeds}
        `;

        // 선택된 건물 정보
        const selectedContent = document.getElementById('devSelectedBuilding');
        if (selectedBuilding && selectedBuilding.userData) {
            const x = selectedBuilding.userData.tileX;
            const y = selectedBuilding.userData.tileY;
            const key = `${x},${y}`;
            const isBurning = burningBuildings.has(key);
            const hasCrime = activeCrimes.has(key);
            const hasMedical = activeMedicalEmergencies && activeMedicalEmergencies.has(key);
            const zoneType = selectedBuilding.userData.zoneType || 'Unknown';
            const isAbandoned = selectedBuilding.userData.isAbandoned || false;

            let statusText = '✅ 정상';
            if (isAbandoned) statusText = '🏚️ 폐건물';
            else if (isBurning) statusText = '🔥 화재 중';
            else if (hasCrime) statusText = '🚨 강도 중';
            else if (hasMedical) statusText = '💔 환자 발생';

            selectedContent.innerHTML = `
                Position: (${x}, ${y})<br>
                Type: ${zoneType}<br>
                Status: ${statusText}
            `;
        } else {
            selectedContent.textContent = 'None selected';
        }

        // 시간 슬라이더 동기화
        const currentHour = (timeState.gameTime / 3600) % 24;
        devTimeSlider.value = currentHour;
        const h = Math.floor(currentHour);
        const m = Math.floor((currentHour - h) * 60);
        devTimeDisplay.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;

        // 퍼포먼스 모니터 업데이트
        if (perfMonitor) perfMonitor.update();
    }

    // 2초마다 업데이트 (최적화)
    setInterval(updateDevPanel, 2000);

    // 차량 정보 팝업 HTML 생성
    const vehiclePopupEl = document.createElement('div');
    vehiclePopupEl.id = 'vehiclePopup';
    vehiclePopupEl.innerHTML = `
        <div class="vehicle-popup-header">
            <span class="vehicle-popup-icon">🚗</span>
            <span id="vehiclePopupTitle" class="vehicle-popup-title">시민</span>
            <div class="vehicle-popup-actions">
                <button id="vehicleFollowBtn" class="vehicle-follow-btn" title="따라가기">📍</button>
                <button id="vehiclePopupClose" class="vehicle-popup-close">✕</button>
            </div>
        </div>
        <div class="vehicle-popup-body">
            <div class="vehicle-popup-row activity-row">
                <span id="vehiclePopupActivity" class="vehicle-popup-activity">드라이브 중 🚗</span>
            </div>
            <div class="vehicle-popup-row">
                <span class="vehicle-popup-label">출발:</span>
                <span id="vehiclePopupOrigin" class="vehicle-popup-value origin-info">주거지</span>
            </div>
            <div class="vehicle-popup-row">
                <span class="vehicle-popup-label">도착:</span>
                <span id="vehiclePopupDest" class="vehicle-popup-value dest-info">상업지구</span>
            </div>
            <div class="vehicle-popup-row">
                <span class="vehicle-popup-label">속도:</span>
                <span id="vehiclePopupSpeed" class="vehicle-popup-value vehicle-speed">0 km/h</span>
            </div>
            <div class="vehicle-popup-row">
                <span class="vehicle-popup-label">진행:</span>
                <div class="vehicle-progress-bar">
                    <div id="vehiclePopupProgress" class="vehicle-progress-fill"></div>
                </div>
                <span id="vehiclePopupProgressText" class="vehicle-progress-text">0%</span>
            </div>
        </div>
    `;
    vehiclePopupEl.style.cssText = `
        position: fixed;
        display: none;
        background: rgba(30, 40, 60, 0.95);
        border: 1px solid #4a9eff;
        border-radius: 8px;
        padding: 0;
        min-width: 220px;
        z-index: 1001;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        font-family: 'Segoe UI', sans-serif;
        color: #fff;
    `;
    document.body.appendChild(vehiclePopupEl);

    // 차량 팝업 스타일 추가
    const vehiclePopupStyle = document.createElement('style');
    vehiclePopupStyle.textContent = `
        .vehicle-popup-header {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: rgba(74, 158, 255, 0.2);
            border-bottom: 1px solid rgba(74, 158, 255, 0.3);
            border-radius: 8px 8px 0 0;
        }
        .vehicle-popup-icon {
            font-size: 20px;
            margin-right: 8px;
        }
        .vehicle-popup-title {
            flex: 1;
            font-weight: bold;
            font-size: 14px;
        }
        .vehicle-popup-actions {
            display: flex;
            gap: 5px;
        }
        .vehicle-follow-btn {
            background: #4a9eff;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .vehicle-follow-btn:hover {
            background: #3a8eef;
        }
        .vehicle-follow-btn.active {
            background: #ff9500;
        }
        .vehicle-popup-close {
            background: transparent;
            border: none;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            padding: 2px 6px;
        }
        .vehicle-popup-close:hover {
            color: #fff;
        }
        .vehicle-popup-body {
            padding: 10px 12px;
        }
        .vehicle-popup-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 12px;
        }
        .vehicle-popup-label {
            color: #8899aa;
            min-width: 45px;
        }
        .vehicle-popup-value {
            color: #fff;
        }
        .vehicle-speed {
            color: #4aff4a;
            font-weight: bold;
        }
        .vehicle-status {
            font-weight: bold;
        }
        .vehicle-status.moving {
            color: #4aff4a;
        }
        .vehicle-status.signal {
            color: #ff4a4a;
        }
        .vehicle-status.vehicle {
            color: #ffa64a;
        }
        .route-info {
            color: #aabbcc;
            font-size: 11px;
        }
        .vehicle-progress-bar {
            flex: 1;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin: 0 8px;
            overflow: hidden;
        }
        .vehicle-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #4aff9e);
            border-radius: 4px;
            transition: width 0.3s;
        }
        .vehicle-progress-text {
            color: #4a9eff;
            font-size: 11px;
            min-width: 35px;
            text-align: right;
        }
    `;
    document.head.appendChild(vehiclePopupStyle);

    // 차량 팝업 이벤트
    document.getElementById('vehiclePopupClose').addEventListener('click', () => {
        trafficManager.deselectVehicle();
    });

    document.getElementById('vehicleFollowBtn').addEventListener('click', (e) => {
        const btn = e.target;
        if (trafficManager.followingVehicle) {
            trafficManager.stopFollowing();
            btn.classList.remove('active');
            btn.textContent = '📍';
        } else if (trafficManager.selectedVehicle) {
            trafficManager.startFollowing(trafficManager.selectedVehicle);
            btn.classList.add('active');
            btn.textContent = '⏹';
        }
    });

    // 차량 클릭 감지용 레이캐스터
    const vehicleRaycaster = new THREE.Raycaster();
    const vehicleMouse = new THREE.Vector2();

    // 차량 클릭 감지
    renderer.domElement.addEventListener('click', (e) => {
        if (currentMode !== MODE.CAMERA) return;

        vehicleMouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
        vehicleMouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;

        vehicleRaycaster.setFromCamera(vehicleMouse, camera);

        // 활성화된 차량의 메쉬만 체크
        const vehicleMeshes = trafficManager.vehicles
            .filter(v => v.isActive && v.mesh)
            .map(v => v.mesh);

        const intersects = vehicleRaycaster.intersectObjects(vehicleMeshes, true);

        if (intersects.length > 0) {
            // 클릭된 메쉬의 부모(차량 그룹) 찾기
            let clickedMesh = intersects[0].object;
            while (clickedMesh.parent && !trafficManager.vehicleGroup.children.includes(clickedMesh)) {
                clickedMesh = clickedMesh.parent;
            }

            // 해당 메쉬를 가진 차량 찾기
            const clickedVehicle = trafficManager.vehicles.find(v => v.mesh === clickedMesh);
            if (clickedVehicle) {
                trafficManager.selectVehicle(clickedVehicle);
                e.stopPropagation();
                return;
            }
        }
    });

    /* =========================================================
     * MODE SYSTEM
     * ========================================================= */
    const MODE = {
        CAMERA: "camera",
        BUILD: "build",
        BUILD_4LANE: "build_4lane",  // 4차로 도로 설치 모드
        WATER: "water",  // 수로 설치 모드
        DEMOLISH: "demolish",  // 도로/수로 철거 모드
        ZONE_RESIDENTIAL: "zone_residential",
        ZONE_COMMERCIAL: "zone_commercial",
        ZONE_INDUSTRIAL: "zone_industrial",
        ZONE_DELETE: "zone_delete",
        LAND_VALUE_VIEW: "land_value_view",  // 땅값 확인 모드
        POPULATION_VIEW: "population_view",  // 인구 확인 모드
        TRAFFIC_VIEW: "traffic_view",  // 교통량 확인 모드
        // 공공시설 설치 모드
        PLACE_SCHOOL: "place_school",
        PLACE_POLICE: "place_police",
        PLACE_FIRE: "place_fire",
        PLACE_PARK: "place_park",
        PLACE_HOSPITAL: "place_hospital",
        // 발전소 설치 모드
        PLACE_POWER_COAL: "place_power_coal",
        PLACE_POWER_WIND: "place_power_wind",
        PLACE_POWER_SOLAR: "place_power_solar",
        // 전력 뷰 모드
        POWER_VIEW: "power_view",
        // 풍량 뷰 모드
        WIND_VIEW: "wind_view",
        // 방파제 인접 수도 시설 설치 모드 (2x4)
        PLACE_WASTEWATER: "place_wastewater",           // 하수처리장
        PLACE_WATER_PUMP_COAST: "place_water_pump_coast", // 해안 워터펌프
        // 수도 뷰 모드
        WATER_VIEW: "water_view",
        // 방파제 설치 모드
        PLACE_BREAKWATER: "place_breakwater",
        // 하수 뷰 모드
        SEWAGE_VIEW: "sewage_view",
    };
    let currentMode = MODE.CAMERA;
    let currentZoneType = null;

    // 철거 모드 독립 토글 (다른 모드와 공존 가능)
    let isDemolishModeActive = false;

    // 철거 모드와 공존 불가능한 모드 (건물 설치 모드)
    function isExclusiveWithDemolish(mode) {
        return mode === MODE.PLACE_SCHOOL ||
               mode === MODE.PLACE_POLICE ||
               mode === MODE.PLACE_FIRE ||
               mode === MODE.PLACE_PARK ||
               mode === MODE.PLACE_HOSPITAL ||
               mode === MODE.PLACE_POWER_COAL ||
               mode === MODE.PLACE_POWER_WIND ||
               mode === MODE.PLACE_POWER_SOLAR;
    }

    // 설치 모드의 부모 모드 찾기 (설치 모드 -> 토글 모드)
    function getParentModeForPlacement(mode) {
        if (mode === MODE.PLACE_POWER_COAL || mode === MODE.PLACE_POWER_WIND || mode === MODE.PLACE_POWER_SOLAR) {
            return MODE.POWER_VIEW;  // 발전소 설치 -> 전력 뷰
        }
        // 기타 공공시설은 카메라 모드로
        return MODE.CAMERA;
    }

    // 철거 모드 토글
    function toggleDemolishMode() {
        const hint = document.getElementById('hint');
        const ghost = window.ghostMesh;  // ghost 참조

        if (isDemolishModeActive) {
            // 철거 모드 끄기
            isDemolishModeActive = false;
            if (btnDemolish) btnDemolish.classList.remove('active');
            // 현재 모드에 맞는 힌트로 복원
            updateHintForCurrentMode();
            // 회전 다시 활성화 (카메라 모드나 그래프 모드일 때만)
            const allowRotate = currentMode === MODE.CAMERA || currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW;
            controls.enableRotate = allowRotate;
            // 철거 하이라이트 제거
            clearDemolishHighlight();
            // Ctrl+철거 선택 프리뷰 제거
            ctrlDemolishSelectedRoads = [];
            clearLinePreview();
        } else {
            // 철거 모드 켜기 전에 건물 설치 모드면 부모 모드로 이동
            if (isExclusiveWithDemolish(currentMode)) {
                const parentMode = getParentModeForPlacement(currentMode);
                closeSubMenu();
                setMode(parentMode);
            }
            isDemolishModeActive = true;
            if (btnDemolish) btnDemolish.classList.add('active');
            // 철거 모드 힌트 표시
            if (hint) hint.textContent = "클릭/드래그로 도로/수로/건물 철거 (ESC로 취소)";
            if (ghost) ghost.material.color.set(0xff4444);
            // 격자 표시
            if (typeof gridHelper !== 'undefined') gridHelper.visible = true;
            // 회전 비활성화
            controls.enableRotate = false;
        }
    }

    // 현재 모드에 맞는 힌트 업데이트 (철거 모드 OFF 시 호출)
    function updateHintForCurrentMode() {
        const hint = document.getElementById('hint');
        const ghost = window.ghostMesh;
        if (!hint) return;

        if (currentMode === MODE.CAMERA) {
            hint.textContent = i18n.t('hint.camera');
            if (ghost) ghost.visible = false;
        } else if (currentMode === MODE.BUILD) {
            hint.textContent = i18n.t('hint.road');
        } else if (currentMode === MODE.BUILD_4LANE) {
            hint.textContent = "클릭으로 4차선 도로 설치 (2x2)";
            if (ghost) ghost.visible = false;  // 2x2 프리뷰 사용
        } else if (currentMode === MODE.WATER) {
            hint.textContent = "클릭/드래그로 수로 설치";
            if (ghost) ghost.material.color.set(0x4488ff);
        } else if (currentMode === MODE.ZONE_RESIDENTIAL) {
            hint.textContent = i18n.t('hint.residential');
        } else if (currentMode === MODE.ZONE_COMMERCIAL) {
            hint.textContent = i18n.t('hint.commercial');
        } else if (currentMode === MODE.ZONE_INDUSTRIAL) {
            hint.textContent = i18n.t('hint.industrial');
        } else if (currentMode === MODE.ZONE_DELETE) {
            hint.textContent = i18n.t('hint.delete');
        } else if (currentMode === MODE.POWER_VIEW) {
            hint.textContent = '전력 뷰 모드';
        }
        // 격자 가시성 업데이트
        if (typeof gridHelper !== 'undefined') {
            gridHelper.visible = (currentMode === MODE.BUILD || currentMode === MODE.BUILD_4LANE || currentMode === MODE.WATER || isPlacementMode(currentMode));
        }
    }

    // 철거 모드 강제 종료 (건물 설치 모드 진입 시 호출)
    function deactivateDemolishMode() {
        if (isDemolishModeActive) {
            isDemolishModeActive = false;
            if (btnDemolish) btnDemolish.classList.remove('active');
            // 회전 다시 활성화 (카메라 모드나 그래프 모드일 때만)
            const allowRotate = currentMode === MODE.CAMERA || currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW;
            controls.enableRotate = allowRotate;
            // 철거 하이라이트 제거
            clearDemolishHighlight();
            // Ctrl+철거 선택 프리뷰 제거
            ctrlDemolishSelectedRoads = [];
            clearLinePreview();
        }
    }

    // 구역 버튼 참조
    const btnZoneDelete = document.getElementById("btnZoneDelete");
    const btnZoneResidential = document.getElementById("btnZoneResidential");
    const btnZoneCommercial = document.getElementById("btnZoneCommercial");
    const btnZoneIndustrial = document.getElementById("btnZoneIndustrial");
    // btnWater removed - water is now in roads submenu

    function setMode(mode) {
        if (mode !== MODE.CAMERA && !MAP_CONFIG.isOwner) {
            toast({
                title: "편집 권한 없음",
                desc: "자신의 도시만 편집할 수 있습니다.",
            });
            return;
        }

        // 직선 프리뷰 제거
        clearLinePreview();

        // 프리뷰 그룹 제거 (4차선 도로 등)
        if (typeof clearPreviewGroup === 'function') {
            clearPreviewGroup();
        }

        // 이전 모드 저장 (효과 전환용)
        const prevMode = currentMode;

        // 카메라 모드로 전환 시 모든 텍스처 강제 복구
        if (mode === MODE.CAMERA) {
            // 모든 뷰 모드 머티리얼 복원
            if (typeof waterManager !== 'undefined') {
                // 수도관/아이콘 숨기기
                if (waterManager.waterPipeGroup) waterManager.waterPipeGroup.visible = false;
                if (waterManager.waterIconGroup) waterManager.waterIconGroup.visible = false;
                if (waterManager.isWaterViewActive) {
                    waterManager.restoreWaterViewMaterials();
                    waterManager.isWaterViewActive = false;
                }
            }
            // 하수관/아이콘 숨기기 (머티리얼 복원은 oceanSewageSystem이 담당)
            if (typeof sewageManager !== 'undefined') {
                if (sewageManager.sewagePipeGroup) sewageManager.sewagePipeGroup.visible = false;
                if (sewageManager.sewageIconGroup) sewageManager.sewageIconGroup.visible = false;
                sewageManager.isSewageViewActive = false;
            }
            // 전력선/아이콘 숨기기
            if (typeof powerManager !== 'undefined') {
                if (powerManager.powerLineGroup) powerManager.powerLineGroup.visible = false;
                if (powerManager.powerIconGroup) powerManager.powerIconGroup.visible = false;
                if (powerManager.isPowerViewActive) {
                    powerManager.restorePowerViewMaterials();
                    powerManager.isPowerViewActive = false;
                }
            }
            if (typeof oceanSewageSystem !== 'undefined' && oceanSewageSystem.isViewActive) {
                oceanSewageSystem.applyDataViewMaterials(false);
                oceanSewageSystem.originalMaterials.clear();
                oceanSewageSystem.isViewActive = false;
            }
            // 전역 머티리얼 복원 (안전장치)
            if (typeof restoreOriginalMaterials === 'function') {
                restoreOriginalMaterials(true);
            }
            if (typeof restoreAllBuildingOpacity === 'function') {
                restoreAllBuildingOpacity();
            }
            // 환경 효과 재적용
            if (typeof forceUpdateEnvironmentEffects === 'function') {
                forceUpdateEnvironmentEffects();
            }
            // 유틸리티 범례 강제 숨김 (전력/수도/하수)
            if (typeof hideUtilityLegend === 'function') {
                hideUtilityLegend();
            }
        }

        // 카메라 모드에서 다른 모드로 전환시 팝업/아웃라인 숨기기
        if (prevMode === MODE.CAMERA && mode !== MODE.CAMERA) {
            hideBuildingPopup();
        }

        // === ViewModeManager를 통한 통합 뷰 모드 전환 처리 ===
        // 모드별 관련 뷰 타입 매핑
        const modeToViewType = {
            [MODE.LAND_VALUE_VIEW]: 'landValue',
            [MODE.POPULATION_VIEW]: 'population',
            [MODE.TRAFFIC_VIEW]: 'traffic',
            [MODE.POWER_VIEW]: 'power',
            [MODE.WATER_VIEW]: 'water',
            [MODE.SEWAGE_VIEW]: 'sewage',
            [MODE.WIND_VIEW]: 'wind'
        };

        // 모드 그룹 정의
        const zoneRelatedModes = [MODE.ZONE_RESIDENTIAL, MODE.ZONE_COMMERCIAL, MODE.ZONE_INDUSTRIAL,
                                  MODE.ZONE_DELETE, MODE.LAND_VALUE_VIEW, MODE.POPULATION_VIEW];
        const roadRelatedModes = [MODE.BUILD, MODE.BUILD_4LANE, MODE.WATER, MODE.TRAFFIC_VIEW];
        const waterRelatedModes = [MODE.WATER_VIEW, MODE.PLACE_WATER_PUMP_COAST];
        const sewageRelatedModes = [MODE.SEWAGE_VIEW, MODE.PLACE_WASTEWATER];
        const powerRelatedModes = [MODE.POWER_VIEW, MODE.PLACE_POWER_COAL, MODE.PLACE_POWER_WIND, MODE.PLACE_POWER_SOLAR, MODE.WIND_VIEW];

        // 이전 뷰 모드에서 나갈 때 종료 처리
        const prevViewType = modeToViewType[prevMode];
        const newViewType = modeToViewType[mode];

        if (prevViewType && prevViewType !== newViewType) {
            ViewModeManager.exitViewMode(prevViewType);
        }

        // 모드 그룹 전환 시 관련 뷰 종료
        const prevIsZoneRelated = zoneRelatedModes.includes(prevMode);
        const newIsZoneRelated = zoneRelatedModes.includes(mode);
        if (prevIsZoneRelated && !newIsZoneRelated) {
            ViewModeManager.exitViewMode('landValue');
            ViewModeManager.exitViewMode('population');
        }

        const prevIsRoadRelated = roadRelatedModes.includes(prevMode);
        const newIsRoadRelated = roadRelatedModes.includes(mode);
        if (prevIsRoadRelated && !newIsRoadRelated) {
            ViewModeManager.exitViewMode('traffic');
        }

        const prevIsWaterRelated = waterRelatedModes.includes(prevMode);
        const newIsWaterRelated = waterRelatedModes.includes(mode);
        if (prevIsWaterRelated && !newIsWaterRelated) {
            ViewModeManager.exitViewMode('water');
            hideUtilityLegend();  // 수도 게이지 패널 숨기기
            // 하수 뷰도 아니면 바다 하수 시각화 숨기기
            if (!sewageRelatedModes.includes(mode)) {
                if (typeof oceanSewageSystem !== 'undefined') {
                    oceanSewageSystem.toggleView(false);
                }
            } else {
                // 수도 → 하수 전환 시 oceanSewageSystem 머티리얼 캐시 갱신
                // (수도 뷰에서 저장된 회색 머티리얼을 복원된 원본으로 업데이트)
                if (typeof oceanSewageSystem !== 'undefined' && oceanSewageSystem.isViewActive) {
                    oceanSewageSystem.originalMaterials.clear();
                    oceanSewageSystem.applyDataViewMaterials(true);
                }
            }
        }

        const prevIsSewageRelated = sewageRelatedModes.includes(prevMode);
        const newIsSewageRelated = sewageRelatedModes.includes(mode);
        if (prevIsSewageRelated && !newIsSewageRelated) {
            ViewModeManager.exitViewMode('sewage');
            hideUtilityLegend();  // 하수 게이지 패널 숨기기
            if (typeof sewageManager !== 'undefined' && sewageManager.toggleSewageView) {
                sewageManager.toggleSewageView(false);
            }
            // 수도 뷰도 아니면 바다 하수 시각화 숨기기
            if (!waterRelatedModes.includes(mode)) {
                if (typeof oceanSewageSystem !== 'undefined') {
                    oceanSewageSystem.toggleView(false);
                }
            } else {
                // 하수 → 수도 전환 시 oceanSewageSystem 머티리얼 캐시 갱신
                if (typeof oceanSewageSystem !== 'undefined' && oceanSewageSystem.isViewActive) {
                    oceanSewageSystem.originalMaterials.clear();
                    oceanSewageSystem.applyDataViewMaterials(true);
                }
            }
        }

        const prevIsPowerRelated = powerRelatedModes.includes(prevMode);
        const newIsPowerRelated = powerRelatedModes.includes(mode);
        if (prevIsPowerRelated && !newIsPowerRelated) {
            ViewModeManager.exitViewMode('power');
            ViewModeManager.exitViewMode('wind');  // 풍량 뷰도 종료
            hideUtilityLegend();  // 전력 게이지 패널 숨기기
        }

        // 건물 설치 모드에서 나갈 때 효과 복원 및 미리보기/서비스효과 숨김
        if (isPlacementMode(prevMode) && !isPlacementMode(mode)) {
            restorePlacementModeEffect();
            hideBuildingPreview();
            // 서비스 뷰 모드도 종료
            if (isServiceViewActive()) {
                exitServiceBuildingView();
            } else {
                clearServiceEffects();
            }
            costTooltip.style.display = 'none';
        }

        // 서비스 뷰가 활성화된 상태에서 비관련 모드로 전환 시 종료
        const serviceRelatedModes = [MODE.PLACE_FIRE, MODE.PLACE_POLICE, MODE.PLACE_SCHOOL,
                                     MODE.PLACE_HOSPITAL, MODE.PLACE_PARK, MODE.CAMERA];
        if (isServiceViewActive() && !serviceRelatedModes.includes(mode)) {
            exitServiceBuildingView();
        }

        // 건물 설치 모드 진입 시 철거 모드 비활성화 (상호 배제)
        if (isPlacementMode(mode)) {
            deactivateDemolishMode();
        }

        currentMode = mode;

        // 건설 모드일 때 카메라 회전만 비활성화 (좌클릭 드래그 충돌 방지)
        // 우클릭 이동은 활성화 유지
        // 철거 모드는 독립 토글이므로 isDemolishModeActive 사용
        const isConstructionMode = mode === MODE.BUILD || mode === MODE.BUILD_4LANE || mode === MODE.WATER ||
                                   isDemolishModeActive || mode === MODE.ZONE_DELETE ||
                                   isZoneMode() || isPlacementMode(mode);
        controls.enableRotate = !isConstructionMode;

        // Clear all active states first
        clearToolButtonActive();

        // Set active state for current mode (bottom bar buttons)
        btnCam.classList.toggle("active", mode === MODE.CAMERA);
        if (btnBuild) btnBuild.classList.toggle("active", mode === MODE.BUILD || mode === MODE.BUILD_4LANE);
        // 철거 버튼은 독립 토글이므로 isDemolishModeActive로 관리 (setMode에서 건드리지 않음)

        // Zone modes - activate the Zones button
        if (isZoneMode()) {
            if (btnZones) btnZones.classList.add("active");
        }

        // Placement modes - activate individual buttons
        if (mode === MODE.PLACE_POLICE && btnPolice) btnPolice.classList.add("active");
        if (mode === MODE.PLACE_FIRE && btnFire) btnFire.classList.add("active");
        if (mode === MODE.PLACE_SCHOOL && btnSchool) btnSchool.classList.add("active");
        if (mode === MODE.PLACE_HOSPITAL && btnHospital) btnHospital.classList.add("active");
        if (mode === MODE.PLACE_PARK && btnParkBtn) btnParkBtn.classList.add("active");

        // Power modes - activate power button
        const isPowerMode = mode === MODE.PLACE_POWER_COAL || mode === MODE.PLACE_POWER_WIND || mode === MODE.PLACE_POWER_SOLAR || mode === MODE.POWER_VIEW;
        if (isPowerMode && btnPower) btnPower.classList.add("active");

        // Water modes - activate water button
        const isWaterMode = mode === MODE.WATER_VIEW || mode === MODE.PLACE_WATER_PUMP_COAST;
        if (isWaterMode && btnWater) btnWater.classList.add("active");

        // Sewage modes - activate sewage button
        const isSewageMode = mode === MODE.SEWAGE_VIEW || mode === MODE.PLACE_WASTEWATER;
        if (isSewageMode && btnSewage) btnSewage.classList.add("active");

        // Legacy buttons (hidden)
        if (btnZoneResidential) btnZoneResidential.classList.toggle("active", mode === MODE.ZONE_RESIDENTIAL);
        if (btnZoneCommercial) btnZoneCommercial.classList.toggle("active", mode === MODE.ZONE_COMMERCIAL);
        if (btnZoneIndustrial) btnZoneIndustrial.classList.toggle("active", mode === MODE.ZONE_INDUSTRIAL);
        if (btnZoneDelete) btnZoneDelete.classList.toggle("active", mode === MODE.ZONE_DELETE);

        // 회전은 카메라/그래프 모드에서만, 이동은 항상 가능 (줌은 커스텀 핸들러 사용)
        // 철거 모드일 때는 회전 비활성화
        controls.enabled = true;  // 컨트롤 항상 활성화
        const allowRotate = (mode === MODE.CAMERA || mode === MODE.LAND_VALUE_VIEW || mode === MODE.POPULATION_VIEW) && !isDemolishModeActive;
        controls.enableRotate = allowRotate;
        controls.enableZoom = false;  // 커스텀 줌 사용
        controls.enablePan = true;

        // 격자 가시성 - 도로/수로/철거/건물 설치 모드에서 표시
        gridHelper.visible = (mode === MODE.BUILD || mode === MODE.BUILD_4LANE || mode === MODE.WATER || isDemolishModeActive || isPlacementMode(mode));

        // 구역 메시 가시성 - 구역 모드에서만 보이게
        const showZones = isZoneMode() || mode === MODE.ZONE_DELETE;
        residentialMesh.visible = showZones;
        commercialMesh.visible = showZones;
        industrialMesh.visible = showZones;

        // 구역/수치 모드 진입/퇴장 시 오브젝트 색상 변경
        // 땅값 뷰는 자체 색상 시스템 사용 (빨강-흰색-초록 그라데이션)
        const showWhiteEffect = showZones || mode === MODE.POPULATION_VIEW;
        if (showWhiteEffect) {
            applyZoneModeEffect();
        } else if (mode !== MODE.LAND_VALUE_VIEW) {
            // 땅값 뷰가 아닐 때만 복원 (땅값 뷰는 자체적으로 복원)
            restoreOriginalMaterials();
        }

        // 카메라 모드로 전환 시 모든 오브젝트 완전 복원
        if (mode === MODE.CAMERA) {
            restoreOriginalMaterials(true);
            restoreAllBuildingOpacity();
        }

        // 좌측 사이드바 - 구역 모드일 때만 표시 (땅값/인구 토글 버튼)
        if (leftSidebar) {
            const showLeftSidebar = isZoneMode() || mode === MODE.ZONE_DELETE ||
                                    mode === MODE.LAND_VALUE_VIEW || mode === MODE.POPULATION_VIEW;
            if (showLeftSidebar) {
                leftSidebar.classList.add('visible');
            } else {
                leftSidebar.classList.remove('visible');
                // 땅값/인구 뷰 종료
                if (isLandValueViewActive) exitLandValueView();
                if (isPopulationViewActive) exitPopulationView();
            }
        }

        // 구역 모드 단축키 힌트 패널 표시/숨김
        const zoneModeHint = document.getElementById('zoneModeHint');
        if (zoneModeHint) {
            if (isZoneMode()) {
                zoneModeHint.classList.add('visible');
            } else {
                zoneModeHint.classList.remove('visible');
            }
        }

        // 구역 모드 범례 표시/숨김
        const isZoneModeNow = isZoneMode() || mode === MODE.ZONE_DELETE;
        const wasZoneMode = prevMode === MODE.ZONE_RESIDENTIAL || prevMode === MODE.ZONE_COMMERCIAL ||
                           prevMode === MODE.ZONE_INDUSTRIAL || prevMode === MODE.ZONE_DELETE;
        const wasDataViewMode = prevMode === MODE.LAND_VALUE_VIEW || prevMode === MODE.POPULATION_VIEW;
        if (isZoneModeNow && !wasZoneMode && !wasDataViewMode) {
            // 구역 모드 진입 시 범례 표시 (땅값/인구 뷰에서 전환한 경우 제외)
            showDataViewLegend('zone');
        } else if (!isZoneModeNow && wasZoneMode) {
            // 구역 모드 퇴장 시 범례 숨김 (다른 뷰 모드가 아닐 때만)
            if (mode !== MODE.LAND_VALUE_VIEW && mode !== MODE.POPULATION_VIEW && mode !== MODE.TRAFFIC_VIEW) {
                hideDataViewLegend();
            }
        }

        // 도로 모드 우측 사이드바 표시/숨김
        if (rightSidebarRoad) {
            if (mode === MODE.BUILD || mode === MODE.BUILD_4LANE || mode === MODE.WATER || mode === MODE.TRAFFIC_VIEW) {
                rightSidebarRoad.classList.add('visible');
            } else {
                rightSidebarRoad.classList.remove('visible');
                if (btnTrafficView) btnTrafficView.classList.remove('active');
                // 교통량 뷰 종료
                if (typeof hideTrafficView === 'function') {
                    hideTrafficView();
                }
            }
        }

        // 전력 모드 좌측 사이드바 표시/숨김
        if (leftSidebarPower) {
            if (mode === MODE.PLACE_POWER_COAL || mode === MODE.PLACE_POWER_WIND || mode === MODE.PLACE_POWER_SOLAR || mode === MODE.WIND_VIEW) {
                leftSidebarPower.classList.add('visible');
            } else {
                leftSidebarPower.classList.remove('visible');
                if (btnWindView) btnWindView.classList.remove('active');
            }
        }

        // 전력 모드 시각화 업데이트
        if (powerManager.initialized) {
            powerManager.updatePowerVisualization();
        }

        // 현재 구역 타입 설정
        if (mode === MODE.ZONE_RESIDENTIAL) {
            currentZoneType = CELL.ZONE_RESIDENTIAL;
        } else if (mode === MODE.ZONE_COMMERCIAL) {
            currentZoneType = CELL.ZONE_COMMERCIAL;
        } else if (mode === MODE.ZONE_INDUSTRIAL) {
            currentZoneType = CELL.ZONE_INDUSTRIAL;
        } else if (mode === MODE.ZONE_DELETE) {
            currentZoneType = CELL.EMPTY;
        } else {
            currentZoneType = null;
        }

        // X 버튼 표시/숨김 (카메라 모드 제외 모든 모드에서 표시)
        if (btnExitMode) {
            btnExitMode.style.display = (mode === MODE.CAMERA) ? 'none' : 'block';
        }

        // hintContainer 표시/숨김 (전력 건물 설치 모드에서만 표시)
        const isPowerPlacementMode = mode === MODE.PLACE_POWER_COAL || mode === MODE.PLACE_POWER_WIND || mode === MODE.PLACE_POWER_SOLAR;
        const isWaterPlacementMode = mode === MODE.PLACE_WASTEWATER || mode === MODE.PLACE_WATER_PUMP_COAST;
        if (hintContainer) {
            if (isPowerPlacementMode || isWaterPlacementMode) {
                hintContainer.classList.add('visible');
            } else {
                hintContainer.classList.remove('visible');
            }
        }

        // 힌트 텍스트 업데이트
        if (mode === MODE.CAMERA) {
            hint.textContent = MAP_CONFIG.isOwner
                ? i18n.t('hint.camera')
                : i18n.t('hint.viewOnly', { username: MAP_CONFIG.username });
            ghost.visible = false;
            setPreviewPath(null);
            set4LanePathPreview(null);
            isBuildDragging = false;
            isDemolishDragging = false;
            buildStart = null;
            currentPath = null;
            current4LanePath = null;
            costTooltip.style.display = 'none';
            // 구역 모드에서 벗어날 때 투명도 다시 활성화, emissive 리셋
            ghost.material.transparent = true;
            ghost.material.opacity = 0.35;
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
        } else if (mode === MODE.BUILD) {
            hint.textContent = i18n.t('hint.road');
            ghost.material.transparent = true;
            ghost.material.opacity = 0.35;
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
        } else if (mode === MODE.BUILD_4LANE) {
            hint.textContent = "드래그로 4차선 도로 설치 (2x2)";
            ghost.visible = false;  // 2x2 프리뷰 사용
        } else if (mode === MODE.WATER) {
            hint.textContent = "클릭/드래그로 수로 설치";
            ghost.material.color.set(0x4488ff);  // 파란색
            ghost.material.transparent = true;
            ghost.material.opacity = 0.35;
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
        } else if (mode === MODE.ZONE_RESIDENTIAL) {
            hint.textContent = i18n.t('hint.residential');
            ghost.material.color.set(ZONE_COLORS[CELL.ZONE_RESIDENTIAL]);
            ghost.material.emissive.set(ZONE_COLORS[CELL.ZONE_RESIDENTIAL]);
            ghost.material.emissiveIntensity = 0.5;
            ghost.material.transparent = false;  // 구역 프리뷰 투명도 제거
        } else if (mode === MODE.ZONE_COMMERCIAL) {
            hint.textContent = i18n.t('hint.commercial');
            ghost.material.color.set(ZONE_COLORS[CELL.ZONE_COMMERCIAL]);
            ghost.material.emissive.set(ZONE_COLORS[CELL.ZONE_COMMERCIAL]);
            ghost.material.emissiveIntensity = 0.5;
            ghost.material.transparent = false;
        } else if (mode === MODE.ZONE_INDUSTRIAL) {
            hint.textContent = i18n.t('hint.industrial');
            ghost.material.color.set(ZONE_COLORS[CELL.ZONE_INDUSTRIAL]);
            ghost.material.emissive.set(ZONE_COLORS[CELL.ZONE_INDUSTRIAL]);
            ghost.material.emissiveIntensity = 0.5;
            ghost.material.transparent = false;
        } else if (mode === MODE.ZONE_DELETE) {
            hint.textContent = i18n.t('hint.delete');
            ghost.material.color.set(0xff4444);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            ghost.material.transparent = true;  // 삭제 모드는 투명도 유지
        } else if (mode === MODE.LAND_VALUE_VIEW) {
            hint.textContent = '땅값 보기 모드 (ESC로 종료)';
            ghost.visible = false;
        } else if (mode === MODE.POPULATION_VIEW) {
            hint.textContent = '인구 보기 모드 (ESC로 종료)';
            ghost.visible = false;
        } else if (mode === MODE.TRAFFIC_VIEW) {
            hint.textContent = '교통량 보기 모드 (ESC로 종료)';
            ghost.visible = false;
        } else if (mode === MODE.WIND_VIEW) {
            hint.textContent = '풍량 보기 모드 (ESC로 종료)';
            ghost.visible = false;
        } else if (mode === MODE.PLACE_SCHOOL) {
            hint.textContent = '클릭으로 학교 설치 (2x2) - ₩4,000';
            ghost.material.color.set(0x4488ff);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('school');
            showServiceEffects('school');
        } else if (mode === MODE.PLACE_POLICE) {
            hint.textContent = '클릭으로 경찰서 설치 (2x2) - ₩3,000';
            ghost.material.color.set(0x4488ff);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('police');
            showServiceEffects('police');
        } else if (mode === MODE.PLACE_FIRE) {
            hint.textContent = '클릭으로 소방서 설치 (2x2) - ₩3,000';
            ghost.material.color.set(0xff6644);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('fire');
            showServiceEffects('fire');
        } else if (mode === MODE.PLACE_PARK) {
            hint.textContent = '클릭으로 공원 설치 (2x2) - ₩1,000';
            ghost.material.color.set(0x44cc66);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('park');
            showServiceEffects('park');
        } else if (mode === MODE.PLACE_HOSPITAL) {
            hint.textContent = '클릭으로 병원 설치 (2x2) - ₩6,000';
            ghost.material.color.set(0xff6688);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('hospital');
            showServiceEffects('hospital');
        } else if (mode === MODE.PLACE_POWER_COAL) {
            hint.textContent = '클릭으로 화력 발전소 설치 (2x2) - ₩5,000';
            ghost.material.color.set(0xffcc00);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            // 전력 뷰가 이미 활성화되어 있으므로 placement effect는 적용하지 않음
            // 서비스 효과 범위 그라데이션 제거
            clearServiceEffects();
            powerManager.recalculatePowerGrid();
        } else if (mode === MODE.PLACE_POWER_WIND) {
            hint.textContent = '클릭으로 풍력 발전소 설치 (3x4) - ₩3,000';
            ghost.material.color.set(0xffcc00);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            // 전력 뷰가 이미 활성화되어 있으므로 placement effect는 적용하지 않음
            // 서비스 효과 범위 그라데이션 제거
            clearServiceEffects();
            powerManager.recalculatePowerGrid();

            // 풍력발전소는 전기 뷰와 풍량 뷰 동시 활성화
            if (!isWindViewActive) {
                isWindViewActive = true;
                createWindVisualization();
                windViewGroup.visible = true;
                cacheWindDistanceMap();
                showDataViewLegend('wind');
            }
        } else if (mode === MODE.PLACE_POWER_SOLAR) {
            hint.textContent = '클릭으로 태양광 발전소 설치 (3x3) - ₩4,000';
            ghost.material.color.set(0xffaa00);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            // 전력 뷰가 이미 활성화되어 있으므로 placement effect는 적용하지 않음
            // 서비스 효과 범위 그라데이션 제거
            clearServiceEffects();
            powerManager.recalculatePowerGrid();
        } else if (mode === MODE.POWER_VIEW) {
            hint.textContent = '전력 사용량 뷰 - 발전소를 선택하여 설치하세요 (ESC로 종료)';
            ghost.visible = false;
            powerManager.recalculatePowerGrid();
        } else if (mode === MODE.PLACE_WASTEWATER) {
            hint.textContent = '방파제 옆에 하수처리장 설치 (2x4) - ₩8,000';
            ghost.material.color.set(0x8B4513);  // 갈색
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            clearServiceEffects();
            waterManager.recalculateWaterGrid();
        } else if (mode === MODE.PLACE_WATER_PUMP_COAST) {
            hint.textContent = '방파제 옆에 해안 취수장 설치 (2x4) - ₩6,000';
            ghost.material.color.set(0x87CEEB);  // 하늘색
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            clearServiceEffects();
            waterManager.recalculateWaterGrid();
        } else if (mode === MODE.WATER_VIEW) {
            hint.textContent = '수도 사용량 뷰 - 수도시설을 선택하여 설치하세요 (ESC로 종료)';
            ghost.visible = false;
            waterManager.recalculateWaterGrid();
        } else if (mode === MODE.SEWAGE_VIEW) {
            hint.textContent = '하수 처리량 뷰 - 하수처리시설을 선택하여 설치하세요 (ESC로 종료)';
            ghost.visible = false;
            if (sewageManager && sewageManager.recalculateSewageGrid) {
                sewageManager.recalculateSewageGrid();
            }
        }

        // 서브메뉴가 열려있으면 활성 아이템 상태 업데이트
        if (typeof updateSubmenuActiveState === 'function') {
            updateSubmenuActiveState();
        }
    }

    // 건물 설치 모드인지 확인
    function isPlacementMode(mode) {
        return mode === MODE.PLACE_SCHOOL ||
               mode === MODE.PLACE_POLICE ||
               mode === MODE.PLACE_FIRE ||
               mode === MODE.PLACE_PARK ||
               mode === MODE.PLACE_HOSPITAL ||
               mode === MODE.PLACE_POWER_COAL ||
               mode === MODE.PLACE_POWER_WIND ||
               mode === MODE.PLACE_POWER_SOLAR ||
               mode === MODE.PLACE_WASTEWATER ||
               mode === MODE.PLACE_WATER_PUMP_COAST;
    }

    // 현재 설치 중인 건물 타입 가져오기
    function getCurrentPlacementType() {
        switch(currentMode) {
            case MODE.PLACE_SCHOOL: return 'school';
            case MODE.PLACE_POLICE: return 'police';
            case MODE.PLACE_FIRE: return 'fire';
            case MODE.PLACE_PARK: return 'park';
            case MODE.PLACE_HOSPITAL: return 'hospital';
            case MODE.PLACE_POWER_COAL: return 'powerplant_coal';
            case MODE.PLACE_POWER_WIND: return 'powerplant_wind';
            case MODE.PLACE_POWER_SOLAR: return 'powerplant_solar';
            case MODE.PLACE_WASTEWATER: return 'wastewater';
            case MODE.PLACE_WATER_PUMP_COAST: return 'water_pump_coast';
            default: return null;
        }
    }

    /* =========================================================
     * TRAFFIC VIEW SYSTEM (교통량 뷰)
     * ========================================================= */
    const trafficViewGroup = new THREE.Group();
    trafficViewGroup.renderOrder = 999;  // 다른 오브젝트 위에 렌더링
    scene.add(trafficViewGroup);
    let isTrafficViewActive = false;

    // 둥근 모서리 박스 지오메트리 생성
    function createRoundedBoxGeometry(width, height, depth, radius) {
        const shape = new THREE.Shape();
        const w = width / 2 - radius;
        const d = depth / 2 - radius;

        shape.moveTo(-w, -depth / 2);
        shape.lineTo(w, -depth / 2);
        shape.quadraticCurveTo(width / 2, -depth / 2, width / 2, -d);
        shape.lineTo(width / 2, d);
        shape.quadraticCurveTo(width / 2, depth / 2, w, depth / 2);
        shape.lineTo(-w, depth / 2);
        shape.quadraticCurveTo(-width / 2, depth / 2, -width / 2, d);
        shape.lineTo(-width / 2, -d);
        shape.quadraticCurveTo(-width / 2, -depth / 2, -w, -depth / 2);

        const extrudeSettings = {
            depth: height,
            bevelEnabled: false,
        };

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.rotateX(-Math.PI / 2);
        geometry.translate(0, height / 2, 0);
        return geometry;
    }

    // 도로 직선 구간 탐지 (가로/세로 연속 도로)
    function detectRoadSegments() {
        const segments = [];
        const visitedH = new Set();  // 가로 방향 방문 기록
        const visitedV = new Set();  // 세로 방향 방문 기록

        // 도로인지 확인
        function isRoadTile(x, y) {
            if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return false;
            const cell = grid[y][x];
            return cell === CELL.ROAD || cell === CELL.LOCKED_ROAD;
        }

        // 가로 방향 연속 도로 탐지
        for (let y = 0; y < GRID_H; y++) {
            let segmentStart = -1;
            for (let x = 0; x <= GRID_W; x++) {
                const isRoad = x < GRID_W && isRoadTile(x, y);
                // 가로 연결이 있는 도로 (좌우에 도로가 있거나, 단독 가로 도로)
                const hasHorizontalConnection = isRoad && (isRoadTile(x - 1, y) || isRoadTile(x + 1, y));

                if (hasHorizontalConnection && segmentStart === -1) {
                    segmentStart = x;
                } else if ((!hasHorizontalConnection || !isRoad) && segmentStart !== -1) {
                    const endX = x - 1;
                    if (endX >= segmentStart) {
                        segments.push({
                            type: 'horizontal',
                            startX: segmentStart,
                            endX: endX,
                            y: y
                        });
                    }
                    segmentStart = -1;
                }
            }
        }

        // 세로 방향 연속 도로 탐지
        for (let x = 0; x < GRID_W; x++) {
            let segmentStart = -1;
            for (let y = 0; y <= GRID_H; y++) {
                const isRoad = y < GRID_H && isRoadTile(x, y);
                // 세로 연결이 있는 도로 (상하에 도로가 있거나, 단독 세로 도로)
                const hasVerticalConnection = isRoad && (isRoadTile(x, y - 1) || isRoadTile(x, y + 1));

                if (hasVerticalConnection && segmentStart === -1) {
                    segmentStart = y;
                } else if ((!hasVerticalConnection || !isRoad) && segmentStart !== -1) {
                    const endY = y - 1;
                    if (endY >= segmentStart) {
                        segments.push({
                            type: 'vertical',
                            x: x,
                            startY: segmentStart,
                            endY: endY
                        });
                    }
                    segmentStart = -1;
                }
            }
        }

        return segments;
    }

    // 교통량 히트맵 (DataTexture 기반 그라데이션)
    let trafficTexture = null;
    let trafficTextureData = null;
    let trafficPlane = null;
    let trafficOutline = null;

    // 혼잡도 → RGB 색상 (0~255)
    function getCongestionRGB(congestion) {
        // 녹색(0) → 노란색(0.5) → 빨간색(1)
        if (congestion <= 0.5) {
            const t = congestion * 2;
            return {
                r: Math.floor(t * 255),
                g: 255,
                b: 0
            };
        } else {
            const t = (congestion - 0.5) * 2;
            return {
                r: 255,
                g: Math.floor((1 - t) * 255),
                b: 0
            };
        }
    }

    // 도로인지 체크
    function isRoadCell(gx, gy) {
        if (gx < 0 || gx >= GRID_W || gy < 0 || gy >= GRID_H) return false;
        const cell = grid[gx][gy];
        return cell === CELL.ROAD || cell === CELL.LOCKED_ROAD;
    }

    // 교통량 텍스처 생성
    function createTrafficTexture() {
        trafficTextureData = new Uint8Array(GRID_W * GRID_H * 4);

        // 초기화 (모두 투명)
        for (let i = 0; i < GRID_W * GRID_H * 4; i += 4) {
            trafficTextureData[i] = 0;
            trafficTextureData[i + 1] = 0;
            trafficTextureData[i + 2] = 0;
            trafficTextureData[i + 3] = 0;
        }

        trafficTexture = new THREE.DataTexture(
            trafficTextureData,
            GRID_W,
            GRID_H,
            THREE.RGBAFormat
        );
        trafficTexture.magFilter = THREE.NearestFilter;  // 타일 기반 (픽셀화)
        trafficTexture.minFilter = THREE.NearestFilter;
        trafficTexture.needsUpdate = true;

        return trafficTexture;
    }

    // 교통량 텍스처 업데이트
    function updateTrafficTexture() {
        if (!trafficTexture || !trafficTextureData) return;

        const baseOpacity = 200;

        for (let gy = 0; gy < GRID_H; gy++) {
            for (let gx = 0; gx < GRID_W; gx++) {
                // 텍스처 좌표 (Y축 뒤집기 - Three.js 텍스처 좌표계)
                const idx = ((GRID_H - 1 - gy) * GRID_W + gx) * 4;

                if (isRoadCell(gx, gy)) {
                    const key = `${gx},${gy}`;
                    const congestion = trafficManager.initialized
                        ? (trafficManager.congestionMap.get(key) || 0)
                        : 0;

                    const rgb = getCongestionRGB(congestion);
                    trafficTextureData[idx] = rgb.r;
                    trafficTextureData[idx + 1] = rgb.g;
                    trafficTextureData[idx + 2] = rgb.b;
                    trafficTextureData[idx + 3] = baseOpacity;
                } else {
                    // 도로가 아닌 곳은 투명
                    trafficTextureData[idx] = 0;
                    trafficTextureData[idx + 1] = 0;
                    trafficTextureData[idx + 2] = 0;
                    trafficTextureData[idx + 3] = 0;
                }
            }
        }

        trafficTexture.needsUpdate = true;
    }

    // 도로 아웃라인 생성 (샤프한 경계선)
    function createTrafficOutline() {
        const positions = [];
        const height = 0.12;

        for (let gy = 0; gy < GRID_H; gy++) {
            for (let gx = 0; gx < GRID_W; gx++) {
                if (!isRoadCell(gx, gy)) continue;

                // ORIGIN 오프셋 적용 (그리드 중심이 0,0이 되도록)
                const x0 = (ORIGIN_X + gx) * TILE_SIZE;
                const x1 = (ORIGIN_X + gx + 1) * TILE_SIZE;
                const z0 = (ORIGIN_Z + gy) * TILE_SIZE;
                const z1 = (ORIGIN_Z + gy + 1) * TILE_SIZE;

                // 상단 경계 (gy-1이 도로가 아닐 때)
                if (!isRoadCell(gx, gy - 1)) {
                    positions.push(x0, height, z0, x1, height, z0);
                }
                // 하단 경계 (gy+1이 도로가 아닐 때)
                if (!isRoadCell(gx, gy + 1)) {
                    positions.push(x0, height, z1, x1, height, z1);
                }
                // 좌측 경계 (gx-1이 도로가 아닐 때)
                if (!isRoadCell(gx - 1, gy)) {
                    positions.push(x0, height, z0, x0, height, z1);
                }
                // 우측 경계 (gx+1이 도로가 아닐 때)
                if (!isRoadCell(gx + 1, gy)) {
                    positions.push(x1, height, z0, x1, height, z1);
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        const material = new THREE.LineBasicMaterial({
            color: 0x000000,
            linewidth: 2,
            transparent: true,
            opacity: 0.8
        });

        return new THREE.LineSegments(geometry, material);
    }

    // 교통량 뷰 표시
    function showTrafficView() {
        if (isTrafficViewActive) return;
        isTrafficViewActive = true;

        // Bloom 효과 끄기
        if (typeof bloomPass !== 'undefined') {
            bloomPass.enabled = false;
        }

        // 다른 수치 모드처럼 오브젝트를 흰색으로 변경
        applyZoneModeEffect();

        // 범례 패널 표시
        showDataViewLegend('traffic');

        // 격자 투명도 절반으로 설정
        if (typeof gridHelper !== 'undefined' && gridHelper.material) {
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.5;
        }

        // 기존 제거
        while (trafficViewGroup.children.length > 0) {
            const child = trafficViewGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (child.material.map) {
                    child.material.map.dispose();
                    child.material.map = null;
                }
                child.material.dispose();
            }
            trafficViewGroup.remove(child);
        }

        // 텍스처 생성
        createTrafficTexture();
        updateTrafficTexture();

        // 평면 생성 (각 타일에 맞게 UV 조정)
        const planeWidth = GRID_W * TILE_SIZE;
        const planeHeight = GRID_H * TILE_SIZE;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

        const material = new THREE.MeshBasicMaterial({
            map: trafficTexture,
            transparent: true,
            opacity: 0,
            depthWrite: false
        });

        trafficPlane = new THREE.Mesh(geometry, material);
        trafficPlane.rotation.x = -Math.PI / 2;  // 수평으로 눕히기
        // 평면 중심이 그리드 중심에 오도록 배치 (ORIGIN이 -GRID/2이므로 중심은 0,0)
        trafficPlane.position.set(0, 0.06, 0);

        trafficViewGroup.add(trafficPlane);

        // 샤프한 아웃라인 추가
        trafficOutline = createTrafficOutline();
        trafficOutline.material.opacity = 0;
        trafficViewGroup.add(trafficOutline);

        trafficViewGroup.visible = true;

        // 페이드인 애니메이션
        const duration = 400;
        const startTime = performance.now();

        function animateFadeIn(time) {
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            if (trafficPlane && trafficPlane.material) {
                trafficPlane.material.opacity = eased * 0.85;
            }
            if (trafficOutline && trafficOutline.material) {
                trafficOutline.material.opacity = eased * 0.9;
            }

            if (progress < 1 && isTrafficViewActive) {
                requestAnimationFrame(animateFadeIn);
            }
        }
        requestAnimationFrame(animateFadeIn);
    }

    // 교통량 뷰 실시간 업데이트
    function updateTrafficView() {
        if (!isTrafficViewActive || !trafficManager.initialized) return;
        if (!trafficTexture) return;

        updateTrafficTexture();
    }

    // 교통량 뷰 숨기기
    function hideTrafficView() {
        // ViewModeManager에 위임
        ViewModeManager.exitViewMode('traffic');
    }

    // 교통량 뷰 버튼 이벤트
    if (btnTrafficView) {
        btnTrafficView.addEventListener('click', () => {
            if (isTrafficViewActive) {
                hideTrafficView();
                btnTrafficView.classList.remove('active');
                setMode(MODE.BUILD);
            } else {
                showTrafficView();
                btnTrafficView.classList.add('active');
                setMode(MODE.TRAFFIC_VIEW);
            }
        });
    }

    // 풍량 뷰 버튼 이벤트
    if (btnWindView) {
        btnWindView.addEventListener('click', () => {
            toggleWindView();
        });
    }

    // 현재 모드가 카메라가 아니면 카메라 모드로 전환 (서브메뉴 열기 전 정리용)
    function exitCurrentModeIfNeeded() {
        if (currentMode !== MODE.CAMERA) {
            closeSubMenu();
            setMode(MODE.CAMERA);
        }
    }

    btnCam.addEventListener("click", () => {
        closeSubMenu();
        hideAllServicePanels();  // 모든 서비스 패널 닫기
        exitServiceBuildingView();
        clearToolButtonActive();
        setMode(MODE.CAMERA);
    });

    // 카메라 설정 패널 기능
    const cameraSettingsPanel = document.getElementById('cameraSettingsPanel');
    const cameraSettingsClose = document.getElementById('cameraSettingsClose');
    const minZoomSlider = document.getElementById('minZoomSlider');
    const maxZoomSlider = document.getElementById('maxZoomSlider');
    const minAngleSlider = document.getElementById('minAngleSlider');
    const maxAngleSlider = document.getElementById('maxAngleSlider');
    const minZoomValue = document.getElementById('minZoomValue');
    const maxZoomValue = document.getElementById('maxZoomValue');
    const minAngleValue = document.getElementById('minAngleValue');
    const maxAngleValue = document.getElementById('maxAngleValue');
    const cameraResetBtn = document.getElementById('cameraResetBtn');

    // 카메라 기본값 (원근 카메라용)
    const CAMERA_DEFAULTS = {
        minDistance: 0.1,  // 가까이
        maxDistance: 150,  // 멀리
        minAngle: 0,
        maxAngle: 89
    };

    // 카메라 버튼 우클릭으로 설정 패널 열기
    btnCam.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const isVisible = cameraSettingsPanel.style.display === 'block';
        cameraSettingsPanel.style.display = isVisible ? 'none' : 'block';
    });

    // 설정 패널 닫기
    if (cameraSettingsClose) {
        cameraSettingsClose.addEventListener('click', () => {
            cameraSettingsPanel.style.display = 'none';
        });
    }

    // 최소 거리 슬라이더 (원근 카메라용 - 가까이)
    if (minZoomSlider) {
        minZoomSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);  // 슬라이더 값 그대로 사용
            controls.minDistance = value;
            minZoomValue.textContent = value.toFixed(1);
            // 현재 거리가 최소보다 작으면 조정
            if (targetCameraDistance < value) {
                targetCameraDistance = value;
            }
        });
    }

    // 최대 거리 슬라이더 (원근 카메라용 - 멀리)
    if (maxZoomSlider) {
        maxZoomSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);  // 슬라이더 값 그대로 사용
            controls.maxDistance = value;
            maxZoomValue.textContent = value.toFixed(0);
            // 현재 거리가 최대보다 크면 조정
            if (targetCameraDistance > value) {
                targetCameraDistance = value;
            }
        });
    }

    // 최소 각도 슬라이더
    if (minAngleSlider) {
        minAngleSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            controls.minPolarAngle = value * Math.PI / 180;
            minAngleValue.textContent = value + '°';
        });
    }

    // 최대 각도 슬라이더
    if (maxAngleSlider) {
        maxAngleSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            controls.maxPolarAngle = value * Math.PI / 180;
            maxAngleValue.textContent = value + '°';
        });
    }

    // 기본값 초기화 버튼
    if (cameraResetBtn) {
        cameraResetBtn.addEventListener('click', () => {
            // 슬라이더 값 초기화
            minZoomSlider.value = CAMERA_DEFAULTS.minDistance;
            maxZoomSlider.value = CAMERA_DEFAULTS.maxDistance;
            minAngleSlider.value = CAMERA_DEFAULTS.minAngle;
            maxAngleSlider.value = CAMERA_DEFAULTS.maxAngle;

            // 표시값 초기화
            minZoomValue.textContent = CAMERA_DEFAULTS.minDistance.toFixed(1);
            maxZoomValue.textContent = CAMERA_DEFAULTS.maxDistance.toFixed(0);
            minAngleValue.textContent = CAMERA_DEFAULTS.minAngle + '°';
            maxAngleValue.textContent = CAMERA_DEFAULTS.maxAngle + '°';

            // 카메라 컨트롤 초기화 (원근 카메라)
            controls.minDistance = CAMERA_DEFAULTS.minDistance;
            controls.maxDistance = CAMERA_DEFAULTS.maxDistance;
            controls.minPolarAngle = CAMERA_DEFAULTS.minAngle * Math.PI / 180;
            controls.maxPolarAngle = CAMERA_DEFAULTS.maxAngle * Math.PI / 180;
        });
    }

    // 도로 버튼 - 토글 형식
    if (btnBuild) btnBuild.addEventListener("click", () => {
        const isRoadModeActive = currentMode === MODE.BUILD || currentMode === MODE.BUILD_4LANE || currentMode === MODE.WATER || currentMode === MODE.TRAFFIC_VIEW;
        const isRoadSubmenuOpen = currentSubmenu === 'roads' && subMenu.classList.contains('open');

        if (isRoadModeActive || isRoadSubmenuOpen) {
            // 이미 도로 모드이거나 서브메뉴가 열려 있으면 토글 OFF → 카메라 모드로
            closeSubMenu();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            clearToolButtonActive();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            openSubMenu('roads');
        }
    });
    // btnWater removed - water is now in roads submenu

    // Legacy zone buttons (hidden, for compatibility)
    if (btnZoneResidential) btnZoneResidential.addEventListener("click", () => setMode(MODE.ZONE_RESIDENTIAL));
    if (btnZoneCommercial) btnZoneCommercial.addEventListener("click", () => setMode(MODE.ZONE_COMMERCIAL));
    if (btnZoneIndustrial) btnZoneIndustrial.addEventListener("click", () => setMode(MODE.ZONE_INDUSTRIAL));
    if (btnZoneDelete) btnZoneDelete.addEventListener("click", () => setMode(MODE.ZONE_DELETE));

    // 구역 버튼 - 토글 형식
    if (btnZones) btnZones.addEventListener("click", () => {
        const isZoneModeActive = isZoneMode() || currentMode === MODE.ZONE_DELETE ||
                                  currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW;
        if (isZoneModeActive) {
            // 이미 구역 모드면 토글 OFF → 카메라 모드로
            closeSubMenu();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            clearToolButtonActive();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            setMode(MODE.ZONE_RESIDENTIAL);
            openSubMenu('zones');
        }
    });
    // 유틸리티 뷰 정리 함수 (전력/수도/하수 간 전환 시 이전 뷰 정리)
    function cleanupUtilityViews(exceptType = null) {
        // 전력 뷰 정리
        if (exceptType !== 'power' && btnPower && btnPower.classList.contains('active')) {
            btnPower.classList.remove('active');
            if (typeof powerManager !== 'undefined') {
                powerManager.restorePowerViewMaterials();
                if (powerManager.powerLineGroup) powerManager.powerLineGroup.visible = false;
                if (powerManager.powerIconGroup) powerManager.powerIconGroup.visible = false;
            }
        }
        // 수도 뷰 정리
        if (exceptType !== 'water' && btnWater && btnWater.classList.contains('active')) {
            btnWater.classList.remove('active');
            if (typeof waterManager !== 'undefined') {
                waterManager.restoreWaterViewMaterials();
                if (waterManager.waterPipeGroup) waterManager.waterPipeGroup.visible = false;
                if (waterManager.waterIconGroup) waterManager.waterIconGroup.visible = false;
            }
            if (typeof oceanSewageSystem !== 'undefined') {
                oceanSewageSystem.toggleView(false);
            }
        }
        // 하수 뷰 정리
        if (exceptType !== 'sewage' && btnSewage && btnSewage.classList.contains('active')) {
            btnSewage.classList.remove('active');
            if (typeof sewageManager !== 'undefined') {
                // 파이프/아이콘만 숨김 (머티리얼 복원은 oceanSewageSystem이 담당)
                if (sewageManager.toggleSewageView) sewageManager.toggleSewageView(false);
                if (sewageManager.sewagePipeGroup) sewageManager.sewagePipeGroup.visible = false;
                if (sewageManager.sewageIconGroup) sewageManager.sewageIconGroup.visible = false;
            }
            // oceanSewageSystem이 머티리얼 복원을 담당
            if (typeof oceanSewageSystem !== 'undefined') {
                oceanSewageSystem.toggleView(false);
            }
        }
        hideUtilityLegend();
    }

    // 전력 버튼 - 전력 뷰 모드 진입 + 발전소 선택 서브메뉴 열기
    if (btnPower) btnPower.addEventListener("click", () => {
        const isPowerActive = btnPower.classList.contains('active');

        if (isPowerActive) {
            // 전력 모드 활성화 상태면 종료 (OFF)
            closeSubMenu();
            hideAllServicePanels();
            cleanupUtilityViews();
            setMode(MODE.CAMERA);
        } else {
            // 전력 모드 비활성화 상태면 진입 (ON)
            // 먼저 다른 유틸리티 뷰 정리 (텍스처 복구)
            cleanupUtilityViews('power');
            deactivateDemolishMode();
            exitServiceBuildingView(true);
            hideAllServicePanels();
            closeSubMenu();
            clearToolButtonActive();
            btnPower.classList.add('active');
            setMode(MODE.POWER_VIEW);
            openSubMenu('power');
            showUtilityLegend('power');
        }
    });

    // 수도 버튼 - 수도 뷰 모드 진입 + 수도시설 선택 서브메뉴 열기
    if (btnWater) btnWater.addEventListener("click", () => {
        const isWaterActive = btnWater.classList.contains('active');

        if (isWaterActive) {
            // 수도 모드 활성화 상태면 종료 (OFF)
            closeSubMenu();
            hideAllServicePanels();
            cleanupUtilityViews();
            setMode(MODE.CAMERA);
        } else {
            // 수도 모드 비활성화 상태면 진입 (ON)
            // 먼저 다른 유틸리티 뷰 정리 (텍스처 복구)
            cleanupUtilityViews('water');
            deactivateDemolishMode();
            exitServiceBuildingView(true);
            hideAllServicePanels();
            closeSubMenu();
            clearToolButtonActive();
            btnWater.classList.add('active');
            // 바다 하수 시각화 표시 (setMode 전에 원본 머티리얼 저장)
            if (typeof oceanSewageSystem !== 'undefined') {
                oceanSewageSystem.toggleView(true);
            }
            setMode(MODE.WATER_VIEW);
            openSubMenu('waterSupply');
            showUtilityLegend('water');
        }
    });

    // 하수 버튼 - 하수 뷰 모드 진입 + 하수시설 선택 서브메뉴 열기
    if (btnSewage) btnSewage.addEventListener("click", () => {
        const isSewageActive = btnSewage.classList.contains('active');

        if (isSewageActive) {
            // 하수 모드 활성화 상태면 종료 (OFF)
            closeSubMenu();
            hideAllServicePanels();
            cleanupUtilityViews();
            setMode(MODE.CAMERA);
        } else {
            // 하수 모드 비활성화 상태면 진입 (ON)
            // 먼저 다른 유틸리티 뷰 정리 (텍스처 복구)
            cleanupUtilityViews('sewage');
            deactivateDemolishMode();
            exitServiceBuildingView(true);
            hideAllServicePanels();
            closeSubMenu();
            clearToolButtonActive();
            btnSewage.classList.add('active');
            // 바다 하수 시각화 표시 (setMode 전에 원본 머티리얼 저장)
            if (typeof oceanSewageSystem !== 'undefined') {
                oceanSewageSystem.toggleView(true);
            }
            setMode(MODE.SEWAGE_VIEW);
            openSubMenu('sewage');
            showUtilityLegend('sewage');
            if (typeof sewageManager !== 'undefined' && sewageManager.toggleSewageView) {
                sewageManager.toggleSewageView(true);
            }
        }
    });

    // Public facility individual buttons - 토글 형식 (서브메뉴 + 범례 모드)
    if (btnPolice) btnPolice.addEventListener("click", () => {
        const isPoliceModeActive = currentMode === MODE.PLACE_POLICE;
        const isPoliceViewActive = activeServiceViewType === 'police';

        if (isPoliceModeActive || isPoliceViewActive) {
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (enterServiceBuildingView 내부에서 이전 서비스 뷰 종료 처리)
            deactivateDemolishMode();
            hideUtilityLegend();
            hideAllServicePanels();  // 기존 패널 닫기
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('police');
            openSubMenu('police');
        }
    });
    if (btnFire) btnFire.addEventListener("click", () => {
        const isFireModeActive = currentMode === MODE.PLACE_FIRE;
        const isFireViewActive = activeServiceViewType === 'fire';

        if (isFireModeActive || isFireViewActive) {
            // 이미 소방서 모드/뷰가 활성화되어 있으면 종료
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (enterServiceBuildingView 내부에서 이전 서비스 뷰 종료 처리)
            deactivateDemolishMode();
            hideUtilityLegend();
            hideAllServicePanels();  // 기존 패널 닫기
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('fire');
            openSubMenu('fire');
        }
    });
    if (btnSchool) btnSchool.addEventListener("click", () => {
        const isSchoolModeActive = currentMode === MODE.PLACE_SCHOOL;
        const isSchoolViewActive = activeServiceViewType === 'school';

        if (isSchoolModeActive || isSchoolViewActive) {
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (enterServiceBuildingView 내부에서 이전 서비스 뷰 종료 처리)
            deactivateDemolishMode();
            hideUtilityLegend();
            hideAllServicePanels();  // 기존 패널 닫기
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('school');
            openSubMenu('school');
        }
    });
    if (btnHospital) btnHospital.addEventListener("click", () => {
        const isHospitalModeActive = currentMode === MODE.PLACE_HOSPITAL;
        const isHospitalViewActive = activeServiceViewType === 'hospital';

        if (isHospitalModeActive || isHospitalViewActive) {
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (enterServiceBuildingView 내부에서 이전 서비스 뷰 종료 처리)
            deactivateDemolishMode();
            hideUtilityLegend();
            hideAllServicePanels();  // 기존 패널 닫기
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('hospital');
            openSubMenu('hospital');
        }
    });
    if (btnParkBtn) btnParkBtn.addEventListener("click", () => {
        const isParkModeActive = currentMode === MODE.PLACE_PARK;
        const isParkViewActive = activeServiceViewType === 'park';

        if (isParkModeActive || isParkViewActive) {
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            hideAllServicePanels();  // 모든 서비스 패널 닫기
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (enterServiceBuildingView 내부에서 이전 서비스 뷰 종료 처리)
            deactivateDemolishMode();
            hideUtilityLegend();
            hideAllServicePanels();  // 기존 패널 닫기
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('park');
            openSubMenu('park');
        }
    });

    // 철거 버튼 - 독립 토글 (다른 모드와 공존 가능)
    if (btnDemolish) btnDemolish.addEventListener("click", () => {
        toggleDemolishMode();
    });

    // X 버튼 클릭으로 카메라 모드로 복귀
    if (btnExitMode) btnExitMode.addEventListener("click", () => {
        closeSubMenu();
        hideAllServicePanels();  // 모든 서비스 패널 닫기
        exitServiceBuildingView();
        clearToolButtonActive();
        setMode(MODE.CAMERA);
    });

    // 좌측 사이드바 버튼 이벤트
    if (btnLandValue) btnLandValue.addEventListener("click", () => {
        toggleLandValueView();
    });

    if (btnPopulation) btnPopulation.addEventListener("click", () => {
        togglePopulationView();
    });

    window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
            // 철거 모드 비활성화
            if (isDemolishModeActive) {
                deactivateDemolishMode();
            }
            // 서비스 건물 뷰 모드면 종료
            if (isServiceViewActive()) {
                exitServiceBuildingView();
            }
            // 땅값 뷰 모드면 종료
            if (isLandValueViewActive) {
                exitLandValueView();
            }
            // 인구 뷰 모드면 종료
            if (isPopulationViewActive) {
                exitPopulationView();
            }
            // 하수 뷰 모드면 종료
            if (typeof sewageManager !== 'undefined' && sewageManager.isSewageViewActive) {
                sewageManager.toggleSewageView(false);
            }
            // 바다 하수 시각화 숨기기
            if (typeof oceanSewageSystem !== 'undefined') {
                oceanSewageSystem.toggleView(false);
            }
            // 유틸리티 범례 숨기기 (전력/수도/하수 모드)
            hideUtilityLegend();
            closeSubMenu();
            // 툴바 버튼 비활성화
            if (btnSewage) btnSewage.classList.remove('active');
            if (btnWater) btnWater.classList.remove('active');
            setMode(MODE.CAMERA);
        }
        // 배속 조절
        if (e.key === " ") {  // Space - 일시정지/재생
            e.preventDefault();
            setGameSpeed(timeState.speed === 0 ? 1 : 0);
        }
        if (e.key === "," || e.key === "<") setGameSpeed(Math.max(0, timeState.speed / 2));  // 감속
        if (e.key === "." || e.key === ">") setGameSpeed(Math.min(4, timeState.speed === 0 ? 1 : timeState.speed * 2));  // 가속
        // 모드 전환
        if (e.key === "1") { closeSubMenu(); setMode(MODE.CAMERA); }
        if (e.key === "2" && MAP_CONFIG.isOwner) { closeSubMenu(); setMode(MODE.BUILD); }
        if (e.key === "3" && MAP_CONFIG.isOwner) setMode(MODE.ZONE_RESIDENTIAL);
        if (e.key === "4" && MAP_CONFIG.isOwner) setMode(MODE.ZONE_COMMERCIAL);
        if (e.key === "5" && MAP_CONFIG.isOwner) setMode(MODE.ZONE_INDUSTRIAL);
        if (e.key === "6" && MAP_CONFIG.isOwner) setMode(MODE.ZONE_DELETE);
        // Ctrl+S 저장
        if ((e.ctrlKey || e.metaKey) && e.key === "s" && MAP_CONFIG.isOwner) {
            e.preventDefault();
            saveMapData();
        }
    });

    // Ctrl 키 떼면 직선 프리뷰 제거
    window.addEventListener("keyup", (e) => {
        if (e.key === "Control" || e.key === "Meta") {
            clearLinePreview();
        }
    });

    setMode(MODE.CAMERA);

    /* =========================================================
     * SAVE / LOAD API
     * ========================================================= */
    let isSaving = false;
    let isDirty = false;  // 변경사항 추적
    let lastSaveTime = 0;  // 마지막 저장 시간
    const SAVE_COOLDOWN = 10000;  // 저장 쿨다운 10초

    function markDirty() {
        if (!MAP_CONFIG.isOwner) return;
        isDirty = true;
        updateSaveButton();
    }

    function markClean() {
        isDirty = false;
        updateSaveButton();
    }

    function updateSaveButton() {
        const btnSave = document.getElementById('btnSave');
        if (btnSave) {
            if (isDirty) {
                btnSave.classList.add('dirty');
                btnSave.title = '저장 필요 (Ctrl+S)';
            } else {
                btnSave.classList.remove('dirty');
                btnSave.title = '저장 (Ctrl+S)';
            }
        }
    }

    // 저장 버튼 클릭 이벤트
    const btnSave = document.getElementById('btnSave');
    if (btnSave) {
        // 방문 모드에서는 저장 버튼 숨기기
        if (!MAP_CONFIG.isOwner) {
            btnSave.style.display = 'none';
        } else {
            btnSave.addEventListener('click', () => saveMapData());
        }
    }

    // 1분마다 자동 저장 (소유자만)
    const AUTO_SAVE_INTERVAL = 60000;  // 1분
    if (MAP_CONFIG.isOwner) {
        setInterval(() => {
            if (isDirty && !isSaving) {
                console.log('[AutoSave] 자동 저장 시작...');
                saveMapData();
            }
        }, AUTO_SAVE_INTERVAL);
    }

    function showSaveIndicator(status) {
        saveIndicator.className = status;
        saveIndicator.textContent = status === 'saving' ? i18n.t('toast.saving') : i18n.t('toast.saved');
        if (status === 'saved') {
            setTimeout(() => {
                saveIndicator.className = '';
            }, 1500);
        }
    }

    async function saveMapData() {
        // 테스트 모드: DB 저장 비활성화
        if (TEST_MODE) {
            toast({ title: '테스트 모드', desc: 'DB 저장이 비활성화되어 있습니다.', success: true });
            markClean();
            return;
        }

        // 방문 모드에서는 저장 불가
        if (!MAP_CONFIG.isOwner) {
            toast({ title: '저장 불가', desc: '다른 사람의 도시는 저장할 수 없습니다.', success: false });
            return;
        }

        if (isSaving) return;

        // 쿨다운 체크 (10초)
        const now = Date.now();
        const timeSinceLastSave = now - lastSaveTime;
        if (lastSaveTime > 0 && timeSinceLastSave < SAVE_COOLDOWN) {
            const remainingSeconds = Math.ceil((SAVE_COOLDOWN - timeSinceLastSave) / 1000);
            toast({
                title: '저장 대기',
                desc: `${remainingSeconds}초 후에 다시 저장할 수 있습니다.`,
                success: false
            });
            return;
        }

        if (!isDirty) {
            toast({ title: i18n.t('toast.saved'), desc: i18n.t('toast.savedDesc'), success: true });
            return;
        }

        isSaving = true;
        showSaveIndicator('saving');

        try {
            // 도시 이름이 있으면 해당 도시에 저장, 없으면 기본 도시
            const saveUrl = MAP_CONFIG.cityName
                ? `/api/map/${MAP_CONFIG.username}/${encodeURIComponent(MAP_CONFIG.cityName)}`
                : `/api/map/${MAP_CONFIG.username}`;
            const response = await fetch(saveUrl, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    grid: grid,
                    money: economy.money,
                    buildings: extractBuildingsData(),  // 건물 레벨/폐건물 상태 저장
                    cameraState: {
                        position: {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        },
                        target: {
                            x: controls.target.x,
                            y: controls.target.y,
                            z: controls.target.z
                        },
                        // 카메라 회전 (OrbitControls 극좌표)
                        azimuthAngle: controls.getAzimuthalAngle(),
                        polarAngle: controls.getPolarAngle()
                    },
                    // 게임 시간/날짜 저장
                    gameState: {
                        gameTime: timeState.gameTime,
                        gameDay: timeState.gameDay
                    }
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || i18n.t('toast.saveError'));
            }

            showSaveIndicator('saved');
            markClean();
            lastSaveTime = Date.now();  // 쿨다운 타이머 시작
            toast({ title: i18n.t('toast.saved'), desc: i18n.t('toast.savedDesc'), success: true });
        } catch (error) {
            console.error('Save failed:', error);
            toast({
                title: i18n.t('toast.saveError'),
                desc: error.message
            });
            showSaveIndicator('');
        } finally {
            isSaving = false;
        }
    }

    // 페이지 이탈 시 저장 안 된 변경사항 경고
    window.addEventListener('beforeunload', (e) => {
        if (isDirty && MAP_CONFIG.isOwner) {
            e.preventDefault();
            e.returnValue = '';
        }
    });

    async function loadMapData() {
        console.log('loadMapData 시작...');
        try {
            // 도시 이름이 있으면 해당 도시 로드, 없으면 기본 도시
            const apiUrl = MAP_CONFIG.cityName
                ? `/api/map/${MAP_CONFIG.username}/${encodeURIComponent(MAP_CONFIG.cityName)}`
                : `/api/map/${MAP_CONFIG.username}`;
            const response = await fetch(apiUrl);
            console.log('API 응답 받음');
            if (!response.ok) throw new Error('맵 로드 실패');

            const data = await response.json();

            // 그리드 데이터 로드 및 원본 해안선/바다 저장
            originalCoastline.clear();
            originalSeaTiles.clear();
            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    grid[x][y] = data.grid[x][y];
                    // 원본 맵의 해변 위치 저장
                    if (data.grid[x][y] === CELL.BEACH) {
                        originalCoastline.add(`${x},${y}`);
                        originalSeaTiles.add(`${x},${y}`);
                    }
                    // 원본 맵의 바다 위치 저장 (풍량 계산용)
                    if (data.grid[x][y] === CELL.OCEAN) {
                        originalSeaTiles.add(`${x},${y}`);
                    }
                }
            }

            // 자금 로드 (테스트용 무한 자금 모드면 유지)
            if (!UNLIMITED_MONEY) {
                economy.money = data.money;
            }
            renderMoney();

            // 도시 통계 로드
            cityStats.population = data.population || 0;
            cityStats.happiness = data.happiness || 50;
            cityStats.powerCapacity = data.powerCapacity || 0;
            cityStats.powerUsage = data.powerUsage || 0;
            cityStats.waterCapacity = data.waterCapacity || 0;
            cityStats.waterUsage = data.waterUsage || 0;
            cityStats.crimeRate = data.crimeRate || 0;
            cityStats.fireRisk = data.fireRisk || 0;
            cityStats.trafficLevel = data.trafficLevel || 0;
            cityStats.taxPerHour = data.taxPerHour || 0;
            cityStats.actionPoints = data.actionPoints || 10;
            cityStats.consecutiveLoginDays = data.consecutiveLoginDays || 0;
            cityStats.congestionMap = data.congestionMap || null;

            updateStatsDisplay();

            // 건물 데이터 로드 (새 구조: civilBuildings, publicBuildings)
            const buildingsData = data.buildings || null;
            if (buildingsData && typeof buildingsData === 'object') {
                // 새 구조
                savedBuildingsData = buildingsData.civilBuildings || null;
                console.log('민간 건물 데이터 로드:', savedBuildingsData ? savedBuildingsData.length + '개' : '없음');
                console.log('공공시설 데이터 로드:', buildingsData.publicBuildings ? buildingsData.publicBuildings.length + '개' : '없음');
            } else if (Array.isArray(buildingsData)) {
                // 기존 구조 (하위 호환)
                savedBuildingsData = buildingsData;
                console.log('건물 데이터 로드 (구 구조):', savedBuildingsData.length + '개');
            } else {
                savedBuildingsData = null;
            }

            // 오프라인 수익 표시
            if (data.offlineEarnings && data.offlineEarnings > 0) {
                showOfflineEarnings(data.offlineEarnings);
            }

            // 로그인 보상 표시
            if (data.loginReward && data.loginReward > 0) {
                showLoginReward(data.loginReward);
            }

            // 도로 및 구역 재구성
            console.log('도로 재구성 시작...');
            // 4차선 도로 원점 복원 (저장된 데이터가 있으면 사용, 없으면 그리드에서 재구성)
            if (buildingsData && buildingsData.road4LaneOrigins && buildingsData.road4LaneOrigins.length > 0) {
                restore4LaneOrigins(buildingsData.road4LaneOrigins);
            } else {
                rebuild4LaneOrigins();  // 4차선 도로 원점 그리드에서 재구성
            }
            rebuildRoadInstances();
            rebuildRoadModels();
            rebuildBreakwaters();  // 방파제 재구성
            console.log('구역 재구성 시작...');
            // 저장된 건물만 복원 (구역만 지정하고 저장한 경우 건물이 자동 생성되지 않도록)
            rebuildZoneInstances(true, true);

            // 공공시설 복원
            if (buildingsData && buildingsData.publicBuildings) {
                console.log('공공시설 복원 시작...');
                restoreAllPublicBuildings(buildingsData.publicBuildings);
                console.log('공공시설 복원 완료');
            }

            // 공사중인 현장 복원
            if (buildingsData && buildingsData.constructionSites && buildingsData.constructionSites.length > 0) {
                console.log('공사 현장 복원 시작:', buildingsData.constructionSites.length + '개');
                restoreConstructionSites(buildingsData.constructionSites);
                console.log('공사 현장 복원 완료');
            }

            // 해변 타일 재계산 (바다 인접 육지를 해변으로 변환)
            console.log('해변 타일 재계산 시작...');
            const beachConverted = recalculateBeachTiles();
            if (beachConverted) {
                markDirty();  // 해변 위치 변경 저장 필요
            }
            console.log('해변 타일 재계산 완료');

            // 잔디/수로/다리 타일 재구성
            console.log('타일 재구성 시작...');
            rebuildAllTiles();
            console.log('타일 재구성 완료');

            // 나무 복원 또는 새로 생성
            if (buildingsData && buildingsData.trees && buildingsData.trees.length > 0) {
                // 저장된 나무 데이터가 있으면 복원
                console.log('나무 복원 시작:', buildingsData.trees.length + '개');
                restoreTreesFromData(buildingsData.trees);
                console.log('나무 복원 완료');
            } else {
                // 저장된 나무가 없으면 새로 생성 (새 맵인 경우)
                console.log('새 맵 - 나무 생성 중...');
                const treeSeed = data.treeSeed || Date.now();  // 시드가 저장되어 있으면 사용
                generateTreesWithSeed(treeSeed);
                console.log('나무 생성 완료');
                markDirty();  // 새 나무가 생성되었으므로 저장 필요
            }

            // 혼잡도 시각화
            if (cityStats.congestionMap) {
                updateCongestionVisualization();
            }

            // 카메라 위치/회전 복원
            if (data.cameraState) {
                const { position, target, azimuthAngle, polarAngle } = data.cameraState;
                if (position) {
                    camera.position.set(position.x, position.y, position.z);
                }
                if (target) {
                    controls.target.set(target.x, target.y, target.z);
                }
                controls.update();
                // 줌 거리도 복원
                targetCameraDistance = camera.position.distanceTo(controls.target);
                cameraRestoredFromSave = true;  // 인트로 애니메이션 스킵 플래그
                controls.enabled = true;  // 컨트롤 즉시 활성화
                console.log('카메라 위치 복원 완료:', position, '줌:', targetCameraDistance);
            }

            // 게임 시간/날짜 복원
            if (data.gameState) {
                const { gameTime, gameDay } = data.gameState;
                if (gameTime !== undefined) {
                    timeState.gameTime = gameTime;
                }
                if (gameDay !== undefined) {
                    timeState.gameDay = gameDay;
                }
                // 조명 및 환경 업데이트 (낮/밤 상태 반영)
                updateEnvironment();
                console.log(`게임 시간 복원: Day ${timeState.gameDay}, ${formatGameTime(timeState.gameTime)}`);
            }

            // 도시 이름 업데이트
            if (data.cityName) {
                const cityNameDisplay = document.getElementById('cityNameDisplay');
                if (cityNameDisplay) {
                    cityNameDisplay.innerHTML = `${data.cityName} <span style="opacity: 0.6; font-weight: 400;">- ${data.username}</span>`;
                }
            }

            console.log('맵 로드 완료:', data.username, '도시:', data.cityName, '소유자:', data.isOwner);

        } catch (error) {
            console.error('맵 로드 실패:', error);
            toast({
                title: "로드 실패",
                desc: "맵 데이터를 불러올 수 없습니다."
            });

            // 기본 외곽 도로 생성
            buildOuterRingRoad();
            rebuild4LaneOrigins();  // 4차선 도로 원점 등록 (전력선/수도관 연결용)
            rebuildRoadInstances();
            rebuildRoadModels();
            rebuildZoneInstances();
            rebuildAllTiles();

            // 기본 나무 생성
            generateTreesWithSeed(Date.now());
        }
    }

    // 도로 혼잡도 시각화 업데이트
    function updateCongestionVisualization() {
        if (!cityStats.congestionMap) return;

        // roadGroup의 각 도로 모델에 색상 적용
        roadGroup.children.forEach((roadModel, index) => {
            // 도로 위치에서 그리드 좌표 계산
            const worldX = roadModel.position.x;
            const worldZ = roadModel.position.z;
            const gx = Math.floor(worldX / TILE_SIZE - ORIGIN_X);
            const gy = Math.floor(worldZ / TILE_SIZE - ORIGIN_Z);

            if (gx >= 0 && gx < GRID_W && gy >= 0 && gy < GRID_H && cityStats.congestionMap[gx]) {
                const congestion = cityStats.congestionMap[gx][gy] || 0;

                roadModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        // 원본 재질 복제
                        if (!child.userData.originalMaterial) {
                            child.userData.originalMaterial = child.material;
                        }

                        // 원본 재질이 유효한지 확인 후 복제
                        const origMat = child.userData.originalMaterial;
                        if (origMat && typeof origMat.clone === 'function') {
                            child.material = origMat.clone();
                        }

                        // 혼잡도 30 이상일 때만 색상 적용 (원활할 때는 원래 색상 유지)
                        if (congestion >= 30) {
                            const color = getCongestionColor(congestion);
                            if (child.material.emissive) {
                                child.material.emissive = new THREE.Color(color);
                                child.material.emissiveIntensity = 0.3;
                            }
                        } else {
                            // 혼잡도 낮으면 emissive 없음
                            if (child.material.emissive) {
                                child.material.emissive = new THREE.Color(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        }
                    }
                });
            }
        });
    }

    function getCongestionColor(level) {
        // 30 미만은 이제 여기 도달하지 않음
        if (level < 60) return 0xffcc00;  // 노랑 - 보통
        if (level < 80) return 0xff9500;  // 주황 - 혼잡
        return 0xff4444;  // 빨강 - 정체
    }

    function buildOuterRingRoad() {
        // 하단 경계도로만 (y = GRID_H-2, GRID_H-1)
        for (let x = 0; x < GRID_W; x++) {
            grid[x][GRID_H - 2] = CELL.LOCKED_ROAD_4LANE;
            grid[x][GRID_H - 1] = CELL.LOCKED_ROAD_4LANE;
        }
    }

    /* =========================================================
     * RESIZE / LOOP
     * ========================================================= */
    function resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        renderer.setSize(w, h, false);

        // Post-processing composer 크기 조정
        composer.setSize(w, h);
        // Bloom은 절반 해상도 유지 (성능 최적화)
        bloomPass.resolution.set(
            Math.floor(w * GRAPHICS_SETTINGS.bloomResolutionScale),
            Math.floor(h * GRAPHICS_SETTINGS.bloomResolutionScale)
        );

        // 원근 카메라 비율 조정
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        // 캐시된 렌더러 rect 업데이트 (getBoundingClientRect 호출 최소화)
        cachedRendererRect = renderer.domElement.getBoundingClientRect();
    }

    window.addEventListener("resize", resize);
    resize();

    // 프레임 스킵용 카운터 (최적화)
    let frameCount = 0;

    // 카메라 거리별 LOD 설정
    const LOD_CONFIG = {
        NEAR: 30,      // 가까운 거리 (최고 품질)
        MEDIUM: 60,    // 중간 거리
        FAR: 100,      // 먼 거리 (최적화 적용)
        VERY_FAR: 140  // 매우 먼 거리 (최대 최적화)
    };
    let currentLODLevel = 'NEAR';
    let lastLODCheck = 0;

    // LOD 레벨별 프레임 스킵 배율
    function getLODFrameMultiplier() {
        switch (currentLODLevel) {
            case 'VERY_FAR': return 4;  // 4배 스킵 (6프레임 → 24프레임마다)
            case 'FAR': return 3;       // 3배 스킵
            case 'MEDIUM': return 2;    // 2배 스킵
            default: return 1;          // 기본
        }
    }

    // 카메라 거리에 따른 LOD 레벨 업데이트
    function updateLODLevel() {
        const distance = camera.position.distanceTo(controls.target);
        let newLevel = 'NEAR';

        if (distance > LOD_CONFIG.VERY_FAR) newLevel = 'VERY_FAR';
        else if (distance > LOD_CONFIG.FAR) newLevel = 'FAR';
        else if (distance > LOD_CONFIG.MEDIUM) newLevel = 'MEDIUM';

        if (newLevel !== currentLODLevel) {
            currentLODLevel = newLevel;
            applyLODSettings(newLevel);
        }
    }

    // LOD 설정 적용 (거리별 최적화)
    function applyLODSettings(level) {
        // 차량 가시성 조절
        if (trafficManager.vehicles) {
            const maxVisible = level === 'VERY_FAR' ? 20 :
                              level === 'FAR' ? 40 :
                              level === 'MEDIUM' ? 80 : 200;
            let visibleCount = 0;
            trafficManager.vehicles.forEach(v => {
                if (v.isActive && v.mesh) {
                    v.mesh.visible = visibleCount < maxVisible;
                    visibleCount++;
                }
            });
        }

        // 파티클/이펙트 품질 조절
        if (batchRenderer) {
            batchRenderer.enabled = level !== 'VERY_FAR';
        }

        // 가로등 PointLight 범위 조절
        const lightDist = level === 'VERY_FAR' ? 5 :
                         level === 'FAR' ? 15 :
                         level === 'MEDIUM' ? 20 : 25;
        // STREET_LIGHT_LOD_DISTANCE는 const라서 직접 변경 불가, 대신 가로등 업데이트에서 처리

        // 그림자 품질 조절
        if (renderer.shadowMap) {
            renderer.shadowMap.enabled = level !== 'VERY_FAR';
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const currentTime = performance.now();
        frameCount++;

        // 퍼포먼스 모니터 FPS 계산
        if (perfMonitor) perfMonitor.tick();

        // LOD 레벨 업데이트 (30프레임마다)
        if (frameCount % 30 === 0) {
            updateLODLevel();
        }

        const lodMultiplier = getLODFrameMultiplier();

        // === 매 프레임 실행 (필수) ===
        updateCameraIntro();  // 카메라 인트로 애니메이션
        updateSmoothZoom();   // 부드러운 줌 애니메이션
        updateBuildingPreviewPosition();  // 건물 프리뷰 부드러운 이동
        trafficManager.updateCameraFollow();  // 차량 카메라 따라가기 (부드러움 유지)
        updateCompass();  // 나침반 회전 업데이트

        // === 3프레임마다 실행 (교통 시스템) ===
        if (frameCount % (3 * lodMultiplier) === 0) {
            trafficManager.update(currentTime);  // 교통 시스템 업데이트
        }

        // === 4프레임마다 실행 (UI 위치 업데이트) ===
        if (frameCount % (4 * lodMultiplier) === 0) {
            updatePopupPosition();  // 건물 팝업 위치 업데이트
            updatePublicBuildingPopupPosition();  // 공공시설 팝업 위치 업데이트
            updateConstructionPopupPosition();  // 공사 팝업 위치 업데이트
            trafficManager.updateVehiclePopupPosition();  // 차량 팝업 위치 업데이트
        }

        // === 6프레임마다 실행 (게임 로직) ===
        if (frameCount % (6 * lodMultiplier) === 0) {
            updateGameTime();  // 시간 사이클 업데이트
            updateConstructions();  // 공사 진행 상태 업데이트
            updateConstructionPopupContent();  // 공사 팝업 실시간 업데이트
            trafficManager.updateVehicleOutline();  // 차량 아웃라인 업데이트
            updateTrafficView();  // 교통량 뷰 실시간 업데이트
        }

        // === 10프레임마다 실행 (이벤트 시스템) ===
        if (frameCount % (10 * lodMultiplier) === 0) {
            updateFireSystem();  // 화재 시스템 업데이트
            updateCrimeSystem();  // 강도 사건 시스템 업데이트
            updateMedicalSystem();  // 의료 응급 시스템 업데이트
        }

        // === 15프레임마다 실행 (아이콘 위치 업데이트) ===
        if (frameCount % (15 * lodMultiplier) === 0) {
            updateAllServiceEmojis();  // 서비스 이모지 위치 업데이트
            updateAbandonedIcons();  // 폐건물 아이콘 위치 업데이트
        }

        // === 20프레임마다 실행 (무거운 로직) ===
        if (frameCount % (20 * lodMultiplier) === 0) {
            updateMoveInSystem();   // 입주 시스템 업데이트 (행복도 기반 스폰)
            updateRCIShortageEffects();  // RCI 부족 영향 건물 업데이트
            updateBuildingHappinessStatus();  // 행복도 상태 체크 (폐건물 전환)
            updateCityHappinessDisplay();     // 도시 전체 행복도 UI 업데이트
        }

        // 건물 업그레이드 시스템 - 주기적 땅값 체크
        if (currentTime - lastUpgradeCheck > UPGRADE_CHECK_INTERVAL) {
            checkBuildingLandValues();
            lastUpgradeCheck = currentTime;
        }

        // 하단 바 업데이트 (예산/인구) - 2초마다 (최적화)
        if (currentTime - lastBottomBarUpdate > 2000) {
            updateBudgetDisplay();
            updatePopulationDisplay();
            // 인구 패널이 열려있으면 패널도 업데이트
            if (populationPanel && populationPanel.classList.contains('open')) {
                updatePopulationPanel();
            }
            lastBottomBarUpdate = currentTime;
        }

        // 카메라 이동 제한 (맵 범위 내, 땅 위)
        clampCameraPosition();

        // three.quarks 파티클 시스템 업데이트
        const particleDelta = particleClock.getDelta();
        batchRenderer.update(particleDelta);

        // GLB 모델 애니메이션 업데이트 (풍력 발전소 터빈 등)
        const animationDelta = animationClock.getDelta();
        for (let i = activeAnimationMixers.length - 1; i >= 0; i--) {
            const mixerData = activeAnimationMixers[i];
            if (mixerData && mixerData.mixer) {
                mixerData.mixer.update(animationDelta);
            }
        }

        // 풍력발전기 프로펠러 수동 회전
        for (let i = 0; i < windTurbinePropellers.length; i++) {
            const propData = windTurbinePropellers[i];
            if (propData && propData.propeller) {
                propData.propeller.rotation.x += propData.speed * animationDelta;
            }
        }

        controls.update();
        // Post-processing으로 렌더링 (Bloom, Tone Mapping 적용)
        composer.render();

        // GPU 통계 캡처 (렌더링 직후, 리셋 전에)
        if (perfMonitor) perfMonitor.captureGpuStats();
    }

    /**
     * 렌더링 전 disposed된 텍스처를 가진 머티리얼 정리
     * Three.js에서 texture.map이 disposed되었지만 참조가 남아있으면 렌더링 에러 발생
     */
    function cleanupDisposedMaterials() {
        // 화재/범죄/의료 이펙트 그룹 정리
        if (fireEffectsGroup) {
            fireEffectsGroup.traverse((child) => {
                if (child.material) {
                    // map이 있지만 disposed된 경우 (source와 image 둘 다 없음)
                    if (child.material.map && !child.material.map.source && !child.material.map.image) {
                        child.material.map = null;
                        child.material.needsUpdate = true;
                    }
                }
            });
        }
    }

    /* =========================================================
     * INIT
     * ========================================================= */
    // 건물 모델 로드
    await loadAllBuildingModels();

    await loadMapData();
    updateCurrencySymbols();
    i18n.applyTranslations();

    // 초기 도로 연결 상태 체크
    updateRoadConnectivity();

    // 초기 환경 설정
    updateEnvironment();

    loadingEl.classList.add('hidden');
    // 저장된 카메라 상태가 복원되지 않은 경우에만 인트로 애니메이션 시작
    if (!cameraRestoredFromSave) {
        startCameraIntro();  // 카메라 줌인 애니메이션 시작
    }
    animate();

    // 교통 시스템 초기화 (비동기 - 게임 시작 후 백그라운드에서)
    setTimeout(() => {
        trafficManager.init().catch(e => console.error('Traffic init error:', e));
    }, 1000);

    // 전력망 시스템 초기화
    setTimeout(() => {
        powerManager.init();
        powerManager.recalculatePowerGrid();
    }, 500);

    // 수도 시스템 초기화
    setTimeout(() => {
        waterManager.init();
        waterManager.recalculateWaterGrid();
    }, 600);

    // 하수 시스템 초기화
    setTimeout(() => {
        sewageManager.init();
        sewageManager.recalculateSewageGrid();
    }, 700);

    // 바다 하수 방류 시스템 초기화
    setTimeout(() => {
        oceanSewageSystem.init();
        // 기존 하수처리장들의 방류 지점 등록
        sewageManager.sewageFacilities.forEach((facility, key) => {
            oceanSewageSystem.addDischargePoint(facility.x, facility.y, facility);
        });
    }, 800);

    // 서비스 건물 상태 관리자 초기화
    setTimeout(() => {
        serviceBuildingManager.init();
    }, 900);

    /* =========================================================
     * CITIZEN SNS FEED SYSTEM
     * 시민들의 SNS 피드 시스템 - 이벤트 기반 유쾌한 댓글
     * ========================================================= */
    const CitizenSNS = {
        posts: [],
        maxPosts: 15,
        unreadCount: 0,
        isCollapsed: false,

        // 시민 이름 풀
        firstNames: ['김', '이', '박', '최', '정', '강', '조', '윤', '장', '임', '한', '오', '서', '신', '권', '황', '안', '송', '류', '홍'],
        lastNames: ['민준', '서연', '예준', '서윤', '도윤', '지우', '시우', '하윤', '주원', '지호', '지유', '하준', '수아', '예원', '지민', '채원', '현우', '수빈', '지현', '유진'],

        // 아바타 이모지
        avatars: ['👨', '👩', '👴', '👵', '🧑', '👱', '👨‍🦰', '👩‍🦰', '👨‍🦱', '👩‍🦱', '🧔', '👲', '🧕', '👳‍♂️', '👳‍♀️'],

        // 이벤트별 댓글 템플릿 (비꼬기/유쾌)
        comments: {
            // 전기 관련
            noPower: {
                type: 'negative',
                messages: [
                    "전기가 없어서 살 수가 없어요 완전 원시시대 같네요 🕯️",
                    "촛불 키고 살아야 하나... 로맨틱하긴 한데 너무 로맨틱해요 😅",
                    "핸드폰 충전 어디서 해요? 카페 가야하나... 아 카페도 전기 없겠네 ☠️",
                    "에어컨 없이 여름나기 챌린지 시작합니다 (비자발적) 🥵",
                    "냉장고 음식 다 상했어요... 다이어트 강제 시작 🥗",
                    "암흑시대 체험 중입니다. 별로 재미없어요 ⭐",
                    "발전소 하나만... 제발... 🙏"
                ]
            },
            powerRestored: {
                type: 'positive',
                messages: [
                    "전기 들어왔다!!! 문명의 맛이란 이런 거구나 💡",
                    "드디어 에어컨! 시장님 사랑해요 ❤️",
                    "냉장고야 반가워... 이제 아이스크림 먹을 수 있어 🍦",
                    "충전기 꽂는 순간의 행복을 아시나요 🔋",
                    "빛이 있으라 하시매 빛이 있었고, 그것이 좋았더라 ✨"
                ]
            },

            // 물 관련
            noWater: {
                type: 'negative',
                messages: [
                    "물이 안 나와요... 샤워는 언제 하죠? 🚿",
                    "생수 사재기 시작합니다 💧",
                    "화장실 물이 안 내려가요... 더 이상의 자세한 설명은 생략 🚽",
                    "라면 끓일 물도 없어요 ㅠㅠ 이게 나라냐 🍜",
                    "사막에 사는 기분이에요. 근데 사막은 낭만이라도 있잖아요 🏜️"
                ]
            },
            waterRestored: {
                type: 'positive',
                messages: [
                    "물 나온다!!! 샤워 1시간 해야지 🚿✨",
                    "세탁기 3번 돌립니다. 밀린 빨래가... 🧺",
                    "물 콸콸 나오는 소리가 이렇게 아름다울 줄이야 💧",
                    "드디어 라면 끓일 수 있어요! 🍜"
                ]
            },

            // 화재 관련
            fireStart: {
                type: 'negative',
                messages: [
                    "불이야!!! 🔥🔥🔥 빨리 와주세요!!!",
                    "옆집에 불났어요!!! 소방차 어디 있어요?! 😱",
                    "연기 냄새 나는데... 설마... 🔥",
                    "바베큐 파티 아닙니다! 진짜 불이에요!! 🚒"
                ]
            },
            fireExtinguished: {
                type: 'positive',
                messages: [
                    "소방관 아저씨들 최고예요!!! 🚒💕",
                    "휴... 살았다... 소방서 감사합니다 🙏",
                    "불 다 꺼졌어요! 소방관분들 밥 사드리고 싶네요 🍚",
                    "우리 동네 소방서 반응속도 미쳤다 👍"
                ]
            },
            fireBurnout: {
                type: 'negative',
                messages: [
                    "집이 다 탔어요... 소방차는 어디 있었던 거예요 😭",
                    "폐허가 됐네요... 이사 가야겠어요 🏚️",
                    "보험 들어놓길 잘했다... 😢"
                ]
            },

            // 치안 관련
            noPolice: {
                type: 'warning',
                messages: [
                    "밤에 무서워서 못 다니겠어요... 경찰서 좀 지어주세요 👮",
                    "우리 동네 치안이 불안해요 ㅠㅠ",
                    "CCTV라도 있으면 좋겠는데... 📹",
                    "밤에 편의점 가기 무서워요 🌙"
                ]
            },
            policeHelp: {
                type: 'positive',
                messages: [
                    "어제도 경찰 아저씨가 구해줬어요! 👮‍♂️💪",
                    "경찰서 생기고 마음이 편해졌어요 😊",
                    "순찰 자주 도시니까 안심이 되네요 🚔",
                    "우리 동네 경찰분들 너무 친절해요 ❤️"
                ]
            },

            // 소방서 관련
            noFireStation: {
                type: 'warning',
                messages: [
                    "소방서가 너무 멀어요... 화재나면 어쩌죠? 🔥",
                    "소방차 오는데 30분 걸린대요... 🚒💨",
                    "우리 동네도 소방서 하나만... 🙏"
                ]
            },
            fireStationBuilt: {
                type: 'positive',
                messages: [
                    "소방서 생겼다! 이제 안심이에요 🚒",
                    "소방관 아저씨들 환영합니다~ 👨‍🚒",
                    "화재 걱정 덜었네요! 시장님 감사해요 🙏"
                ]
            },

            // 병원 관련
            noHospital: {
                type: 'warning',
                messages: [
                    "병원이 없어서 아프면 큰일이에요... 🏥",
                    "응급실 가려면 30분 운전해야 해요 😰",
                    "약국이라도 있으면 좋겠어요 💊"
                ]
            },
            hospitalBuilt: {
                type: 'positive',
                messages: [
                    "병원 생겼다! 건강검진 받으러 가야지 🏥",
                    "의사 선생님들 환영해요~ 👨‍⚕️👩‍⚕️",
                    "이제 아파도 괜찮아요! (아프진 말아야지) 💪"
                ]
            },

            // 학교 관련
            noSchool: {
                type: 'warning',
                messages: [
                    "애들 학교 보내려면 버스 타고 1시간이에요 🚌",
                    "학교 좀 지어주세요! 아이들이 불쌍해요 📚",
                    "교육열 높은 부모인데... 학교가 없네요 😅"
                ]
            },
            schoolBuilt: {
                type: 'positive',
                messages: [
                    "학교 생겼다! 우리 애 걸어서 통학 가능! 🏫",
                    "선생님들 환영합니다~ 잘 부탁드려요 👨‍🏫",
                    "드디어 교육 인프라가! 시장님 최고 📚"
                ]
            },

            // 공원 관련
            noPark: {
                type: 'warning',
                messages: [
                    "산책할 데가 없어요... 공원 하나만요 🌳",
                    "아이들 뛰어놀 곳이 없어요 🧒",
                    "운동하고 싶은데 공원이 없네요 🏃"
                ]
            },
            parkBuilt: {
                type: 'positive',
                messages: [
                    "공원 생겼다! 오늘부터 매일 조깅이다 🏃‍♂️",
                    "아이들이 너무 좋아해요! 감사합니다 🌳",
                    "드디어 산책할 수 있어요! 🚶‍♀️💕",
                    "벚꽃 심어주시면 안 될까요? 🌸 (욕심)"
                ]
            },

            // 행복도 관련
            lowHappiness: {
                type: 'negative',
                messages: [
                    "여기 살기 너무 힘들어요... 이사 고민 중 😢",
                    "행복하지 않아요... 뭔가 부족해요 😔",
                    "다른 도시로 이사갈까 봐요 📦",
                    "월세는 비싼데 인프라는 없고... 🏠"
                ]
            },
            highHappiness: {
                type: 'positive',
                messages: [
                    "우리 동네 최고예요! 이사 안 가요! 💕",
                    "살기 좋은 도시에서 산다는 건 축복이에요 ✨",
                    "시장님 덕분에 행복합니다! 다음 선거도 찍을게요 🗳️",
                    "친구들한테 우리 동네 자랑했어요 😊"
                ]
            },

            // 도로 관련
            noRoad: {
                type: 'negative',
                messages: [
                    "도로가 없어서 출근을 못 해요... 🚗❌",
                    "차가 들어올 수가 없어요! 고립됐어요 😱",
                    "배달도 안 오고... 도로 좀 내주세요 🛣️"
                ]
            },

            // 치안 이벤트 - 강도/범죄 관련
            crimeHandled: {
                type: 'positive',
                messages: [
                    "경찰이 강도를 잡았대요! 아주 든든해요 💪👮",
                    "범인 검거 소식 들었어요! 우리 경찰 최고 🚔✨",
                    "순찰 덕분에 범죄가 줄었대요! 안심이에요 😊",
                    "어젯밤 소란이 있었는데 경찰이 바로 출동! 👍",
                    "우리 동네 치안 완전 좋아요~ 경찰서 덕분! 🛡️"
                ]
            },
            crimeFailed: {
                type: 'negative',
                messages: [
                    "이 도시는 치안이란게 없나요? 범죄자가 활개치고 다녀요 😠",
                    "도둑 맞았는데 경찰이 안 와요... 신고해도 소용없네 😤",
                    "밤에 무서워서 못 다니겠어요. 경찰은 어디 있는 거예요? 😰",
                    "우리 동네 치안 불안해서 이사 고민 중... 📦",
                    "범죄율이 너무 높아요! 경찰서 좀 지어주세요! 🚨"
                ]
            },

            // 교통 관련
            trafficJam: {
                type: 'warning',
                messages: [
                    "출퇴근 시간 도로가 꽉 막혀요... 🚗🚗🚗",
                    "30분 거리가 2시간 걸렸어요 ㅠㅠ 🕐",
                    "이 도시 교통 체증 심각해요! 도로 확장 필요! 🛣️",
                    "버스가 제시간에 안 와요... 막혀서 😤"
                ]
            },

            // 인구/발전 관련
            populationGrowth: {
                type: 'positive',
                messages: [
                    "새 이웃이 이사왔어요! 환영합니다~ 🏠",
                    "우리 동네 인기 많아지는 것 같아요! 🌟",
                    "살기 좋아서 사람들이 몰려온대요 😊",
                    "집값 오르기 전에 잘 샀다~ 🏡💰"
                ]
            },
            populationDecline: {
                type: 'negative',
                messages: [
                    "이웃이 이사갔어요... 왜들 떠나는 걸까 😢",
                    "빈집이 늘어나고 있어요. 동네가 쇠락하는 건가... 🏚️",
                    "사람들이 떠나니 가게들도 문 닫아요 😔"
                ]
            },

            // 건물 레벨업/발전
            buildingUpgrade: {
                type: 'positive',
                messages: [
                    "옆집이 새로 리모델링 했어요! 멋지다 🏢✨",
                    "우리 동네 건물들이 점점 좋아지네요! 🌆",
                    "고급 아파트가 들어섰어요! 동네 품격 상승 📈"
                ]
            },

            // 환경/오염 관련
            pollutionHigh: {
                type: 'negative',
                messages: [
                    "공기가 안 좋아요... 마스크 필수 😷",
                    "하수 냄새가 나요 ㅠㅠ 하수처리장이 필요해요 🤢",
                    "공장 연기 때문에 빨래도 못 널어요 🏭💨"
                ]
            },
            pollutionLow: {
                type: 'positive',
                messages: [
                    "공기가 맑아서 기분 좋아요! 🌿",
                    "환경이 깨끗해져서 산책하기 좋네요 🚶‍♂️",
                    "우리 도시 친환경 도시 되는 건가요? 🌱"
                ]
            }
        },

        init() {
            this.feedContent = document.getElementById('snsFeedContent');
            this.badge = document.getElementById('snsBadge');
            this.header = document.getElementById('snsHeader');
            this.panel = document.getElementById('citizenSnsFeed');

            if (!this.feedContent || !this.panel) return;

            // 헤더 클릭으로 접기/펼치기
            this.header.addEventListener('click', () => this.toggleCollapse());

            // 이벤트 기반으로만 포스트 생성 (랜덤 포스트 제거)
            // 게임 내 실제 이벤트 발생 시에만 onEvent() 호출로 포스트 추가

            console.log('[CitizenSNS] 시민 SNS 피드 초기화 완료 (이벤트 기반)');
        },

        toggleCollapse() {
            this.isCollapsed = !this.isCollapsed;
            this.panel.classList.toggle('collapsed', this.isCollapsed);

            if (!this.isCollapsed) {
                // 펼쳤을 때 읽음 처리
                this.unreadCount = 0;
                this.updateBadge();
            }
        },

        updateBadge() {
            if (this.unreadCount > 0) {
                this.badge.textContent = this.unreadCount > 9 ? '9+' : this.unreadCount;
                this.badge.style.display = 'inline';
            } else {
                this.badge.style.display = 'none';
            }
        },

        generateCitizenName() {
            const first = this.firstNames[Math.floor(Math.random() * this.firstNames.length)];
            const last = this.lastNames[Math.floor(Math.random() * this.lastNames.length)];
            return first + last;
        },

        generateAvatar() {
            return this.avatars[Math.floor(Math.random() * this.avatars.length)];
        },

        getRandomMessage(eventType) {
            const eventData = this.comments[eventType];
            if (!eventData) return null;

            const messages = eventData.messages;
            return {
                message: messages[Math.floor(Math.random() * messages.length)],
                type: eventData.type
            };
        },

        formatTime(date) {
            const now = new Date();
            const diff = Math.floor((now - date) / 1000);

            if (diff < 60) return '방금 전';
            if (diff < 3600) return Math.floor(diff / 60) + '분 전';
            if (diff < 86400) return Math.floor(diff / 3600) + '시간 전';
            return Math.floor(diff / 86400) + '일 전';
        },

        addPost(eventType, location = null) {
            const msgData = this.getRandomMessage(eventType);
            if (!msgData) return;

            const post = {
                id: Date.now(),
                name: this.generateCitizenName(),
                avatar: this.generateAvatar(),
                message: msgData.message,
                type: msgData.type,
                location: location || this.generateLocation(),
                time: new Date(),
                likes: Math.floor(Math.random() * 50),
                comments: Math.floor(Math.random() * 10)
            };

            // 포스트 추가 (최신이 위로)
            this.posts.unshift(post);

            // 최대 개수 유지
            if (this.posts.length > this.maxPosts) {
                this.posts.pop();
            }

            // 읽지 않은 개수 증가 (접혀있을 때만)
            if (this.isCollapsed) {
                this.unreadCount++;
                this.updateBadge();
            }

            this.render();
        },

        generateLocation() {
            const areas = ['중앙구', '동부', '서부', '남부', '북부', '신도시', '구시가지', '해안가', '언덕마을', '강변'];
            const types = ['아파트', '빌라', '주택가', '상가', '오피스텔'];
            return areas[Math.floor(Math.random() * areas.length)] + ' ' +
                   types[Math.floor(Math.random() * types.length)];
        },

        render() {
            if (!this.feedContent) return;

            if (this.posts.length === 0) {
                this.feedContent.innerHTML = `
                    <div class="sns-empty">
                        <div class="sns-empty-icon">🏙️</div>
                        <div>아직 시민들의 이야기가 없습니다</div>
                    </div>
                `;
                return;
            }

            this.feedContent.innerHTML = this.posts.map(post => `
                <div class="sns-post ${post.type}">
                    <div class="sns-post-header">
                        <div class="sns-avatar">${post.avatar}</div>
                        <div class="sns-user-info">
                            <div class="sns-username">${post.name}</div>
                            <div class="sns-location">📍 ${post.location}</div>
                        </div>
                    </div>
                    <div class="sns-post-content">${post.message}</div>
                    <div class="sns-post-footer">
                        <div class="sns-post-time">🕐 ${this.formatTime(post.time)}</div>
                        <div class="sns-post-reactions">
                            <span class="sns-reaction">❤️ ${post.likes}</span>
                            <span class="sns-reaction">💬 ${post.comments}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        },

        // 외부에서 호출하는 이벤트 트리거 (게임 이벤트 기반)
        onEvent(eventType, location = null) {
            this.addPost(eventType, location);
        }
    };

    // SNS 시스템 초기화
    setTimeout(() => {
        CitizenSNS.init();
    }, 1000);

    /* =========================================================
     * ANTI-CHEAT (클라이언트 측 - UX용, 실제 보안은 서버)
     * ========================================================= */
    // 참고: Object.freeze()는 정상 게임 동작을 방해하므로 제거
    // 실제 보안은 서버의 GameSecurityService에서 처리

    // 콘솔 경고
    console.log('%c⚠️ 경고!', 'color: red; font-size: 30px; font-weight: bold;');
    console.log('%c이 콘솔을 사용하여 게임 데이터를 조작하면 계정이 제재될 수 있습니다.',
        'color: red; font-size: 14px;');
    console.log('%c모든 게임 데이터는 서버에서 검증됩니다.',
        'color: gray; font-size: 12px;');

</script>
</body>
</html>
