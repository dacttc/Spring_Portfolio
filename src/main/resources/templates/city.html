<!doctype html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title th:text="${mapUsername} + '\'s City'">City</title>
    <script src="/js/i18n.js"></script>

    <style>
        /* 반응형 UI 스케일 변수 */
        :root {
            --ui-scale: 1;
            --font-xs: calc(9px * var(--ui-scale));
            --font-sm: calc(11px * var(--ui-scale));
            --font-md: calc(13px * var(--ui-scale));
            --font-lg: calc(16px * var(--ui-scale));
            --font-xl: calc(20px * var(--ui-scale));
            --font-2xl: calc(24px * var(--ui-scale));
            --font-3xl: calc(32px * var(--ui-scale));
            --spacing-xs: calc(4px * var(--ui-scale));
            --spacing-sm: calc(8px * var(--ui-scale));
            --spacing-md: calc(12px * var(--ui-scale));
            --spacing-lg: calc(16px * var(--ui-scale));
            --spacing-xl: calc(24px * var(--ui-scale));
            --btn-size-sm: calc(32px * var(--ui-scale));
            --btn-size-md: calc(40px * var(--ui-scale));
            --btn-size-lg: calc(50px * var(--ui-scale));
            --icon-size-sm: calc(18px * var(--ui-scale));
            --icon-size-md: calc(24px * var(--ui-scale));
            --icon-size-lg: calc(32px * var(--ui-scale));
            --bar-height: calc(40px * var(--ui-scale));
            --toolbar-height: calc(60px * var(--ui-scale));
            --panel-width: calc(300px * var(--ui-scale));
            --border-radius: calc(6px * var(--ui-scale));
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: #f5f5f5;
            font-size: var(--font-md);
            /* 텍스트 선택 및 드래그 금지 */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ===== TOP BAR (Cities Skylines Style - White Theme) ===== */
        #topBar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--bar-height);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.96) 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-md);
            z-index: 1000;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .top-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .menu-btn {
            width: var(--btn-size-sm);
            height: var(--btn-size-sm);
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: var(--border-radius);
            color: #333;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .menu-btn:hover {
            background: linear-gradient(180deg, #f5f5f5, #e8e8e8);
            border-color: rgba(0, 0, 0, 0.2);
        }

        .top-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: var(--spacing-lg);
        }

        .city-name-display {
            background: linear-gradient(180deg, #ffffff, #f5f5f5);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius);
            padding: var(--spacing-xs) var(--spacing-xl);
            color: #333;
            font-size: var(--font-md);
            font-weight: 600;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        }

        .top-right {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .top-btn {
            padding: var(--spacing-xs) var(--spacing-md);
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius);
            color: #555;
            font-size: var(--font-sm);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        }

        .top-btn:hover {
            background: linear-gradient(180deg, #f0f0f0, #e5e5e5);
            color: #333;
            border-color: rgba(0, 0, 0, 0.15);
        }

        /* ===== BGM CONTROLS ===== */
        .bgm-btn {
            width: var(--btn-size-sm);
            height: var(--btn-size-sm);
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: var(--border-radius);
            color: #555;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        }

        .bgm-btn:hover {
            background: linear-gradient(180deg, #f0f0f0, #e0e0e0);
            border-color: rgba(0, 0, 0, 0.2);
        }

        .bgm-btn.playing {
            background: linear-gradient(180deg, #e8f5e9, #c8e6c9);
            border-color: #4caf50;
            color: #2e7d32;
        }

        .bgm-volume-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .bgm-volume-slider {
            width: 0;
            opacity: 0;
            transition: width 0.3s, opacity 0.3s;
            -webkit-appearance: none;
            appearance: none;
            height: calc(4px * var(--ui-scale));
            background: linear-gradient(to right, #4caf50 0%, #ddd 0%);
            border-radius: calc(2px * var(--ui-scale));
            cursor: pointer;
        }

        .bgm-volume-container:hover .bgm-volume-slider,
        .bgm-volume-slider:focus {
            width: calc(80px * var(--ui-scale));
            opacity: 1;
        }

        .bgm-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: calc(12px * var(--ui-scale));
            height: calc(12px * var(--ui-scale));
            background: #4caf50;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .bgm-volume-slider::-moz-range-thumb {
            width: calc(12px * var(--ui-scale));
            height: calc(12px * var(--ui-scale));
            background: #4caf50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        /* ===== BOTTOM BAR (Main Toolbar - White Theme) ===== */
        #bottomBar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: calc(90px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.99) 100%);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.06);
        }

        /* Left section - Game info */
        .bottom-left {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-sm) var(--spacing-lg);
            min-width: calc(200px * var(--ui-scale));
        }

        .game-speed {
            display: flex;
            gap: var(--spacing-xs);
        }

        .speed-btn {
            width: var(--btn-size-sm);
            height: var(--btn-size-sm);
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: calc(5px * var(--ui-scale));
            color: #666;
            font-size: var(--font-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .speed-btn:hover:not(.active) {
            background: linear-gradient(180deg, #f0f0f0, #e0e0e0);
            color: #333;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .speed-btn.active {
            background: linear-gradient(180deg, #4a90c2, #3a7aaa);
            color: #fff;
            border-color: #3a7aaa;
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .date-display {
            background: linear-gradient(180deg, #e8f4ff, #d8ecff);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: calc(5px * var(--ui-scale));
            padding: var(--spacing-xs) var(--spacing-sm);
            color: #2563eb;
            font-size: var(--font-md);
            font-family: 'Consolas', monospace;
        }

        .clock-display {
            background: linear-gradient(180deg, #fef3e2, #fde8c8);
            border: 1px solid rgba(245, 158, 11, 0.25);
            border-radius: calc(5px * var(--ui-scale));
            padding: var(--spacing-xs) var(--spacing-sm);
            color: #d97706;
            font-size: var(--font-md);
            font-family: 'Consolas', monospace;
        }

        /* RCI Demand Bar - 세로 방향 */
        .rci-demand-bar {
            display: flex;
            flex-direction: row;
            gap: var(--spacing-xs);
            background: linear-gradient(180deg, #ffffff, #f8f9fa);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius);
            padding: var(--spacing-sm) var(--spacing-md);
            margin-left: var(--spacing-md);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .rci-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .rci-label {
            font-size: var(--font-xs);
            font-weight: bold;
            text-align: center;
        }

        .rci-item.residential .rci-label { color: #4ade80; }
        .rci-item.commercial .rci-label { color: #60a5fa; }
        .rci-item.industrial .rci-label { color: #fbbf24; }

        /* City Happiness Display */
        .city-happiness {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            background: linear-gradient(180deg, #ffffff, #f8f9fa);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius);
            padding: var(--spacing-sm) var(--spacing-md);
            margin-left: var(--spacing-md);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .happiness-icon {
            font-size: var(--font-xl);
            line-height: 1;
        }

        .happiness-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
        }

        .happiness-label {
            font-size: var(--font-xs);
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .happiness-value {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .happiness-number {
            font-size: var(--font-lg);
            font-weight: bold;
            color: #333;
            min-width: calc(32px * var(--ui-scale));
            font-family: 'Consolas', monospace;
        }

        /* 행복도 색상은 JavaScript에서 동적으로 설정 */

        .happiness-trend {
            font-size: var(--font-sm);
            opacity: 0.8;
        }

        .happiness-trend.up { color: #4ade80; }
        .happiness-trend.down { color: #f87171; }
        .happiness-trend.stable { color: #888; }

        .rci-bar-container {
            width: 14px;
            height: 50px;
            background: #e8e8e8;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .rci-bar-center {
            position: absolute;
            left: 0;
            top: 50%;
            width: 100%;
            height: 1px;
            background: rgba(0, 0, 0, 0.2);
            z-index: 2;
        }

        .rci-bar-positive {
            position: absolute;
            left: 2px;
            bottom: 50%;
            width: calc(100% - 4px);
            background: linear-gradient(0deg, #22c55e, #4ade80);
            border-radius: 2px;
            transition: height 0.3s ease;
            z-index: 1;
        }

        .rci-bar-negative {
            position: absolute;
            left: 2px;
            top: 50%;
            width: calc(100% - 4px);
            background: linear-gradient(180deg, #ef4444, #f87171);
            border-radius: 2px;
            transition: height 0.3s ease;
            z-index: 1;
        }

        .rci-item.commercial .rci-bar-positive {
            background: linear-gradient(0deg, #3b82f6, #60a5fa);
        }

        .rci-item.industrial .rci-bar-positive {
            background: linear-gradient(0deg, #f59e0b, #fbbf24);
        }

        /* Center section - Main tools */
        .bottom-center {
            flex: 1;
            display: flex;
            justify-content: center;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
            padding: calc(5px * var(--ui-scale)) 0;
        }

        .tool-btn {
            width: calc(62px * var(--ui-scale));
            height: calc(62px * var(--ui-scale));
            background: linear-gradient(180deg, #ffffff, #f0f0f0);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: calc(12px * var(--ui-scale));
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        .tool-btn:hover:not(.active) {
            background: linear-gradient(180deg, #f5f5f5, #e8e8e8);
            border-color: rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .tool-btn.active {
            background: linear-gradient(180deg, #3b82f6, #2563eb);
            border-color: #1d4ed8;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .tool-btn.active:hover {
            background: linear-gradient(180deg, #4a93f7, #3b7de8);
            transform: translateY(-2px);
        }

        .tool-btn .icon {
            font-size: calc(30px * var(--ui-scale));
        }

        .tool-btn.dirty {
            background: linear-gradient(180deg, #fef3c7, #fde68a);
            border-color: #f59e0b;
        }

        .save-btn.dirty {
            animation: pulse-save 1.5s infinite;
        }

        @keyframes pulse-save {
            0%, 100% { box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3); }
            50% { box-shadow: 0 4px 16px rgba(245, 158, 11, 0.6); }
        }

        .tool-divider {
            width: 2px;
            height: calc(50px * var(--ui-scale));
            background: rgba(0, 0, 0, 0.1);
            margin: 0 var(--spacing-md);
            border-radius: 1px;
        }

        /* Circular demolish button */
        .demolish-btn {
            width: calc(70px * var(--ui-scale));
            height: calc(70px * var(--ui-scale));
            background: linear-gradient(180deg, #dc2626, #991b1b);
            border: 3px solid rgba(255, 100, 100, 0.4);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: var(--spacing-lg);
            flex-shrink: 0;
        }

        .demolish-btn:hover {
            background: linear-gradient(180deg, #ef4444, #b91c1c);
            border-color: rgba(255, 150, 150, 0.6);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.5);
        }

        .demolish-btn.active {
            background: linear-gradient(180deg, #f87171, #dc2626);
            border-color: #fca5a5;
            box-shadow: 0 0 25px rgba(255, 100, 100, 0.7);
        }

        .demolish-btn .icon {
            font-size: var(--icon-size-lg);
        }

        .stats-row {
            display: flex;
            gap: var(--spacing-sm);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-lg);
            background: linear-gradient(180deg, #ffffff, #f8f9fa);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--spacing-sm);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .stat-item .icon {
            font-size: var(--font-2xl);
        }

        .stat-item .value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-family: 'Consolas', monospace;
        }

        .stat-item.money .value { color: #4f8; }
        .stat-item.population .value { color: #8af; }
        .stat-item.happiness .value { color: #fa4; }

        .stat-item .change {
            font-size: var(--font-md);
            margin-left: var(--spacing-xs);
        }

        .stat-item .change.positive { color: #4f8; }
        .stat-item .change.negative { color: #f44; }

        /* Central Money Display (White Theme) */
        .money-display-center {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            background: linear-gradient(180deg, #ecfdf5, #d1fae5);
            border: 2px solid rgba(34, 197, 94, 0.4);
            border-radius: 25px;
            margin-left: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.15s;
        }

        .money-display-center:hover {
            background: linear-gradient(180deg, #d1fae5, #a7f3d0);
            border-color: rgba(34, 197, 94, 0.6);
            transform: scale(1.02);
        }

        .money-display-center .money-icon {
            font-size: 28px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .money-display-center .money-amount {
            font-size: 26px;
            font-weight: 700;
            color: #166534;
            font-family: 'Consolas', 'Segoe UI', monospace;
            letter-spacing: 1px;
        }

        .money-display-center .money-rate {
            font-size: 13px;
            font-weight: 600;
            color: #15803d;
            padding: 3px 8px;
            background: rgba(34, 197, 94, 0.15);
            border-radius: 10px;
            font-family: 'Consolas', monospace;
        }

        .money-display-center .money-rate.negative {
            color: #dc2626;
            background: rgba(239, 68, 68, 0.15);
        }

        /* Population Display (White Theme) */
        .population-display-center {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            background: linear-gradient(180deg, #eff6ff, #dbeafe);
            border: 2px solid rgba(59, 130, 246, 0.4);
            border-radius: 25px;
            margin-left: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.15s;
        }

        .population-display-center:hover {
            background: linear-gradient(180deg, #dbeafe, #bfdbfe);
            border-color: rgba(59, 130, 246, 0.6);
            transform: scale(1.02);
        }

        .population-display-center .pop-icon {
            font-size: 28px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .population-display-center .pop-amount {
            font-size: 26px;
            font-weight: 700;
            color: #1e40af;
            font-family: 'Consolas', 'Segoe UI', monospace;
            letter-spacing: 1px;
        }

        .population-display-center .pop-label {
            font-size: 13px;
            font-weight: 600;
            color: #2563eb;
            padding: 3px 8px;
            background: rgba(59, 130, 246, 0.15);
            border-radius: 10px;
            font-family: 'Consolas', monospace;
        }

        /* Population Panel (White Theme) */
        #populationPanel {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            background: linear-gradient(180deg, #ffffff, #f8fafc);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 16px;
            padding: 0;
            min-width: 380px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 1001;
        }

        #populationPanel.open {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) scale(1);
        }

        .pop-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: linear-gradient(180deg, #eff6ff, #dbeafe);
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 14px 14px 0 0;
        }

        .pop-panel-header .panel-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .pop-panel-header .panel-title {
            font-size: 18px;
            font-weight: 700;
            color: #1e40af;
            flex: 1;
        }

        .pop-panel-header .panel-close {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 24px;
            cursor: pointer;
            padding: 0 8px;
            transition: color 0.2s;
        }

        .pop-panel-header .panel-close:hover {
            color: #1f2937;
        }

        .pop-panel-content {
            padding: 16px;
        }

        .pop-stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .pop-stat-card {
            background: rgba(59, 130, 246, 0.08);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            border: 1px solid rgba(59, 130, 246, 0.1);
        }

        .pop-stat-card.full-width {
            grid-column: 1 / -1;
        }

        .pop-stat-card .stat-icon {
            font-size: 32px;
            margin-bottom: 6px;
        }

        .pop-stat-card .stat-label {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .pop-stat-card .stat-value {
            font-size: 22px;
            font-weight: 700;
            color: #1e40af;
            font-family: 'Consolas', monospace;
        }

        .pop-stat-card .stat-percent {
            font-size: 12px;
            color: #3b82f6;
            margin-top: 4px;
        }

        .pop-tier-section {
            margin-top: 16px;
        }

        .pop-tier-section .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 10px;
        }

        .pop-tier-bar {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .pop-tier-bar .tier-icon {
            font-size: 20px;
            width: 36px;
        }

        .pop-tier-bar .tier-label {
            font-size: 13px;
            color: #4b5563;
            width: 70px;
        }

        .pop-tier-bar .tier-bar-bg {
            flex: 1;
            height: 20px;
            background: rgba(0, 0, 0, 0.08);
            border-radius: 10px;
            overflow: hidden;
            margin: 0 10px;
        }

        .pop-tier-bar .tier-bar-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .pop-tier-bar .tier-bar-fill.middle {
            background: linear-gradient(90deg, #4a9eff, #66b3ff);
        }

        .pop-tier-bar .tier-bar-fill.high {
            background: linear-gradient(90deg, #ffc107, #ffca28);
        }

        .pop-tier-bar .tier-value {
            font-size: 14px;
            font-weight: 600;
            color: #1f2937;
            width: 70px;
            text-align: right;
            font-family: 'Consolas', monospace;
        }

        /* ===== SUB MENU (White Theme) ===== */
        #subMenu {
            position: fixed;
            bottom: 146px;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.99) 0%, rgba(248, 250, 252, 0.99) 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-bottom: none;
            border-radius: 16px 16px 0 0;
            padding: 20px 25px;
            z-index: 999;
            opacity: 0;
            transition: all 0.25s ease;
            pointer-events: none;
            min-width: 400px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
        }

        #subMenu.open {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .submenu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: calc(10px * var(--ui-scale));
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .submenu-title {
            color: #1f2937;
            font-size: var(--font-md);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .submenu-close {
            width: var(--icon-size-md);
            height: var(--icon-size-md);
            background: rgba(0, 0, 0, 0.06);
            border: none;
            border-radius: var(--spacing-xs);
            color: #6b7280;
            cursor: pointer;
            font-size: var(--font-md);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .submenu-close:hover {
            background: rgba(239, 68, 68, 0.15);
            color: #dc2626;
        }

        .submenu-items {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .submenu-item {
            width: calc(100px * var(--ui-scale));
            height: calc(100px * var(--ui-scale));
            background: linear-gradient(180deg, #ffffff, #f5f5f5);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: calc(12px * var(--ui-scale));
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            transition: all 0.15s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .submenu-item:hover {
            background: linear-gradient(180deg, #f0f0f0, #e8e8e8);
            border-color: rgba(59, 130, 246, 0.5);
            transform: scale(1.05);
        }

        .submenu-item.active {
            background: linear-gradient(180deg, #3b82f6, #2563eb);
            border-color: #1d4ed8;
        }

        .submenu-item .color-box {
            width: calc(40px * var(--ui-scale));
            height: calc(40px * var(--ui-scale));
            border-radius: var(--spacing-sm);
            border: 2px solid rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-2xl);
        }

        .submenu-item .name {
            font-size: var(--font-sm);
            color: #4b5563;
            text-align: center;
            font-weight: 600;
        }

        .submenu-item.active .name {
            color: #fff;
        }

        .submenu-item .cost {
            font-size: var(--font-xs);
            color: #059669;
        }

        /* Zone colors */
        .zone-residential { background: #4ade80 !important; }
        .zone-commercial { background: #60a5fa !important; }
        .zone-industrial { background: #fbbf24 !important; }
        .zone-delete { background: #ef4444 !important; }

        /* Disabled submenu item */
        .submenu-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .submenu-item.disabled:hover {
            transform: none;
            border-color: rgba(0, 0, 0, 0.1);
        }

        /* ===== SUBMENU TOOLTIP (White Theme) ===== */
        .submenu-tooltip {
            position: fixed;
            min-width: calc(220px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.99) 0%, rgba(248, 250, 252, 0.99) 100%);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: calc(10px * var(--ui-scale));
            padding: var(--spacing-md) calc(14px * var(--ui-scale));
            z-index: 10000;
            display: none;
            pointer-events: none;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
        }

        .submenu-tooltip .tooltip-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: calc(10px * var(--ui-scale));
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .submenu-tooltip .tooltip-icon {
            font-size: var(--font-xl);
        }

        .submenu-tooltip .tooltip-name {
            font-size: var(--font-md);
            font-weight: 600;
            color: #1f2937;
        }

        .submenu-tooltip .tooltip-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .submenu-tooltip .tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-sm);
        }

        .submenu-tooltip .tooltip-row .label {
            color: #6b7280;
        }

        .submenu-tooltip .tooltip-row .value {
            color: #1f2937;
            font-weight: 500;
        }

        .submenu-tooltip .tooltip-row.maintenance .value {
            color: #dc2626;
        }

        .submenu-tooltip .tooltip-desc {
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            font-size: var(--font-sm);
            color: #6b7280;
            line-height: 1.5;
        }

        /* ===== DAILY STATS PANEL (White Theme) ===== */
        .daily-stats-panel {
            position: fixed;
            bottom: calc(160px * var(--ui-scale));
            left: calc(20px * var(--ui-scale));
            min-width: calc(220px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(248, 250, 252, 0.99) 100%);
            border-radius: calc(12px * var(--ui-scale));
            padding: var(--spacing-lg);
            z-index: 1001;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }

        .daily-stats-panel.fire-panel {
            border: 1px solid rgba(239, 68, 68, 0.4);
        }

        .daily-stats-panel.crime-panel {
            border: 1px solid rgba(59, 130, 246, 0.4);
        }

        .daily-stats-panel.medical-panel {
            border: 1px solid rgba(236, 72, 153, 0.4);
        }

        .daily-stats-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            padding-bottom: calc(10px * var(--ui-scale));
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .daily-stats-header .stat-number {
            font-size: var(--font-3xl);
            font-weight: 700;
            color: #1f2937;
            min-width: calc(50px * var(--ui-scale));
            text-align: center;
        }

        .daily-stats-header .stat-title {
            font-size: var(--font-md);
            color: #6b7280;
            line-height: 1.3;
        }

        .daily-stats-rows {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .daily-stats-row {
            display: flex;
            align-items: center;
            gap: calc(10px * var(--ui-scale));
            font-size: var(--font-md);
        }

        .daily-stats-row .row-number {
            font-size: var(--font-md);
            font-weight: 600;
            color: #fff;
            min-width: calc(30px * var(--ui-scale));
        }

        .daily-stats-row .row-label {
            color: #888;
        }

        .daily-stats-footer {
            margin-top: var(--spacing-md);
            padding-top: calc(10px * var(--ui-scale));
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            font-size: var(--font-sm);
            color: #666;
        }

        /* ===== RIGHT PANEL (Info Panel - Collapsible) ===== */
        #infoPanel {
            position: fixed;
            top: calc(50px * var(--ui-scale));
            right: calc(10px * var(--ui-scale));
            width: calc(280px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(25, 30, 38, 0.95) 0%, rgba(18, 22, 28, 0.98) 100%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: calc(10px * var(--ui-scale));
            z-index: 998;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        #infoPanel.collapsed {
            width: calc(180px * var(--ui-scale));
        }

        #infoPanel.collapsed .panel-content {
            display: none;
        }

        #infoPanel.collapsed .panel-header {
            border-bottom: none;
        }

        .panel-header {
            background: linear-gradient(180deg, #3a4550, #2a3540);
            padding: calc(10px * var(--ui-scale)) calc(15px * var(--ui-scale));
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }

        .panel-header:hover {
            background: linear-gradient(180deg, #4a5560, #3a4550);
        }

        .panel-title {
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        .panel-toggle {
            color: #888;
            font-size: var(--font-sm);
            transition: transform 0.3s ease;
        }

        #infoPanel.collapsed .panel-toggle {
            transform: rotate(-90deg);
        }

        .panel-close {
            width: calc(20px * var(--ui-scale));
            height: calc(20px * var(--ui-scale));
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: var(--font-lg);
        }

        .panel-close:hover {
            color: #fff;
        }

        .panel-content {
            padding: calc(15px * var(--ui-scale));
            max-height: calc(500px * var(--ui-scale));
            overflow-y: auto;
        }

        .panel-stat {
            display: flex;
            justify-content: space-between;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .panel-stat:last-child {
            border-bottom: none;
        }

        .panel-stat .label {
            color: #888;
            font-size: var(--font-sm);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .panel-stat .value {
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        .panel-stat .value.good { color: #4f8; }
        .panel-stat .value.warning { color: #fa4; }
        .panel-stat .value.danger { color: #f44; }

        .panel-section {
            margin-top: calc(15px * var(--ui-scale));
            padding-top: calc(15px * var(--ui-scale));
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-section-title {
            font-size: var(--font-sm);
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: calc(10px * var(--ui-scale));
        }

        /* Earnings box */
        .earnings-box {
            background: linear-gradient(135deg, rgba(0, 200, 100, 0.15), rgba(0, 150, 80, 0.1));
            border: 1px solid rgba(0, 200, 100, 0.3);
            border-radius: var(--spacing-sm);
            padding: var(--spacing-md);
            margin-top: calc(10px * var(--ui-scale));
        }

        .earnings-label {
            font-size: var(--font-xs);
            color: #4f8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .earnings-value {
            font-size: var(--font-xl);
            font-weight: 700;
            color: #4f8;
            margin: calc(5px * var(--ui-scale)) 0;
        }

        .collect-btn {
            width: 100%;
            padding: calc(10px * var(--ui-scale));
            background: linear-gradient(180deg, #3a8060, #2a6050);
            border: 1px solid rgba(100, 255, 150, 0.3);
            border-radius: var(--border-radius);
            color: #fff;
            font-weight: 600;
            font-size: var(--font-sm);
            cursor: pointer;
            transition: all 0.2s;
        }

        .collect-btn:hover {
            background: linear-gradient(180deg, #4a9070, #3a7060);
            transform: translateY(-1px);
        }

        /* ===== TOAST ===== */
        #toastRoot {
            position: fixed;
            top: 50%;
            right: calc(20px * var(--ui-scale));
            transform: translateY(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(180deg, rgba(40, 45, 55, 0.98), rgba(30, 35, 45, 0.99));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--spacing-sm);
            padding: var(--spacing-md) var(--spacing-xl);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transform: translateX(100px);
            opacity: 0;
            animation: toastIn 0.3s ease forwards;
        }

        @keyframes toastIn {
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.out {
            animation: toastOut 0.3s ease forwards;
        }

        @keyframes toastOut {
            to {
                transform: translateX(100px);
                opacity: 0;
            }
        }

        .toast .icon {
            width: var(--btn-size-sm);
            height: var(--btn-size-sm);
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-lg);
            font-weight: 700;
        }

        .toast .icon.success {
            background: rgba(100, 255, 150, 0.2);
            color: #4f8;
        }

        .toast .icon.error {
            background: rgba(255, 100, 100, 0.2);
            color: #f66;
        }

        .toast .body .title {
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        .toast .body .desc {
            color: #ffffff;
            font-size: var(--font-sm);
            margin-top: 2px;
        }

        /* ===== HINT ===== */
        #hintContainer {
            position: fixed;
            bottom: calc(156px * var(--ui-scale));
            left: 50%;
            transform: translateX(-50%);
            display: none;  /* 기본적으로 숨김 - 전력 건물 설치 모드에서만 표시 */
            align-items: center;
            gap: var(--spacing-sm);
            z-index: 10;
            transition: bottom 0.25s ease, opacity 0.25s ease;
        }

        #hintContainer.visible {
            display: flex;
        }

        #hint {
            padding: var(--spacing-sm) var(--spacing-xl);
            background: rgba(0, 0, 0, 0.8);
            border-radius: calc(25px * var(--ui-scale));
            color: rgba(255, 255, 255, 0.9);
            font-size: var(--font-lg);
        }

        #btnExitMode {
            display: none;
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 80, 80, 0.9);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        #btnExitMode:hover {
            background: rgba(255, 50, 50, 1);
            transform: scale(1.1);
        }

        #hintContainer.submenu-open {
            bottom: 276px;
            opacity: 0.6;
            pointer-events: none;
        }

        /* ===== COST TOOLTIP ===== */
        #costTooltip {
            position: fixed;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 6px;
            color: #4ade80;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
            display: none;
            white-space: nowrap;
        }
        #costTooltip.insufficient {
            color: #f87171;
        }

        /* 플로팅 금액 표시 (건설 시 차감 금액) */
        .floating-cost {
            position: fixed;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            color: #f87171;
            font-size: 18px;
            font-weight: bold;
            z-index: 1001;
            pointer-events: none;
            white-space: nowrap;
            animation: floatUp 1.2s ease-out forwards;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            50% {
                opacity: 1;
                transform: translateY(-30px) scale(1.1);
            }
            100% {
                opacity: 0;
                transform: translateY(-60px) scale(0.9);
            }
        }

        /* 서비스 효과 이모지 (물결 효과) */
        .service-emoji {
            position: fixed;
            font-size: 28px;
            z-index: 1002;
            pointer-events: none;
            animation: emojiFloat 1.5s ease-out forwards;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        @keyframes emojiFloat {
            0% {
                opacity: 0;
                transform: translateY(10px) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translateY(0) scale(1.2);
            }
            50% {
                opacity: 1;
                transform: translateY(-20px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0.8);
            }
        }

        /* 도로 끊김 경고 아이콘 */
        .road-disconnect-icon {
            position: fixed;
            font-size: 24px;
            z-index: 1001;
            pointer-events: none;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
            animation: disconnectPulse 2s ease-in-out infinite;
            transform: translate(-50%, -50%);
        }

        @keyframes disconnectPulse {
            0%, 100% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.15);
            }
        }

        /* 그래프 툴팁 (인구/땅값) */
        #graphTooltip {
            position: fixed;
            padding: 8px 14px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            z-index: 1001;
            pointer-events: none;
            display: none;
            white-space: nowrap;
        }
        #graphTooltip .value {
            color: #4ade80;
            font-size: 16px;
        }
        #graphTooltip.landvalue .value {
            color: #fbbf24;
        }

        /* ===== BUILDING INFO POPUP ===== */
        #buildingPopup {
            position: fixed;
            min-width: calc(280px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(45, 50, 58, 0.98) 0%, rgba(35, 40, 48, 0.99) 100%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: calc(12px * var(--ui-scale));
            z-index: 1002;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .popup-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) var(--spacing-lg);
            background: linear-gradient(180deg, rgba(60, 65, 75, 0.9) 0%, rgba(50, 55, 65, 0.9) 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .popup-header .icon {
            font-size: var(--font-2xl);
            margin-right: var(--spacing-sm);
        }

        .popup-header .title {
            flex: 1;
            color: #fff;
            font-size: var(--font-lg);
            font-weight: 600;
        }

        .popup-close {
            width: calc(28px * var(--ui-scale));
            height: calc(28px * var(--ui-scale));
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: #aaa;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .popup-close:hover {
            background: rgba(255, 100, 100, 0.3);
            color: #fff;
        }

        .popup-content {
            padding: var(--spacing-lg);
        }

        .popup-row {
            display: flex;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .popup-row:last-child {
            border-bottom: none;
        }

        .popup-row .label {
            color: #888;
            font-size: var(--font-md);
            min-width: calc(80px * var(--ui-scale));
        }

        .popup-row .value {
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        .popup-row .value.green { color: #4ade80; }
        .popup-row .value.yellow { color: #fbbf24; }
        .popup-row .value.blue { color: #60a5fa; }

        .popup-type {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-md);
            border-radius: calc(20px * var(--ui-scale));
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
        }

        .popup-type.residential {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .popup-type.commercial {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
        }

        .popup-type.industrial {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .popup-happiness {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .popup-happiness .emoji {
            font-size: 28px;
        }

        .popup-happiness .happiness-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .happiness-bar-container {
            width: 80px;
            height: 10px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .happiness-bar-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .happiness-value {
            font-size: 14px;
            font-weight: 700;
            min-width: 32px;
            text-align: center;
        }

        /* 시민 한마디 */
        .citizen-quote {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #60a5fa;
        }

        .citizen-quote .quote-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .citizen-quote .quote-text {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
            font-style: italic;
        }

        .citizen-quote.high {
            border-left-color: #4ade80;
        }

        .citizen-quote.mid {
            border-left-color: #fbbf24;
        }

        .citizen-quote.low {
            border-left-color: #f87171;
        }

        .citizen-quote.shortage {
            border-left-color: #f97316;
            background: rgba(249, 115, 22, 0.15);
        }

        .citizen-quote.positive {
            border-left-color: #22c55e;
            background: rgba(34, 197, 94, 0.15);
        }

        .citizen-quote.negative {
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
        }

        .citizen-quote.abandoned {
            border-left-color: #6b7280;
            background: rgba(107, 114, 128, 0.2);
        }

        .citizen-quote.abandoned .quote-text {
            color: #9ca3af;
        }

        /* ===== LEVEL PROGRESS BAR (Cities Skylines Style) ===== */
        .level-progress-container {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .level-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .level-progress-title {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #aaa;
            font-size: 12px;
        }

        .level-progress-title .icon {
            font-size: 14px;
        }

        .level-progress-value {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            font-family: 'Consolas', monospace;
        }

        .level-progress-bar {
            position: relative;
            height: 24px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            overflow: visible;
            display: flex;
        }

        /* 구역 분할 (레벨 1 | 레벨 2) */
        .level-progress-section {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .level-progress-section.level1 {
            flex: 1;
            background: linear-gradient(180deg, rgba(96, 165, 250, 0.4) 0%, rgba(59, 130, 246, 0.3) 100%);
            border-radius: 6px 0 0 6px;
            border-right: 2px solid rgba(255, 255, 255, 0.3);
        }

        .level-progress-section.level2 {
            flex: 1;
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.2) 0%, rgba(34, 197, 94, 0.15) 100%);
            border-radius: 0 6px 6px 0;
        }

        .level-progress-section.level2.active {
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.5) 0%, rgba(34, 197, 94, 0.4) 100%);
        }

        .level-progress-section .section-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .level-progress-section.level1 .section-label {
            color: rgba(96, 165, 250, 0.8);
        }

        .level-progress-section.level2.active .section-label {
            color: rgba(74, 222, 128, 0.9);
        }

        /* 현재 위치 마커 */
        .level-progress-marker {
            position: absolute;
            top: -8px;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
            transition: left 0.4s ease;
        }

        .level-progress-marker .marker-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(180deg, #60a5fa, #3b82f6);
            border: 2px solid #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
        }

        .level-progress-marker.eligible .marker-icon {
            background: linear-gradient(180deg, #4ade80, #22c55e);
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.5);
        }

        .level-progress-marker .marker-line {
            width: 2px;
            height: 32px;
            background: linear-gradient(180deg, #60a5fa, transparent);
        }

        .level-progress-marker.eligible .marker-line {
            background: linear-gradient(180deg, #4ade80, transparent);
        }

        /* 목표치 표시 */
        .level-threshold-marker {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
        }

        .level-threshold-marker .threshold-line {
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.6);
        }

        .level-threshold-marker .threshold-label {
            position: absolute;
            bottom: -18px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            white-space: nowrap;
        }

        /* 레벨 뱃지 */
        .level-badges {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
        }

        .level-badge {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: #888;
        }

        .level-badge .badge-icon {
            font-size: 12px;
        }

        .level-badge.current {
            color: #60a5fa;
            font-weight: 600;
        }

        .level-badge.next {
            color: #4ade80;
        }

        /* 폐건물 상태 */
        .level-progress-container.abandoned .level-progress-section {
            background: rgba(107, 114, 128, 0.2) !important;
        }

        .level-progress-container.abandoned .level-progress-marker .marker-icon {
            background: linear-gradient(180deg, #6b7280, #4b5563);
            box-shadow: 0 2px 8px rgba(107, 114, 128, 0.5);
        }

        .level-progress-container.abandoned .level-progress-marker .marker-line {
            background: linear-gradient(180deg, #6b7280, transparent);
        }

        /* ===== ABANDONED BUILDING STYLES ===== */
        .popup-type.abandoned {
            background: rgba(42, 42, 42, 0.8) !important;
            color: #888 !important;
        }

        .popup-demolish-info {
            margin-top: 12px;
            padding: 14px;
            background: linear-gradient(180deg, rgba(42, 42, 42, 0.9) 0%, rgba(30, 30, 30, 0.95) 100%);
            border: 2px solid rgba(239, 68, 68, 0.6);
            border-radius: 8px;
            text-align: center;
        }

        .demolish-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .demolish-title {
            color: #f87171;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
        }

        .demolish-desc {
            color: #888;
            font-size: 11px;
            line-height: 1.4;
        }

        /* 건물 상태 아이콘 애니메이션 (통합) */
        @keyframes statusIconBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        /* 레거시 호환 */
        @keyframes abandonedIconBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        .building-status-icon {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .abandoned-icon-float {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* ===== CONSTRUCTION POPUP ===== */
        #constructionPopup {
            position: fixed;
            min-width: 260px;
            background: linear-gradient(180deg, rgba(45, 50, 58, 0.98) 0%, rgba(35, 40, 48, 0.99) 100%);
            border: 1px solid rgba(251, 191, 36, 0.4);
            border-radius: 12px;
            z-index: 1002;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(251, 191, 36, 0.2);
            overflow: hidden;
        }

        #constructionPopup .popup-header {
            background: linear-gradient(180deg, rgba(251, 191, 36, 0.3) 0%, rgba(245, 158, 11, 0.2) 100%);
        }

        .construction-progress-container {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 12px;
        }

        .construction-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
            border-radius: 5px;
            transition: width 0.5s ease;
        }

        .construction-time-info {
            margin-top: 12px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .construction-time-info .time-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }

        .construction-time-info .time-label {
            color: #888;
            font-size: 12px;
        }

        .construction-time-info .time-value {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
        }

        .construction-time-info .time-value.highlight {
            color: #fbbf24;
            font-size: 16px;
        }

        .construction-status {
            text-align: center;
            font-size: 13px;
            color: #aaa;
            margin-top: 4px;
        }

        /* ===== PUBLIC BUILDING POPUP ===== */
        #publicBuildingPopup {
            position: fixed;
            min-width: 280px;
            background: linear-gradient(180deg, rgba(45, 50, 58, 0.98) 0%, rgba(35, 40, 48, 0.99) 100%);
            border: 1px solid rgba(239, 68, 68, 0.4);
            border-radius: 12px;
            z-index: 1002;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(239, 68, 68, 0.2);
            overflow: hidden;
        }

        #publicBuildingPopup .popup-header {
            background: linear-gradient(180deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.2) 100%);
        }

        #publicBuildingPopup .popup-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            margin: 12px 0 8px 0;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .firetruck-status {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
        }

        .firetruck-bar-container {
            margin-bottom: 10px;
        }

        .firetruck-bar-bg {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            display: flex;
        }

        .firetruck-bar-dispatched {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f87171);
            transition: width 0.3s ease;
        }

        .firetruck-bar-available {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            transition: width 0.3s ease;
        }

        .firetruck-bar-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 11px;
        }

        .firetruck-bar-labels .dispatched-label {
            color: #f87171;
        }

        .firetruck-bar-labels .available-label {
            color: #4ade80;
        }

        .firetruck-total {
            text-align: center;
            font-size: 12px;
            color: #aaa;
            margin-top: 8px;
        }

        .firetruck-total span {
            color: #fff;
            font-weight: 600;
        }

        /* ===== CAMERA SETTINGS PANEL ===== */
        #cameraSettingsPanel {
            position: fixed;
            bottom: calc(80px * var(--ui-scale));
            left: 50%;
            transform: translateX(-50%);
            min-width: calc(320px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(45, 50, 58, 0.98) 0%, rgba(35, 40, 48, 0.99) 100%);
            border: 1px solid rgba(96, 165, 250, 0.4);
            border-radius: calc(12px * var(--ui-scale));
            z-index: 1003;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(96, 165, 250, 0.2);
            overflow: hidden;
        }

        #cameraSettingsPanel .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) var(--spacing-lg);
            background: linear-gradient(180deg, rgba(96, 165, 250, 0.3) 0%, rgba(59, 130, 246, 0.2) 100%);
            border-bottom: 1px solid rgba(96, 165, 250, 0.3);
        }

        #cameraSettingsPanel .panel-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            color: #fff;
            font-size: var(--font-md);
            font-weight: 600;
        }

        #cameraSettingsPanel .panel-title .icon {
            font-size: var(--font-lg);
        }

        #cameraSettingsPanel .panel-close {
            width: var(--icon-size-md);
            height: var(--icon-size-md);
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
            border-radius: var(--spacing-xs);
            cursor: pointer;
            font-size: var(--font-md);
            transition: all 0.2s;
        }

        #cameraSettingsPanel .panel-close:hover {
            background: rgba(239, 68, 68, 0.3);
            color: #f87171;
        }

        #cameraSettingsPanel .panel-content {
            padding: var(--spacing-lg);
        }

        .camera-setting-row {
            margin-bottom: var(--spacing-lg);
        }

        .camera-setting-row:last-child {
            margin-bottom: 0;
        }

        .camera-setting-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .camera-setting-label .name {
            color: #aaa;
            font-size: var(--font-sm);
        }

        .camera-setting-label .value {
            color: #60a5fa;
            font-size: var(--font-sm);
            font-weight: 600;
            min-width: calc(40px * var(--ui-scale));
            text-align: right;
        }

        .camera-setting-slider {
            width: 100%;
            height: calc(6px * var(--ui-scale));
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: calc(3px * var(--ui-scale));
            outline: none;
            cursor: pointer;
        }

        .camera-setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: calc(16px * var(--ui-scale));
            height: calc(16px * var(--ui-scale));
            background: linear-gradient(180deg, #60a5fa, #3b82f6);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        .camera-setting-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .camera-setting-slider::-moz-range-thumb {
            width: calc(16px * var(--ui-scale));
            height: calc(16px * var(--ui-scale));
            background: linear-gradient(180deg, #60a5fa, #3b82f6);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .camera-settings-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: var(--spacing-lg) 0;
        }

        .camera-reset-btn {
            width: 100%;
            padding: calc(10px * var(--ui-scale));
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--border-radius);
            color: #aaa;
            font-size: var(--font-sm);
            cursor: pointer;
            transition: all 0.2s;
        }

        .camera-reset-btn:hover {
            background: rgba(96, 165, 250, 0.2);
            border-color: rgba(96, 165, 250, 0.4);
            color: #60a5fa;
        }

        /* ===== LOADING ===== */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a1628 0%, #1a2d4a 50%, #0d2137 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
        }

        #loading.hidden {
            display: none;
        }

        .loading-content {
            text-align: center;
        }

        .loading-logo {
            font-size: calc(2.5rem * var(--ui-scale));
            font-weight: 900;
            background: linear-gradient(135deg, #00d4ff, #00ffcc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: calc(20px * var(--ui-scale));
        }

        .loading-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: calc(1rem * var(--ui-scale));
        }

        .loading-spinner {
            width: calc(40px * var(--ui-scale));
            height: calc(40px * var(--ui-scale));
            border: calc(3px * var(--ui-scale)) solid rgba(0, 212, 255, 0.2);
            border-top-color: #00d4ff;
            border-radius: 50%;
            margin: calc(20px * var(--ui-scale)) auto 0;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== SAVE INDICATOR ===== */
        #saveIndicator {
            position: fixed;
            bottom: calc(120px * var(--ui-scale));
            right: calc(20px * var(--ui-scale));
            padding: calc(10px * var(--ui-scale)) calc(18px * var(--ui-scale));
            border-radius: var(--spacing-sm);
            font-size: var(--font-md);
            font-weight: 600;
            z-index: 100;
            display: none;
        }

        #saveIndicator.saving {
            display: block;
            background: rgba(255, 180, 0, 0.9);
            color: #000;
        }

        #saveIndicator.saved {
            display: block;
            background: rgba(0, 200, 100, 0.9);
            color: #fff;
        }

        /* ===== LEFT SIDEBAR (Zone Stats Buttons) ===== */
        #leftSidebar {
            position: fixed;
            top: 50%;
            left: calc(10px * var(--ui-scale));
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        #leftSidebar.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Zone Mode Hint Panel */
        #zoneModeHint {
            position: fixed;
            bottom: calc(100px * var(--ui-scale));
            left: calc(10px * var(--ui-scale));
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: calc(10px * var(--ui-scale));
            padding: var(--spacing-md) calc(14px * var(--ui-scale));
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            min-width: calc(160px * var(--ui-scale));
        }

        #zoneModeHint.visible {
            opacity: 1;
            visibility: visible;
        }

        #zoneModeHint .hint-title {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #fbbf24;
            margin-bottom: calc(10px * var(--ui-scale));
            padding-bottom: var(--spacing-xs);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #zoneModeHint .hint-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xs);
        }

        #zoneModeHint .hint-item:last-child {
            margin-bottom: 0;
        }

        #zoneModeHint .hint-key {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #fff;
            background: rgba(96, 165, 250, 0.3);
            padding: calc(3px * var(--ui-scale)) var(--spacing-sm);
            border-radius: var(--spacing-xs);
            border: 1px solid rgba(96, 165, 250, 0.5);
        }

        #zoneModeHint .hint-desc {
            font-size: var(--font-sm);
            color: #aaa;
        }

        /* Road mode sidebar (left side) */
        #rightSidebarRoad {
            position: fixed;
            top: 50%;
            left: calc(10px * var(--ui-scale));
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        #rightSidebarRoad.visible {
            opacity: 1;
            visibility: visible;
        }


        .sidebar-btn {
            width: var(--btn-size-lg);
            height: var(--btn-size-lg);
            background: linear-gradient(180deg, rgba(30, 35, 42, 0.95) 0%, rgba(20, 25, 32, 0.98) 100%);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: calc(10px * var(--ui-scale));
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: calc(2px * var(--ui-scale));
            transition: all 0.2s;
        }

        .sidebar-btn:hover {
            background: linear-gradient(180deg, rgba(50, 60, 70, 0.95) 0%, rgba(40, 50, 60, 0.98) 100%);
            border-color: rgba(100, 180, 255, 0.5);
            transform: scale(1.05);
        }

        .sidebar-btn.active {
            background: linear-gradient(180deg, #4a80b0, #3a6090);
            border-color: #6af;
            box-shadow: 0 0 15px rgba(100, 170, 255, 0.4);
        }

        .sidebar-btn .icon {
            font-size: var(--font-xl);
        }

        .sidebar-btn .label {
            font-size: var(--font-xs);
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .sidebar-btn.active .label {
            color: #fff;
        }

        /* ===== DATA VIEW LEGEND PANEL ===== */
        #dataViewLegend {
            position: fixed;
            top: calc(70px * var(--ui-scale));
            left: calc(20px * var(--ui-scale));
            width: calc(280px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(240, 245, 240, 0.97) 0%, rgba(230, 235, 230, 0.98) 100%);
            border-radius: var(--spacing-sm);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            font-family: 'Segoe UI', sans-serif;
            color: #333;
        }

        #dataViewLegend.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            background: linear-gradient(180deg, rgba(130, 180, 80, 0.9) 0%, rgba(100, 150, 60, 0.95) 100%);
            border-radius: var(--spacing-sm) var(--spacing-sm) 0 0;
        }

        .legend-header-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .legend-header-icon {
            font-size: var(--font-lg);
        }

        .legend-header-title {
            font-size: calc(15px * var(--ui-scale));
            font-weight: 600;
            color: #fff;
        }

        .legend-close {
            width: var(--icon-size-md);
            height: var(--icon-size-md);
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: var(--spacing-xs);
            color: #fff;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .legend-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .legend-body {
            padding: calc(14px * var(--ui-scale)) var(--spacing-lg);
        }

        .legend-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: calc(14px * var(--ui-scale));
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .legend-stat-label {
            font-size: var(--font-md);
            color: #666;
        }

        .legend-stat-value {
            font-size: var(--font-md);
            font-weight: 600;
            color: #2a5a2a;
        }

        .legend-section-title {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #555;
            margin-bottom: var(--spacing-md);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            margin-bottom: calc(14px * var(--ui-scale));
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xs);
        }

        .legend-item-label {
            font-size: var(--font-sm);
            color: #555;
        }

        .legend-item-toggle {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            font-size: var(--font-sm);
            color: #777;
        }

        .legend-item-toggle input[type="checkbox"] {
            width: calc(14px * var(--ui-scale));
            height: calc(14px * var(--ui-scale));
            cursor: pointer;
            accent-color: #5a9a5a;
        }

        .legend-gradient-bar {
            height: calc(12px * var(--ui-scale));
            border-radius: var(--border-radius);
            position: relative;
            margin-bottom: var(--spacing-xs);
        }

        .legend-gradient-bar.land-value {
            background: linear-gradient(90deg, #3b82f6 0%, #22c55e 50%, #f59e0b 100%);
        }

        .legend-gradient-bar.building-value {
            background: linear-gradient(90deg, #ef4444 0%, #eab308 50%, #22c55e 100%);
        }

        .legend-gradient-bar.population {
            background: linear-gradient(90deg, #94a3b8 0%, #60a5fa 50%, #8b5cf6 100%);
        }

        .legend-gradient-bar.traffic {
            background: linear-gradient(90deg, #22c55e 0%, #eab308 50%, #ef4444 100%);
        }

        .legend-gradient-labels {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: #888;
        }

        /* ===== UTILITY LEGEND PANEL (Power/Water Gauge) ===== */
        #utilityLegend {
            position: fixed;
            top: calc(70px * var(--ui-scale));
            left: calc(20px * var(--ui-scale));
            width: calc(260px * var(--ui-scale));
            background: linear-gradient(180deg, rgba(240, 245, 250, 0.97) 0%, rgba(230, 235, 245, 0.98) 100%);
            border-radius: var(--spacing-sm);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            font-family: 'Segoe UI', sans-serif;
            color: #333;
        }

        #utilityLegend.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        #utilityLegend.power .utility-legend-header {
            background: linear-gradient(180deg, rgba(245, 180, 60, 0.95) 0%, rgba(220, 150, 40, 0.98) 100%);
        }

        #utilityLegend.water .utility-legend-header {
            background: linear-gradient(180deg, rgba(80, 160, 220, 0.95) 0%, rgba(60, 130, 190, 0.98) 100%);
        }

        .utility-legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--spacing-sm) var(--spacing-sm) 0 0;
        }

        .utility-legend-header-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .utility-legend-icon {
            font-size: var(--font-xl);
        }

        .utility-legend-title {
            font-size: calc(15px * var(--ui-scale));
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .utility-legend-body {
            padding: var(--spacing-md) var(--spacing-lg);
        }

        /* 게이지 미터 */
        .gauge-container {
            position: relative;
            margin-bottom: var(--spacing-md);
        }

        .gauge-svg {
            width: 100%;
            height: auto;
        }

        .gauge-value {
            font-size: calc(18px * var(--ui-scale));
            font-weight: 700;
            fill: #374151;
        }

        .gauge-needle {
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: 100px 100px;
        }

        .gauge-labels {
            display: flex;
            justify-content: space-between;
            padding: 0 calc(12px * var(--ui-scale));
            margin-top: calc(-8px * var(--ui-scale));
        }

        .gauge-label-min,
        .gauge-label-max {
            font-size: var(--font-xs);
            color: #666;
            font-weight: 500;
        }

        /* 사용량 정보 */
        .utility-stats {
            background: rgba(255, 255, 255, 0.6);
            border-radius: var(--spacing-xs);
            padding: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .utility-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(6px * var(--ui-scale)) 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        }

        .utility-stat-row:last-child {
            border-bottom: none;
        }

        .utility-stat-row.highlight {
            background: rgba(34, 197, 94, 0.1);
            margin: calc(4px * var(--ui-scale)) calc(-8px * var(--ui-scale));
            padding: calc(8px * var(--ui-scale));
            border-radius: var(--spacing-xs);
            border-bottom: none;
        }

        .utility-stat-row.highlight.warning {
            background: rgba(234, 179, 8, 0.15);
        }

        .utility-stat-row.highlight.danger {
            background: rgba(239, 68, 68, 0.15);
        }

        .utility-stat-label {
            font-size: var(--font-sm);
            color: #555;
        }

        .utility-stat-value {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #333;
        }

        .utility-stat-row.highlight .utility-stat-value {
            color: #16a34a;
        }

        .utility-stat-row.highlight.warning .utility-stat-value {
            color: #ca8a04;
        }

        .utility-stat-row.highlight.danger .utility-stat-value {
            color: #dc2626;
        }

        /* 상태 표시 */
        .utility-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            padding: var(--spacing-sm);
            background: rgba(34, 197, 94, 0.15);
            border-radius: var(--spacing-xs);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .utility-status.warning {
            background: rgba(234, 179, 8, 0.15);
            border-color: rgba(234, 179, 8, 0.3);
        }

        .utility-status.danger {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
        }

        .utility-status-icon {
            font-size: var(--font-md);
        }

        .utility-status-text {
            font-size: var(--font-sm);
            font-weight: 500;
            color: #16a34a;
        }

        .utility-status.warning .utility-status-text {
            color: #ca8a04;
        }

        .utility-status.danger .utility-status-text {
            color: #dc2626;
        }

        /* ===== BUDGET PANEL ===== */
        #budgetPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: calc(500px * var(--ui-scale));
            max-height: 85vh;
            background: linear-gradient(180deg, rgba(25, 30, 40, 0.98) 0%, rgba(18, 22, 30, 0.99) 100%);
            border: 1px solid rgba(100, 180, 255, 0.3);
            border-radius: calc(16px * var(--ui-scale));
            z-index: 2000;
            display: none;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 0 30px rgba(100, 180, 255, 0.15);
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
        }

        #budgetPanel.open {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .budget-panel-header {
            background: linear-gradient(180deg, #3a4a60, #2a3a50);
            padding: calc(14px * var(--ui-scale)) calc(18px * var(--ui-scale));
            display: flex;
            align-items: center;
            gap: calc(10px * var(--ui-scale));
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .budget-panel-header .panel-icon {
            font-size: calc(22px * var(--ui-scale));
        }

        .budget-panel-header .panel-title {
            flex: 1;
            font-size: var(--font-lg);
            font-weight: 600;
            color: #fff;
        }

        .budget-panel-header .panel-close {
            width: calc(28px * var(--ui-scale));
            height: calc(28px * var(--ui-scale));
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: var(--border-radius);
            color: #aaa;
            font-size: var(--font-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .budget-panel-header .panel-close:hover {
            background: rgba(255, 100, 100, 0.3);
            color: #fff;
        }

        .budget-panel-content {
            padding: var(--spacing-lg) calc(18px * var(--ui-scale));
            max-height: calc(85vh - 60px * var(--ui-scale));
            overflow-y: auto;
        }

        .budget-section {
            margin-bottom: var(--spacing-sm);
        }

        .budget-section-header {
            margin-bottom: calc(10px * var(--ui-scale));
        }

        .budget-section-header .section-title {
            font-size: var(--font-md);
            font-weight: 600;
            color: #8af;
        }

        .budget-bars {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .budget-bar-row {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-xs) calc(10px * var(--ui-scale));
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--border-radius);
        }

        .budget-bar-row .bar-icon {
            font-size: var(--font-lg);
            width: var(--icon-size-md);
            text-align: center;
        }

        .budget-bar-row .bar-label {
            font-size: var(--font-sm);
            color: #bbb;
            width: calc(65px * var(--ui-scale));
        }

        .budget-bar-row .bar-graph {
            flex: 1;
            height: calc(12px * var(--ui-scale));
            background: rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
        }

        .budget-bar-row .bar-fill {
            height: 100%;
            border-radius: var(--border-radius);
            transition: width 0.3s ease;
        }

        .budget-bar-row .bar-fill.income {
            background: linear-gradient(90deg, #22c55e, #4ade80);
        }

        .budget-bar-row .bar-fill.expense {
            background: linear-gradient(90deg, #dc2626, #f87171);
        }

        .budget-bar-row .bar-value {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #4ade80;
            min-width: calc(60px * var(--ui-scale));
            text-align: right;
            font-family: 'Consolas', monospace;
        }

        .budget-bar-row .bar-value.expense {
            color: #f87171;
        }

        .budget-bar-row .bar-count {
            font-size: var(--font-sm);
            color: #888;
            min-width: calc(30px * var(--ui-scale));
            text-align: right;
        }

        .tax-rate-control {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            min-width: calc(80px * var(--ui-scale));
        }

        .tax-slider {
            width: calc(50px * var(--ui-scale));
            height: calc(6px * var(--ui-scale));
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: calc(3px * var(--ui-scale));
            outline: none;
            cursor: pointer;
        }

        .tax-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: calc(14px * var(--ui-scale));
            height: calc(14px * var(--ui-scale));
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .tax-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .tax-slider::-moz-range-thumb {
            width: calc(14px * var(--ui-scale));
            height: calc(14px * var(--ui-scale));
            background: #60a5fa;
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }

        .tax-percent {
            font-size: var(--font-sm);
            color: #60a5fa;
            min-width: calc(28px * var(--ui-scale));
            text-align: right;
        }

        .budget-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.08);
            margin: calc(14px * var(--ui-scale)) 0;
        }

        .budget-summary {
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--spacing-sm);
            padding: var(--spacing-md) calc(14px * var(--ui-scale));
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(5px * var(--ui-scale)) 0;
        }

        .summary-row.total {
            margin-top: var(--spacing-sm);
            padding-top: calc(10px * var(--ui-scale));
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .summary-label {
            font-size: var(--font-md);
            color: #aaa;
        }

        .summary-row.total .summary-label {
            font-weight: 600;
            color: #fff;
        }

        .summary-value {
            font-size: var(--font-md);
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }

        .summary-value.income {
            color: #4ade80;
        }

        .summary-value.expense {
            color: #f87171;
        }

        .summary-row.total .summary-value {
            font-size: var(--font-lg);
        }

        .bond-cards {
            display: flex;
            gap: calc(10px * var(--ui-scale));
            margin-top: calc(10px * var(--ui-scale));
        }

        .bond-card {
            flex: 1;
            background: linear-gradient(180deg, rgba(60, 70, 90, 0.5), rgba(40, 50, 70, 0.5));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: calc(10px * var(--ui-scale));
            padding: var(--spacing-md);
            text-align: center;
            transition: all 0.2s;
        }

        .bond-card:hover {
            border-color: rgba(100, 180, 255, 0.4);
            background: linear-gradient(180deg, rgba(70, 80, 100, 0.6), rgba(50, 60, 80, 0.6));
        }

        .bond-card.issued {
            border-color: rgba(250, 180, 80, 0.5);
            background: linear-gradient(180deg, rgba(100, 80, 50, 0.4), rgba(80, 60, 40, 0.4));
        }

        .bond-name {
            font-size: var(--font-sm);
            font-weight: 600;
            color: #fff;
            margin-bottom: var(--spacing-xs);
        }

        .bond-amount {
            font-size: var(--font-md);
            font-weight: 700;
            color: #4ade80;
            margin-bottom: var(--spacing-xs);
            font-family: 'Consolas', monospace;
        }

        .bond-interest {
            font-size: var(--font-sm);
            color: #fbbf24;
            margin-bottom: var(--spacing-sm);
        }

        .bond-btn {
            width: 100%;
            padding: var(--spacing-xs) calc(10px * var(--ui-scale));
            background: linear-gradient(180deg, #4a6a90, #3a5a80);
            border: 1px solid rgba(100, 180, 255, 0.3);
            border-radius: calc(5px * var(--ui-scale));
            color: #fff;
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }

        .bond-btn:hover {
            background: linear-gradient(180deg, #5a7aa0, #4a6a90);
        }

        .bond-btn.repay {
            background: linear-gradient(180deg, #8a6040, #7a5030);
            border-color: rgba(250, 180, 80, 0.3);
        }

        .bond-btn.repay:hover {
            background: linear-gradient(180deg, #9a7050, #8a6040);
        }

        .bond-debt {
            margin-top: var(--spacing-md);
            padding: calc(10px * var(--ui-scale));
            background: rgba(255, 100, 100, 0.1);
            border: 1px solid rgba(255, 100, 100, 0.2);
            border-radius: var(--border-radius);
            font-size: var(--font-sm);
            color: #f87171;
            text-align: center;
        }

        .bond-debt span {
            font-weight: 700;
        }

        .budget-total {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(14px * var(--ui-scale)) var(--spacing-lg);
            background: linear-gradient(180deg, rgba(50, 120, 80, 0.2), rgba(40, 100, 70, 0.15));
            border: 1px solid rgba(100, 255, 150, 0.2);
            border-radius: calc(10px * var(--ui-scale));
        }

        .total-label {
            font-size: var(--font-md);
            color: #4ade80;
            font-weight: 600;
        }

        .total-value {
            font-size: calc(22px * var(--ui-scale));
            font-weight: 700;
            color: #4ade80;
            font-family: 'Consolas', monospace;
        }

        /* Legacy */
        #ui { display: none; }
        #toolbar { display: none; }
        #hud { display: none; }
    </style>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "three.quarks": "https://esm.sh/three.quarks@0.15.3?external=three"
          }
        }
    </script>

    <!-- 서버 데이터 주입 -->
    <script th:inline="javascript">
        const MAP_CONFIG = {
            username: /*[[${mapUsername}]]*/ '',
            isOwner: /*[[${isOwner}]]*/ false,
            currentUsername: /*[[${currentUsername}]]*/ null,
            cityName: /*[[${cityName}]]*/ null
        };
    </script>
</head>

<body>
<div id="loading">
    <div class="loading-content">
        <div class="loading-logo" data-i18n="app.name">CITY BUILDER</div>
        <div class="loading-text" data-i18n="common.loading">Loading...</div>
        <div class="loading-spinner"></div>
    </div>
</div>

<!-- ===== TOP BAR ===== -->
<div id="topBar">
    <div class="top-left">
        <a href="/" class="menu-btn" title="Home">🏠</a>
    </div>
    <div class="top-center">
        <div class="city-name-display" id="cityNameDisplay">
            <span id="cityNameText" th:text="${mapUsername}">Username</span>'s City
        </div>
    </div>
    <div class="top-right">
        <div class="bgm-volume-container">
            <button class="bgm-btn" id="btnBgm" title="BGM 재생/정지">🔇</button>
            <input type="range" class="bgm-volume-slider" id="bgmVolume" min="0" max="100" value="30">
        </div>
        <a href="/" class="top-btn" data-i18n="common.home">Home</a>
        <a th:if="${currentUsername != null}" href="/mypage" class="top-btn" data-i18n="common.mypage">My Page</a>
    </div>
</div>

<!-- ===== LEFT SIDEBAR (Zone Stats - Only visible in Zone mode) ===== -->
<div id="leftSidebar" th:if="${isOwner}">
    <button class="sidebar-btn" id="btnLandValue" title="땅값 보기">
        <span class="icon">💰</span>
        <span class="label">땅값</span>
    </button>
    <button class="sidebar-btn" id="btnPopulation" title="인구 보기">
        <span class="icon">👥</span>
        <span class="label">인구</span>
    </button>
</div>

<!-- ===== DATA VIEW LEGEND PANEL ===== -->
<div id="dataViewLegend">
    <div class="legend-header">
        <div class="legend-header-left">
            <span class="legend-header-icon" id="legendIcon">💰</span>
            <span class="legend-header-title" id="legendTitle">땅값</span>
        </div>
        <button class="legend-close" id="legendClose">×</button>
    </div>
    <div class="legend-body">
        <!-- 평균 통계 -->
        <div class="legend-stat">
            <span class="legend-stat-label" id="legendStatLabel">평균 땅값</span>
            <span class="legend-stat-value" id="legendStatValue">₩0/칸</span>
        </div>

        <!-- 지도 범례 -->
        <div class="legend-section-title">지도 범례</div>

        <!-- 땅값 범례 (땅값 모드) -->
        <div class="legend-item" id="legendLandValue">
            <div class="legend-item-header">
                <span class="legend-item-label">땅값</span>
                <label class="legend-item-toggle">
                    <span>지형 색상</span>
                    <input type="checkbox" id="legendTerrainColor" checked>
                </label>
            </div>
            <div class="legend-gradient-bar land-value"></div>
            <div class="legend-gradient-labels">
                <span>낮음</span>
                <span>높음</span>
            </div>
        </div>

        <!-- 건물 가치 범례 (땅값 모드) -->
        <div class="legend-item" id="legendBuildingValue">
            <div class="legend-item-header">
                <span class="legend-item-label">건설 부지 가치</span>
                <label class="legend-item-toggle">
                    <span>건물 색상</span>
                    <input type="checkbox" id="legendBuildingColor" checked>
                </label>
            </div>
            <div class="legend-gradient-bar building-value"></div>
            <div class="legend-gradient-labels">
                <span>낮음</span>
                <span>높음</span>
            </div>
        </div>

        <!-- 인구 범례 (인구 모드) -->
        <div class="legend-item" id="legendPopulation" style="display: none;">
            <div class="legend-item-header">
                <span class="legend-item-label">인구 밀도</span>
                <label class="legend-item-toggle">
                    <span>건물 색상</span>
                    <input type="checkbox" id="legendPopColor" checked>
                </label>
            </div>
            <div class="legend-gradient-bar population"></div>
            <div class="legend-gradient-labels">
                <span>낮음</span>
                <span>높음</span>
            </div>
        </div>

        <!-- 교통량 범례 (교통량 모드) -->
        <div class="legend-item" id="legendTraffic" style="display: none;">
            <div class="legend-item-header">
                <span class="legend-item-label">도로 혼잡도</span>
                <label class="legend-item-toggle">
                    <span>도로 색상</span>
                    <input type="checkbox" id="legendTrafficColor" checked>
                </label>
            </div>
            <div class="legend-gradient-bar traffic"></div>
            <div class="legend-gradient-labels">
                <span>원활</span>
                <span>혼잡</span>
            </div>
        </div>
    </div>
</div>

<!-- ===== UTILITY LEGEND PANEL (Power/Water) ===== -->
<div id="utilityLegend">
    <div class="utility-legend-header">
        <div class="utility-legend-header-left">
            <span class="utility-legend-icon" id="utilityLegendIcon">⚡</span>
            <span class="utility-legend-title" id="utilityLegendTitle">전력</span>
        </div>
        <button class="legend-close" id="utilityLegendClose">×</button>
    </div>
    <div class="utility-legend-body">
        <!-- 게이지 미터 -->
        <div class="gauge-container">
            <svg class="gauge-svg" viewBox="0 0 200 120">
                <!-- 게이지 배경 호 -->
                <defs>
                    <linearGradient id="gaugeGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#22c55e"/>
                        <stop offset="50%" style="stop-color:#eab308"/>
                        <stop offset="100%" style="stop-color:#ef4444"/>
                    </linearGradient>
                </defs>
                <!-- 배경 호 (회색) -->
                <path class="gauge-bg" d="M 20 100 A 80 80 0 0 1 180 100"
                      fill="none" stroke="#e5e7eb" stroke-width="16" stroke-linecap="round"/>
                <!-- 게이지 호 (그라데이션) -->
                <path class="gauge-fill" d="M 20 100 A 80 80 0 0 1 180 100"
                      fill="none" stroke="url(#gaugeGradient)" stroke-width="16" stroke-linecap="round"/>
                <!-- 눈금 표시 -->
                <g class="gauge-ticks">
                    <line x1="20" y1="100" x2="28" y2="100" stroke="#888" stroke-width="2"/>
                    <line x1="35" y1="55" x2="42" y2="60" stroke="#888" stroke-width="2"/>
                    <line x1="100" y1="20" x2="100" y2="28" stroke="#888" stroke-width="2"/>
                    <line x1="165" y1="55" x2="158" y2="60" stroke="#888" stroke-width="2"/>
                    <line x1="180" y1="100" x2="172" y2="100" stroke="#888" stroke-width="2"/>
                </g>
                <!-- 수치 표시 (바늘 아래에 배치) -->
                <text x="100" y="85" text-anchor="middle" class="gauge-value" id="gaugeValue">0%</text>
                <!-- 바늘 (맨 위에 배치) -->
                <g class="gauge-needle" id="gaugeNeedle" transform="rotate(-90, 100, 100)">
                    <polygon points="100,30 94,100 106,100" fill="#374151" stroke="#1f2937" stroke-width="1"/>
                    <circle cx="100" cy="100" r="10" fill="#374151"/>
                    <circle cx="100" cy="100" r="5" fill="#f59e0b"/>
                </g>
            </svg>
            <div class="gauge-labels">
                <span class="gauge-label-min">0</span>
                <span class="gauge-label-max" id="gaugeMaxLabel">100</span>
            </div>
        </div>

        <!-- 사용량 정보 -->
        <div class="utility-stats">
            <div class="utility-stat-row">
                <span class="utility-stat-label">현재 사용량</span>
                <span class="utility-stat-value" id="utilityCurrentUsage">0</span>
            </div>
            <div class="utility-stat-row">
                <span class="utility-stat-label">총 용량</span>
                <span class="utility-stat-value" id="utilityTotalCapacity">0</span>
            </div>
            <div class="utility-stat-row highlight">
                <span class="utility-stat-label">여유 용량</span>
                <span class="utility-stat-value" id="utilityRemaining">0</span>
            </div>
        </div>

        <!-- 상태 표시 -->
        <div class="utility-status" id="utilityStatus">
            <span class="utility-status-icon">✓</span>
            <span class="utility-status-text">정상 공급 중</span>
        </div>
    </div>
</div>

<!-- ===== ZONE MODE HINT (Only visible in Zone mode) ===== -->
<div id="zoneModeHint" th:if="${isOwner}">
    <div class="hint-title">💡 단축키</div>
    <div class="hint-item">
        <span class="hint-key">Ctrl + 클릭</span>
        <span class="hint-desc">도로 따라 직선 선택</span>
    </div>
    <div class="hint-item">
        <span class="hint-key">드래그</span>
        <span class="hint-desc">영역 칠하기</span>
    </div>
</div>

<!-- ===== RIGHT SIDEBAR (Traffic View - Only visible in Road mode) ===== -->
<div id="rightSidebarRoad" th:if="${isOwner}">
    <button class="sidebar-btn" id="btnTrafficView" title="교통량 보기">
        <span class="icon">🚗</span>
        <span class="label">교통량</span>
    </button>
</div>


<!-- ===== BUILDING INFO POPUP ===== -->
<div id="buildingPopup">
    <div class="popup-header">
        <span class="icon" id="popupIcon">🏠</span>
        <span class="title" id="popupTitle">Building Name</span>
        <button class="popup-close" id="popupClose">×</button>
    </div>
    <div class="popup-content">
        <div class="popup-type residential" id="popupType">
            <span id="popupTypeIcon">🏠</span>
            <span id="popupTypeText">주거</span>
        </div>
        <div class="popup-row" id="popupPopulationRow">
            <span class="label">인구</span>
            <span class="value green" id="popupPopulation">0명</span>
        </div>
        <div class="popup-happiness" id="popupHappiness">
            <span class="emoji" id="happinessEmoji">😊</span>
            <div class="happiness-info">
                <div class="happiness-bar-container" id="happinessBarContainer">
                    <div class="happiness-bar-fill" id="happinessBarFill"></div>
                </div>
                <div class="happiness-value" id="happinessValue">50</div>
            </div>
        </div>
        <div class="citizen-quote" id="citizenQuote">
            <span class="quote-icon">💬</span>
            <span class="quote-text" id="citizenQuoteText">그럭저럭 살만합니다.</span>
        </div>
        <!-- 레벨업 진행도 (땅값 통합) -->
        <div class="level-progress-container" id="levelProgressContainer">
            <div class="level-progress-header">
                <div class="level-progress-title">
                    <span class="icon">💰</span>
                    <span>땅값</span>
                </div>
                <div class="level-progress-value" id="levelProgressValue">0 / 50</div>
            </div>
            <div class="level-progress-bar" id="levelProgressBar">
                <div class="level-progress-section level1">
                    <span class="section-label">LV.1</span>
                </div>
                <div class="level-progress-section level2" id="levelSection2">
                    <span class="section-label">LV.2</span>
                </div>
                <!-- 목표치 마커 -->
                <div class="level-threshold-marker">
                    <div class="threshold-line"></div>
                    <span class="threshold-label">목표</span>
                </div>
                <!-- 현재 위치 마커 -->
                <div class="level-progress-marker" id="levelProgressMarker">
                    <div class="marker-icon">🏠</div>
                    <div class="marker-line"></div>
                </div>
            </div>
            <div class="level-badges">
                <div class="level-badge current" id="levelBadgeCurrent">
                    <span class="badge-icon">🏠</span>
                    <span>현재 레벨</span>
                </div>
                <div class="level-badge next" id="levelBadgeNext">
                    <span class="badge-icon">🏢</span>
                    <span>다음 레벨</span>
                </div>
            </div>
        </div>
        <!-- 폐건물 철거 안내 -->
        <div class="popup-demolish-info" id="demolishInfoContainer" style="display: none;">
            <div class="demolish-icon">🏚️</div>
            <div class="demolish-title">철거 필요</div>
            <div class="demolish-desc">이 건물은 복구가 불가능합니다.<br>철거 후 새 건물을 지어주세요.</div>
        </div>
    </div>
</div>

<!-- ===== CONSTRUCTION POPUP ===== -->
<div id="constructionPopup">
    <div class="popup-header">
        <span class="icon">🏗️</span>
        <span class="title" id="constructionTitle">공사 중</span>
        <button class="popup-close" id="constructionPopupClose">×</button>
    </div>
    <div class="popup-content">
        <div class="construction-status" id="constructionStatus">입주민 대기 중...</div>
        <div class="construction-time-info">
            <div class="time-row">
                <span class="time-label">총 소요시간</span>
                <span class="time-value" id="constructionTotalTime">1:00</span>
            </div>
            <div class="time-row">
                <span class="time-label">남은 시간</span>
                <span class="time-value highlight" id="constructionTimeLeft">0:00</span>
            </div>
        </div>
        <div class="construction-progress-container">
            <div class="construction-progress-bar" id="constructionProgress"></div>
        </div>
    </div>
</div>

<!-- ===== PUBLIC BUILDING POPUP ===== -->
<div id="publicBuildingPopup">
    <div class="popup-header">
        <span class="icon" id="publicPopupIcon">🏛️</span>
        <span class="title" id="publicPopupTitle">공공시설</span>
        <button class="popup-close" id="publicPopupClose">×</button>
    </div>
    <div class="popup-content">
        <div class="popup-row">
            <span class="label">시설 종류</span>
            <div class="popup-type" id="publicPopupType">
                <span class="type-icon" id="publicPopupTypeIcon">🚒</span>
                <span class="type-text" id="publicPopupTypeText">소방서</span>
            </div>
        </div>

        <!-- 소방서 전용: 소방차 현황 -->
        <div id="firetruckStatusSection" style="display:none;">
            <div class="popup-section-title">🚒 소방차 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="firetruckBarDispatched"></div>
                        <div class="firetruck-bar-available" id="firetruckBarAvailable"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">출동 중: <span id="firetruckDispatched">0</span></span>
                        <span class="available-label">대기 중: <span id="firetruckAvailable">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    총 보유: <span id="firetruckTotal">0</span> / <span id="firetruckMax">2</span>대
                </div>
            </div>
        </div>

        <!-- 경찰서 전용: 경찰차 및 감옥 현황 -->
        <div id="policeStatusSection" style="display:none;">
            <div class="popup-section-title">🚔 경찰차 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="policeBarDispatched" style="background: linear-gradient(90deg, #3b82f6, #60a5fa);"></div>
                        <div class="firetruck-bar-available" id="policeBarAvailable" style="background: linear-gradient(90deg, #22c55e, #4ade80);"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">출동 중: <span id="policeDispatched">0</span></span>
                        <span class="available-label">대기 중: <span id="policeAvailable">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    총 보유: <span id="policeTotal">0</span> / <span id="policeMax">2</span>대
                </div>
            </div>
            <div class="popup-section-title" style="margin-top: 8px;">⛓️ 감옥 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="prisonBarOccupied" style="background: linear-gradient(90deg, #ef4444, #f87171);"></div>
                        <div class="firetruck-bar-available" id="prisonBarEmpty" style="background: linear-gradient(90deg, #6b7280, #9ca3af);"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">수감 중: <span id="prisonOccupied">0</span></span>
                        <span class="available-label">빈 자리: <span id="prisonEmpty">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    정원: <span id="prisonTotal">0</span> / <span id="prisonMax">5</span>명
                </div>
            </div>
        </div>

        <!-- 병원 전용: 구급차 및 환자 현황 -->
        <div id="hospitalStatusSection" style="display:none;">
            <div class="popup-section-title">🚑 구급차 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="ambulanceBarDispatched" style="background: linear-gradient(90deg, #ec4899, #f472b6);"></div>
                        <div class="firetruck-bar-available" id="ambulanceBarAvailable" style="background: linear-gradient(90deg, #22c55e, #4ade80);"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">출동 중: <span id="ambulanceDispatched">0</span></span>
                        <span class="available-label">대기 중: <span id="ambulanceAvailable">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    총 보유: <span id="ambulanceTotal">0</span> / <span id="ambulanceMax">2</span>대
                </div>
            </div>
            <div class="popup-section-title" style="margin-top: 8px;">🏥 병상 현황</div>
            <div class="firetruck-status">
                <div class="firetruck-bar-container">
                    <div class="firetruck-bar-bg">
                        <div class="firetruck-bar-dispatched" id="patientBarOccupied" style="background: linear-gradient(90deg, #ef4444, #f87171);"></div>
                        <div class="firetruck-bar-available" id="patientBarEmpty" style="background: linear-gradient(90deg, #6b7280, #9ca3af);"></div>
                    </div>
                    <div class="firetruck-bar-labels">
                        <span class="dispatched-label">입원 중: <span id="patientOccupied">0</span></span>
                        <span class="available-label">빈 병상: <span id="patientEmpty">0</span></span>
                    </div>
                </div>
                <div class="firetruck-total">
                    정원: <span id="patientTotal">0</span> / <span id="patientMax">8</span>명
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ===== RIGHT INFO PANEL (Collapsible) ===== -->
<div id="infoPanel" class="collapsed">
    <div class="panel-header" onclick="toggleInfoPanel()">
        <span class="panel-title"><span data-i18n="hud.cityStats">📊 City Stats</span></span>
        <span class="panel-toggle" id="panelToggleIcon">▼</span>
    </div>
    <div class="panel-content">
        <div class="panel-stat">
            <span class="label">👥 <span data-i18n="hud.population">Population</span></span>
            <span class="value" id="populationText">0</span>
        </div>
        <div class="panel-stat">
            <span class="label">😊 <span data-i18n="hud.happiness">Happiness</span></span>
            <span class="value" id="happinessText">50%</span>
        </div>
        <div class="panel-stat">
            <span class="label">⚡ <span data-i18n="hud.power">Power</span></span>
            <span class="value" id="powerText">0/0</span>
        </div>
        <div class="panel-stat">
            <span class="label">💧 <span data-i18n="hud.water">Water</span></span>
            <span class="value" id="waterText">0/0</span>
        </div>
        <div class="panel-stat">
            <span class="label">🚗 <span data-i18n="hud.traffic">Traffic</span></span>
            <span class="value" id="trafficText">0%</span>
        </div>
        <div class="panel-stat">
            <span class="label">🚨 <span data-i18n="hud.crime">Crime</span></span>
            <span class="value" id="crimeText">0%</span>
        </div>

        <div th:if="${isOwner}" class="panel-section">
            <div class="panel-section-title" data-i18n="hud.daily">Daily</div>
            <div class="panel-stat">
                <span class="label">⚡ <span data-i18n="hud.ap">AP</span></span>
                <span class="value" id="apText">10/10</span>
            </div>
            <div class="panel-stat">
                <span class="label">📅 <span data-i18n="hud.loginStreak">Streak</span></span>
                <span class="value" id="streakText">0 <span data-i18n="hud.days">days</span></span>
            </div>
        </div>

        <div th:if="${isOwner}" id="offlineEarningsBox" class="earnings-box" style="display:none;">
            <div class="earnings-label" data-i18n="hud.offlineEarnings">Offline Earnings</div>
            <div class="earnings-value"><span id="offlineCurrency">$</span><span id="offlineEarningsText">0</span></div>
            <button id="btnCollectTax" class="collect-btn" data-i18n="hud.collect">Collect</button>
        </div>

        <div th:if="${isOwner}" id="loginRewardBox" class="earnings-box" style="display:none;">
            <div class="earnings-label" data-i18n="hud.loginReward">Login Reward!</div>
            <div class="earnings-value"><span id="rewardCurrency">$</span><span id="loginRewardText">0</span></div>
            <button id="btnClaimReward" class="collect-btn" data-i18n="hud.claim">Claim</button>
        </div>
    </div>
</div>

<!-- ===== SUB MENU (Slide up) ===== -->
<div id="subMenu">
    <div class="submenu-header">
        <span class="submenu-title" id="submenuTitle">🏠 Zones</span>
        <button class="submenu-close" onclick="closeSubMenu()">×</button>
    </div>
    <div class="submenu-items" id="submenuItems">
        <!-- Dynamically populated -->
    </div>
</div>

<!-- ===== SUBMENU TOOLTIP ===== -->
<div id="submenuTooltip" class="submenu-tooltip">
    <div class="tooltip-header">
        <span class="tooltip-icon" id="tooltipIcon">🚒</span>
        <span class="tooltip-name" id="tooltipName">동네 소방서</span>
    </div>
    <div class="tooltip-content">
        <div class="tooltip-row">
            <span class="label">건설비</span>
            <span class="value" id="tooltipCost">₩3,000</span>
        </div>
        <div class="tooltip-row maintenance">
            <span class="label">운영비</span>
            <span class="value" id="tooltipMaintenance">₩50/시간</span>
        </div>
        <div class="tooltip-desc" id="tooltipDesc">화재 예방 및 신속한 진압</div>
    </div>
</div>

<!-- ===== DAILY STATS PANELS ===== -->
<!-- 화재 통계 패널 -->
<div id="fireStatsPanel" class="daily-stats-panel fire-panel">
    <div class="daily-stats-header">
        <span class="stat-number" id="statBurnedBuildings">0</span>
        <span class="stat-title">하루에 불에 탄 건물</span>
    </div>
    <div class="daily-stats-rows">
        <div class="daily-stats-row">
            <span class="row-number" id="statExtinguishedFires">0</span>
            <span class="row-number">/</span>
            <span class="row-number" id="statTotalFires">0</span>
            <span class="row-label">하루에 진압한 화재</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statHazmatFires">0</span>
            <span class="row-label">하루에 진압한 위험물 화재</span>
        </div>
    </div>
</div>

<!-- 범죄 통계 패널 -->
<div id="crimeStatsPanel" class="daily-stats-panel crime-panel">
    <div class="daily-stats-header">
        <span class="stat-number" id="statTotalCrimes">0</span>
        <span class="stat-title">하루에 발생한 범죄</span>
    </div>
    <div class="daily-stats-rows">
        <div class="daily-stats-row">
            <span class="row-number" id="statEscapedCriminals">0</span>
            <span class="row-label">잡히지 않은 범죄자</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statArrestedCriminals">0</span>
            <span class="row-label">하루에 체포한 범죄자</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statPrisoners">0</span>
            <span class="row-label">죄수</span>
        </div>
    </div>
</div>

<!-- 의료 통계 패널 -->
<div id="medicalStatsPanel" class="daily-stats-panel medical-panel">
    <div class="daily-stats-header">
        <span class="stat-number" id="statTotalEmergencies">0</span>
        <span class="stat-title">하루에 발생한 응급환자</span>
    </div>
    <div class="daily-stats-rows">
        <div class="daily-stats-row">
            <span class="row-number" id="statDeadPatients">0</span>
            <span class="row-label">사망 환자</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statSavedPatients">0</span>
            <span class="row-label">하루에 구조한 환자</span>
        </div>
        <div class="daily-stats-row">
            <span class="row-number" id="statHospitalPatients">0</span>
            <span class="row-number">/</span>
            <span class="row-number" id="statHospitalCapacity">0</span>
            <span class="row-label">입원 환자</span>
        </div>
    </div>
</div>

<!-- ===== BOTTOM BAR (Main Toolbar) ===== -->
<div id="bottomBar">
    <!-- Left: Time & Speed Controls -->
    <div class="bottom-left">
        <div class="game-speed">
            <button class="speed-btn active" id="btnSpeed1" title="1x">▶</button>
            <button class="speed-btn" id="btnSpeed2" title="2x">▶▶</button>
            <button class="speed-btn" id="btnSpeed3" title="3x">▶▶▶</button>
        </div>
        <div class="time-display">
            <div class="date-display" id="dateDisplay" data-i18n-template="game.day">Day 1</div>
            <div class="clock-display" id="clockDisplay">06:00</div>
        </div>

        <!-- RCI Demand Bar -->
        <div class="rci-demand-bar">
            <div class="rci-item residential">
                <span class="rci-label">R</span>
                <div class="rci-bar-container">
                    <div class="rci-bar-negative"></div>
                    <div class="rci-bar-center"></div>
                    <div class="rci-bar-positive" id="rciResidential"></div>
                </div>
            </div>
            <div class="rci-item commercial">
                <span class="rci-label">C</span>
                <div class="rci-bar-container">
                    <div class="rci-bar-negative"></div>
                    <div class="rci-bar-center"></div>
                    <div class="rci-bar-positive" id="rciCommercial"></div>
                </div>
            </div>
            <div class="rci-item industrial">
                <span class="rci-label">I</span>
                <div class="rci-bar-container">
                    <div class="rci-bar-negative"></div>
                    <div class="rci-bar-center"></div>
                    <div class="rci-bar-positive" id="rciIndustrial"></div>
                </div>
            </div>
        </div>

        <!-- City Happiness -->
        <div class="city-happiness">
            <span class="happiness-icon" id="cityHappinessIcon">😊</span>
            <div class="happiness-info">
                <span class="happiness-label">행복도</span>
                <div class="happiness-value">
                    <span class="happiness-number high" id="cityHappinessNumber">50</span>
                    <span class="happiness-trend stable" id="cityHappinessTrend">→</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Center: Main Tools (Icons Only) -->
    <div class="bottom-center">
        <button class="tool-btn active" id="btnCam" title="카메라 모드">
            <span class="icon">📷</span>
        </button>

        <th:block th:if="${isOwner}">
            <button class="tool-btn" id="btnBuild" title="도로/수로">
                <span class="icon">🛣️</span>
            </button>

            <button class="tool-btn" id="btnZones" title="구역 지정">
                <span class="icon">🏘️</span>
            </button>

            <div class="tool-divider"></div>

            <button class="tool-btn" id="btnPower" title="발전소">
                <span class="icon">⚡</span>
            </button>

            <button class="tool-btn" id="btnWater" title="수도">
                <span class="icon">💧</span>
            </button>

            <div class="tool-divider"></div>

            <button class="tool-btn" id="btnPolice" title="경찰서 (₩3,000)">
                <span class="icon">🚔</span>
            </button>

            <button class="tool-btn" id="btnFire" title="소방서 (₩3,000)">
                <span class="icon">🚒</span>
            </button>

            <button class="tool-btn" id="btnSchool" title="학교 (₩4,000)">
                <span class="icon">🏫</span>
            </button>

            <button class="tool-btn" id="btnHospital" title="병원 (₩6,000)">
                <span class="icon">🏥</span>
            </button>

            <button class="tool-btn" id="btnPark" title="공원 (₩1,000)">
                <span class="icon">🌳</span>
            </button>

        </th:block>

        <th:block th:if="${isOwner}">
            <button class="demolish-btn" id="btnDemolish" title="철거 모드">
                <span class="icon">🔨</span>
            </button>
        </th:block>

        <th:block th:if="${isOwner}">
            <button class="tool-btn save-btn" id="btnSave" title="저장 (Ctrl+S)">
                <span class="icon">💾</span>
            </button>
        </th:block>

        <div class="tool-divider"></div>

        <!-- 중앙 자금 표시 (SimCity 스타일) -->
        <div class="money-display-center" id="moneyDisplayBtn" title="시 예산">
            <div class="money-icon">💰</div>
            <div class="money-amount" id="moneyDisplayCenter">49,069</div>
            <div class="money-rate" id="moneyRateCenter">+₩0/h</div>
        </div>

        <!-- 인구 표시 -->
        <div class="population-display-center" id="populationDisplayBtn" title="인구 통계">
            <div class="pop-icon">👥</div>
            <div class="pop-amount" id="popDisplayCenter">0</div>
            <div class="pop-label">명</div>
        </div>
    </div>
</div>

<!-- ===== BUDGET PANEL ===== -->
<div id="budgetPanel">
    <div class="budget-panel-header">
        <span class="panel-icon">📊</span>
        <span class="panel-title">시 예산</span>
        <button class="panel-close" id="btnCloseBudget">×</button>
    </div>
    <div class="budget-panel-content">
        <!-- 수입/지출 그래프 -->
        <div class="budget-section">
            <div class="budget-section-header">
                <span class="section-title">💵 수입</span>
            </div>
            <div class="budget-bars" id="incomeBars">
                <div class="budget-bar-row">
                    <span class="bar-icon">🏠</span>
                    <span class="bar-label">주거 세금</span>
                    <div class="bar-graph">
                        <div class="bar-fill income" id="barResidential" style="width: 60%;"></div>
                    </div>
                    <span class="bar-value" id="valResidential">₩0</span>
                    <div class="tax-rate-control">
                        <input type="range" min="0" max="20" value="10" id="taxResidential" class="tax-slider">
                        <span class="tax-percent" id="taxResidentialPercent">10%</span>
                    </div>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🏪</span>
                    <span class="bar-label">상업 세금</span>
                    <div class="bar-graph">
                        <div class="bar-fill income" id="barCommercial" style="width: 40%;"></div>
                    </div>
                    <span class="bar-value" id="valCommercial">₩0</span>
                    <div class="tax-rate-control">
                        <input type="range" min="0" max="20" value="10" id="taxCommercial" class="tax-slider">
                        <span class="tax-percent" id="taxCommercialPercent">10%</span>
                    </div>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🏭</span>
                    <span class="bar-label">공업 세금</span>
                    <div class="bar-graph">
                        <div class="bar-fill income" id="barIndustrial" style="width: 30%;"></div>
                    </div>
                    <span class="bar-value" id="valIndustrial">₩0</span>
                    <div class="tax-rate-control">
                        <input type="range" min="0" max="20" value="10" id="taxIndustrial" class="tax-slider">
                        <span class="tax-percent" id="taxIndustrialPercent">10%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="budget-divider"></div>

        <div class="budget-section">
            <div class="budget-section-header">
                <span class="section-title">💸 지출</span>
            </div>
            <div class="budget-bars" id="expenseBars">
                <div class="budget-bar-row">
                    <span class="bar-icon">🚒</span>
                    <span class="bar-label">소방서</span>
                    <div class="bar-graph">
                        <div class="bar-fill expense" id="barFireExpense" style="width: 20%;"></div>
                    </div>
                    <span class="bar-value expense" id="valFireExpense">-₩0</span>
                    <span class="bar-count" id="countFire">×0</span>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🚔</span>
                    <span class="bar-label">경찰서</span>
                    <div class="bar-graph">
                        <div class="bar-fill expense" id="barPoliceExpense" style="width: 25%;"></div>
                    </div>
                    <span class="bar-value expense" id="valPoliceExpense">-₩0</span>
                    <span class="bar-count" id="countPolice">×0</span>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🏫</span>
                    <span class="bar-label">학교</span>
                    <div class="bar-graph">
                        <div class="bar-fill expense" id="barSchoolExpense" style="width: 30%;"></div>
                    </div>
                    <span class="bar-value expense" id="valSchoolExpense">-₩0</span>
                    <span class="bar-count" id="countSchool">×0</span>
                </div>
                <div class="budget-bar-row">
                    <span class="bar-icon">🌳</span>
                    <span class="bar-label">공원</span>
                    <div class="bar-graph">
                        <div class="bar-fill expense" id="barParkExpense" style="width: 10%;"></div>
                    </div>
                    <span class="bar-value expense" id="valParkExpense">-₩0</span>
                    <span class="bar-count" id="countPark">×0</span>
                </div>
            </div>
        </div>

        <div class="budget-divider"></div>

        <!-- 요약 -->
        <div class="budget-summary">
            <div class="summary-row">
                <span class="summary-label">총 수입</span>
                <span class="summary-value income" id="totalIncome">+₩0/h</span>
            </div>
            <div class="summary-row">
                <span class="summary-label">총 지출</span>
                <span class="summary-value expense" id="totalExpense">-₩0/h</span>
            </div>
            <div class="summary-row total">
                <span class="summary-label">순이익</span>
                <span class="summary-value" id="netProfit">+₩0/h</span>
            </div>
        </div>

        <div class="budget-divider"></div>

        <!-- 채권 -->
        <div class="budget-section">
            <div class="budget-section-header">
                <span class="section-title">💳 채권</span>
            </div>
            <div class="bond-cards">
                <div class="bond-card" id="bondA">
                    <div class="bond-name">채권 A</div>
                    <div class="bond-amount">₩10,000</div>
                    <div class="bond-interest">이자 5%</div>
                    <button class="bond-btn" id="btnBondA">발행</button>
                </div>
                <div class="bond-card" id="bondB">
                    <div class="bond-name">채권 B</div>
                    <div class="bond-amount">₩50,000</div>
                    <div class="bond-interest">이자 7%</div>
                    <button class="bond-btn" id="btnBondB">발행</button>
                </div>
                <div class="bond-card" id="bondC">
                    <div class="bond-name">채권 C</div>
                    <div class="bond-amount">₩100,000</div>
                    <div class="bond-interest">이자 10%</div>
                    <button class="bond-btn" id="btnBondC">발행</button>
                </div>
            </div>
            <div class="bond-debt">
                현재 부채: <span id="totalDebt">₩0</span> (이자: <span id="debtInterest">₩0/h</span>)
            </div>
        </div>

        <div class="budget-divider"></div>

        <!-- 총 자산 -->
        <div class="budget-total">
            <span class="total-label">💵 총 자산</span>
            <span class="total-value" id="totalAssets">₩0</span>
        </div>
    </div>
</div>

<!-- ===== POPULATION PANEL ===== -->
<div id="populationPanel">
    <div class="pop-panel-header">
        <span class="panel-icon">👥</span>
        <span class="panel-title">인구 통계</span>
        <button class="panel-close" id="btnClosePopulation">×</button>
    </div>
    <div class="pop-panel-content">
        <!-- 총 인구 -->
        <div class="pop-stat-grid">
            <div class="pop-stat-card full-width">
                <div class="stat-icon">🏙️</div>
                <div class="stat-label">총 인구</div>
                <div class="stat-value" id="popTotalValue">0</div>
            </div>
            <div class="pop-stat-card">
                <div class="stat-icon">🏠</div>
                <div class="stat-label">주거 건물</div>
                <div class="stat-value" id="popResidentialBuildings">0</div>
            </div>
            <div class="pop-stat-card">
                <div class="stat-icon">📊</div>
                <div class="stat-label">평균 인구/건물</div>
                <div class="stat-value" id="popAvgPerBuilding">0</div>
            </div>
        </div>

        <!-- 계층별 인구 -->
        <div class="pop-tier-section">
            <div class="section-title">계층별 인구 분포</div>
            <div class="pop-tier-bar">
                <span class="tier-icon">🏢</span>
                <span class="tier-label">중산층</span>
                <div class="tier-bar-bg">
                    <div class="tier-bar-fill middle" id="tierBarMiddle" style="width: 0%;"></div>
                </div>
                <span class="tier-value" id="tierValueMiddle">0명</span>
            </div>
            <div class="pop-tier-bar">
                <span class="tier-icon">🏰</span>
                <span class="tier-label">상류층</span>
                <div class="tier-bar-bg">
                    <div class="tier-bar-fill high" id="tierBarHigh" style="width: 0%;"></div>
                </div>
                <span class="tier-value" id="tierValueHigh">0명</span>
            </div>
        </div>
    </div>
</div>

<!-- Mode Hint with Exit Button -->
<div id="hintContainer">
    <div id="hint">Camera Mode</div>
    <button id="btnExitMode" title="모드 종료 (ESC)">✕</button>
</div>

<!-- Cost Tooltip (follows mouse) -->
<div id="costTooltip"></div>

<!-- Graph Tooltip (population/land value) -->
<div id="graphTooltip">
    <span class="label"></span>
    <span class="value"></span>
</div>

<!-- Camera Settings Panel -->
<div id="cameraSettingsPanel">
    <div class="panel-header">
        <div class="panel-title">
            <span class="icon">📷</span>
            <span>카메라 설정</span>
        </div>
        <button class="panel-close" id="cameraSettingsClose">×</button>
    </div>
    <div class="panel-content">
        <div class="camera-setting-row">
            <div class="camera-setting-label">
                <span class="name">최소 줌</span>
                <span class="value" id="minZoomValue">0.1</span>
            </div>
            <input type="range" class="camera-setting-slider" id="minZoomSlider" min="0.1" max="10" step="0.1" value="0.1">
        </div>
        <div class="camera-setting-row">
            <div class="camera-setting-label">
                <span class="name">최대 줌</span>
                <span class="value" id="maxZoomValue">80</span>
            </div>
            <input type="range" class="camera-setting-slider" id="maxZoomSlider" min="20" max="150" step="5" value="80">
        </div>
        <div class="camera-settings-divider"></div>
        <div class="camera-setting-row">
            <div class="camera-setting-label">
                <span class="name">최소 각도</span>
                <span class="value" id="minAngleValue">0°</span>
            </div>
            <input type="range" class="camera-setting-slider" id="minAngleSlider" min="0" max="45" step="1" value="0">
        </div>
        <div class="camera-setting-row">
            <div class="camera-setting-label">
                <span class="name">최대 각도</span>
                <span class="value" id="maxAngleValue">89°</span>
            </div>
            <input type="range" class="camera-setting-slider" id="maxAngleSlider" min="45" max="89" step="1" value="89">
        </div>
        <div class="camera-settings-divider"></div>
        <button class="camera-reset-btn" id="cameraResetBtn">기본값으로 초기화</button>
    </div>
</div>

<!-- Legacy elements for JS compatibility -->
<div id="toolbar" style="display:none;">
    <button id="btnZoneResidential"></button>
    <button id="btnZoneCommercial"></button>
    <button id="btnZoneIndustrial"></button>
    <button id="btnZoneDelete"></button>
</div>
<div id="hud" style="display:none;"></div>
<div id="ui" style="display:none;"></div>

<div id="saveIndicator"></div>
<div id="toastRoot"></div>

<canvas id="c"></canvas>

<script type="module">
    const GRID_W = 48;
    const GRID_H = 48;
    const TILE_SIZE = 1;
    const ORIGIN_X = -GRID_W / 2;
    const ORIGIN_Z = -GRID_H / 2;
    const roadCenterOffset = {
        straight: new THREE.Vector3(),
        corner:   new THREE.Vector3(),
        t:        new THREE.Vector3(),
        cross:    new THREE.Vector3(),
    };
    const road4laneCenterOffset = {
        straight: new THREE.Vector3(),
        corner:   new THREE.Vector3(),
        t:        new THREE.Vector3(),
        cross:    new THREE.Vector3(),
        // 2차선 연결용 모델
        straight_side_full: new THREE.Vector3(),
        straight_side_single: new THREE.Vector3(),
        straight_side_single_reversed: new THREE.Vector3(),
        straight_side_corner: new THREE.Vector3(),
        straight_side_corner_reversed: new THREE.Vector3(),
        straight_both_sides: new THREE.Vector3(),
    };

    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // Post-processing imports
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

    // Three.quarks particle system
    import {
        ParticleSystem,
        QuarksLoader,
        BatchedParticleRenderer,
        ConstantValue,
        IntervalValue,
        ConstantColor,
        ColorRange,
        RandomColor,
        Gradient,
        ColorOverLife,
        SizeOverLife,
        RotationOverLife,
        SpeedOverLife,
        FrameOverLife,
        ForceOverLife,
        OrbitOverLife,
        WidthOverLength,
        ApplyForce,
        Rotation3DOverLife,
        SpriteBatch,
        ConeEmitter,
        SphereEmitter,
        PointEmitter,
        DonutEmitter,
        RenderMode,
        PiecewiseBezier,
        Bezier
    } from "three.quarks";

    /* =========================================================
     * 반응형 UI 스케일 시스템
     * ========================================================= */
    const UI_BASE_WIDTH = 1920;  // 기준 해상도 너비
    const UI_BASE_HEIGHT = 1080; // 기준 해상도 높이
    const UI_MIN_SCALE = 0.6;    // 최소 스케일
    const UI_MAX_SCALE = 1.5;    // 최대 스케일

    function updateUIScale() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        // 너비와 높이 중 작은 비율 사용
        const scaleByWidth = width / UI_BASE_WIDTH;
        const scaleByHeight = height / UI_BASE_HEIGHT;
        let scale = Math.min(scaleByWidth, scaleByHeight);

        // 스케일 범위 제한
        scale = Math.max(UI_MIN_SCALE, Math.min(UI_MAX_SCALE, scale));

        // CSS 변수 업데이트
        document.documentElement.style.setProperty('--ui-scale', scale.toFixed(3));
    }

    // 초기 스케일 설정
    updateUIScale();

    // 창 크기 변경 시 스케일 업데이트 (디바운스 적용)
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateUIScale, 100);
    });

    // 틸트-시프트 쉐이더 (미니어처 효과)
    const TiltShiftShader = {
        uniforms: {
            'tDiffuse': { value: null },
            'blurAmount': { value: 0.0 },     // 블러 강도 (0~1)
            'focusCenter': { value: 0.5 },    // 초점 중심 (0~1, 0.5=화면 중앙)
            'focusRange': { value: 0.3 },     // 초점 범위 (작을수록 좁은 초점)
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float blurAmount;
            uniform float focusCenter;
            uniform float focusRange;
            varying vec2 vUv;

            void main() {
                vec4 color = vec4(0.0);

                // 초점 거리 계산 (상하 가장자리에서 멀어질수록 블러)
                float dist = abs(vUv.y - focusCenter);
                float blur = smoothstep(focusRange * 0.5, focusRange, dist) * blurAmount;

                if (blur > 0.001) {
                    // 가우시안 블러 샘플링 (9 샘플)
                    vec2 texelSize = vec2(1.0 / 1920.0, 1.0 / 1080.0);
                    float kernel[9];
                    kernel[0] = 0.0625; kernel[1] = 0.125; kernel[2] = 0.0625;
                    kernel[3] = 0.125;  kernel[4] = 0.25;  kernel[5] = 0.125;
                    kernel[6] = 0.0625; kernel[7] = 0.125; kernel[8] = 0.0625;

                    int index = 0;
                    for (int y = -1; y <= 1; y++) {
                        for (int x = -1; x <= 1; x++) {
                            vec2 offset = vec2(float(x), float(y)) * texelSize * blur * 8.0;
                            color += texture2D(tDiffuse, vUv + offset) * kernel[index];
                            index++;
                        }
                    }
                } else {
                    color = texture2D(tDiffuse, vUv);
                }

                gl_FragColor = color;
            }
        `
    };

    // 색상 보정 쉐이더 (채도, 밝기, 대비)
    const ColorCorrectionShader = {
        uniforms: {
            'tDiffuse': { value: null },
            'saturation': { value: 1.3 },    // 채도 (1.0 = 기본, >1 = 더 선명)
            'brightness': { value: 0.05 },   // 밝기 추가 (+/-)
            'contrast': { value: 1.1 },      // 대비 (1.0 = 기본)
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float saturation;
            uniform float brightness;
            uniform float contrast;
            varying vec2 vUv;

            void main() {
                vec4 color = texture2D(tDiffuse, vUv);

                // 밝기 조정
                color.rgb += brightness;

                // 대비 조정
                color.rgb = (color.rgb - 0.5) * contrast + 0.5;

                // 채도 조정 (luminance 기반)
                float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                color.rgb = mix(vec3(luminance), color.rgb, saturation);

                // 클램프
                color.rgb = clamp(color.rgb, 0.0, 1.0);

                gl_FragColor = color;
            }
        `
    };

    const loader = new GLTFLoader();

    /* =========================================================
     * DOM REFERENCES
     * ========================================================= */
    const moneyText = document.getElementById("moneyText");
    const costPerMeterText = document.getElementById("costPerMeterText");
    const hudCard = document.querySelector(".hud-card");
    const toastRoot = document.getElementById("toastRoot");
    const loadingEl = document.getElementById("loading");
    const saveIndicator = document.getElementById("saveIndicator");

    const canvas = document.querySelector("#c");
    const btnCam = document.getElementById("btnCam");
    const btnBuild = document.getElementById("btnBuild");
    const btnDemolish = document.getElementById("btnDemolish");
    const hint = document.getElementById("hint");
    const hintContainer = document.getElementById("hintContainer");
    const btnExitMode = document.getElementById("btnExitMode");
    const costTooltip = document.getElementById("costTooltip");
    const graphTooltip = document.getElementById("graphTooltip");

    // New Cities Skylines style buttons
    const btnZones = document.getElementById("btnZones");
    const btnPower = document.getElementById("btnPower");
    const btnWater = document.getElementById("btnWater");

    // Public facility buttons (individual)
    const btnPolice = document.getElementById("btnPolice");
    const btnFire = document.getElementById("btnFire");
    const btnSchool = document.getElementById("btnSchool");
    const btnHospital = document.getElementById("btnHospital");
    const btnParkBtn = document.getElementById("btnPark");

    // Submenu elements
    const subMenu = document.getElementById("subMenu");
    const submenuTitle = document.getElementById("submenuTitle");
    const submenuItems = document.getElementById("submenuItems");

    // Info panel
    const infoPanel = document.getElementById("infoPanel");

    // Left sidebar (zone stats buttons)
    const leftSidebar = document.getElementById("leftSidebar");
    const btnLandValue = document.getElementById("btnLandValue");
    const btnPopulation = document.getElementById("btnPopulation");

    // Right sidebar (road mode - traffic view)
    const rightSidebarRoad = document.getElementById("rightSidebarRoad");
    const btnTrafficView = document.getElementById("btnTrafficView");


    // Building info popup
    const buildingPopup = document.getElementById("buildingPopup");
    const popupIcon = document.getElementById("popupIcon");
    const popupTitle = document.getElementById("popupTitle");
    const popupClose = document.getElementById("popupClose");
    const popupType = document.getElementById("popupType");
    const popupTypeIcon = document.getElementById("popupTypeIcon");
    const popupTypeText = document.getElementById("popupTypeText");
    const popupPopulationRow = document.getElementById("popupPopulationRow");
    const popupPopulation = document.getElementById("popupPopulation");
    const popupHappiness = document.getElementById("popupHappiness");
    const happinessEmoji = document.getElementById("happinessEmoji");
    const happinessBarContainer = document.getElementById("happinessBarContainer");
    const happinessBarFill = document.getElementById("happinessBarFill");
    const happinessValue = document.getElementById("happinessValue");
    const citizenQuote = document.getElementById("citizenQuote");
    const citizenQuoteText = document.getElementById("citizenQuoteText");

    // Construction popup
    const constructionPopup = document.getElementById("constructionPopup");
    const constructionTitle = document.getElementById("constructionTitle");
    const constructionStatus = document.getElementById("constructionStatus");
    const constructionTotalTime = document.getElementById("constructionTotalTime");
    const constructionTimeLeft = document.getElementById("constructionTimeLeft");
    const constructionProgress = document.getElementById("constructionProgress");
    const constructionPopupClose = document.getElementById("constructionPopupClose");

    // Public building popup
    const publicBuildingPopup = document.getElementById("publicBuildingPopup");
    const publicPopupIcon = document.getElementById("publicPopupIcon");
    const publicPopupTitle = document.getElementById("publicPopupTitle");
    const publicPopupClose = document.getElementById("publicPopupClose");
    const publicPopupType = document.getElementById("publicPopupType");
    const publicPopupTypeIcon = document.getElementById("publicPopupTypeIcon");
    const publicPopupTypeText = document.getElementById("publicPopupTypeText");
    const firetruckStatusSection = document.getElementById("firetruckStatusSection");
    const firetruckBarDispatched = document.getElementById("firetruckBarDispatched");
    const firetruckBarAvailable = document.getElementById("firetruckBarAvailable");
    const firetruckDispatched = document.getElementById("firetruckDispatched");
    const firetruckAvailable = document.getElementById("firetruckAvailable");
    const firetruckTotal = document.getElementById("firetruckTotal");
    const firetruckMax = document.getElementById("firetruckMax");

    // 경찰서 현황 요소
    const policeStatusSection = document.getElementById("policeStatusSection");
    const policeBarDispatched = document.getElementById("policeBarDispatched");
    const policeBarAvailable = document.getElementById("policeBarAvailable");
    const policeDispatched = document.getElementById("policeDispatched");
    const policeAvailable = document.getElementById("policeAvailable");
    const policeTotal = document.getElementById("policeTotal");
    const policeMax = document.getElementById("policeMax");
    const prisonBarOccupied = document.getElementById("prisonBarOccupied");
    const prisonBarEmpty = document.getElementById("prisonBarEmpty");
    const prisonOccupied = document.getElementById("prisonOccupied");
    const prisonEmpty = document.getElementById("prisonEmpty");
    const prisonTotal = document.getElementById("prisonTotal");
    const prisonMax = document.getElementById("prisonMax");

    // 병원 현황 요소
    const hospitalStatusSection = document.getElementById("hospitalStatusSection");
    const ambulanceBarDispatched = document.getElementById("ambulanceBarDispatched");
    const ambulanceBarAvailable = document.getElementById("ambulanceBarAvailable");
    const ambulanceDispatched = document.getElementById("ambulanceDispatched");
    const ambulanceAvailable = document.getElementById("ambulanceAvailable");
    const ambulanceTotal = document.getElementById("ambulanceTotal");
    const ambulanceMax = document.getElementById("ambulanceMax");
    const patientBarOccupied = document.getElementById("patientBarOccupied");
    const patientBarEmpty = document.getElementById("patientBarEmpty");
    const patientOccupied = document.getElementById("patientOccupied");
    const patientEmpty = document.getElementById("patientEmpty");
    const patientTotal = document.getElementById("patientTotal");
    const patientMax = document.getElementById("patientMax");

    // Bottom bar stats
    const popBottomText = document.getElementById("popBottomText");
    const happyBottomText = document.getElementById("happyBottomText");

    /* =========================================================
     * SUBMENU SYSTEM (Cities Skylines Style)
     * ========================================================= */
    let currentSubmenu = null;

    const SUBMENU_CONFIG = {
        roads: {
            title: '🛣️ 도로/수로',
            items: [
                { id: 'road2lane', icon: '🛤️', color: '#666666', name: '2차로', desc: '기본 도로' },
                { id: 'road4lane', icon: '🛣️', color: '#888888', name: '4차로', desc: '대로' },
                { id: 'water', icon: '🌊', color: '#3b82f6', name: '수로', desc: '수로 설치' },
            ]
        },
        zones: {
            title: '🏘️ Zones',
            items: [
                { id: 'residential', icon: '🏠', color: '#4ade80', name: 'Residential', desc: 'Housing area' },
                { id: 'commercial', icon: '🏪', color: '#60a5fa', name: 'Commercial', desc: 'Shopping area' },
                { id: 'industrial', icon: '🏭', color: '#fbbf24', name: 'Industrial', desc: 'Factory area' },
                { id: 'delete', icon: '❌', color: '#ef4444', name: 'Delete', desc: 'Remove zone' },
            ]
        },
        buildings: {
            title: '🏛️ Buildings',
            items: [
                { id: 'park', icon: '🌳', cost: 1000, name: 'Park', desc: '+10 Happiness' },
                { id: 'school', icon: '🏫', cost: 4000, name: 'School', desc: 'Education' },
                { id: 'hospital', icon: '🏥', cost: 6000, name: 'Hospital', desc: 'Healthcare' },
            ]
        },
        power: {
            title: '⚡ 전력',
            items: [
                { id: 'powerplant_coal', icon: '🏭', cost: 5000, maintenance: 100, name: '화력 발전소', desc: '석탄을 태워 전기를 생산합니다. 대용량이지만 오염을 유발합니다.', powerOutput: 500, effectRadius: 15, size: '2x2' },
                { id: 'powerplant_wind', icon: '💨', cost: 3000, maintenance: 30, name: '풍력 발전기', desc: '바람으로 전기를 생산합니다. 친환경이지만 소용량입니다.', powerOutput: 100, effectRadius: 8, size: '1x1' },
                { id: 'powerplant_solar', icon: '☀️', cost: 4000, maintenance: 40, name: '태양광 발전소', desc: '태양광으로 전기를 생산합니다. 친환경 중용량 발전소입니다.', powerOutput: 200, effectRadius: 10, size: '2x2', disabled: true },
            ]
        },
        waterSupply: {
            title: '💧 수도',
            items: [
                { id: 'water_tower', icon: '🏗️', cost: 4000, maintenance: 60, name: '급수탑', desc: '물을 저장하고 공급합니다. 대용량 수도 시설입니다.', waterOutput: 400, effectRadius: 12, size: '2x2' },
                { id: 'water_pump', icon: '💧', cost: 2000, maintenance: 25, name: '펌프장', desc: '지하수를 퍼올려 수도를 공급합니다. 소용량이지만 저렴합니다.', waterOutput: 150, effectRadius: 8, size: '1x1' },
            ]
        },
        services: {
            title: '🚒 Services',
            items: [
                { id: 'police', icon: '🚔', cost: 3000, name: 'Police', desc: 'Crime prevention', size: '2x2' },
                { id: 'fire', icon: '🚒', cost: 3000, name: 'Fire Station', desc: 'Fire prevention', size: '2x2' },
                { id: 'school', icon: '🏫', cost: 4000, name: 'School', desc: 'Education', size: '2x2' },
                { id: 'park', icon: '🌳', cost: 1000, name: 'Park', desc: '+10 Happiness', size: '2x2' },
            ]
        },
        fire: {
            title: '🚒 소방서',
            items: [
                { id: 'fire_small', icon: '🚒', cost: 3000, maintenance: 50, name: '동네 소방서', desc: '화재 예방 및 신속한 진압으로 건물과 시민을 보호합니다.', effectRadius: 8, size: '2x2' },
                { id: 'fire_large', icon: '🏢', cost: 8000, maintenance: 120, name: '대형 소방서', desc: '넓은 범위의 화재에 대응할 수 있는 대형 시설입니다. (미구현)', effectRadius: 15, size: '3x3', disabled: true },
            ]
        },
        police: {
            title: '🚔 경찰서',
            items: [
                { id: 'police_small', icon: '🚔', cost: 3000, maintenance: 60, name: '소형 경찰서', desc: '범죄를 예방하고 치안을 유지하여 시민들의 안전을 보장합니다.', effectRadius: 8, size: '2x2' },
                { id: 'police_large', icon: '🏛️', cost: 8000, maintenance: 150, name: '대형 경찰서', desc: '광범위한 지역의 치안을 담당하는 대형 시설입니다. (미구현)', effectRadius: 15, size: '3x3', disabled: true },
            ]
        },
        school: {
            title: '🏫 학교',
            items: [
                { id: 'school_small', icon: '🏫', cost: 4000, maintenance: 80, name: '초등학교', desc: '시민들에게 교육 서비스를 제공하여 중류층 전환율을 높입니다.', effectRadius: 10, size: '2x2' },
                { id: 'school_large', icon: '🎓', cost: 10000, maintenance: 200, name: '고등학교', desc: '고급 교육을 제공하여 상류층 전환율을 높입니다. (미구현)', effectRadius: 18, size: '3x3', disabled: true },
            ]
        },
        park: {
            title: '🌳 공원',
            items: [
                { id: 'park_small', icon: '🌳', cost: 1000, maintenance: 20, name: '소형 공원', desc: '녹지 공간을 제공하여 시민들의 행복도를 높입니다.', effectRadius: 5, size: '2x2' },
                { id: 'park_large', icon: '🏞️', cost: 5000, maintenance: 50, name: '대형 공원', desc: '넓은 녹지 공간으로 더 많은 시민에게 휴식을 제공합니다. (미구현)', effectRadius: 10, size: '3x3', disabled: true },
            ]
        },
        hospital: {
            title: '🏥 병원',
            items: [
                { id: 'hospital_small', icon: '🏥', cost: 6000, maintenance: 100, name: '동네 병원', desc: '시민들에게 의료 서비스를 제공하여 상류층 전환율을 높이고 행복도를 증가시킵니다.', effectRadius: 12, size: '2x2' },
                { id: 'hospital_large', icon: '🏨', cost: 15000, maintenance: 250, name: '종합병원', desc: '넓은 지역에 고급 의료 서비스를 제공합니다. (미구현)', effectRadius: 20, size: '3x3', disabled: true },
            ]
        }
    };

    // ===== SUBMENU TOOLTIP FUNCTIONS =====
    const submenuTooltip = document.getElementById('submenuTooltip');
    const tooltipIcon = document.getElementById('tooltipIcon');
    const tooltipName = document.getElementById('tooltipName');
    const tooltipCost = document.getElementById('tooltipCost');
    const tooltipMaintenance = document.getElementById('tooltipMaintenance');
    const tooltipDesc = document.getElementById('tooltipDesc');

    function showSubmenuTooltip(item, x, y) {
        if (!submenuTooltip) return;

        tooltipIcon.textContent = item.icon || '🏛️';
        tooltipName.textContent = item.name || '';
        tooltipCost.textContent = item.cost ? `${i18n.getCurrency()}${item.cost.toLocaleString()}` : '-';
        tooltipMaintenance.textContent = item.maintenance ? `${i18n.getCurrency()}${item.maintenance}/시간` : '-';
        tooltipDesc.textContent = item.desc || '';

        submenuTooltip.style.display = 'block';
        updateSubmenuTooltipPosition(x, y);
    }

    function updateSubmenuTooltipPosition(x, y) {
        if (!submenuTooltip) return;

        const tooltipWidth = submenuTooltip.offsetWidth;
        const tooltipHeight = submenuTooltip.offsetHeight;

        // 툴팁을 마우스 위에 표시 (서브메뉴보다 위로)
        let posX = x - tooltipWidth / 2;
        let posY = y - tooltipHeight - 20;

        // 화면 경계 체크
        if (posX < 10) posX = 10;
        if (posX + tooltipWidth > window.innerWidth - 10) {
            posX = window.innerWidth - tooltipWidth - 10;
        }
        if (posY < 10) {
            posY = y + 20;  // 위에 공간 없으면 아래로
        }

        submenuTooltip.style.left = posX + 'px';
        submenuTooltip.style.top = posY + 'px';
    }

    function hideSubmenuTooltip() {
        if (submenuTooltip) {
            submenuTooltip.style.display = 'none';
        }
    }

    function openSubMenu(type) {
        if (currentSubmenu === type && subMenu.classList.contains('open')) {
            closeSubMenu();
            return;
        }

        const config = SUBMENU_CONFIG[type];
        if (!config) return;

        currentSubmenu = type;
        submenuTitle.textContent = config.title;
        submenuItems.innerHTML = '';

        config.items.forEach(item => {
            const el = document.createElement('div');
            el.className = 'submenu-item' + (item.disabled ? ' disabled' : '');
            el.innerHTML = `
                <div class="color-box" style="background: ${item.color || '#666'};">${item.icon}</div>
                <div class="name">${item.name}</div>
                ${item.cost ? `<div class="cost">${i18n.getCurrency()}${item.cost}</div>` : ''}
            `;
            el.addEventListener('click', () => handleSubmenuClick(type, item.id));

            // 서비스 건물 툴팁 (운영비, 설명 포함)
            if (item.maintenance !== undefined || item.effectRadius !== undefined) {
                el.addEventListener('mouseenter', (e) => {
                    showSubmenuTooltip(item, e.clientX, e.clientY);
                });
                el.addEventListener('mousemove', (e) => {
                    updateSubmenuTooltipPosition(e.clientX, e.clientY);
                });
                el.addEventListener('mouseleave', () => {
                    hideSubmenuTooltip();
                });
            }

            submenuItems.appendChild(el);
        });

        // Update button states
        updateToolButtonStates(type);

        subMenu.classList.add('open');
        if (hintContainer) hintContainer.classList.add('submenu-open');

        // 서브메뉴 열릴 때: 먼저 모든 사이드바 숨기고 해당 사이드바만 표시 (라디오 버튼처럼)
        // 모든 사이드바 숨기기
        if (leftSidebar) leftSidebar.classList.remove('visible');
        if (rightSidebarRoad) rightSidebarRoad.classList.remove('visible');

        // 뷰 모드도 해제
        if (type !== 'zones') {
            // 구역 관련 뷰 모드 해제
            if (currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW) {
                setMode(MODE.CAMERA);
            }
        }
        if (type !== 'roads') {
            // 도로 관련 뷰 모드 해제
            if (currentMode === MODE.TRAFFIC_VIEW) {
                setMode(MODE.CAMERA);
            }
        }
        if (type !== 'power') {
            // 전력 관련 뷰 모드 해제
            if (currentMode === MODE.POWER_VIEW) {
                setMode(MODE.CAMERA);
                powerManager.updatePowerVisualization();
            }
        }

        // 해당 서브메뉴 사이드바만 표시
        if (type === 'roads') {
            // 도로/수로 서브메뉴 → 교통량 토글 표시
            if (rightSidebarRoad) rightSidebarRoad.classList.add('visible');
        } else if (type === 'zones') {
            // 구역 서브메뉴 → 땅값/인구 토글 표시
            if (leftSidebar) leftSidebar.classList.add('visible');
        }

        // 일일 통계 패널 표시/숨김
        const fireStatsPanel = document.getElementById('fireStatsPanel');
        const crimeStatsPanel = document.getElementById('crimeStatsPanel');
        const medicalStatsPanel = document.getElementById('medicalStatsPanel');

        if (fireStatsPanel) fireStatsPanel.style.display = 'none';
        if (crimeStatsPanel) crimeStatsPanel.style.display = 'none';
        if (medicalStatsPanel) medicalStatsPanel.style.display = 'none';

        if (type === 'fire') {
            if (fireStatsPanel) {
                fireStatsPanel.style.display = 'block';
                updateDailyStatsPanel();
            }
        } else if (type === 'police') {
            if (crimeStatsPanel) {
                crimeStatsPanel.style.display = 'block';
                updateDailyStatsPanel();
            }
        } else if (type === 'hospital') {
            if (medicalStatsPanel) {
                medicalStatsPanel.style.display = 'block';
                updateDailyStatsPanel();
            }
        }
    }

    function closeSubMenu() {
        // 서브메뉴 닫힐 때 현재 모드가 해당 뷰 모드가 아니면 사이드바도 숨김
        if (currentSubmenu === 'roads') {
            const isRoadMode = currentMode === MODE.BUILD || currentMode === MODE.BUILD_4LANE || currentMode === MODE.WATER || currentMode === MODE.TRAFFIC_VIEW;
            if (!isRoadMode && rightSidebarRoad) {
                rightSidebarRoad.classList.remove('visible');
                if (btnTrafficView) btnTrafficView.classList.remove('active');
            }
        } else if (currentSubmenu === 'zones') {
            const isZoneModeActive = isZoneMode() || currentMode === MODE.ZONE_DELETE ||
                                     currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW;
            if (!isZoneModeActive && leftSidebar) {
                leftSidebar.classList.remove('visible');
            }
        } else if (currentSubmenu === 'power') {
            const isPowerModeActive = currentMode === MODE.PLACE_POWER_COAL ||
                                      currentMode === MODE.PLACE_POWER_WIND ||
                                      currentMode === MODE.POWER_VIEW;
            if (!isPowerModeActive) {
                powerManager.updatePowerVisualization();
            }
        }

        subMenu.classList.remove('open');
        currentSubmenu = null;
        if (hintContainer) hintContainer.classList.remove('submenu-open');

        // 일일 통계 패널 숨기기
        const fireStatsPanel = document.getElementById('fireStatsPanel');
        const crimeStatsPanel = document.getElementById('crimeStatsPanel');
        const medicalStatsPanel = document.getElementById('medicalStatsPanel');
        if (fireStatsPanel) fireStatsPanel.style.display = 'none';
        if (crimeStatsPanel) crimeStatsPanel.style.display = 'none';
        if (medicalStatsPanel) medicalStatsPanel.style.display = 'none';
    }

    // Make closeSubMenu globally accessible for onclick
    window.closeSubMenu = closeSubMenu;

    function handleSubmenuClick(type, itemId) {
        if (type === 'roads') {
            switch(itemId) {
                case 'road2lane':
                    setMode(MODE.BUILD);
                    break;
                case 'road4lane':
                    setMode(MODE.BUILD_4LANE);
                    break;
                case 'water':
                    setMode(MODE.WATER);
                    break;
            }
        } else if (type === 'zones') {
            switch(itemId) {
                case 'residential':
                    setMode(MODE.ZONE_RESIDENTIAL);
                    break;
                case 'commercial':
                    setMode(MODE.ZONE_COMMERCIAL);
                    break;
                case 'industrial':
                    setMode(MODE.ZONE_INDUSTRIAL);
                    break;
                case 'delete':
                    setMode(MODE.ZONE_DELETE);
                    break;
            }
        } else if (type === 'services') {
            switch(itemId) {
                case 'police':
                    setMode(MODE.PLACE_POLICE);
                    break;
                case 'fire':
                    setMode(MODE.PLACE_FIRE);
                    break;
                case 'school':
                    setMode(MODE.PLACE_SCHOOL);
                    break;
                case 'park':
                    setMode(MODE.PLACE_PARK);
                    break;
            }
        } else if (type === 'fire') {
            switch(itemId) {
                case 'fire_small':
                    setMode(MODE.PLACE_FIRE);
                    break;
                case 'fire_large':
                    toast({
                        title: '미구현',
                        desc: '대형 소방서는 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'police') {
            switch(itemId) {
                case 'police_small':
                    setMode(MODE.PLACE_POLICE);
                    break;
                case 'police_large':
                    toast({
                        title: '미구현',
                        desc: '대형 경찰서는 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'school') {
            switch(itemId) {
                case 'school_small':
                    setMode(MODE.PLACE_SCHOOL);
                    break;
                case 'school_large':
                    toast({
                        title: '미구현',
                        desc: '고등학교는 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'park') {
            switch(itemId) {
                case 'park_small':
                    setMode(MODE.PLACE_PARK);
                    break;
                case 'park_large':
                    toast({
                        title: '미구현',
                        desc: '대형 공원은 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'hospital') {
            switch(itemId) {
                case 'hospital_small':
                    setMode(MODE.PLACE_HOSPITAL);
                    break;
                case 'hospital_large':
                    toast({
                        title: '미구현',
                        desc: '종합병원은 아직 준비 중입니다.',
                    });
                    return; // 서브메뉴 닫지 않음
            }
        } else if (type === 'power') {
            switch(itemId) {
                case 'powerplant_coal':
                    setMode(MODE.PLACE_POWER_COAL);
                    break;
                case 'powerplant_wind':
                    setMode(MODE.PLACE_POWER_WIND);
                    break;
                case 'powerplant_solar':
                    toast({
                        title: '미구현',
                        desc: '태양광 발전소는 아직 준비 중입니다.',
                    });
                    return;
            }
        } else if (type === 'waterSupply') {
            switch(itemId) {
                case 'water_tower':
                    setMode(MODE.PLACE_WATER_TOWER);
                    break;
                case 'water_pump':
                    setMode(MODE.PLACE_WATER_PUMP);
                    break;
            }
        } else if (type === 'buildings') {
            toast({
                title: i18n.t('toast.comingSoon') || 'Coming Soon',
                desc: i18n.t('toast.comingSoonDesc') || 'This feature will be available soon!',
            });
        }
        closeSubMenu();
    }

    function updateToolButtonStates(activeType) {
        clearToolButtonActive();
        if (activeType === 'roads' && btnBuild) btnBuild.classList.add('active');
        if (activeType === 'zones' && btnZones) btnZones.classList.add('active');
        if (activeType === 'power' && btnPower) btnPower.classList.add('active');
        if (activeType === 'waterSupply' && btnWater) btnWater.classList.add('active');
        if (activeType === 'fire' && btnFire) btnFire.classList.add('active');
        if (activeType === 'police' && btnPolice) btnPolice.classList.add('active');
        if (activeType === 'school' && btnSchool) btnSchool.classList.add('active');
        if (activeType === 'hospital' && btnHospital) btnHospital.classList.add('active');
        if (activeType === 'park' && btnParkBtn) btnParkBtn.classList.add('active');
    }

    function clearToolButtonActive() {
        btnCam.classList.remove('active');
        if (btnBuild) btnBuild.classList.remove('active');
        if (btnZones) btnZones.classList.remove('active');
        if (btnPower) btnPower.classList.remove('active');
        if (btnWater) btnWater.classList.remove('active');
        if (btnDemolish) btnDemolish.classList.remove('active');
        // Public facility buttons
        if (btnPolice) btnPolice.classList.remove('active');
        if (btnFire) btnFire.classList.remove('active');
        if (btnSchool) btnSchool.classList.remove('active');
        if (btnHospital) btnHospital.classList.remove('active');
        if (btnParkBtn) btnParkBtn.classList.remove('active');
    }

    // Toggle info panel (collapsible)
    function toggleInfoPanel() {
        if (infoPanel) {
            infoPanel.classList.toggle('collapsed');
        }
    }
    window.toggleInfoPanel = toggleInfoPanel;

    /* =========================================================
     * TEST MODE (테스트용 - 돈 무한, DB 저장 비활성화)
     * ========================================================= */
    const TEST_MODE = false;  // DB 연동 활성화
    const UNLIMITED_MONEY = true;  // 테스트용: 자금 무한 (DB 저장은 유지)

    /* =========================================================
     * ECONOMY
     * ========================================================= */
    const economy = {
        money: UNLIMITED_MONEY ? 9999999 : 5000,
        roadCostPerMeter: 25,
    };

    /* =========================================================
     * BUDGET SYSTEM (예산 시스템)
     * ========================================================= */
    const budgetSystem = {
        // 세금율 (0~20%, 기본 10%)
        taxRates: {
            residential: 10,
            commercial: 10,
            industrial: 10
        },
        // 발행된 채권
        issuedBonds: {
            A: false,
            B: false,
            C: false
        },
        // 채권 정보
        bondInfo: {
            A: { amount: 10000, interest: 0.05 },
            B: { amount: 50000, interest: 0.07 },
            C: { amount: 100000, interest: 0.10 }
        },
        // 계산된 값들
        taxIncome: { residential: 0, commercial: 0, industrial: 0, total: 0 },
        operatingCost: { fire: 0, police: 0, school: 0, park: 0, total: 0 },
        buildingCounts: { fire: 0, police: 0, school: 0, park: 0 },
        debtInterest: 0,
        totalDebt: 0,
        netProfit: 0
    };

    // 배치된 공공시설 Map (조기 초기화 - TDZ 방지)
    let placedPublicBuildings = new Map();

    // 예산 패널 DOM 요소
    const budgetPanel = document.getElementById('budgetPanel');
    const btnCloseBudget = document.getElementById('btnCloseBudget');

    // 중앙 자금 표시 DOM 요소 (하단 툴바)
    const moneyDisplayCenter = document.getElementById('moneyDisplayCenter');
    const moneyRateCenter = document.getElementById('moneyRateCenter');

    // 인구 패널 DOM 요소
    const populationPanel = document.getElementById('populationPanel');
    const populationDisplayBtn = document.getElementById('populationDisplayBtn');
    const btnClosePopulation = document.getElementById('btnClosePopulation');
    const popDisplayCenter = document.getElementById('popDisplayCenter');

    // 인구 패널 세부 요소
    const popTotalValue = document.getElementById('popTotalValue');
    const popResidentialBuildings = document.getElementById('popResidentialBuildings');
    const popAvgPerBuilding = document.getElementById('popAvgPerBuilding');
    const tierBarMiddle = document.getElementById('tierBarMiddle');
    const tierBarHigh = document.getElementById('tierBarHigh');
    const tierValueMiddle = document.getElementById('tierValueMiddle');
    const tierValueHigh = document.getElementById('tierValueHigh');

    // 예산 패널 세부 요소
    const barResidential = document.getElementById('barResidential');
    const barCommercial = document.getElementById('barCommercial');
    const barIndustrial = document.getElementById('barIndustrial');
    const valResidential = document.getElementById('valResidential');
    const valCommercial = document.getElementById('valCommercial');
    const valIndustrial = document.getElementById('valIndustrial');
    const taxResidential = document.getElementById('taxResidential');
    const taxCommercial = document.getElementById('taxCommercial');
    const taxIndustrial = document.getElementById('taxIndustrial');
    const taxResidentialPercent = document.getElementById('taxResidentialPercent');
    const taxCommercialPercent = document.getElementById('taxCommercialPercent');
    const taxIndustrialPercent = document.getElementById('taxIndustrialPercent');

    const barFireExpense = document.getElementById('barFireExpense');
    const barPoliceExpense = document.getElementById('barPoliceExpense');
    const barSchoolExpense = document.getElementById('barSchoolExpense');
    const barParkExpense = document.getElementById('barParkExpense');
    const valFireExpense = document.getElementById('valFireExpense');
    const valPoliceExpense = document.getElementById('valPoliceExpense');
    const valSchoolExpense = document.getElementById('valSchoolExpense');
    const valParkExpense = document.getElementById('valParkExpense');
    const countFire = document.getElementById('countFire');
    const countPolice = document.getElementById('countPolice');
    const countSchool = document.getElementById('countSchool');
    const countPark = document.getElementById('countPark');

    const totalIncomeEl = document.getElementById('totalIncome');
    const totalExpenseEl = document.getElementById('totalExpense');
    const netProfitEl = document.getElementById('netProfit');
    const totalDebtEl = document.getElementById('totalDebt');
    const debtInterestEl = document.getElementById('debtInterest');
    const totalAssetsEl = document.getElementById('totalAssets');

    const btnBondA = document.getElementById('btnBondA');
    const btnBondB = document.getElementById('btnBondB');
    const btnBondC = document.getElementById('btnBondC');
    const bondCardA = document.getElementById('bondA');
    const bondCardB = document.getElementById('bondB');
    const bondCardC = document.getElementById('bondC');

    function formatMoney(n) {
        return i18n.formatMoney(Math.max(0, Math.floor(n)));
    }

    function updateCurrencySymbols() {
        const currency = i18n.getCurrency();
        const symbols = document.querySelectorAll('#currencySymbol, #offlineCurrency, #rewardCurrency');
        symbols.forEach(el => { if (el) el.textContent = currency; });
    }

    function renderMoney() {
        if (moneyText) moneyText.textContent = formatMoney(economy.money);
        if (costPerMeterText) costPerMeterText.textContent = formatMoney(economy.roadCostPerMeter);

        // 예산 패널이 열려있으면 총 자산도 업데이트
        if (budgetPanel && budgetPanel.classList.contains('open') && totalAssetsEl) {
            const assets = economy.money - budgetSystem.totalDebt;
            const sign = assets < 0 ? '-' : '';
            totalAssetsEl.textContent = sign + i18n.getCurrency() + formatMoney(Math.abs(assets));
            totalAssetsEl.style.color = assets >= 0 ? '#4ade80' : '#f87171';
        }
    }

    function flashMoney() {
        if (!hudCard) return;
        hudCard.classList.remove("money-flash");
        void hudCard.offsetWidth;
        hudCard.classList.add("money-flash");
    }

    function canSpend(amount) {
        return economy.money >= amount;
    }

    function toast({ title, desc, ms = 2200, success = false }) {
        const el = document.createElement("div");
        el.className = "toast";
        el.innerHTML = `
            <div class="bar ${success ? 'success' : ''}"></div>
            <div class="body">
              <div class="icon ${success ? 'success' : ''}">${success ? '✓' : '!'}</div>
              <div>
                <div class="title">${title}</div>
                <div class="desc">${desc}</div>
              </div>
            </div>
        `;
        toastRoot.appendChild(el);
        setTimeout(() => {
            el.classList.add("out");
            setTimeout(() => el.remove(), 220);
        }, ms);
    }

    function trySpend(amount, reasonText) {
        // 테스트 모드: 항상 성공, 비용 차감 안함
        if (TEST_MODE || UNLIMITED_MONEY) {
            return true;
        }

        if (!canSpend(amount)) {
            toast({
                title: i18n.t('toast.insufficientFunds'),
                desc: i18n.t('toast.insufficientFundsDesc', {
                    item: reasonText,
                    cost: i18n.getCurrency() + formatMoney(amount),
                    current: i18n.getCurrency() + formatMoney(economy.money)
                }),
            });
            return false;
        }
        economy.money -= amount;
        renderMoney();
        flashMoney();
        return true;
    }

    function calcRoadCostByLengthMeters(lengthMeters) {
        return Math.ceil(lengthMeters * economy.roadCostPerMeter);
    }

    // 경로 기반 비용 계산
    function calcPathCost(path) {
        if (!path || path.length === 0) return 0;
        // 각 타일은 1미터로 계산
        return calcRoadCostByLengthMeters(path.length);
    }

    renderMoney();

    // ========== 예산 계산 함수들 ==========

    // 서비스 건물 수 계산
    function countServiceBuildings() {
        const counts = { fire: 0, police: 0, school: 0, park: 0, hospital: 0 };

        if (typeof placedPublicBuildings !== 'undefined') {
            placedPublicBuildings.forEach((building, key) => {
                // ref가 있는 항목은 참조이므로 스킵 (중복 카운트 방지)
                if (building && building.type && !building.ref && counts.hasOwnProperty(building.type)) {
                    counts[building.type]++;
                }
            });
        }

        budgetSystem.buildingCounts = counts;
        return counts;
    }

    // 서비스 운영비 계산
    function calculateOperatingCosts() {
        const counts = countServiceBuildings();
        const costs = {
            fire: counts.fire * (PUBLIC_BUILDING_MODELS?.fire?.maintenanceCost || 50),
            police: counts.police * (PUBLIC_BUILDING_MODELS?.police?.maintenanceCost || 60),
            school: counts.school * (PUBLIC_BUILDING_MODELS?.school?.maintenanceCost || 80),
            park: counts.park * (PUBLIC_BUILDING_MODELS?.park?.maintenanceCost || 20),
            hospital: counts.hospital * (PUBLIC_BUILDING_MODELS?.hospital?.maintenanceCost || 100),
            total: 0
        };

        costs.total = costs.fire + costs.police + costs.school + costs.park + costs.hospital;
        budgetSystem.operatingCost = costs;
        return costs;
    }

    // 건물별 세금 계산 (건물 레벨 × 시민 수 × 세금율)
    function calculateTaxIncome() {
        const income = { residential: 0, commercial: 0, industrial: 0, total: 0 };

        // 건물 데이터에서 세금 계산
        if (typeof buildingDataMap !== 'undefined') {
            for (const [key, data] of buildingDataMap.entries()) {
                if (!data || !data.zoneType) continue;

                const level = data.level || 1;
                const citizens = data.population || 0;

                // 기본 세금 (레벨 × 시민 수 × 세금율)
                const baseTax = level * citizens;

                switch (data.zoneType) {
                    case 'residential':
                        income.residential += baseTax * (budgetSystem.taxRates.residential / 100);
                        break;
                    case 'commercial':
                        income.commercial += baseTax * (budgetSystem.taxRates.commercial / 100);
                        break;
                    case 'industrial':
                        income.industrial += baseTax * (budgetSystem.taxRates.industrial / 100);
                        break;
                }
            }
        }

        // 구역 타일 기반 기본 세금 (건물 데이터 없을 경우 보완)
        if (income.residential === 0 && typeof cityStats !== 'undefined') {
            income.residential = (cityStats.residentialTiles || 0) * 10 * (budgetSystem.taxRates.residential / 100);
            income.commercial = (cityStats.commercialTiles || 0) * 15 * (budgetSystem.taxRates.commercial / 100);
            income.industrial = (cityStats.industrialTiles || 0) * 12 * (budgetSystem.taxRates.industrial / 100);
        }

        income.total = income.residential + income.commercial + income.industrial;
        budgetSystem.taxIncome = income;
        return income;
    }

    // 채권 이자 계산
    function calculateDebtInterest() {
        let totalDebt = 0;
        let interestPerHour = 0;

        for (const [bondId, issued] of Object.entries(budgetSystem.issuedBonds)) {
            if (issued) {
                const info = budgetSystem.bondInfo[bondId];
                totalDebt += info.amount;
                interestPerHour += info.amount * info.interest;
            }
        }

        budgetSystem.totalDebt = totalDebt;
        budgetSystem.debtInterest = interestPerHour;
        return { totalDebt, interestPerHour };
    }

    // 순이익 계산
    function calculateNetProfit() {
        const income = calculateTaxIncome();
        const costs = calculateOperatingCosts();
        const debt = calculateDebtInterest();

        const netProfit = income.total - costs.total - debt.interestPerHour;
        budgetSystem.netProfit = netProfit;
        return netProfit;
    }

    // 예산 UI 업데이트 (중앙 자금 표시)
    function updateBudgetDisplay() {
        const netProfit = calculateNetProfit();

        // 중앙 자금 표시 업데이트 (SimCity 스타일)
        if (moneyDisplayCenter) {
            moneyDisplayCenter.textContent = formatMoney(economy.money);
        }
        if (moneyRateCenter) {
            const sign = netProfit >= 0 ? '+' : '';
            moneyRateCenter.textContent = sign + i18n.getCurrency() + formatMoney(Math.abs(netProfit)) + '/h';
            moneyRateCenter.className = 'money-rate' + (netProfit < 0 ? ' negative' : '');
        }
    }

    // 예산 패널 UI 업데이트
    function updateBudgetPanel() {
        const income = budgetSystem.taxIncome;
        const costs = budgetSystem.operatingCost;
        const counts = budgetSystem.buildingCounts;

        // 최대값 계산 (그래프 비율 기준)
        const maxIncome = Math.max(income.residential, income.commercial, income.industrial, 1);
        const maxExpense = Math.max(costs.fire, costs.police, costs.school, costs.park, 1);

        // 수입 바
        if (barResidential) barResidential.style.width = (income.residential / maxIncome * 100) + '%';
        if (barCommercial) barCommercial.style.width = (income.commercial / maxIncome * 100) + '%';
        if (barIndustrial) barIndustrial.style.width = (income.industrial / maxIncome * 100) + '%';

        if (valResidential) valResidential.textContent = i18n.getCurrency() + formatMoney(income.residential);
        if (valCommercial) valCommercial.textContent = i18n.getCurrency() + formatMoney(income.commercial);
        if (valIndustrial) valIndustrial.textContent = i18n.getCurrency() + formatMoney(income.industrial);

        // 지출 바
        if (barFireExpense) barFireExpense.style.width = (costs.fire / maxExpense * 100) + '%';
        if (barPoliceExpense) barPoliceExpense.style.width = (costs.police / maxExpense * 100) + '%';
        if (barSchoolExpense) barSchoolExpense.style.width = (costs.school / maxExpense * 100) + '%';
        if (barParkExpense) barParkExpense.style.width = (costs.park / maxExpense * 100) + '%';

        if (valFireExpense) valFireExpense.textContent = '-' + i18n.getCurrency() + formatMoney(costs.fire);
        if (valPoliceExpense) valPoliceExpense.textContent = '-' + i18n.getCurrency() + formatMoney(costs.police);
        if (valSchoolExpense) valSchoolExpense.textContent = '-' + i18n.getCurrency() + formatMoney(costs.school);
        if (valParkExpense) valParkExpense.textContent = '-' + i18n.getCurrency() + formatMoney(costs.park);

        if (countFire) countFire.textContent = '×' + counts.fire;
        if (countPolice) countPolice.textContent = '×' + counts.police;
        if (countSchool) countSchool.textContent = '×' + counts.school;
        if (countPark) countPark.textContent = '×' + counts.park;

        // 요약
        if (totalIncomeEl) totalIncomeEl.textContent = '+' + i18n.getCurrency() + formatMoney(income.total) + '/h';
        if (totalExpenseEl) totalExpenseEl.textContent = '-' + i18n.getCurrency() + formatMoney(costs.total) + '/h';

        const netProfit = budgetSystem.netProfit;
        if (netProfitEl) {
            const sign = netProfit >= 0 ? '+' : '';
            netProfitEl.textContent = sign + i18n.getCurrency() + formatMoney(Math.abs(netProfit)) + '/h';
            netProfitEl.className = 'summary-value ' + (netProfit >= 0 ? 'income' : 'expense');
        }

        // 채권 정보
        if (totalDebtEl) totalDebtEl.textContent = i18n.getCurrency() + formatMoney(budgetSystem.totalDebt);
        if (debtInterestEl) debtInterestEl.textContent = i18n.getCurrency() + formatMoney(budgetSystem.debtInterest) + '/h';

        // 총 자산 (현재 보유 자금 - 채권 부채)
        if (totalAssetsEl) {
            const assets = economy.money - budgetSystem.totalDebt;
            const sign = assets < 0 ? '-' : '';
            totalAssetsEl.textContent = sign + i18n.getCurrency() + formatMoney(Math.abs(assets));
            totalAssetsEl.style.color = assets >= 0 ? '#4ade80' : '#f87171';
        }

        // 채권 카드 상태 업데이트
        updateBondCards();
    }

    // 채권 카드 상태 업데이트
    function updateBondCards() {
        ['A', 'B', 'C'].forEach(bondId => {
            const card = document.getElementById('bond' + bondId);
            const btn = document.getElementById('btnBond' + bondId);

            if (card && btn) {
                if (budgetSystem.issuedBonds[bondId]) {
                    card.classList.add('issued');
                    btn.textContent = '상환';
                    btn.classList.add('repay');
                } else {
                    card.classList.remove('issued');
                    btn.textContent = '발행';
                    btn.classList.remove('repay');
                }
            }
        });
    }

    // 채권 발행/상환
    function toggleBond(bondId) {
        const info = budgetSystem.bondInfo[bondId];
        if (!info) return;

        if (budgetSystem.issuedBonds[bondId]) {
            // 상환
            if (economy.money >= info.amount) {
                economy.money -= info.amount;
                budgetSystem.issuedBonds[bondId] = false;
                toast({ title: '채권 상환', desc: `채권 ${bondId} (${i18n.getCurrency()}${formatMoney(info.amount)}) 상환 완료`, success: true });
            } else {
                toast({ title: '자금 부족', desc: `상환에 ${i18n.getCurrency()}${formatMoney(info.amount)}이 필요합니다` });
                return;
            }
        } else {
            // 발행
            economy.money += info.amount;
            budgetSystem.issuedBonds[bondId] = true;
            toast({ title: '채권 발행', desc: `채권 ${bondId} 발행 (${i18n.getCurrency()}${formatMoney(info.amount)}, 이자 ${info.interest * 100}%)`, success: true });
        }

        renderMoney();
        calculateNetProfit();
        updateBudgetDisplay();
        updateBudgetPanel();
    }

    // 세금율 변경 핸들러
    function handleTaxRateChange(type, value) {
        budgetSystem.taxRates[type] = parseInt(value);
        calculateNetProfit();
        updateBudgetDisplay();
        updateBudgetPanel();
    }

    // 예산 패널 열기/닫기
    function openBudgetPanel() {
        if (budgetPanel) {
            calculateNetProfit();
            updateBudgetPanel();
            budgetPanel.classList.add('open');
        }
    }

    function closeBudgetPanel() {
        if (budgetPanel) {
            budgetPanel.classList.remove('open');
        }
    }

    // ========== 인구 통계 시스템 ==========

    // 계층별 인구 계산
    function calculatePopulationByTier() {
        const result = {
            total: 0,
            middle: 0,
            high: 0,
            buildingCount: 0
        };

        if (typeof placedBuildings === 'undefined') return result;

        placedBuildings.forEach((building, key) => {
            if (building.ref) return;  // 참조 건물 스킵

            const { instance, x, y } = building;
            const userData = instance?.userData;
            if (!userData) return;

            // 폐건물 제외
            if (userData.isAbandoned) return;

            // 주거 건물만 인구 계산
            const zoneType = userData.zoneType;
            if (!zoneType || !zoneType.includes('residential')) return;

            // 건물 크기 파악
            const size = userData.size || '1x1';
            const buildingKey = getBuildingKey(x, y, size);
            const population = buildingPopulations.get(buildingKey) || 0;

            if (population > 0) {
                result.buildingCount++;
                result.total += population;

                // 계층 파악 (tier)
                const tier = userData.tier || TIER.MIDDLE;
                if (tier === TIER.HIGH) {
                    result.high += population;
                } else {
                    result.middle += population;
                }
            }
        });

        return result;
    }

    // 인구 패널 업데이트
    function updatePopulationPanel() {
        const popData = calculatePopulationByTier();

        // 총 인구
        if (popTotalValue) popTotalValue.textContent = popData.total.toLocaleString();
        if (popResidentialBuildings) popResidentialBuildings.textContent = popData.buildingCount.toLocaleString();

        // 평균 인구/건물
        const avg = popData.buildingCount > 0 ? Math.round(popData.total / popData.buildingCount) : 0;
        if (popAvgPerBuilding) popAvgPerBuilding.textContent = avg.toLocaleString();

        // 계층별 인구
        const maxPop = Math.max(popData.middle, popData.high, 1);

        if (tierBarMiddle) tierBarMiddle.style.width = (popData.middle / maxPop * 100) + '%';
        if (tierBarHigh) tierBarHigh.style.width = (popData.high / maxPop * 100) + '%';
        if (tierValueMiddle) tierValueMiddle.textContent = popData.middle.toLocaleString() + '명';
        if (tierValueHigh) tierValueHigh.textContent = popData.high.toLocaleString() + '명';
    }

    // 인구 표시 업데이트 (하단 바)
    function updatePopulationDisplay() {
        if (popDisplayCenter) {
            popDisplayCenter.textContent = cityStats.population.toLocaleString();
        }
    }

    // 인구 패널 열기/닫기
    function openPopulationPanel() {
        if (populationPanel) {
            updatePopulationPanel();
            populationPanel.classList.add('open');
        }
    }

    function closePopulationPanel() {
        if (populationPanel) {
            populationPanel.classList.remove('open');
        }
    }

    // 인구 패널 이벤트 리스너 설정
    function initPopulationEventListeners() {
        // 인구 표시 클릭 시 인구 패널 열기
        if (populationDisplayBtn) {
            populationDisplayBtn.addEventListener('click', () => {
                if (populationPanel && populationPanel.classList.contains('open')) {
                    closePopulationPanel();
                } else {
                    // 예산 패널이 열려있으면 닫기
                    closeBudgetPanel();
                    openPopulationPanel();
                }
            });
        }

        // 닫기 버튼
        if (btnClosePopulation) {
            btnClosePopulation.addEventListener('click', closePopulationPanel);
        }
    }

    // 예산 패널 이벤트 리스너 설정
    function initBudgetEventListeners() {
        // 중앙 자금 표시 클릭 시 예산 패널 열기
        const moneyDisplayContainer = document.querySelector('.money-display-center');
        if (moneyDisplayContainer) {
            moneyDisplayContainer.addEventListener('click', () => {
                if (budgetPanel && budgetPanel.classList.contains('open')) {
                    closeBudgetPanel();
                } else {
                    // 인구 패널이 열려있으면 닫기
                    closePopulationPanel();
                    openBudgetPanel();
                }
            });
        }

        // 닫기 버튼
        if (btnCloseBudget) {
            btnCloseBudget.addEventListener('click', closeBudgetPanel);
        }

        // 세금 슬라이더
        if (taxResidential) {
            taxResidential.addEventListener('input', (e) => {
                if (taxResidentialPercent) taxResidentialPercent.textContent = e.target.value + '%';
                handleTaxRateChange('residential', e.target.value);
            });
        }
        if (taxCommercial) {
            taxCommercial.addEventListener('input', (e) => {
                if (taxCommercialPercent) taxCommercialPercent.textContent = e.target.value + '%';
                handleTaxRateChange('commercial', e.target.value);
            });
        }
        if (taxIndustrial) {
            taxIndustrial.addEventListener('input', (e) => {
                if (taxIndustrialPercent) taxIndustrialPercent.textContent = e.target.value + '%';
                handleTaxRateChange('industrial', e.target.value);
            });
        }

        // 채권 버튼
        if (btnBondA) btnBondA.addEventListener('click', () => toggleBond('A'));
        if (btnBondB) btnBondB.addEventListener('click', () => toggleBond('B'));
        if (btnBondC) btnBondC.addEventListener('click', () => toggleBond('C'));

        // ESC 키로 패널 닫기
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && budgetPanel && budgetPanel.classList.contains('open')) {
                closeBudgetPanel();
            }
        });
    }

    // 초기화 시 예산/인구 UI 업데이트
    setTimeout(() => {
        initBudgetEventListeners();
        initPopulationEventListeners();
        updateBudgetDisplay();
        updatePopulationDisplay();
    }, 100);

    /* =========================================================
     * 텍스트 선택 및 드래그 금지
     * ========================================================= */
    document.addEventListener('dragstart', (e) => e.preventDefault());
    document.addEventListener('selectstart', (e) => {
        // input/textarea는 선택 허용
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        e.preventDefault();
    });

    /* =========================================================
     * CITY STATS
     * ========================================================= */
    const cityStats = {
        population: 0,
        happiness: 50,
        powerCapacity: 0,
        powerUsage: 0,
        waterCapacity: 0,
        waterUsage: 0,
        crimeRate: 0,
        fireRisk: 0,
        trafficLevel: 0,
        taxPerHour: 0,
        actionPoints: 10,
        consecutiveLoginDays: 0,
        congestionMap: null,
        // RCI 수요 시스템 (-100 ~ +100, 0이 균형)
        residentialDemand: 0,
        commercialDemand: 0,
        industrialDemand: 0,
        // 구역 타일 수
        residentialTiles: 0,
        commercialTiles: 0,
        industrialTiles: 0,
        // 일자리 수
        commercialJobs: 0,
        industrialJobs: 0
    };

    // RCI 이상 비율 (주거 60%, 산업 25%, 상업 15%)
    const RCI_IDEAL_RATIO = {
        residential: 0.60,
        industrial: 0.25,
        commercial: 0.15
    };

    /* =========================================================
     * POWER GRID MANAGER (전력망 시스템)
     * ========================================================= */
    const powerManager = {
        initialized: false,
        powerPlants: new Map(),              // 발전소 목록 (key: "x,y")
        poweredBuildings: new Set(),         // 전기가 공급되는 건물 (key: "x,y")
        unpoweredBuildings: new Set(),       // 전기가 부족한 건물 (key: "x,y")
        buildingPowerOffTime: new Map(),     // 건물별 전기 없는 시간 (key: "x,y", value: timestamp)
        buildingPowerAbandonTime: new Map(), // 건물별 폐건물화 예정 시간 (랜덤, 정규분포)
        powerLineGroup: null,                // 전력선 그룹
        powerIconGroup: null,                // 전력 아이콘 그룹 (전력 모드용)
        unpoweredIconGroup: null,            // 전력 부족 아이콘 그룹 (항상 표시)
        buildingPowerIcons: new Map(),       // 건물별 전력 아이콘
        powerViewOriginalMaterials: new Map(), // 전력 뷰 전환 전 원래 머티리얼 저장
        isPowerViewActive: false,            // 전력 뷰 활성화 상태

        // 상수
        POWER_PER_POPULATION: 0.5,           // 인구 1명당 전력 소비량
        PUBLIC_BUILDING_POWER: 20,           // 공공시설 전력 소비량
        POWER_OFF_ABANDON_MEAN: 60000,       // 전기 없이 폐건물 평균 시간 (60초)
        POWER_OFF_ABANDON_STDDEV: 20000,     // 폐건물화 시간 표준편차 (20초)

        // 초기화
        init() {
            if (this.initialized) return;

            this.powerLineGroup = new THREE.Group();
            this.powerLineGroup.name = 'powerLines';
            scene.add(this.powerLineGroup);

            this.powerIconGroup = new THREE.Group();
            this.powerIconGroup.name = 'powerIcons';
            scene.add(this.powerIconGroup);

            // 전력 부족 아이콘 그룹 (항상 표시)
            this.unpoweredIconGroup = new THREE.Group();
            this.unpoweredIconGroup.name = 'unpoweredIcons';
            scene.add(this.unpoweredIconGroup);

            this.initialized = true;

            // 기존 발전소 스캔 및 등록
            this.scanExistingPowerPlants();

            // 전력 체크 타이머 (5초마다)
            setInterval(() => this.checkPowerShortageAbandonment(), 5000);
        },

        // 기존 발전소 스캔 (초기 로드 시)
        scanExistingPowerPlants() {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조 키 스킵
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isPowerPlant) {
                    const powerKey = `${building.x},${building.y}`;
                    if (!this.powerPlants.has(powerKey)) {
                        this.powerPlants.set(powerKey, {
                            x: building.x,
                            y: building.y,
                            type: building.type,
                            output: config.powerOutput || 100,
                            width: config.tileWidth || building.width || 2,
                            depth: config.tileDepth || building.depth || 2
                        });
                        console.log(`기존 발전소 등록: ${powerKey}`);
                    }
                }
            });
        },

        // 발전소 추가
        addPowerPlant(x, y, type, config) {
            const key = `${x},${y}`;
            this.powerPlants.set(key, {
                x, y, type,
                output: config.powerOutput || 100,
                width: config.tileWidth || 1,
                depth: config.tileDepth || 1
            });
            this.recalculatePowerGrid();
        },

        // 발전소 제거
        removePowerPlant(x, y) {
            const key = `${x},${y}`;
            if (this.powerPlants.has(key)) {
                this.powerPlants.delete(key);
                this.recalculatePowerGrid();
            }
        },

        // 전력 사용량 계산 (인구 기반)
        calculatePowerUsage() {
            let usage = 0;

            // 인구 기반 전력 소비
            usage += Math.ceil(cityStats.population * this.POWER_PER_POPULATION);

            // 공공시설 전력 소비
            placedPublicBuildings.forEach((building, key) => {
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && !config.isPowerPlant) {
                    usage += this.PUBLIC_BUILDING_POWER;
                }
            });

            cityStats.powerUsage = usage;
            return usage;
        },

        // 총 전력 용량 계산
        calculatePowerCapacity() {
            let totalCapacity = 0;
            this.powerPlants.forEach(plant => {
                totalCapacity += plant.output;
            });
            cityStats.powerCapacity = totalCapacity;
            return totalCapacity;
        },

        // 전력망 재계산 - BFS 거리 기반으로 가까운 건물부터 전력 공급
        recalculatePowerGrid() {
            this.poweredBuildings.clear();
            this.unpoweredBuildings.clear();

            const capacity = this.calculatePowerCapacity();

            // 도로 연결된 모든 건물 수집 (이미 거리순 정렬됨)
            const allConnectedBuildings = this.collectConnectedBuildings();

            if (allConnectedBuildings.length === 0) {
                // 총 전력 사용량 업데이트
                cityStats.powerUsage = 0;
                this.updatePowerVisualization();
                updateStatsDisplay();
                return;
            }

            // 거리순으로 전력 배분 (가까운 건물 우선)
            let remainingCapacity = capacity;
            let totalUsage = 0;

            allConnectedBuildings.forEach(b => {
                const key = `${b.x},${b.y}`;
                const buildingPower = b.powerUsage || 5; // 기본 전력 사용량 5

                if (remainingCapacity >= buildingPower) {
                    // 전력 공급 가능
                    this.poweredBuildings.add(key);
                    this.buildingPowerOffTime.delete(key);
                    this.buildingPowerAbandonTime.delete(key);  // 폐건물화 타이머 초기화
                    remainingCapacity -= buildingPower;
                    totalUsage += buildingPower;
                } else {
                    // 전력 부족 - 공급 불가
                    this.unpoweredBuildings.add(key);
                    // 전력 차단 시작 시간 기록 + 랜덤 폐건물화 시간 설정
                    if (!this.buildingPowerOffTime.has(key)) {
                        this.buildingPowerOffTime.set(key, Date.now());
                        // 정규분포 랜덤 시간 생성 (Box-Muller 변환)
                        const u1 = Math.random();
                        const u2 = Math.random();
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        const randomTime = Math.max(15000, this.POWER_OFF_ABANDON_MEAN + z * this.POWER_OFF_ABANDON_STDDEV);
                        this.buildingPowerAbandonTime.set(key, randomTime);
                    }
                    totalUsage += buildingPower; // 필요 전력량에는 포함
                }
            });

            // 총 전력 사용량 업데이트
            cityStats.powerUsage = totalUsage;

            // 시각화 업데이트
            this.updatePowerVisualization();
            updateStatsDisplay();
        },

        // 도로 연결된 모든 건물 수집 (BFS) - 발전소에서의 거리 포함
        collectConnectedBuildings() {
            const buildings = [];
            const visited = new Set();
            const roadDistances = new Map(); // 도로별 최소 거리

            // 모든 발전소에서 BFS 시작 (거리 0부터)
            this.powerPlants.forEach(plant => {
                // 발전소 인접 도로 찾기 (거리 1)
                for (let dx = -1; dx <= plant.width; dx++) {
                    for (let dy = -1; dy <= plant.depth; dy++) {
                        const nx = plant.x + dx;
                        const ny = plant.y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            if (isRoad(nx, ny) || isBridge(nx, ny)) {
                                const key = `${nx},${ny}`;
                                // 더 가까운 거리로 업데이트
                                if (!roadDistances.has(key) || roadDistances.get(key) > 1) {
                                    roadDistances.set(key, 1);
                                }
                            }
                        }
                    }
                }
            });

            // BFS 큐 초기화 (발전소 인접 도로들)
            const queue = [];
            roadDistances.forEach((dist, key) => {
                const [x, y] = key.split(',').map(Number);
                queue.push({ x, y, distance: dist });
                visited.add(`road_${key}`);
            });

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            // BFS로 도로 따라 이동하며 인접 건물 수집 (거리 계산)
            while (queue.length > 0) {
                const current = queue.shift();

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const roadKey = `road_${nx},${ny}`;
                    const buildingKey = `building_${nx},${ny}`;
                    const newDistance = current.distance + 1;

                    // 도로면 계속 탐색
                    if ((isRoad(nx, ny) || isBridge(nx, ny)) && !visited.has(roadKey)) {
                        visited.add(roadKey);
                        roadDistances.set(`${nx},${ny}`, newDistance);
                        queue.push({ x: nx, y: ny, distance: newDistance });
                    }

                    // 건물이면 수집 (거리 정보 포함) - 민간 건물 + 공공 건물 모두 체크
                    if (!visited.has(buildingKey)) {
                        let building = placedBuildings.get(`${nx},${ny}`);
                        let isPublicBuilding = false;

                        // 공공 건물도 체크
                        if (!building || building.ref) {
                            const publicBuilding = placedPublicBuildings.get(`${nx},${ny}`);
                            if (publicBuilding && !publicBuilding.ref) {
                                building = publicBuilding;
                                isPublicBuilding = true;
                            }
                        }

                        if (building && !building.ref && !building.isAbandoned) {
                            visited.add(buildingKey);
                            // 건물별 전력 사용량 계산
                            const powerUsage = isPublicBuilding ?
                                this.calculatePublicBuildingPowerUsage(building) :
                                this.calculateBuildingPowerUsage(building);
                            buildings.push({
                                x: nx,
                                y: ny,
                                building,
                                distance: current.distance, // 발전소로부터의 거리
                                powerUsage,  // 건물별 전력 사용량
                                isPublicBuilding
                            });
                        }
                    }
                }
            }

            // 거리순 정렬 (가까운 건물 우선)
            buildings.sort((a, b) => a.distance - b.distance);

            return buildings;
        },

        // 건물별 전력 사용량 계산
        calculateBuildingPowerUsage(building) {
            if (!building) return 0;

            // 인구 기반 전력 소비
            const population = building.population || 0;
            let usage = Math.ceil(population * this.POWER_PER_POPULATION);

            // 최소 전력 사용량 (건물이 있으면 최소 5 소비)
            if (usage < 5) usage = 5;

            return usage;
        },

        // 공공 건물 전력 사용량 계산
        calculatePublicBuildingPowerUsage(building) {
            if (!building) return 0;

            // 공공 건물별 전력 사용량 설정 (건물 크기에 비례)
            const width = building.width || 2;
            const depth = building.depth || 2;
            const area = width * depth;

            // 기본 전력 사용량: 크기당 10
            return area * 10;
        },

        // 전력 차단으로 인한 폐건물 체크 (랜덤 시간 적용)
        checkPowerShortageAbandonment() {
            const now = Date.now();

            this.buildingPowerOffTime.forEach((startTime, key) => {
                const abandonTime = this.buildingPowerAbandonTime.get(key) || this.POWER_OFF_ABANDON_MEAN;
                const elapsedTime = now - startTime;

                if (elapsedTime >= abandonTime) {
                    // 폐건물로 전환
                    const building = placedBuildings.get(key);
                    if (building && !building.ref && !building.isAbandoned) {
                        this.convertToAbandoned(key, building);
                        // 전력 부족 상태 아이콘 제거 (폐건물 아이콘으로 대체됨)
                        removeBuildingStatus(building.x, building.y, 'NO_POWER');
                    }
                }
            });
        },

        // 건물을 폐건물로 전환 (전력 부족)
        convertToAbandoned(key, building) {
            if (!building || building.isAbandoned) return;

            building.isAbandoned = true;

            // 폐건물 사유 및 시간 저장
            if (building.instance && building.instance.userData) {
                building.instance.userData.isAbandoned = true;
                building.instance.userData.abandonedReason = '전기가 없어서 살 수 없어요...';
                building.instance.userData.abandonedTime = Date.now();
            }

            // 건물 외관 변경 (어둡게)
            if (building.instance) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (!child.userData.originalMaterial) {
                            child.userData.originalMaterial = child.material.clone();
                        }
                        const darkMat = child.material.clone();
                        darkMat.color.multiplyScalar(0.3);
                        child.material = darkMat;
                    }
                });
            }

            // 인구 감소
            if (building.population) {
                cityStats.population -= building.population;
                if (cityStats.population < 0) cityStats.population = 0;
            }

            // 폐건물 목록에 추가
            if (typeof abandonedBuildings !== 'undefined') {
                abandonedBuildings.add(key);
            }

            // 폐건물 상태 아이콘 표시 (통합 시스템)
            addBuildingStatus(building.x, building.y, 'ABANDONED', building);

            // 전력 추적 정리
            this.buildingPowerOffTime.delete(key);
            this.buildingPowerAbandonTime.delete(key);

            console.log(`Building at ${key} became abandoned due to power shortage`);
        },

        // 타일에 전력이 공급되는지 확인
        isPowered(x, y) {
            return this.poweredBuildings.has(`${x},${y}`);
        },

        // 전력선 시각화 업데이트 (트리 구조로 표시)
        updatePowerVisualization() {
            // 기존 전력선 제거
            while (this.powerLineGroup.children.length > 0) {
                const child = this.powerLineGroup.children[0];
                this.powerLineGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            // 기존 전력 모드 아이콘 제거
            while (this.powerIconGroup.children.length > 0) {
                this.powerIconGroup.remove(this.powerIconGroup.children[0]);
            }
            this.buildingPowerIcons.clear();

            // 전력 부족 아이콘 항상 업데이트
            this.updateUnpoweredIcons();

            // 전력 관련 모드가 아니면 전력선/발전소 아이콘만 숨김
            const isPowerRelatedMode = currentMode === MODE.POWER_VIEW ||
                                       currentMode === MODE.PLACE_POWER_COAL ||
                                       currentMode === MODE.PLACE_POWER_WIND;
            if (!isPowerRelatedMode) {
                this.powerLineGroup.visible = false;
                this.powerIconGroup.visible = false;
                if (this.isPowerViewActive) {
                    this.restorePowerViewMaterials();
                    this.isPowerViewActive = false;
                }
                return;
            }

            // 전력 뷰 머티리얼 적용
            if (!this.isPowerViewActive) {
                this.applyPowerViewMaterials();
                this.isPowerViewActive = true;
            }

            this.powerLineGroup.visible = true;
            this.powerIconGroup.visible = true;

            // 전력선 트리 구조 생성
            this.createPowerLineTree();

            // 건물 전력 상태 아이콘 표시 (전력 모드용)
            this.updateBuildingPowerIcons();
        },

        // 전력 부족 아이콘 업데이트 (통합 상태 아이콘 시스템 사용)
        // 이전 전력 부족 건물 목록 (상태 변경 감지용)
        _prevUnpoweredBuildings: new Set(),

        updateUnpoweredIcons() {
            // 기존 3D 아이콘 제거 (레거시)
            while (this.unpoweredIconGroup && this.unpoweredIconGroup.children.length > 0) {
                this.unpoweredIconGroup.remove(this.unpoweredIconGroup.children[0]);
            }

            // 새로 전력 공급된 건물에서 상태 제거
            this._prevUnpoweredBuildings.forEach(key => {
                if (!this.unpoweredBuildings.has(key)) {
                    const [x, y] = key.split(',').map(Number);
                    removeBuildingStatus(x, y, 'NO_POWER');
                }
            });

            // 새로 전력 부족한 건물에 상태 추가
            this.unpoweredBuildings.forEach(key => {
                if (!this._prevUnpoweredBuildings.has(key)) {
                    const building = placedBuildings.get(key);
                    if (building && building.instance && !building.ref) {
                        addBuildingStatus(building.x, building.y, 'NO_POWER', building);
                    }
                }
            });

            // 이전 상태 업데이트
            this._prevUnpoweredBuildings = new Set(this.unpoweredBuildings);
        },

        // 전력 부족 아이콘 생성 (항상 표시용)
        createUnpoweredIcon(x, y, buildingInstance) {
            if (!buildingInstance || !this.unpoweredIconGroup) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);

            // ⚡ 아이콘 스프라이트 (빨간색 번개)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // 빨간색 원 배경
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();

            // 흰색 테두리
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // 번개 아이콘
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('⚡', 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(material);

            sprite.position.set(center.x, box.max.y + 0.4, center.z);
            sprite.scale.set(0.5, 0.5, 1);

            this.unpoweredIconGroup.add(sprite);
        },

        // 전력 뷰 머티리얼 적용 (토대는 흰색, 나머지는 회색, 발전소는 초록색)
        applyPowerViewMaterials() {
            this.powerViewOriginalMaterials.clear();

            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const greenMat = new THREE.MeshStandardMaterial({
                color: 0x44ff66,
                transparent: true,
                opacity: 0.85,
                emissive: 0x22aa44,
                emissiveIntensity: 0.3,
            });

            // 토대(잔디) - 흰색
            grassGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.powerViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = whiteMat;
                }
            });

            // 나무 - 흰색
            treeGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.powerViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = whiteMat;
                }
            });

            // 도로, 수로, 다리 - 회색
            const grayGroups = [roadGroup, waterGroup, bridgeGroup];
            grayGroups.forEach(group => {
                group.traverse((child) => {
                    if (child.isMesh && child.material) {
                        this.powerViewOriginalMaterials.set(child.uuid, child.material);
                        child.material = grayMat;
                    }
                });
            });

            // 건물 - 회색
            buildingGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.powerViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = grayMat;
                }
            });

            // 발전소 건물 - 초록색으로 하이라이트
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isPowerPlant && building.instance) {
                    building.instance.traverse((child) => {
                        if (child.isMesh && child.material) {
                            this.powerViewOriginalMaterials.set(child.uuid, child.material);
                            child.material = greenMat;
                        }
                    });
                }
            });

            // 차량도 회색으로 변경
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                trafficManager.vehicleGroup.traverse((child) => {
                    if (child.isMesh && child.material) {
                        this.powerViewOriginalMaterials.set(child.uuid, child.material);
                        child.material = grayMat;
                    }
                });
            }
        },

        // 전력 뷰 머티리얼 복원
        restorePowerViewMaterials() {
            const restoreMaterial = (child) => {
                if (child.isMesh && this.powerViewOriginalMaterials.has(child.uuid)) {
                    child.material = this.powerViewOriginalMaterials.get(child.uuid);
                }
            };

            grassGroup.traverse(restoreMaterial);
            treeGroup.traverse(restoreMaterial);
            roadGroup.traverse(restoreMaterial);
            waterGroup.traverse(restoreMaterial);
            bridgeGroup.traverse(restoreMaterial);
            buildingGroup.traverse(restoreMaterial);

            // 차량 복원
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                trafficManager.vehicleGroup.traverse(restoreMaterial);
            }

            // 공공시설은 buildingGroup에 포함되어 있으므로 별도 처리 불필요

            this.powerViewOriginalMaterials.clear();
        },

        // 전력선 트리 구조 생성 (발전소에서 전력 공급 건물까지만 전선 표시)
        createPowerLineTree() {
            const drawnConnections = new Set();
            const buildingToRoadConnections = [];

            // 1단계: 전력이 공급되는 건물만 인접 도로 수집
            const poweredBuildingRoads = new Set(); // 전력 공급 건물 인접 도로
            const powerPlantRoads = new Set(); // 발전소 인접 도로

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            // 건물에서 인접 도로 찾는 헬퍼 (건물당 하나의 도로 연결만)
            const collectBuildingRoads = (bx, by, width, height, isPowered, buildingKey) => {
                let foundConnection = false;

                for (let dx = 0; dx < width && !foundConnection; dx++) {
                    for (let dy = 0; dy < height && !foundConnection; dy++) {
                        const tileX = bx + dx;
                        const tileY = by + dy;

                        for (const dir of directions) {
                            if (foundConnection) break;

                            const rx = tileX + dir.dx;
                            const ry = tileY + dir.dy;

                            // 건물 영역 내부는 스킵
                            if (rx >= bx && rx < bx + width && ry >= by && ry < by + height) continue;

                            if (rx >= 0 && rx < GRID_W && ry >= 0 && ry < GRID_H) {
                                if (isRoad(rx, ry) || isBridge(rx, ry)) {
                                    if (isPowered) {
                                        poweredBuildingRoads.add(`${rx},${ry}`);
                                        buildingToRoadConnections.push({
                                            buildingX: tileX,
                                            buildingY: tileY,
                                            roadX: rx,
                                            roadY: ry,
                                            buildingKey
                                        });
                                    }
                                    foundConnection = true;
                                }
                            }
                        }
                    }
                }
            };

            // 발전소 인접 도로 수집
            this.powerPlants.forEach((plant, key) => {
                for (let dx = -1; dx <= plant.width; dx++) {
                    for (let dy = -1; dy <= plant.depth; dy++) {
                        const nx = plant.x + dx;
                        const ny = plant.y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            if (isRoad(nx, ny) || isBridge(nx, ny)) {
                                powerPlantRoads.add(`${nx},${ny}`);
                            }
                        }
                    }
                }
            });

            // 일반 건물 (주거/상업/공업) - 전력 공급되는 건물만
            placedBuildings.forEach((building, key) => {
                if (building.ref) return;
                const isPowered = this.poweredBuildings.has(key);
                collectBuildingRoads(building.x, building.y, building.width || 1, building.depth || 1, isPowered, key);
            });

            // 서비스 건물 (학교, 경찰서, 소방서, 병원, 공원 등) - 전력 공급되는 건물만
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                // 발전소는 제외 (발전소는 전력 생산)
                if (this.powerPlants.has(key)) return;
                const isPowered = this.poweredBuildings.has(key);
                collectBuildingRoads(building.x, building.y, building.width || 2, building.depth || 2, isPowered, key);
            });

            // 전력 공급 건물이 없으면 발전소만 있으므로 전선 없음
            if (poweredBuildingRoads.size === 0) return;

            // 2단계: 발전소에서 BFS로 전력 공급 건물까지의 경로 찾기
            const neededRoads = new Set(); // 전선이 필요한 도로
            const roadParent = new Map(); // 경로 추적용

            // 발전소 인접 도로에서 BFS 시작
            const visited = new Set();
            const queue = [];

            powerPlantRoads.forEach(roadKey => {
                visited.add(roadKey);
                queue.push(roadKey);
            });

            // BFS로 전력 공급 건물까지 경로 탐색
            while (queue.length > 0) {
                const current = queue.shift();
                const [cx, cy] = current.split(',').map(Number);

                for (const dir of directions) {
                    const nx = cx + dir.dx;
                    const ny = cy + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const nkey = `${nx},${ny}`;
                    if (visited.has(nkey)) continue;

                    if (isRoad(nx, ny) || isBridge(nx, ny)) {
                        visited.add(nkey);
                        roadParent.set(nkey, current);
                        queue.push(nkey);
                    }
                }
            }

            // 전력 공급 건물에서 발전소까지 경로 역추적하여 필요한 도로 마킹
            poweredBuildingRoads.forEach(roadKey => {
                let trace = roadKey;
                while (trace && !powerPlantRoads.has(trace)) {
                    neededRoads.add(trace);
                    trace = roadParent.get(trace);
                }
                // 발전소 인접 도로도 추가
                if (trace) {
                    neededRoads.add(trace);
                }
            });

            // 발전소 인접 도로 중 필요한 것만 추가
            powerPlantRoads.forEach(roadKey => {
                // 이 도로에서 시작하여 다른 필요한 도로로 연결되는지 확인
                for (const dir of directions) {
                    const [x, y] = roadKey.split(',').map(Number);
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;
                    if (neededRoads.has(nkey)) {
                        neededRoads.add(roadKey);
                        break;
                    }
                }
            });

            // 3단계: 필요한 도로에 전선 그리기 (4차선 도로는 원점 기준으로 통합)
            const processed4LaneOrigins = new Set();

            neededRoads.forEach(roadKey => {
                const [x, y] = roadKey.split(',').map(Number);

                // 4차선 도로인 경우 원점만 처리 (중복 방지)
                if (is4LaneRoad(x, y)) {
                    const origin = find4LaneOrigin(x, y);
                    if (origin) {
                        const originKey = `${origin.x},${origin.y}`;
                        if (processed4LaneOrigins.has(originKey)) return;  // 이미 처리됨
                        processed4LaneOrigins.add(originKey);
                    }
                }

                // 4방향 인접 도로와 연결
                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;

                    if (neededRoads.has(nkey) || powerPlantRoads.has(nkey)) {
                        // 같은 4차선 도로 내부 연결 스킵
                        if (is4LaneRoad(x, y) && is4LaneRoad(nx, ny)) {
                            const origin1 = find4LaneOrigin(x, y);
                            const origin2 = find4LaneOrigin(nx, ny);
                            if (origin1 && origin2 && origin1.x === origin2.x && origin1.y === origin2.y) {
                                continue;  // 같은 4차선 도로 내부
                            }
                        }

                        // 연결 키 생성 (4차선은 원점 기준)
                        let key1 = roadKey;
                        let key2 = nkey;
                        if (is4LaneRoad(x, y)) {
                            const o = find4LaneOrigin(x, y);
                            if (o) key1 = `4L_${o.x},${o.y}`;
                        }
                        if (is4LaneRoad(nx, ny)) {
                            const o = find4LaneOrigin(nx, ny);
                            if (o) key2 = `4L_${o.x},${o.y}`;
                        }

                        const connKey = [key1, key2].sort().join('_');
                        if (!drawnConnections.has(connKey)) {
                            drawnConnections.add(connKey);
                            this.drawPowerLine(x, y, nx, ny);
                        }
                    }
                }
            });

            // 4단계: 발전소에서 인접 필요 도로로 연결선 그리기
            this.powerPlants.forEach((plant, key) => {
                const plantCenterX = plant.x + (plant.width - 1) / 2;
                const plantCenterY = plant.y + (plant.depth - 1) / 2;

                // 발전소에서 가장 가까운 필요 도로 찾기
                let closestRoad = null;
                let closestDist = Infinity;

                neededRoads.forEach(roadKey => {
                    const [rx, ry] = roadKey.split(',').map(Number);
                    // 발전소 인접한 도로인지 확인
                    let isAdjacent = false;
                    for (let dx = -1; dx <= plant.width; dx++) {
                        for (let dy = -1; dy <= plant.depth; dy++) {
                            if (rx === plant.x + dx && ry === plant.y + dy) {
                                isAdjacent = true;
                                break;
                            }
                        }
                        if (isAdjacent) break;
                    }

                    if (isAdjacent) {
                        const dist = Math.abs(rx - plantCenterX) + Math.abs(ry - plantCenterY);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestRoad = { x: rx, y: ry };
                        }
                    }
                });

                if (closestRoad) {
                    const connKey = `plant_${key}_to_${closestRoad.x},${closestRoad.y}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        // 발전소 중심에서 도로로 연결
                        this.drawPowerLine(Math.floor(plantCenterX), Math.floor(plantCenterY), closestRoad.x, closestRoad.y);
                    }
                }
            });

            // 5단계: 전력 공급 건물에서 도로로의 연결선 그리기
            buildingToRoadConnections.forEach(conn => {
                const roadKey = `${conn.roadX},${conn.roadY}`;
                // 필요한 도로에 연결된 건물만 전선 연결
                if (neededRoads.has(roadKey)) {
                    const connKey = `building_${conn.buildingKey}_to_${roadKey}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        this.drawPowerLine(conn.buildingX, conn.buildingY, conn.roadX, conn.roadY);
                    }
                }
            });
        },

        // 4차선 도로의 월드 중심 좌표 가져오기
        get4LaneWorldCenter(x, y) {
            const origin = find4LaneOrigin(x, y);
            if (!origin) return tileToWorldCenter(x, y);
            // 2x2 영역의 중심
            const c1 = tileToWorldCenter(origin.x, origin.y);
            const c2 = tileToWorldCenter(origin.x + 1, origin.y + 1);
            return { x: (c1.x + c2.x) / 2, z: (c1.z + c2.z) / 2 };
        },

        // 전력선 그리기 - 4차선 도로 지원 (직각 연결)
        drawPowerLine(x1, y1, x2, y2) {
            // 4차선 도로인 경우 중심 좌표 사용
            const is4Lane1 = is4LaneRoad(x1, y1);
            const is4Lane2 = is4LaneRoad(x2, y2);

            const pos1 = is4Lane1 ? this.get4LaneWorldCenter(x1, y1) : tileToWorldCenter(x1, y1);
            const pos2 = is4Lane2 ? this.get4LaneWorldCenter(x2, y2) : tileToWorldCenter(x2, y2);
            const height = 0.12;

            // 4차선 도로는 굵은 선 (0.10), 2차선은 기본 (0.07)
            const lineWidth = (is4Lane1 || is4Lane2) ? 0.10 : 0.07;

            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.95
            });

            // 대각선이면 직각으로 꺾어서 연결 (4차선 도로 또는 일반 도로 모두)
            const dx = Math.abs(pos2.x - pos1.x);
            const dz = Math.abs(pos2.z - pos1.z);
            const isDiagonal = dx > 0.01 && dz > 0.01;  // 대각선 판단

            if (isDiagonal) {
                // 직각 연결: 먼저 X방향, 그 다음 Z방향
                const midPos = { x: pos2.x, z: pos1.z };

                // 첫 번째 선 (X방향)
                const curve1 = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(midPos.x, height, midPos.z)
                );
                const tube1 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve1, 1, lineWidth, 6, false),
                    tubeMaterial.clone()
                );
                this.powerLineGroup.add(tube1);

                // 두 번째 선 (Z방향)
                const curve2 = new THREE.LineCurve3(
                    new THREE.Vector3(midPos.x, height, midPos.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube2 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve2, 1, lineWidth, 6, false),
                    tubeMaterial.clone()
                );
                this.powerLineGroup.add(tube2);
            } else {
                // 직선 연결 (같은 X 또는 같은 Z)
                const curve = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube = new THREE.Mesh(
                    new THREE.TubeGeometry(curve, 1, lineWidth, 6, false),
                    tubeMaterial
                );
                this.powerLineGroup.add(tube);
            }
        },

        // 건물 전력 아이콘 업데이트
        updateBuildingPowerIcons() {
            // 전력 부족 건물에만 아이콘 표시
            this.unpoweredBuildings.forEach(key => {
                const building = placedBuildings.get(key);
                if (building && building.instance) {
                    this.createPowerIcon(building.x, building.y, building.instance, false);
                }
            });

            // 발전소 아이콘 표시
            this.powerPlants.forEach((plant, key) => {
                const building = placedPublicBuildings.get(key);
                if (building && building.instance) {
                    this.createPowerPlantIcon(plant.x, plant.y, building.instance, plant.output);
                }
            });
        },

        // 전력 아이콘 생성
        createPowerIcon(x, y, buildingInstance, isPowered) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.3;

            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444';
            ctx.fill();

            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('⚡', 32, 28);

            // X 표시
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(18, 42);
            ctx.lineTo(46, 42);
            ctx.stroke();

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.5, 0.5, 1);

            this.powerIconGroup.add(sprite);
            this.buildingPowerIcons.set(`${x},${y}`, sprite);
        },

        // 발전소 아이콘 생성
        createPowerPlantIcon(x, y, buildingInstance, output) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.5;

            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // 배경
            ctx.fillStyle = '#22c55e';
            ctx.beginPath();
            ctx.roundRect(0, 0, 128, 64, 8);
            ctx.fill();

            // 텍스트
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'black';
            ctx.fillText(`⚡${output}`, 64, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.8, 0.4, 1);

            this.powerIconGroup.add(sprite);
        },

        // 전력 뷰 토글
        togglePowerView() {
            if (currentMode === MODE.POWER_VIEW) {
                setMode(MODE.CAMERA);
            } else {
                setMode(MODE.POWER_VIEW);
            }
        }
    };

    // 공공시설 존재 확인 헬퍼
    function hasPublicBuildingAt(x, y) {
        return placedPublicBuildings.has(`${x},${y}`);
    }

    // showPowerEffects 함수 (발전소 설치 시 효과 범위 표시)
    function showPowerEffects(type) {
        // 기존 서비스 효과와 유사하게 처리
        const config = PUBLIC_BUILDING_MODELS[type];
        if (!config) return;

        // 전력 뷰 활성화
        powerManager.updatePowerVisualization();
    }

    /* =========================================================
     * WATER GRID MANAGER (수도망 시스템)
     * ========================================================= */
    const waterManager = {
        initialized: false,
        waterFacilities: new Map(),          // 수도 시설 목록 (key: "x,y")
        wateredBuildings: new Set(),         // 수도가 공급되는 건물 (key: "x,y")
        unwateredBuildings: new Set(),       // 수도가 부족한 건물 (key: "x,y")
        buildingWaterOffTime: new Map(),     // 건물별 수도 없는 시간 (key: "x,y", value: timestamp)
        buildingWaterAbandonTime: new Map(), // 건물별 폐건물화 예정 시간 (랜덤, 정규분포)
        waterPipeGroup: null,                // 수도관 그룹
        waterIconGroup: null,                // 수도 아이콘 그룹 (수도 모드용)
        unwateredIconGroup: null,            // 수도 부족 아이콘 그룹 (항상 표시)
        buildingWaterIcons: new Map(),       // 건물별 수도 아이콘
        waterViewOriginalMaterials: new Map(), // 수도 뷰 전환 전 원래 머티리얼 저장
        isWaterViewActive: false,            // 수도 뷰 활성화 상태

        // 상수
        WATER_PER_POPULATION: 0.3,           // 인구 1명당 수도 소비량
        PUBLIC_BUILDING_WATER: 15,           // 공공시설 수도 소비량
        WATER_OFF_ABANDON_MEAN: 80000,       // 수도 없이 폐건물 평균 시간 (80초)
        WATER_OFF_ABANDON_STDDEV: 25000,     // 폐건물화 시간 표준편차 (25초)

        // 초기화
        init() {
            if (this.initialized) return;

            this.waterPipeGroup = new THREE.Group();
            this.waterPipeGroup.name = 'waterPipes';
            scene.add(this.waterPipeGroup);

            this.waterIconGroup = new THREE.Group();
            this.waterIconGroup.name = 'waterIcons';
            scene.add(this.waterIconGroup);

            // 수도 부족 아이콘 그룹 (항상 표시)
            this.unwateredIconGroup = new THREE.Group();
            this.unwateredIconGroup.name = 'unwateredIcons';
            scene.add(this.unwateredIconGroup);

            this.initialized = true;

            // 기존 급수시설 스캔 및 등록
            this.scanExistingWaterFacilities();

            // 수도 체크 타이머 (5초마다)
            setInterval(() => this.checkWaterShortageAbandonment(), 5000);
        },

        // 기존 급수시설 스캔 (초기 로드 시)
        scanExistingWaterFacilities() {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조 키 스킵
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isWaterFacility) {
                    const waterKey = `${building.x},${building.y}`;
                    if (!this.waterFacilities.has(waterKey)) {
                        this.waterFacilities.set(waterKey, {
                            x: building.x,
                            y: building.y,
                            type: building.type,
                            output: config.waterOutput || 100,
                            width: config.tileWidth || building.width || 2,
                            depth: config.tileDepth || building.depth || 2
                        });
                        console.log(`기존 급수시설 등록: ${waterKey}`);
                    }
                }
            });
        },

        // 수도 시설 추가
        addWaterFacility(x, y, type, config) {
            const key = `${x},${y}`;
            this.waterFacilities.set(key, {
                x, y, type,
                output: config.waterOutput || 100,
                width: config.tileWidth || 1,
                depth: config.tileDepth || 1
            });
            this.recalculateWaterGrid();
        },

        // 수도 시설 제거
        removeWaterFacility(x, y) {
            const key = `${x},${y}`;
            if (this.waterFacilities.has(key)) {
                this.waterFacilities.delete(key);
                this.recalculateWaterGrid();
            }
        },

        // 수도 사용량 계산 (인구 기반)
        calculateWaterUsage() {
            let usage = 0;

            // 인구 기반 수도 소비
            usage += Math.ceil(cityStats.population * this.WATER_PER_POPULATION);

            // 공공시설 수도 소비
            placedPublicBuildings.forEach((building, key) => {
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && !config.isWaterFacility) {
                    usage += this.PUBLIC_BUILDING_WATER;
                }
            });

            cityStats.waterUsage = usage;
            return usage;
        },

        // 총 수도 용량 계산
        calculateWaterCapacity() {
            let totalCapacity = 0;
            this.waterFacilities.forEach(facility => {
                totalCapacity += facility.output;
            });
            cityStats.waterCapacity = totalCapacity;
            return totalCapacity;
        },

        // 수도망 재계산 - BFS 거리 기반으로 가까운 건물부터 수도 공급
        recalculateWaterGrid() {
            this.wateredBuildings.clear();
            this.unwateredBuildings.clear();

            const capacity = this.calculateWaterCapacity();

            // 도로 연결된 모든 건물 수집 (이미 거리순 정렬됨)
            const allConnectedBuildings = this.collectConnectedBuildings();

            if (allConnectedBuildings.length === 0) {
                // 총 수도 사용량 업데이트
                cityStats.waterUsage = 0;
                this.updateWaterVisualization();
                updateStatsDisplay();
                return;
            }

            // 거리순으로 수도 배분 (가까운 건물 우선)
            let remainingCapacity = capacity;
            let totalUsage = 0;

            allConnectedBuildings.forEach(b => {
                const key = `${b.x},${b.y}`;
                const buildingWater = b.waterUsage || 3; // 기본 수도 사용량 3

                if (remainingCapacity >= buildingWater) {
                    // 수도 공급 가능
                    this.wateredBuildings.add(key);
                    this.buildingWaterOffTime.delete(key);
                    this.buildingWaterAbandonTime.delete(key);  // 폐건물화 타이머 초기화
                    remainingCapacity -= buildingWater;
                    totalUsage += buildingWater;
                } else {
                    // 수도 부족 - 공급 불가
                    this.unwateredBuildings.add(key);
                    // 수도 차단 시작 시간 기록 + 랜덤 폐건물화 시간 설정
                    if (!this.buildingWaterOffTime.has(key)) {
                        this.buildingWaterOffTime.set(key, Date.now());
                        // 정규분포 랜덤 시간 생성 (Box-Muller 변환)
                        const u1 = Math.random();
                        const u2 = Math.random();
                        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                        const randomTime = Math.max(20000, this.WATER_OFF_ABANDON_MEAN + z * this.WATER_OFF_ABANDON_STDDEV);
                        this.buildingWaterAbandonTime.set(key, randomTime);
                    }
                    totalUsage += buildingWater; // 필요 수도량에는 포함
                }
            });

            // 총 수도 사용량 업데이트
            cityStats.waterUsage = totalUsage;

            // 시각화 업데이트
            this.updateWaterVisualization();
            updateStatsDisplay();
        },

        // 도로 연결된 모든 건물 수집 (BFS) - 수도 시설에서의 거리 포함
        collectConnectedBuildings() {
            const buildings = [];
            const visited = new Set();
            const roadDistances = new Map(); // 도로별 최소 거리

            // 모든 수도 시설에서 BFS 시작 (거리 0부터)
            this.waterFacilities.forEach(facility => {
                // 수도 시설 인접 도로 찾기 (거리 1)
                for (let dx = -1; dx <= facility.width; dx++) {
                    for (let dy = -1; dy <= facility.depth; dy++) {
                        const nx = facility.x + dx;
                        const ny = facility.y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            if (isRoad(nx, ny) || isBridge(nx, ny)) {
                                const key = `${nx},${ny}`;
                                // 더 가까운 거리로 업데이트
                                if (!roadDistances.has(key) || roadDistances.get(key) > 1) {
                                    roadDistances.set(key, 1);
                                }
                            }
                        }
                    }
                }
            });

            // BFS 큐 초기화 (수도 시설 인접 도로들)
            const queue = [];
            roadDistances.forEach((dist, key) => {
                const [x, y] = key.split(',').map(Number);
                queue.push({ x, y, distance: dist });
                visited.add(`road_${key}`);
            });

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            // BFS로 도로 따라 이동하며 인접 건물 수집 (거리 계산)
            while (queue.length > 0) {
                const current = queue.shift();

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const roadKey = `road_${nx},${ny}`;
                    const buildingKey = `building_${nx},${ny}`;
                    const newDistance = current.distance + 1;

                    // 도로면 계속 탐색
                    if ((isRoad(nx, ny) || isBridge(nx, ny)) && !visited.has(roadKey)) {
                        visited.add(roadKey);
                        roadDistances.set(`${nx},${ny}`, newDistance);
                        queue.push({ x: nx, y: ny, distance: newDistance });
                    }

                    // 건물이면 수집 (거리 정보 포함) - 민간 건물 + 공공 건물 모두 체크
                    if (!visited.has(buildingKey)) {
                        let building = placedBuildings.get(`${nx},${ny}`);
                        let isPublicBuilding = false;

                        // 공공 건물도 체크
                        if (!building || building.ref) {
                            const publicBuilding = placedPublicBuildings.get(`${nx},${ny}`);
                            if (publicBuilding && !publicBuilding.ref) {
                                building = publicBuilding;
                                isPublicBuilding = true;
                            }
                        }

                        if (building && !building.ref && !building.isAbandoned) {
                            visited.add(buildingKey);
                            // 건물별 수도 사용량 계산
                            const waterUsage = isPublicBuilding ?
                                this.calculatePublicBuildingWaterUsage(building) :
                                this.calculateBuildingWaterUsage(building);
                            buildings.push({
                                x: nx,
                                y: ny,
                                building,
                                distance: current.distance, // 수도 시설로부터의 거리
                                waterUsage,  // 건물별 수도 사용량
                                isPublicBuilding
                            });
                        }
                    }
                }
            }

            // 거리순 정렬 (가까운 건물 우선)
            buildings.sort((a, b) => a.distance - b.distance);

            return buildings;
        },

        // 건물별 수도 사용량 계산
        calculateBuildingWaterUsage(building) {
            if (!building) return 0;

            // 인구 기반 수도 소비
            const population = building.population || 0;
            let usage = Math.ceil(population * this.WATER_PER_POPULATION);

            // 최소 수도 사용량 (건물이 있으면 최소 3 소비)
            if (usage < 3) usage = 3;

            return usage;
        },

        // 공공 건물 수도 사용량 계산
        calculatePublicBuildingWaterUsage(building) {
            if (!building) return 0;

            // 공공 건물별 수도 사용량 설정 (건물 크기에 비례)
            const width = building.width || 2;
            const depth = building.depth || 2;
            const area = width * depth;

            // 기본 수도 사용량: 크기당 6
            return area * 6;
        },

        // 수도 차단으로 인한 폐건물 체크 (랜덤 시간 적용)
        checkWaterShortageAbandonment() {
            const now = Date.now();

            this.buildingWaterOffTime.forEach((startTime, key) => {
                const abandonTime = this.buildingWaterAbandonTime.get(key) || this.WATER_OFF_ABANDON_MEAN;
                const elapsedTime = now - startTime;

                if (elapsedTime >= abandonTime) {
                    // 폐건물로 전환
                    const building = placedBuildings.get(key);
                    if (building && !building.ref && !building.isAbandoned) {
                        this.convertToAbandoned(key, building);
                        // 수도 부족 상태 아이콘 제거 (폐건물 아이콘으로 대체됨)
                        removeBuildingStatus(building.x, building.y, 'NO_WATER');
                    }
                }
            });
        },

        // 건물을 폐건물로 전환 (수도 부족)
        convertToAbandoned(key, building) {
            if (!building || building.isAbandoned) return;

            building.isAbandoned = true;

            // 폐건물 사유 및 시간 저장
            if (building.instance && building.instance.userData) {
                building.instance.userData.isAbandoned = true;
                building.instance.userData.abandonedReason = '물이 없어서 살 수 없어요...';
                building.instance.userData.abandonedTime = Date.now();
            }

            // 건물 외관 변경 (어둡게)
            if (building.instance) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (!child.userData.originalMaterial) {
                            child.userData.originalMaterial = child.material.clone();
                        }
                        const darkMat = child.material.clone();
                        darkMat.color.multiplyScalar(0.3);
                        child.material = darkMat;
                    }
                });
            }

            // 인구 감소
            if (building.population) {
                cityStats.population -= building.population;
                if (cityStats.population < 0) cityStats.population = 0;
            }

            // 폐건물 목록에 추가
            if (typeof abandonedBuildings !== 'undefined') {
                abandonedBuildings.add(key);
            }

            // 폐건물 상태 아이콘 표시 (통합 시스템)
            addBuildingStatus(building.x, building.y, 'ABANDONED', building);

            // 수도 추적 정리
            this.buildingWaterOffTime.delete(key);
            this.buildingWaterAbandonTime.delete(key);

            console.log(`Building at ${key} became abandoned due to water shortage`);
        },

        // 타일에 수도가 공급되는지 확인
        isWatered(x, y) {
            return this.wateredBuildings.has(`${x},${y}`);
        },

        // 수도관 시각화 업데이트 (트리 구조로 표시)
        updateWaterVisualization() {
            // 기존 수도관 제거
            while (this.waterPipeGroup.children.length > 0) {
                const child = this.waterPipeGroup.children[0];
                this.waterPipeGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }

            // 기존 수도 모드 아이콘 제거
            while (this.waterIconGroup.children.length > 0) {
                this.waterIconGroup.remove(this.waterIconGroup.children[0]);
            }
            this.buildingWaterIcons.clear();

            // 수도 부족 아이콘 항상 업데이트
            this.updateUnwateredIcons();

            // 수도 관련 모드가 아니면 수도관/수도 시설 아이콘만 숨김
            const isWaterRelatedMode = currentMode === MODE.WATER_VIEW ||
                                       currentMode === MODE.PLACE_WATER_TOWER ||
                                       currentMode === MODE.PLACE_WATER_PUMP;
            if (!isWaterRelatedMode) {
                this.waterPipeGroup.visible = false;
                this.waterIconGroup.visible = false;
                if (this.isWaterViewActive) {
                    this.restoreWaterViewMaterials();
                    this.isWaterViewActive = false;
                }
                return;
            }

            // 수도 뷰 머티리얼 적용
            if (!this.isWaterViewActive) {
                this.applyWaterViewMaterials();
                this.isWaterViewActive = true;
            }

            this.waterPipeGroup.visible = true;
            this.waterIconGroup.visible = true;

            // 수도관 트리 구조 생성
            this.createWaterPipeTree();

            // 건물 수도 상태 아이콘 표시 (수도 모드용)
            this.updateBuildingWaterIcons();
        },

        // 수도 부족 아이콘 업데이트 (통합 상태 아이콘 시스템 사용)
        _prevUnwateredBuildings: new Set(),

        updateUnwateredIcons() {
            // 기존 3D 아이콘 제거 (레거시)
            while (this.unwateredIconGroup && this.unwateredIconGroup.children.length > 0) {
                this.unwateredIconGroup.remove(this.unwateredIconGroup.children[0]);
            }

            // 새로 수도 공급된 건물에서 상태 제거
            this._prevUnwateredBuildings.forEach(key => {
                if (!this.unwateredBuildings.has(key)) {
                    const [x, y] = key.split(',').map(Number);
                    removeBuildingStatus(x, y, 'NO_WATER');
                }
            });

            // 새로 수도 부족한 건물에 상태 추가
            this.unwateredBuildings.forEach(key => {
                if (!this._prevUnwateredBuildings.has(key)) {
                    const building = placedBuildings.get(key);
                    if (building && building.instance && !building.ref) {
                        addBuildingStatus(building.x, building.y, 'NO_WATER', building);
                    }
                }
            });

            // 이전 상태 업데이트
            this._prevUnwateredBuildings = new Set(this.unwateredBuildings);
        },

        // 수도 뷰 머티리얼 적용 (토대는 흰색, 나머지는 회색)
        applyWaterViewMaterials() {
            this.waterViewOriginalMaterials.clear();

            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });

            // 수도 시설 하이라이트용 초록색 재질
            const greenMat = new THREE.MeshStandardMaterial({
                color: 0x44ff66,
                transparent: true,
                opacity: 0.85,
                emissive: 0x22aa44,
                emissiveIntensity: 0.3,
                roughness: 0.5,
                metalness: 0.0,
            });

            // 토대(잔디) - 흰색
            grassGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.waterViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = whiteMat;
                }
            });

            // 나무 - 흰색
            treeGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.waterViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = whiteMat;
                }
            });

            // 도로, 수로, 다리 - 회색
            const grayGroups = [roadGroup, waterGroup, bridgeGroup];
            grayGroups.forEach(group => {
                group.traverse((child) => {
                    if (child.isMesh && child.material) {
                        this.waterViewOriginalMaterials.set(child.uuid, child.material);
                        child.material = grayMat;
                    }
                });
            });

            // 건물 - 회색
            buildingGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    this.waterViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = grayMat;
                }
            });

            // 수도 시설 - 초록색으로 하이라이트
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (config && config.isWaterFacility && building.instance) {
                    building.instance.traverse((child) => {
                        if (child.isMesh && child.material) {
                            this.waterViewOriginalMaterials.set(child.uuid, child.material);
                            child.material = greenMat;
                        }
                    });
                }
            });

            // 차량도 회색으로 변경
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                trafficManager.vehicleGroup.traverse((child) => {
                    if (child.isMesh && child.material) {
                        this.waterViewOriginalMaterials.set(child.uuid, child.material);
                        child.material = grayMat;
                    }
                });
            }
        },

        // 수도 뷰 머티리얼 복원
        restoreWaterViewMaterials() {
            const restoreMaterial = (child) => {
                if (child.isMesh && this.waterViewOriginalMaterials.has(child.uuid)) {
                    child.material = this.waterViewOriginalMaterials.get(child.uuid);
                }
            };

            grassGroup.traverse(restoreMaterial);
            treeGroup.traverse(restoreMaterial);
            roadGroup.traverse(restoreMaterial);
            waterGroup.traverse(restoreMaterial);
            bridgeGroup.traverse(restoreMaterial);
            buildingGroup.traverse(restoreMaterial);

            // 차량 복원
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                trafficManager.vehicleGroup.traverse(restoreMaterial);
            }

            // 공공시설은 buildingGroup에 포함되어 있으므로 별도 처리 불필요

            this.waterViewOriginalMaterials.clear();
        },

        // 수도관 트리 구조 생성 (수도 시설에서 수도 공급 건물까지만 파이프 표시)
        createWaterPipeTree() {
            const drawnConnections = new Set();
            const buildingToRoadConnections = [];

            // 1단계: 수도가 공급되는 건물만 인접 도로 수집
            const wateredBuildingRoads = new Set();
            const waterFacilityRoads = new Set();

            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];

            // 건물에서 인접 도로 찾는 헬퍼
            const collectBuildingRoads = (bx, by, width, height, isWatered, buildingKey) => {
                let foundConnection = false;

                for (let dx = 0; dx < width && !foundConnection; dx++) {
                    for (let dy = 0; dy < height && !foundConnection; dy++) {
                        const tileX = bx + dx;
                        const tileY = by + dy;

                        for (const dir of directions) {
                            if (foundConnection) break;

                            const rx = tileX + dir.dx;
                            const ry = tileY + dir.dy;

                            if (rx >= bx && rx < bx + width && ry >= by && ry < by + height) continue;

                            if (rx >= 0 && rx < GRID_W && ry >= 0 && ry < GRID_H) {
                                if (isRoad(rx, ry) || isBridge(rx, ry)) {
                                    if (isWatered) {
                                        wateredBuildingRoads.add(`${rx},${ry}`);
                                        buildingToRoadConnections.push({
                                            buildingX: tileX,
                                            buildingY: tileY,
                                            roadX: rx,
                                            roadY: ry,
                                            buildingKey
                                        });
                                    }
                                    foundConnection = true;
                                }
                            }
                        }
                    }
                }
            };

            // 수도 시설 인접 도로 수집
            this.waterFacilities.forEach((facility, key) => {
                for (let dx = -1; dx <= facility.width; dx++) {
                    for (let dy = -1; dy <= facility.depth; dy++) {
                        const nx = facility.x + dx;
                        const ny = facility.y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            if (isRoad(nx, ny) || isBridge(nx, ny)) {
                                waterFacilityRoads.add(`${nx},${ny}`);
                            }
                        }
                    }
                }
            });

            // 일반 건물 - 수도 공급되는 건물만
            placedBuildings.forEach((building, key) => {
                if (building.ref) return;
                const isWatered = this.wateredBuildings.has(key);
                collectBuildingRoads(building.x, building.y, building.width || 1, building.depth || 1, isWatered, key);
            });

            // 서비스 건물 - 수도 공급되는 건물만
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;
                if (this.waterFacilities.has(key)) return;
                const isWatered = this.wateredBuildings.has(key);
                collectBuildingRoads(building.x, building.y, building.width || 2, building.depth || 2, isWatered, key);
            });

            if (wateredBuildingRoads.size === 0) return;

            // 2단계: 수도 시설에서 BFS로 수도 공급 건물까지의 경로 찾기
            const neededRoads = new Set();
            const roadParent = new Map();

            const visited = new Set();
            const queue = [];

            waterFacilityRoads.forEach(roadKey => {
                visited.add(roadKey);
                queue.push(roadKey);
            });

            while (queue.length > 0) {
                const current = queue.shift();
                const [cx, cy] = current.split(',').map(Number);

                for (const dir of directions) {
                    const nx = cx + dir.dx;
                    const ny = cy + dir.dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                    const nkey = `${nx},${ny}`;
                    if (visited.has(nkey)) continue;

                    if (isRoad(nx, ny) || isBridge(nx, ny)) {
                        visited.add(nkey);
                        roadParent.set(nkey, current);
                        queue.push(nkey);
                    }
                }
            }

            // 수도 공급 건물에서 수도 시설까지 경로 역추적
            wateredBuildingRoads.forEach(roadKey => {
                let trace = roadKey;
                while (trace && !waterFacilityRoads.has(trace)) {
                    neededRoads.add(trace);
                    trace = roadParent.get(trace);
                }
                if (trace) {
                    neededRoads.add(trace);
                }
            });

            waterFacilityRoads.forEach(roadKey => {
                for (const dir of directions) {
                    const [x, y] = roadKey.split(',').map(Number);
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;
                    if (neededRoads.has(nkey)) {
                        neededRoads.add(roadKey);
                        break;
                    }
                }
            });

            // 3단계: 필요한 도로에 수도관 그리기 (4차선 도로는 원점 기준으로 통합)
            const processed4LaneOrigins = new Set();

            neededRoads.forEach(roadKey => {
                const [x, y] = roadKey.split(',').map(Number);

                // 4차선 도로인 경우 원점만 처리 (중복 방지)
                if (is4LaneRoad(x, y)) {
                    const origin = find4LaneOrigin(x, y);
                    if (origin) {
                        const originKey = `${origin.x},${origin.y}`;
                        if (processed4LaneOrigins.has(originKey)) return;
                        processed4LaneOrigins.add(originKey);
                    }
                }

                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const nkey = `${nx},${ny}`;

                    if (neededRoads.has(nkey) || waterFacilityRoads.has(nkey)) {
                        // 같은 4차선 도로 내부 타일끼리는 연결선 스킵
                        if (is4LaneRoad(x, y) && is4LaneRoad(nx, ny)) {
                            const origin1 = find4LaneOrigin(x, y);
                            const origin2 = find4LaneOrigin(nx, ny);
                            if (origin1 && origin2 && origin1.x === origin2.x && origin1.y === origin2.y) {
                                continue;
                            }
                        }

                        // 4차선 도로는 원점 좌표를 사용하여 연결 키 생성
                        let keyX = x, keyY = y, keyNX = nx, keyNY = ny;
                        if (is4LaneRoad(x, y)) {
                            const origin = find4LaneOrigin(x, y);
                            if (origin) { keyX = origin.x; keyY = origin.y; }
                        }
                        if (is4LaneRoad(nx, ny)) {
                            const origin = find4LaneOrigin(nx, ny);
                            if (origin) { keyNX = origin.x; keyNY = origin.y; }
                        }

                        const connKey = [`${keyX},${keyY}`, `${keyNX},${keyNY}`].sort().join('_');
                        if (!drawnConnections.has(connKey)) {
                            drawnConnections.add(connKey);
                            this.drawWaterPipe(x, y, nx, ny);
                        }
                    }
                }
            });

            // 4단계: 수도 시설에서 인접 필요 도로로 연결선 그리기
            this.waterFacilities.forEach((facility, key) => {
                const facilityCenterX = facility.x + (facility.width - 1) / 2;
                const facilityCenterY = facility.y + (facility.depth - 1) / 2;

                let closestRoad = null;
                let closestDist = Infinity;

                neededRoads.forEach(roadKey => {
                    const [rx, ry] = roadKey.split(',').map(Number);
                    let isAdjacent = false;
                    for (let dx = -1; dx <= facility.width; dx++) {
                        for (let dy = -1; dy <= facility.depth; dy++) {
                            if (rx === facility.x + dx && ry === facility.y + dy) {
                                isAdjacent = true;
                                break;
                            }
                        }
                        if (isAdjacent) break;
                    }

                    if (isAdjacent) {
                        const dist = Math.abs(rx - facilityCenterX) + Math.abs(ry - facilityCenterY);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestRoad = { x: rx, y: ry };
                        }
                    }
                });

                if (closestRoad) {
                    const connKey = `facility_${key}_to_${closestRoad.x},${closestRoad.y}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        this.drawWaterPipe(Math.floor(facilityCenterX), Math.floor(facilityCenterY), closestRoad.x, closestRoad.y);
                    }
                }
            });

            // 5단계: 수도 공급 건물에서 도로로의 연결선 그리기
            buildingToRoadConnections.forEach(conn => {
                const roadKey = `${conn.roadX},${conn.roadY}`;
                if (neededRoads.has(roadKey)) {
                    const connKey = `building_${conn.buildingKey}_to_${roadKey}`;
                    if (!drawnConnections.has(connKey)) {
                        drawnConnections.add(connKey);
                        this.drawWaterPipe(conn.buildingX, conn.buildingY, conn.roadX, conn.roadY);
                    }
                }
            });
        },

        // 4차선 도로의 월드 중심 좌표 가져오기
        get4LaneWorldCenter(x, y) {
            const origin = find4LaneOrigin(x, y);
            if (!origin) return tileToWorldCenter(x, y);
            // 2x2 영역의 중심
            const c1 = tileToWorldCenter(origin.x, origin.y);
            const c2 = tileToWorldCenter(origin.x + 1, origin.y + 1);
            return { x: (c1.x + c2.x) / 2, z: (c1.z + c2.z) / 2 };
        },

        // 수도관 그리기 - 4차선 도로 지원 (직각 연결)
        drawWaterPipe(x1, y1, x2, y2) {
            // 4차선 도로인 경우 중심 좌표 사용
            const is4Lane1 = is4LaneRoad(x1, y1);
            const is4Lane2 = is4LaneRoad(x2, y2);

            const pos1 = is4Lane1 ? this.get4LaneWorldCenter(x1, y1) : tileToWorldCenter(x1, y1);
            const pos2 = is4Lane2 ? this.get4LaneWorldCenter(x2, y2) : tileToWorldCenter(x2, y2);
            const height = 0.10;

            // 4차선 도로는 굵은 선 (0.10), 2차선은 기본 (0.07)
            const lineWidth = (is4Lane1 || is4Lane2) ? 0.10 : 0.07;

            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,  // 하늘색 (Sky Blue)
                transparent: true,
                opacity: 0.95
            });

            // 대각선이면 직각으로 꺾어서 연결 (4차선 도로 또는 일반 도로 모두)
            const dx = Math.abs(pos2.x - pos1.x);
            const dz = Math.abs(pos2.z - pos1.z);
            const isDiagonal = dx > 0.01 && dz > 0.01;  // 대각선 판단

            if (isDiagonal) {
                // 직각 연결: 먼저 X방향, 그 다음 Z방향
                const midPos = { x: pos2.x, z: pos1.z };

                // 첫 번째 선 (X방향)
                const curve1 = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(midPos.x, height, midPos.z)
                );
                const tube1 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve1, 1, lineWidth, 6, false),
                    tubeMaterial.clone()
                );
                this.waterPipeGroup.add(tube1);

                // 두 번째 선 (Z방향)
                const curve2 = new THREE.LineCurve3(
                    new THREE.Vector3(midPos.x, height, midPos.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube2 = new THREE.Mesh(
                    new THREE.TubeGeometry(curve2, 1, lineWidth, 6, false),
                    tubeMaterial.clone()
                );
                this.waterPipeGroup.add(tube2);
            } else {
                // 직선 연결 (같은 X 또는 같은 Z)
                const curve = new THREE.LineCurve3(
                    new THREE.Vector3(pos1.x, height, pos1.z),
                    new THREE.Vector3(pos2.x, height, pos2.z)
                );
                const tube = new THREE.Mesh(
                    new THREE.TubeGeometry(curve, 1, lineWidth, 6, false),
                    tubeMaterial
                );
                this.waterPipeGroup.add(tube);
            }
        },

        // 건물 수도 아이콘 업데이트
        updateBuildingWaterIcons() {
            // 수도 부족 건물에만 아이콘 표시
            this.unwateredBuildings.forEach(key => {
                const building = placedBuildings.get(key);
                if (building && building.instance) {
                    this.createWaterIcon(building.x, building.y, building.instance, false);
                }
            });

            // 수도 시설 아이콘 표시
            this.waterFacilities.forEach((facility, key) => {
                const building = placedPublicBuildings.get(key);
                if (building && building.instance) {
                    this.createWaterFacilityIcon(facility.x, facility.y, building.instance, facility.output);
                }
            });
        },

        // 수도 아이콘 생성
        createWaterIcon(x, y, buildingInstance, isWatered) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.3;

            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444';
            ctx.fill();

            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('💧', 32, 28);

            // X 표시
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(18, 42);
            ctx.lineTo(46, 42);
            ctx.stroke();

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.5, 0.5, 1);

            this.waterIconGroup.add(sprite);
            this.buildingWaterIcons.set(`${x},${y}`, sprite);
        },

        // 수도 시설 아이콘 생성
        createWaterFacilityIcon(x, y, buildingInstance, output) {
            if (!buildingInstance) return;

            const box = new THREE.Box3().setFromObject(buildingInstance);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const top = box.max.y + 0.5;

            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // 배경 (하늘색)
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.roundRect(0, 0, 128, 64, 8);
            ctx.fill();

            // 텍스트
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'black';
            ctx.fillText(`💧${output}`, 64, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(center.x, top, center.z);
            sprite.scale.set(0.8, 0.4, 1);

            this.waterIconGroup.add(sprite);
        },

        // 수도 뷰 토글
        toggleWaterView() {
            if (currentMode === MODE.WATER_VIEW) {
                setMode(MODE.CAMERA);
            } else {
                setMode(MODE.WATER_VIEW);
            }
        }
    };

    // showWaterEffects 함수 (수도 시설 설치 시 효과 범위 표시)
    function showWaterEffects(type) {
        const config = PUBLIC_BUILDING_MODELS[type];
        if (!config) return;

        // 수도 뷰 활성화
        waterManager.updateWaterVisualization();
    }

    // DOM elements for stats
    const taxPerHourText = document.getElementById("taxPerHourText");
    const populationText = document.getElementById("populationText");
    const happinessText = document.getElementById("happinessText");
    const powerText = document.getElementById("powerText");
    const waterText = document.getElementById("waterText");
    const trafficText = document.getElementById("trafficText");
    const crimeText = document.getElementById("crimeText");
    const apText = document.getElementById("apText");
    const streakText = document.getElementById("streakText");
    const offlineEarningsBox = document.getElementById("offlineEarningsBox");
    const offlineEarningsText = document.getElementById("offlineEarningsText");
    const loginRewardBox = document.getElementById("loginRewardBox");
    const loginRewardText = document.getElementById("loginRewardText");
    const btnCollectTax = document.getElementById("btnCollectTax");
    const btnClaimReward = document.getElementById("btnClaimReward");

    function updateStatsDisplay() {
        // 전력 사용량 업데이트 (인구 기반)
        if (powerManager.initialized) {
            powerManager.calculatePowerUsage();
            powerManager.calculatePowerCapacity();
        }

        // Info panel stats
        if (populationText) populationText.textContent = cityStats.population.toLocaleString();
        if (happinessText) {
            happinessText.textContent = cityStats.happiness + '%';
            happinessText.className = 'value ' + getStatClass(cityStats.happiness, 70, 40);
        }
        if (powerText) {
            powerText.textContent = `${cityStats.powerUsage}/${cityStats.powerCapacity}`;
            powerText.className = 'value ' + (cityStats.powerUsage > cityStats.powerCapacity ? 'danger' : 'good');
        }
        if (waterText) {
            waterText.textContent = `${cityStats.waterUsage}/${cityStats.waterCapacity}`;
            waterText.className = 'value ' + (cityStats.waterUsage > cityStats.waterCapacity ? 'danger' : 'good');
        }
        if (trafficText) {
            trafficText.textContent = cityStats.trafficLevel + '%';
            trafficText.className = 'value ' + getStatClass(100 - cityStats.trafficLevel, 70, 40);
        }
        if (crimeText) {
            crimeText.textContent = cityStats.crimeRate + '%';
            crimeText.className = 'value ' + getStatClass(100 - cityStats.crimeRate, 70, 40);
        }
        if (taxPerHourText) taxPerHourText.textContent = '+' + formatMoney(cityStats.taxPerHour) + '/hr';
        if (apText) apText.textContent = `${cityStats.actionPoints}/10`;
        if (streakText) streakText.textContent = `${cityStats.consecutiveLoginDays} ${i18n.t('hud.days')}`;

        // Bottom bar stats (Cities Skylines style)
        if (popBottomText) popBottomText.textContent = cityStats.population.toLocaleString();
        if (happyBottomText) happyBottomText.textContent = cityStats.happiness + '%';

        // RCI 수요 바 업데이트
        updateRCIDemandBar();
    }

    /* =========================================================
     * RCI DEMAND SYSTEM (수요 시스템)
     * 주거 60% / 산업 25% / 상업 15% 비율 기준
     * ========================================================= */

    // RCI 바 DOM 요소
    const rciResidentialBar = document.getElementById('rciResidential');
    const rciCommercialBar = document.getElementById('rciCommercial');
    const rciIndustrialBar = document.getElementById('rciIndustrial');

    // 구역 타일 수 계산
    function countZoneTiles() {
        let residential = 0, commercial = 0, industrial = 0;

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const cell = grid[x][y];
                if (cell === CELL.ZONE_RESIDENTIAL) residential++;
                else if (cell === CELL.ZONE_COMMERCIAL) commercial++;
                else if (cell === CELL.ZONE_INDUSTRIAL) industrial++;
            }
        }

        cityStats.residentialTiles = residential;
        cityStats.commercialTiles = commercial;
        cityStats.industrialTiles = industrial;

        return { residential, commercial, industrial };
    }

    // RCI 수요 계산
    // 양수 = 수요 있음 (더 지어야 함), 음수 = 과잉 공급
    function calculateRCIDemand() {
        const tiles = countZoneTiles();
        const total = tiles.residential + tiles.commercial + tiles.industrial;

        // 구역이 없으면 모두 수요 있음
        if (total === 0) {
            cityStats.residentialDemand = 50;  // 초기 주거 수요
            cityStats.commercialDemand = 10;   // 약간의 상업 수요
            cityStats.industrialDemand = 30;   // 산업 수요
            return;
        }

        // 현재 비율 계산
        const currentRatio = {
            residential: tiles.residential / total,
            commercial: tiles.commercial / total,
            industrial: tiles.industrial / total
        };

        // 이상 비율과의 차이로 수요 계산
        // 차이 * 200으로 -100 ~ +100 범위로 변환
        // 현재 비율이 이상보다 낮으면 양수(수요), 높으면 음수(과잉)

        // === 주거 수요 ===
        // 주거는 일자리(산업+상업)가 있어야 수요 발생
        const totalJobs = (tiles.commercial * 5) + (tiles.industrial * 8);  // 상업: 5명, 산업: 8명
        const jobDemandFactor = Math.min(totalJobs / Math.max(cityStats.population, 1), 1.5);
        const residentialBase = (RCI_IDEAL_RATIO.residential - currentRatio.residential) * 150;
        cityStats.residentialDemand = Math.max(-100, Math.min(100, residentialBase * jobDemandFactor));

        // === 상업 수요 ===
        // 상업은 인구(소비자)와 산업(물품)이 필요
        const consumerDemand = cityStats.population / Math.max(tiles.commercial * 20, 1);  // 상업 1타일당 20명 소화
        const goodsSupply = tiles.industrial / Math.max(tiles.commercial, 1);  // 산업이 상업에 물품 공급
        const commercialBase = (RCI_IDEAL_RATIO.commercial - currentRatio.commercial) * 150;
        const commercialModifier = Math.min(consumerDemand, 1.5) * Math.min(goodsSupply + 0.5, 1.5);
        cityStats.commercialDemand = Math.max(-100, Math.min(100, commercialBase * commercialModifier));

        // === 산업 수요 ===
        // 산업은 주거(노동력)가 필요, 상업(판매처)이 있으면 보너스
        const laborSupply = cityStats.population / Math.max(tiles.industrial * 15, 1);  // 산업 1타일당 15명 필요
        const salesOutlet = tiles.commercial / Math.max(tiles.industrial * 0.5, 1);  // 상업이 판매처
        const industrialBase = (RCI_IDEAL_RATIO.industrial - currentRatio.industrial) * 150;
        const industrialModifier = Math.min(laborSupply, 1.5) * Math.min(salesOutlet + 0.3, 1.2);
        cityStats.industrialDemand = Math.max(-100, Math.min(100, industrialBase * industrialModifier));

        // 일자리 수 업데이트
        cityStats.commercialJobs = tiles.commercial * 5;
        cityStats.industrialJobs = tiles.industrial * 8;
    }

    // RCI 수요 바 UI 업데이트
    function updateRCIDemandBar() {
        calculateRCIDemand();

        // 각 바 업데이트 (수요를 바 너비로 변환: 0~50% = 절반)
        updateSingleRCIBar(rciResidentialBar, cityStats.residentialDemand, 'residential');
        updateSingleRCIBar(rciCommercialBar, cityStats.commercialDemand, 'commercial');
        updateSingleRCIBar(rciIndustrialBar, cityStats.industrialDemand, 'industrial');
    }

    function updateSingleRCIBar(barElement, demand, type) {
        if (!barElement) return;

        const container = barElement.parentElement;
        const negativeBar = container.querySelector('.rci-bar-negative');

        // 수요 값을 바 높이로 변환 (최대 50% = 절반, 세로 방향)
        const absValue = Math.abs(demand);
        const heightPercent = Math.min(absValue / 2, 50);  // 최대 50%

        if (demand >= 0) {
            // 양수: 녹색 바 (위쪽으로)
            barElement.style.height = heightPercent + '%';
            if (negativeBar) negativeBar.style.height = '0%';
        } else {
            // 음수: 빨간 바 (아래쪽으로)
            barElement.style.height = '0%';
            if (negativeBar) negativeBar.style.height = heightPercent + '%';
        }
    }

    function getStatClass(value, goodThreshold, warningThreshold) {
        if (value >= goodThreshold) return 'good';
        if (value >= warningThreshold) return 'warning';
        return 'danger';
    }

    function showOfflineEarnings(amount) {
        if (offlineEarningsBox && amount > 0) {
            offlineEarningsText.textContent = formatMoney(amount);
            offlineEarningsBox.style.display = 'block';
        }
    }

    function showLoginReward(amount) {
        if (loginRewardBox && amount > 0) {
            loginRewardText.textContent = formatMoney(amount);
            loginRewardBox.style.display = 'block';
        }
    }

    async function collectTax() {
        try {
            // 도시 이름 파라미터 추가
            const cityNameParam = MAP_CONFIG.cityName ? `?cityName=${encodeURIComponent(MAP_CONFIG.cityName)}` : '';
            const response = await fetch(`/api/map/${MAP_CONFIG.username}/collect-tax${cityNameParam}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            if (response.ok) {
                const data = await response.json();
                economy.money = data.money;
                renderMoney();
                flashMoney();
                if (offlineEarningsBox) offlineEarningsBox.style.display = 'none';
                toast({ title: i18n.t('toast.taxCollected'), desc: i18n.t('toast.taxCollectedDesc'), success: true });
            }
        } catch (e) {
            console.error("세금 수집 실패:", e);
        }
    }

    async function claimLoginReward() {
        try {
            // 도시 이름 파라미터 추가
            const cityNameParam = MAP_CONFIG.cityName ? `?cityName=${encodeURIComponent(MAP_CONFIG.cityName)}` : '';
            const response = await fetch(`/api/map/${MAP_CONFIG.username}/claim-reward${cityNameParam}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            if (response.ok) {
                const data = await response.json();
                economy.money = data.money;
                renderMoney();
                flashMoney();
                if (loginRewardBox) loginRewardBox.style.display = 'none';
                toast({ title: i18n.t('toast.rewardClaimed'), desc: i18n.t('toast.rewardClaimedDesc'), success: true });
            }
        } catch (e) {
            console.error("Reward claim failed:", e);
        }
    }

    if (btnCollectTax) btnCollectTax.addEventListener('click', collectTax);
    if (btnClaimReward) btnClaimReward.addEventListener('click', claimLoginReward);

    /* =========================================================
     * TILE MODELS (도로, 수로, 잔디, 다리)
     * ========================================================= */
    const TILE_MODELS = {
        // 기본 잔디 타일
        grass: "/models/tile_for_home_1x1.005.glb",
        // 도로 타일 (2차로)
        road: {
            straight: "/models/roads/DD.glb",
            corner:   "/models/roads/CCC.glb",
            t:        "/models/roads/CCCC.glb",
            cross:    "/models/roads/road_tile_1x1_4.glb",
        },
        // 4차로 도로 타일
        road4lane: {
            straight: "/models/roads/road_tile_2x2_6_L.glb",
            corner:   "/models/roads/road_tile_2x2_4_L.glb",
            t:        "/models/roads/road_tile_2x2_2_L.glb",
            cross:    "/models/roads/road_tile_2x2_5.glb",
            // 2차선 연결용 모델
            straight_side_full: "/models/roads/road_tile_2x2_1_L.glb",   // 한 면 양쪽 연결 (1,2 or 3,4)
            straight_side_single: "/models/roads/road_tile_2x2_3_L.glb", // 한 면 한쪽만 연결
            straight_side_single_reversed: "/models/roads/road_tile_2x2_3 reversal.glb", // 좌상단(1) 연결용 반전 모델
            straight_side_corner: "/models/roads/road_tile_2x2_7_L.glb", // 모서리 양쪽 연결 (3-2, 2-3 대각선)
            straight_side_corner_reversed: "/models/roads/road_tile_2x2_7 reversal.glb", // 1-4 대각선용 좌우반전 모델
            straight_both_sides: "/models/roads/road_tile_2x2_1_L.glb",  // 양쪽 면 모두 연결
        },
        // 수로 타일
        water: {
            straight: "/models/roads/road_tile_river_1x1_1.glb",
            corner:   "/models/roads/road_tile_river_1x1_2.glb",
            t:        "/models/roads/road_tile_river_1x1_4.glb",
            cross:    "/models/roads/road_tile_river_1x1_3.glb",
        },
        // 다리 타일 (수로 위 도로)
        bridge: "/models/roads/road_tile_bridge_1x1_3.glb",
        // 나무 모델
        trees: [
            "/models/trees.010.glb",
            "/models/trees.011.glb"
        ],
    };

    // 하위 호환성을 위한 별칭
    const ROAD_MODELS = TILE_MODELS.road;

    /* =========================================================
     * BUILDING MODELS - 계층별/크기별 분류
     * ========================================================= */
    // 계층 상수: 0=중산층(middle), 1=상류층(high)
    const TIER = { MIDDLE: 0, HIGH: 1 };

    /* =========================================================
     * LAND VALUE SYSTEM - 땅값 시스템
     * ========================================================= */
    // 땅값 범위: -100 ~ 100 (0이 중간)
    // 50 이상이면 상류층 (HIGH), 미만이면 중산층 (MIDDLE)
    const LAND_VALUE_THRESHOLD = 50;

    // 업그레이드 시스템 설정
    const UPGRADE_CHECK_INTERVAL = 5000;  // 5초마다 땅값 체크
    const UPGRADE_MIN_DELAY = 3000;       // 업그레이드 최소 딜레이 (3초)
    const UPGRADE_MAX_DELAY = 15000;      // 업그레이드 최대 딜레이 (15초)
    const pendingUpgrades = new Map();    // 업그레이드 대기 목록
    const upgradeTimers = new Map();      // 업그레이드 딜레이 타이머 (건물 키 -> 타이머ID)
    const upgradeEligibleBuildings = new Map();  // 업그레이드 자격 충족 건물 (키 -> 시간)
    const abandonedBuildings = new Set(); // 폐건물 목록
    let lastUpgradeCheck = 0;             // 마지막 체크 시간
    let lastBottomBarUpdate = 0;          // 하단 바 업데이트 시간

    // 땅값 2D 배열 (GRID_W x GRID_H)
    const landValues = [];

    // 땅값 초기화
    function initLandValues() {
        for (let z = 0; z < GRID_H; z++) {
            landValues[z] = [];
            for (let x = 0; x < GRID_W; x++) {
                landValues[z][x] = 0;
            }
        }
    }

    // 특정 타일의 땅값 조회
    function getLandValue(x, z) {
        if (x < 0 || x >= GRID_W || z < 0 || z >= GRID_H) return 0;
        return landValues[z][x];
    }

    // 서비스 시설로 인한 땅값 버프 계산
    function getServiceBonus(x, z, skipAbandonedCheck = false) {
        // 해당 위치 건물이 폐건물인지 확인 - 폐건물은 버프를 받지 못함
        if (!skipAbandonedCheck) {
            const key = `${x},${z}`;
            if (abandonedBuildings.has(key)) {
                return 0;  // 폐건물은 서비스 보너스 없음
            }
            // buildingDataMap에서도 확인
            if (typeof buildingDataMap !== 'undefined') {
                const buildingData = buildingDataMap.get(key);
                if (buildingData && buildingData.isAbandoned) {
                    return 0;
                }
            }
        }

        let totalBonus = 0;

        // 모든 배치된 공공시설 확인
        if (typeof placedPublicBuildings !== 'undefined') {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조는 스킵

                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (!config) return;

                const bx = building.x;
                const by = building.y;
                const bw = building.width || 2;
                const bd = building.depth || 2;

                // 건물 중심 좌표
                const centerX = bx + bw / 2;
                const centerY = by + bd / 2;

                // 타일 중심과의 거리 계산
                const dx = (x + 0.5) - centerX;
                const dy = (z + 0.5) - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 효과 범위 내에 있으면 버프 적용 (거리에 따라 감소)
                if (distance <= config.effectRadius) {
                    const falloff = 1 - (distance / config.effectRadius);
                    totalBonus += config.landValueBonus * falloff;
                }
            });
        }

        return Math.round(totalBonus);
    }

    // 폐건물로 인한 땅값 감소 오라 계산 (행복도에는 영향 없음)
    const ABANDONED_AURA_RADIUS = 4;  // 폐건물 효과 범위 (4칸)
    const ABANDONED_LAND_VALUE_PENALTY = -50;  // 최대 땅값 감소

    function getAbandonedPenalty(x, z) {
        let totalPenalty = 0;

        // 모든 폐건물 확인
        abandonedBuildings.forEach(key => {
            const [bx, by] = key.split(',').map(Number);

            // 자기 자신은 제외
            if (bx === x && by === z) return;

            // 거리 계산
            const dx = x - bx;
            const dy = z - by;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // 효과 범위 내에 있으면 페널티 적용 (거리에 따라 감소)
            if (distance <= ABANDONED_AURA_RADIUS && distance > 0) {
                const falloff = 1 - (distance / ABANDONED_AURA_RADIUS);
                totalPenalty += ABANDONED_LAND_VALUE_PENALTY * falloff;
            }
        });

        return Math.round(totalPenalty);
    }

    // 총 땅값 계산 (기본 + 서비스 보너스 - 폐건물 페널티)
    function getTotalLandValue(x, z) {
        const baseLandValue = getLandValue(x, z);
        const serviceBonus = getServiceBonus(x, z);
        const abandonedPenalty = getAbandonedPenalty(x, z);
        return Math.max(0, baseLandValue + serviceBonus + abandonedPenalty);
    }

    // 땅값에 따른 계층 결정 (서비스 보너스 + 폐건물 페널티 포함)
    function getTierByLandValue(x, z) {
        const totalLandValue = getTotalLandValue(x, z);
        return totalLandValue >= LAND_VALUE_THRESHOLD ? TIER.HIGH : TIER.MIDDLE;
    }

    // 초기화 호출
    initLandValues();

    /* =========================================================
     * BUILDING UPGRADE SYSTEM - 건물 업그레이드 시스템
     * ========================================================= */

    // 모든 건물의 땅값 체크 (주기적으로 호출)
    function checkBuildingLandValues() {
        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData) continue;

            // 총 땅값 계산 (서비스 보너스 + 폐건물 페널티 포함)
            const totalLandValue = getTotalLandValue(x, y);
            userData.currentLandValue = totalLandValue;

            // 레벨 1 → 레벨 2 업그레이드 체크
            if (userData.level === 1 && !userData.isAbandoned) {
                if (totalLandValue >= LAND_VALUE_THRESHOLD) {
                    checkUpgradeEligibility(building, key);
                } else {
                    // 땅값 조건 미달 시 업그레이드 타이머 취소
                    cancelUpgradeTimer(key);
                }
            }

            // 레벨 2 → 폐건물 체크
            if (userData.level === 2 && !userData.isAbandoned) {
                if (totalLandValue < LAND_VALUE_THRESHOLD) {
                    userData.abandonedReason = '땅값이 하락해서 더 이상 살 수 없어요...';
                    markBuildingAbandoned(building, key);
                }
            }

            // 폐건물은 복구 불가 - 철거해야 함
            // (복구 로직 제거됨)
        }
    }

    // 업그레이드 가능 여부 확인 (랜덤 딜레이 적용)
    function checkUpgradeEligibility(building, key) {
        const { x, y, width, instance } = building;
        const userData = instance.userData;
        const zoneType = userData.zoneType;

        // 이미 2x2거나 레벨2면 스킵
        if (width === 2 || userData.level === 2) return;

        // 이미 업그레이드 대기 중이면 스킵
        if (upgradeTimers.has(key)) return;

        // 2x2 합체 가능 여부 확인
        const mergeResult = check2x2MergeEligibility(x, y, zoneType);

        if (mergeResult.canMerge) {
            // 랜덤 딜레이 계산 (3~15초)
            const delay = UPGRADE_MIN_DELAY + Math.random() * (UPGRADE_MAX_DELAY - UPGRADE_MIN_DELAY);

            // 업그레이드 자격 충족 표시 (땅값 조건 만족)
            upgradeEligibleBuildings.set(key, Date.now());

            // 딜레이 후 업그레이드 실행
            const timerId = setTimeout(() => {
                upgradeTimers.delete(key);
                upgradeEligibleBuildings.delete(key);

                // 건물이 아직 존재하고 조건이 여전히 만족하는지 확인
                const currentBuilding = placedBuildings.get(key);
                if (!currentBuilding) return;

                const currentUserData = currentBuilding.instance?.userData;
                if (!currentUserData || currentUserData.isAbandoned) return;
                if (currentUserData.level !== 1) return;

                // 땅값 재확인
                const totalLandValue = getTotalLandValue(x, y);
                if (totalLandValue < LAND_VALUE_THRESHOLD) return;

                // 2x2 합체 가능 여부 재확인
                const currentMergeResult = check2x2MergeEligibility(x, y, zoneType);
                if (currentMergeResult.canMerge) {
                    queueMergeUpgrade(currentMergeResult);
                }
            }, delay);

            upgradeTimers.set(key, timerId);
            console.log(`[Upgrade] Building at ${key} scheduled for upgrade in ${(delay/1000).toFixed(1)}s`);
        }
    }

    // 업그레이드 타이머 취소 (건물 제거 시 호출)
    function cancelUpgradeTimer(key) {
        if (upgradeTimers.has(key)) {
            clearTimeout(upgradeTimers.get(key));
            upgradeTimers.delete(key);
            upgradeEligibleBuildings.delete(key);
        }
    }

    // 2x2로 합체 가능한지 확인 (앞 2타일은 건물 필수, 뒤 2타일은 빈 공간 허용)
    function check2x2MergeEligibility(startX, startY, zoneType) {
        // 4가지 2x2 배치 시도 (현재 타일이 각 모서리인 경우)
        const configs = [
            { x: startX, y: startY },         // 좌상단
            { x: startX - 1, y: startY },     // 우상단
            { x: startX, y: startY - 1 },     // 좌하단
            { x: startX - 1, y: startY - 1 }  // 우하단
        ];

        // 구역 문자열을 셀 타입으로 변환
        let zoneCellType = CELL.ZONE_RESIDENTIAL;
        if (zoneType === 'commercial') zoneCellType = CELL.ZONE_COMMERCIAL;
        else if (zoneType === 'industrial') zoneCellType = CELL.ZONE_INDUSTRIAL;

        for (const config of configs) {
            const x = config.x;
            const y = config.y;

            // 범위 체크
            if (x < 0 || y < 0 || x + 1 >= GRID_W || y + 1 >= GRID_H) continue;

            // 도로 방향 찾기 (canPlace2x2Building과 유사한 로직)
            const roadCounts = { top: 0, bottom: 0, left: 0, right: 0 };

            // 위쪽 (y - 1)
            if (inBounds(x, y - 1) && isRoad(x, y - 1)) roadCounts.top++;
            if (inBounds(x + 1, y - 1) && isRoad(x + 1, y - 1)) roadCounts.top++;
            // 아래쪽 (y + 2)
            if (inBounds(x, y + 2) && isRoad(x, y + 2)) roadCounts.bottom++;
            if (inBounds(x + 1, y + 2) && isRoad(x + 1, y + 2)) roadCounts.bottom++;
            // 왼쪽 (x - 1)
            if (inBounds(x - 1, y) && isRoad(x - 1, y)) roadCounts.left++;
            if (inBounds(x - 1, y + 1) && isRoad(x - 1, y + 1)) roadCounts.left++;
            // 오른쪽 (x + 2)
            if (inBounds(x + 2, y) && isRoad(x + 2, y)) roadCounts.right++;
            if (inBounds(x + 2, y + 1) && isRoad(x + 2, y + 1)) roadCounts.right++;

            // 도로가 있는 방향 (가장 많은 도로 우선)
            const directions = Object.entries(roadCounts)
                .filter(([_, count]) => count > 0)
                .sort((a, b) => b[1] - a[1])
                .map(([dir]) => dir);

            if (directions.length === 0) continue;

            // 앞/뒤 타일 설정 (도로 방향 기준)
            const directionConfigs = {
                top: {
                    frontTiles: [{ x: x, y: y }, { x: x + 1, y: y }],
                    backTiles: [{ x: x, y: y + 1 }, { x: x + 1, y: y + 1 }]
                },
                bottom: {
                    frontTiles: [{ x: x, y: y + 1 }, { x: x + 1, y: y + 1 }],
                    backTiles: [{ x: x, y: y }, { x: x + 1, y: y }]
                },
                left: {
                    frontTiles: [{ x: x, y: y }, { x: x, y: y + 1 }],
                    backTiles: [{ x: x + 1, y: y }, { x: x + 1, y: y + 1 }]
                },
                right: {
                    frontTiles: [{ x: x + 1, y: y }, { x: x + 1, y: y + 1 }],
                    backTiles: [{ x: x, y: y }, { x: x, y: y + 1 }]
                }
            };

            // 각 도로 방향을 시도
            for (const roadDir of directions) {
                const { frontTiles, backTiles } = directionConfigs[roadDir];
                let isValid = true;
                const buildings = [];

                // 앞쪽 2타일: 반드시 적합한 건물이 있어야 함
                for (const tile of frontTiles) {
                    const bld = findBuildingAt(tile.x, tile.y);
                    if (!bld || bld.width !== 1) { isValid = false; break; }

                    const ud = bld.instance?.userData;
                    if (!ud || ud.level !== 1 || ud.zoneType !== zoneType || ud.isAbandoned) {
                        isValid = false; break;
                    }

                    const landValue = getTotalLandValue(tile.x, tile.y);
                    if (landValue < LAND_VALUE_THRESHOLD) { isValid = false; break; }

                    buildings.push({ x: tile.x, y: tile.y, building: bld });
                }
                if (!isValid) continue;

                // 뒤쪽 2타일: 적합한 건물이거나 빈 공간(잔디 또는 같은 구역) 허용
                for (const tile of backTiles) {
                    const cellValue = grid[tile.x][tile.y];
                    const bld = findBuildingAt(tile.x, tile.y);

                    if (bld) {
                        // 건물이 있으면 조건 확인
                        if (bld.width !== 1) { isValid = false; break; }
                        const ud = bld.instance?.userData;
                        if (!ud || ud.level !== 1 || ud.zoneType !== zoneType || ud.isAbandoned) {
                            isValid = false; break;
                        }
                        const landValue = getTotalLandValue(tile.x, tile.y);
                        if (landValue < LAND_VALUE_THRESHOLD) { isValid = false; break; }
                        buildings.push({ x: tile.x, y: tile.y, building: bld });
                    } else {
                        // 건물이 없으면 빈 공간 또는 같은 구역이어야 함
                        const isEmptyOrSameZone = (cellValue === CELL.EMPTY || cellValue === zoneCellType);
                        // 다른 타입의 구역, 도로, 수로 등은 불가
                        const isBlocker = (cellValue === CELL.ROAD || cellValue === CELL.LOCKED_ROAD ||
                                          cellValue === CELL.WATER || cellValue === CELL.BRIDGE);
                        const isOtherZone = (cellValue === CELL.ZONE_RESIDENTIAL ||
                                            cellValue === CELL.ZONE_COMMERCIAL ||
                                            cellValue === CELL.ZONE_INDUSTRIAL) &&
                                            cellValue !== zoneCellType;

                        if (isBlocker || isOtherZone || !isEmptyOrSameZone) {
                            isValid = false; break;
                        }
                        // 빈 공간은 buildings 배열에 추가하지 않음 (제거할 건물 없음)
                    }
                }
                if (!isValid) continue;

                // 최소 2개의 건물이 있어야 함 (앞쪽 2타일)
                if (buildings.length >= 2) {
                    return { canMerge: true, startX: x, startY: y, buildings, zoneType };
                }
            }
        }

        return { canMerge: false };
    }

    // 구역 문자열을 셀 타입으로 변환
    function getCellTypeForZone(zoneType) {
        if (zoneType === 'residential') return CELL.ZONE_RESIDENTIAL;
        if (zoneType === 'commercial') return CELL.ZONE_COMMERCIAL;
        if (zoneType === 'industrial') return CELL.ZONE_INDUSTRIAL;
        return CELL.ZONE_RESIDENTIAL;
    }

    // 2x2 합체 업그레이드 큐잉
    function queueMergeUpgrade(mergeResult) {
        const { startX, startY, buildings, zoneType } = mergeResult;
        const upgradeKey = `merge_${startX},${startY}`;

        if (pendingUpgrades.has(upgradeKey)) return;

        // 레벨 2 2x2 건물 모델 선택
        const cellType = getCellTypeForZone(zoneType);
        const buildingNames = getBuildingsForZone(cellType, TIER.HIGH, "2x2");
        if (buildingNames.length === 0) return;

        const idx = (startX * 7 + startY * 13) % buildingNames.length;
        const prefabName = buildingNames[idx];
        const buildingPrefab = buildingPrefabs[prefabName];
        if (!buildingPrefab) return;

        pendingUpgrades.set(upgradeKey, { type: 'merge', startX, startY, buildings });

        // 기존 건물 제거 (2x2 합체용이므로 재건축 스킵)
        for (const b of buildings) {
            removeBuildingAt(b.x, b.y, true);  // skipRebuild = true
        }

        // 기존 공사 시스템 사용
        queueConstruction(startX, startY, cellType, 2, 2, buildingPrefab, prefabName);

        console.log(`Merge upgrade queued at (${startX}, ${startY}) for ${zoneType}`);
    }

    // 건물을 폐건물로 표시 (영구적 - 철거만 가능)
    function markBuildingAbandoned(building, key) {
        const { instance, x, y } = building;
        const userData = instance.userData;

        if (userData.isAbandoned) return;

        userData.isAbandoned = true;
        building.isAbandoned = true;
        // 폐건물 이유를 buildingEntry에도 동기화
        building.abandonedReason = userData.abandonedReason || null;
        abandonedBuildings.add(key);

        // 단색 어두운 회색 적용
        applyAbandonedMaterials(instance);

        // 폐건물 아이콘 표시
        showAbandonedIcon(building, x, y);

        console.log(`Building at ${key} is now abandoned (reason: ${userData.abandonedReason || 'unknown'})`);
    }

    // ========================================
    // 통합 건물 상태 아이콘 시스템
    // 우선순위: 폐건물 > 도로 끊김 > 전력 부족 > 물 부족
    // 건물당 하나의 아이콘만 표시 (가장 높은 우선순위)
    // ========================================
    const BUILDING_STATUS = {
        ABANDONED: { priority: 1, icon: '🏚️', className: 'status-abandoned' },
        NO_ROAD: { priority: 2, icon: '🚫', className: 'status-no-road' },
        NO_POWER: { priority: 3, icon: '⚡', className: 'status-no-power' },
        NO_WATER: { priority: 4, icon: '💧', className: 'status-no-water' }
    };

    // 건물별 상태 저장 (key -> Set of status types)
    const buildingStatuses = new Map();
    // 건물별 표시중인 아이콘 (key -> { element, building, currentStatus })
    const buildingStatusIcons = new Map();

    // 건물 상태 추가
    function addBuildingStatus(x, y, statusType, building = null) {
        const key = `${x},${y}`;
        if (!buildingStatuses.has(key)) {
            buildingStatuses.set(key, new Set());
        }
        buildingStatuses.get(key).add(statusType);

        // 건물 참조 저장 (없으면 placedBuildings에서 찾기)
        if (!building) {
            building = placedBuildings.get(key);
        }

        updateBuildingStatusIcon(key, building);
    }

    // 건물 상태 제거
    function removeBuildingStatus(x, y, statusType) {
        const key = `${x},${y}`;
        const statuses = buildingStatuses.get(key);
        if (statuses) {
            statuses.delete(statusType);
            if (statuses.size === 0) {
                buildingStatuses.delete(key);
            }
        }

        const building = placedBuildings.get(key);
        updateBuildingStatusIcon(key, building);
    }

    // 건물의 최우선 상태 가져오기
    function getHighestPriorityStatus(key) {
        const statuses = buildingStatuses.get(key);
        if (!statuses || statuses.size === 0) return null;

        let highest = null;
        let highestPriority = Infinity;

        statuses.forEach(statusType => {
            const statusConfig = BUILDING_STATUS[statusType];
            if (statusConfig && statusConfig.priority < highestPriority) {
                highestPriority = statusConfig.priority;
                highest = statusType;
            }
        });

        return highest;
    }

    // 건물 상태 아이콘 업데이트 (우선순위에 따라 하나만 표시)
    function updateBuildingStatusIcon(key, building) {
        const highestStatus = getHighestPriorityStatus(key);
        const existingIcon = buildingStatusIcons.get(key);

        // 상태 없음 → 아이콘 제거
        if (!highestStatus) {
            if (existingIcon) {
                existingIcon.element.remove();
                buildingStatusIcons.delete(key);
            }
            return;
        }

        // 같은 상태면 유지
        if (existingIcon && existingIcon.currentStatus === highestStatus) {
            return;
        }

        // 기존 아이콘 제거
        if (existingIcon) {
            existingIcon.element.remove();
        }

        // 새 아이콘 생성
        if (!building) {
            building = placedBuildings.get(key);
        }
        if (!building || !building.instance) return;

        const statusConfig = BUILDING_STATUS[highestStatus];
        const iconEl = document.createElement('div');
        iconEl.className = `building-status-icon ${statusConfig.className}`;
        iconEl.textContent = statusConfig.icon;
        iconEl.style.cssText = `
            position: fixed;
            font-size: calc(24px * var(--ui-scale, 1));
            pointer-events: none;
            z-index: 1000;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            animation: statusIconBounce 2s ease-in-out infinite;
        `;
        document.body.appendChild(iconEl);

        buildingStatusIcons.set(key, {
            element: iconEl,
            building: building,
            currentStatus: highestStatus
        });
    }

    // 모든 상태 아이콘 위치 업데이트 (animate 루프)
    const _iconBox = new THREE.Box3();
    const _iconCenter = new THREE.Vector3();
    const _iconTop = new THREE.Vector3();
    const _iconScreenPos = new THREE.Vector3();

    // 상태 아이콘 표시 최대 거리
    const STATUS_ICON_MAX_DISTANCE = 25;

    function updateAllStatusIcons() {
        buildingStatusIcons.forEach((iconData, key) => {
            const { element, building } = iconData;
            if (!building || !building.instance) {
                element.remove();
                buildingStatusIcons.delete(key);
                buildingStatuses.delete(key);
                return;
            }

            // 건물 상단 위치 계산
            _iconBox.setFromObject(building.instance);
            _iconBox.getCenter(_iconCenter);
            _iconTop.set(_iconCenter.x, _iconBox.max.y + 0.8, _iconCenter.z);

            // 카메라와의 거리 계산
            const distanceToCamera = camera.position.distanceTo(_iconCenter);

            // 일정 거리 이상이면 숨김
            if (distanceToCamera > STATUS_ICON_MAX_DISTANCE) {
                element.style.display = 'none';
                return;
            }

            // 3D → 2D 화면 좌표 변환
            _iconScreenPos.copy(_iconTop).project(camera);

            // 카메라 뒤에 있으면 숨김
            if (_iconScreenPos.z > 1) {
                element.style.display = 'none';
                return;
            }

            const rect = cachedRendererRect || renderer.domElement.getBoundingClientRect();
            const screenX = (_iconScreenPos.x * 0.5 + 0.5) * rect.width + rect.left;
            const screenY = (-_iconScreenPos.y * 0.5 + 0.5) * rect.height + rect.top;

            element.style.display = 'block';
            element.style.left = (screenX - 12) + 'px';
            element.style.top = (screenY - 12) + 'px';
        });
    }

    // ========================================
    // 하위 호환성을 위한 래퍼 함수들
    // ========================================

    // 폐건물 아이콘 (레거시 호환)
    const abandonedIcons = buildingStatusIcons;  // 참조 유지 (레거시 코드용)

    function showAbandonedIcon(building, x, y) {
        addBuildingStatus(x, y, 'ABANDONED', building);
    }

    function removeAbandonedIcon(x, y) {
        removeBuildingStatus(x, y, 'ABANDONED');
    }

    // 건물의 모든 상태 제거 (철거 시 호출)
    function clearAllBuildingStatuses(x, y) {
        const key = `${x},${y}`;

        // 모든 상태 제거
        buildingStatuses.delete(key);

        // 아이콘 요소 제거
        const iconData = buildingStatusIcons.get(key);
        if (iconData) {
            iconData.element.remove();
            buildingStatusIcons.delete(key);
        }
    }

    // 레거시 함수명 유지
    function updateAbandonedIcons() {
        updateAllStatusIcons();
    }

    // 폐건물 회색 적용
    const ABANDONED_GRAY = 0x4a4a4a;  // 어두운 회색

    function applyAbandonedMaterials(instance) {
        instance.traverse((child) => {
            if (child.isMesh && child.material) {
                const materials = Array.isArray(child.material) ? child.material : [child.material];

                materials.forEach((mat) => {
                    // 회색으로 변경
                    if (mat.color) {
                        mat.color.setHex(ABANDONED_GRAY);
                    }
                    mat.transparent = false;
                    mat.opacity = 1.0;
                });
            }
        });
    }

    // 폐건물은 복구 불가능 - 철거만 가능
    // (복구 함수 제거됨)

    // 새로운 건물 모델 구조: zone -> tier -> size -> models[]
    const CIVIL_BUILDING_MODELS = {
        residential: {
            [TIER.MIDDLE]: {
                "1x1": [
                    "Group%2012", "Group%2013", "Group%2014", "Group%2015",
                    "Group%2034", "Group%2035", "Group%2036", "Group%2042",
                    "Group%2044", "Group%2045", "Group%2047", "Group%2048",
                    "Group%2049", "Group%2050"
                ],
                "2x2": []  // 중산층 주거는 2x2 없음
            },
            [TIER.HIGH]: {
                "1x1": [
                    "tile_for_home_1x1.006",
                    "tile_for_home_1x1.006%20(1)",
                    "tile_for_home_1x1.006%20(2)",
                    "tile_for_home_1x1.006%20(3)",
                    "tile_for_home_1x1.006%20(4)",
                    "tile_for_home_1x1.006%20(5)"
                ],
                "2x2": [
                    "tile_for_home_1x1.006%20(6)",
                    "tile_for_home_1x1.006%20(7)",
                    "tile_for_home_1x1.006%20(8)",
                    "tile_for_home_1x1.006%20(9)",
                    "tile_for_home_2x2.002",
                    "tile_for_home_2x2.002%20(1)",
                    "tile_for_home_2x2.002%20(2)",
                    "tile_for_home_2x2.002%20(3)",
                    "tile_for_home_2x2.002%20(4)",
                    "tile_for_home_2x2.002%20(5)",
                    "tile_for_home_2x2.002%20(6)",
                    "tile_for_home_2x2.002%20(7)",
                    "tile_for_home_2x2.002%20(8)",
                    "tile_for_home_2x2.002%20(9)"
                ]
            }
        },
        commercial: {
            [TIER.MIDDLE]: {
                "1x1": [
                    "tile_for_home_1x1.006%20(1)%20bookstore",
                    "tile_for_home_1x1.006%20(2)%20gym",
                    "tile_for_home_1x1.006%20(3)%20furniture",
                    "tile_for_home_1x1.006%20(4)%20skateboard",
                    "tile_for_home_1x1.006%20(5)%20guitar",
                    "tile_for_home_1x1.006%20(6)%20shoes",
                    "tile_for_home_1x1.006%20(7)%20hairshop",
                    "tile_for_home_1x1.006%20(8)%20tool",
                    "tile_for_home_1x1.006%20(9)%20glasses",
                    "tile_for_home_1x1.006%20(10)%20whiskey",
                    "tile_for_home_1x1.006%20(11)hamburer",
                    "tile_for_home_1x1.006%20(12)%20store",
                    "tile_for_home_1x1.006%20(13)%20icecream",
                    "tile_for_home_1x1.006%20(14)%20muffin",
                    "tile_for_home_1x1.006%20(15)%20donet",
                    "tile_for_home_1x1.006%20(16)",
                    "tile_for_home_1x1.006%20(17)%20bubbletea",
                    "tile_for_home_1x1.006%20(18)%20coke",
                    "tile_for_home_1x1.006%20speaker",
                    "tile_for_home_1x1.006%20(8)%20supermarket",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(1)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(2)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(3)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(4)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(5)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(6)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(7)",
                    "tile_for_home_1x1.006%20(8)%20supermarket%20(9)"
                ],
                "2x2": ["Group%2024", "Group%2029"]
            },
            [TIER.HIGH]: {
                "1x1": [],  // 상류층 상업은 1x1 없음
                "2x2": [
                    "business%20centers.009",
                    "tile_for_home_2x2.005",
                    "tile_for_home_2x2.005%20(1)",
                    "tile_for_home_2x2.005%20(2)",
                    "tile_for_home_2x2.005%20(3)",
                    "tile_for_home_2x2.005%20(4)",
                    "tile_for_home_2x2.005%20(5)",
                    "tile_for_home_2x2.005%20(6)",
                    "tile_for_home_2x2.005%20(8)"
                ]
            }
        },
        industrial: {
            [TIER.MIDDLE]: { "1x1": [], "2x2": [] },
            [TIER.HIGH]: { "1x1": [], "2x2": [] }
        }
    };

    // 건물 표시 이름 매핑 (prefabName -> 한글 이름)
    // prefabName 형식: {zoneType}_{tier}_{size}_{modelName}
    const BUILDING_DISPLAY_NAMES = {
        // 상업 중산층 1x1
        "commercial_1_1x1_tile_for_home_1x1.006%20(1)%20bookstore": "책벌레 서점",
        "commercial_1_1x1_tile_for_home_1x1.006%20(2)%20gym": "머슬파워 짐",
        "commercial_1_1x1_tile_for_home_1x1.006%20(3)%20furniture": "편안한 가구나라",
        "commercial_1_1x1_tile_for_home_1x1.006%20(4)%20skateboard": "익스트림 보드샵",
        "commercial_1_1x1_tile_for_home_1x1.006%20(5)%20guitar": "록스타 기타",
        "commercial_1_1x1_tile_for_home_1x1.006%20(6)%20shoes": "황금신발 구두방",
        "commercial_1_1x1_tile_for_home_1x1.006%20(7)%20hairshop": "가위손 미용실",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20tool": "뚝딱뚝딱 공구상",
        "commercial_1_1x1_tile_for_home_1x1.006%20(9)%20glasses": "맑은눈 안경점",
        "commercial_1_1x1_tile_for_home_1x1.006%20(10)%20whiskey": "한잔의 여유",
        "commercial_1_1x1_tile_for_home_1x1.006%20(11)hamburer": "왕햄버거",
        "commercial_1_1x1_tile_for_home_1x1.006%20(12)%20store": "24시 행복마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(13)%20icecream": "달콤 아이스",
        "commercial_1_1x1_tile_for_home_1x1.006%20(14)%20muffin": "구름머핀",
        "commercial_1_1x1_tile_for_home_1x1.006%20(15)%20donet": "동글동글 도넛",
        "commercial_1_1x1_tile_for_home_1x1.006%20(16)": "이것저것 잡화점",
        "commercial_1_1x1_tile_for_home_1x1.006%20(17)%20bubbletea": "타피오카 천국",
        "commercial_1_1x1_tile_for_home_1x1.006%20(18)%20coke": "톡톡 음료가게",
        "commercial_1_1x1_tile_for_home_1x1.006%20speaker": "쿵쿵 오디오",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket": "엄마손 슈퍼",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(1)": "싱싱 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(2)": "알뜰 식료품",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(3)": "착한가격 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(4)": "우리동네 가게",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(5)": "쪼꼬미 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(6)": "럭키세븐 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(7)": "매일매일 마트",
        "commercial_1_1x1_tile_for_home_1x1.006%20(8)%20supermarket%20(9)": "싱싱프레시",
    };

    // 건물 표시 이름 가져오기
    function getBuildingDisplayName(prefabName) {
        if (!prefabName) return null;

        // 먼저 매핑된 이름이 있는지 확인
        if (BUILDING_DISPLAY_NAMES[prefabName]) {
            return BUILDING_DISPLAY_NAMES[prefabName];
        }

        // 매핑된 이름이 없으면 prefabName에서 기본 이름 생성
        // prefabName 형식: {zoneType}_{tier}_{size}_{modelName}
        const parts = prefabName.split('_');
        if (parts.length >= 3) {
            const zoneType = parts[0];  // residential, commercial, industrial
            const tier = parseInt(parts[1]);  // 1: MIDDLE, 2: HIGH
            const size = parts[2];  // 1x1, 2x2

            // 상류층(tier=2) 건물의 기본 이름 생성
            if (tier === 2) {
                if (zoneType === 'residential') {
                    // 상류층 주거 → 아파트
                    const num = Math.floor(Math.random() * 100) + 1;
                    const dong = String.fromCharCode(65 + Math.floor(Math.random() * 10));  // A~J동
                    return `${dong}동 아파트`;
                } else if (zoneType === 'commercial') {
                    // 상류층 상업 → 사무실/오피스
                    const officeNames = [
                        '스카이 오피스', '센트럴 타워', '비즈니스 센터', '글로벌 오피스',
                        '파크 타워', '시티 오피스', '테크 빌딩', '프라임 타워',
                        '랜드마크 오피스', '코어 빌딩', '허브 센터', '원 타워'
                    ];
                    return officeNames[Math.floor(Math.random() * officeNames.length)];
                }
            }

            // 중산층(tier=1) 건물의 기본 이름 생성
            if (tier === 1) {
                if (zoneType === 'residential') {
                    // 중산층 주거 → 빌라/주택
                    const villaNames = ['해피 빌라', '그린 빌라', '썬샤인 빌라', '블루 빌라', '행복 주택'];
                    return villaNames[Math.floor(Math.random() * villaNames.length)];
                }
            }
        }

        return null;
    }

    // 기본 경로 생성 함수
    function getCivilBuildingPath(zoneType, tier, size, modelName) {
        const zoneFolder = zoneType === 'residential' ? 'resident' : 'commerical';
        const tierFolder = tier === TIER.HIGH ? 'high' : 'middle';
        return `/models/civil%20buildlings/${zoneFolder}%20${tierFolder}/${size}/${modelName}.glb`;
    }

    // 기존 호환용 (공업구역 등)
    const BUILDING_MODELS = {
        residential: [],
        commercial: [],
        industrial: [],
    };

    // 건물 프리팹 저장소 { name: { prefab, width, depth, height } }
    const buildingPrefabs = {};

    // 건물 그룹 (씬에 배치된 건물들)
    const buildingGroup = new THREE.Group();

    // 건물 위치 추적 Map: "x,y" -> { instance, tiles: ["x,y", ...] }
    const placedBuildings = new Map();
    let savedBuildingsData = null;  // DB에서 로드된 건물 데이터

    // === 건물 순회 최적화: Array 캐시 ===
    // Map.forEach보다 Array iteration이 더 빠름
    let placedBuildingsArrayCache = [];
    let placedBuildingsArrayDirty = true;

    // 건물 배열 캐시 가져오기 (참조 건물 제외, 실제 건물만)
    function getPlacedBuildingsArray() {
        if (placedBuildingsArrayDirty) {
            placedBuildingsArrayCache = [];
            placedBuildings.forEach((building, key) => {
                if (!building.ref) {  // 참조가 아닌 실제 건물만
                    placedBuildingsArrayCache.push({ building, key });
                }
            });
            placedBuildingsArrayDirty = false;
        }
        return placedBuildingsArrayCache;
    }

    // 캐시 무효화
    function invalidateBuildingsCache() {
        placedBuildingsArrayDirty = true;
    }

    // 건물 데이터 추출 (저장용 - 3D 객체 제외)
    function extractBuildingsData() {
        const data = {
            civilBuildings: [],
            publicBuildings: [],
            constructionSites: [],  // 공사중인 현장
            road4LaneOrigins: [],   // 4차로 도로 원점
            trees: []               // 나무 데이터
        };

        // 4차로 도로 원점 저장
        if (typeof road4laneOrigins !== 'undefined') {
            road4laneOrigins.forEach((originData, key) => {
                const [x, y] = key.split(',').map(Number);
                data.road4LaneOrigins.push({
                    x, y,
                    variant: originData.variant,
                    rotY: originData.rotY
                });
            });
        }

        // 민간 건물
        let totalBuildings = 0;
        let refBuildings = 0;
        let savedBuildings = 0;
        let skippedNoCoords = 0;

        console.log(`[Save Debug] placedBuildings size: ${placedBuildings.size}`);

        placedBuildings.forEach((building, key) => {
            totalBuildings++;
            if (building.ref) {
                refBuildings++;
                return;  // 참조 건물 스킵
            }

            // 필수 속성 확인
            if (typeof building.x === 'undefined' || typeof building.y === 'undefined') {
                console.warn(`[Save] 건물 ${key}에 좌표 정보 없음, 스킵`, building);
                skippedNoCoords++;
                return;
            }

            // 인구 데이터 가져오기 (주거 건물만)
            const size = building.width === 2 ? '2x2' : '1x1';
            const popKey = getBuildingKey(building.x, building.y, size);
            const population = buildingPopulations.get(popKey) || 0;

            // 건물 prefab 이름 (건물 복원용)
            const prefabName = building.prefabName || null;
            // 건물 표시 이름 (한글)
            const displayName = building.displayName || getBuildingDisplayName(prefabName);

            // 폐건물 이유 가져오기 (폐건물인 경우만)
            const abandonedReason = (building.isAbandoned && building.instance?.userData?.abandonedReason)
                ? building.instance.userData.abandonedReason
                : null;

            data.civilBuildings.push({
                key,
                x: building.x,
                y: building.y,
                width: building.width,
                depth: building.depth,
                zoneType: building.zoneType,
                level: building.level || 1,
                tier: building.tier || TIER.MIDDLE,
                isAbandoned: building.isAbandoned || false,
                abandonedReason: abandonedReason,  // 폐건물 이유 저장
                population: population,  // 인구 저장
                prefabName: prefabName,  // 건물 모델 이름 저장
                displayName: displayName // 건물 표시 이름 저장
            });
            savedBuildings++;
        });

        console.log(`[Save] placedBuildings 총: ${totalBuildings}개 (참조: ${refBuildings}개, 좌표없음: ${skippedNoCoords}개, 저장됨: ${savedBuildings}개)`);

        // 공공시설
        if (typeof placedPublicBuildings !== 'undefined') {
            placedPublicBuildings.forEach((building, key) => {
                if (building.ref) return;  // 참조 스킵
                // 회전값 추출 (instance가 있는 경우)
                const rotation = building.instance ? building.instance.rotation.y : 0;
                data.publicBuildings.push({
                    key,
                    type: building.type,
                    x: building.x,
                    y: building.y,
                    width: building.width,
                    depth: building.depth,
                    rotation: rotation
                });
            });
        }

        // 공사중인 현장 (3D 객체 제외하고 저장)
        if (typeof constructionSites !== 'undefined') {
            constructionSites.forEach((site, key) => {
                data.constructionSites.push({
                    key,
                    x: site.x,
                    y: site.y,
                    width: site.width,
                    depth: site.depth,
                    zoneType: site.zoneType,
                    state: site.state,
                    zoneStr: site.zoneStr,
                    size: site.size
                });
            });
        }

        // 나무 데이터 저장
        if (typeof placedTrees !== 'undefined') {
            placedTrees.forEach((treeData, key) => {
                const [x, y] = key.split(',').map(Number);
                data.trees.push({
                    x,
                    y,
                    modelIndex: treeData.modelIndex,
                    offsetX: treeData.offsetX,
                    offsetZ: treeData.offsetZ
                });
            });
        }

        // 저장 디버그 로그
        console.log(`[Save] 민간건물: ${data.civilBuildings.length}개, 공공시설: ${data.publicBuildings.length}개, 공사현장: ${data.constructionSites.length}개, 4차로: ${data.road4LaneOrigins.length}개, 나무: ${data.trees.length}개`);

        return data;
    }

    // 저장된 건물 데이터에서 특정 위치의 건물 정보 찾기
    function findSavedBuildingData(x, y) {
        if (!savedBuildingsData) return null;
        return savedBuildingsData.find(b => {
            // 건물이 차지하는 모든 타일 확인
            for (let dx = 0; dx < b.width; dx++) {
                for (let dy = 0; dy < b.depth; dy++) {
                    if (b.x + dx === x && b.y + dy === y) return true;
                }
            }
            return false;
        });
    }

    // 공사중인 현장 복원
    function restoreConstructionSites(sites) {
        if (!sites || sites.length === 0) return;

        for (const site of sites) {
            const { x, y, width, depth, zoneType, zoneStr, size } = site;

            // 해당 위치가 구역 타일인지 확인
            if (x >= 0 && x < GRID_W && y >= 0 && y < GRID_H) {
                const cellType = grid[x][y];
                if (cellType !== CELL.ZONE_RESIDENTIAL &&
                    cellType !== CELL.ZONE_COMMERCIAL &&
                    cellType !== CELL.ZONE_INDUSTRIAL) {
                    console.log(`Skipping construction at (${x},${y}) - not a zone cell`);
                    continue;
                }

                // 이미 건물이 있으면 스킵
                if (findBuildingAt(x, y)) {
                    console.log(`Skipping construction at (${x},${y}) - building already exists`);
                    continue;
                }

                // 해당 티어와 사이즈의 건물 목록 가져오기
                const tier = width === 2 ? TIER.HIGH : TIER.MIDDLE;
                const buildingSize = size || (width === 2 ? "2x2" : "1x1");
                let buildingNames = getBuildingsForZone(cellType, tier, buildingSize);
                if (buildingNames.length === 0) {
                    const otherTier = tier === TIER.HIGH ? TIER.MIDDLE : TIER.HIGH;
                    buildingNames = getBuildingsForZone(cellType, otherTier, buildingSize);
                }

                if (buildingNames.length === 0) {
                    console.warn(`No building found for construction at (${x},${y})`);
                    continue;
                }

                // 랜덤 건물 선택
                const buildingName = buildingNames[Math.floor(Math.random() * buildingNames.length)];
                const building = buildingPrefabs[buildingName];

                if (building) {
                    // 공사 대기열에 추가 (새로 시작)
                    queueConstruction(x, y, cellType, width || 1, depth || 1, building, buildingName);
                }
            }
        }
    }

    // 건물 모델 로드 및 크기 측정 (targetSize: "1x1" 또는 "2x2")
    async function loadBuildingPrefab(path, name, targetSize = "1x1", explicitWidth = null, explicitDepth = null) {
        return new Promise((resolve, reject) => {
            loader.load(path, (gltf) => {
                const prefab = gltf.scene;
                prefab.updateMatrixWorld(true);

                // 바운딩 박스로 크기 측정
                const box = new THREE.Box3().setFromObject(prefab);
                const size = new THREE.Vector3();
                box.getSize(size);

                // 명시적 크기가 있으면 사용, 없으면 targetSize에서 파싱
                const tileWidth = explicitWidth || (targetSize === "2x2" ? 2 : 1);
                const tileDepth = explicitDepth || (targetSize === "2x2" ? 2 : 1);
                const maxTileSizeX = TILE_SIZE * tileWidth;
                const maxTileSizeZ = TILE_SIZE * tileDepth;

                // X와 Z를 각각 독립적으로 스케일링하여 타일을 완전히 채움 (틈새 방지)
                const scaleX = maxTileSizeX / size.x;
                const scaleZ = maxTileSizeZ / size.z;
                const scaleY = Math.min(scaleX, scaleZ);  // Y는 비율 유지
                const scale = scaleY;  // 저장용

                prefab.scale.set(scaleX, scaleY, scaleZ);
                prefab.updateMatrixWorld(true);

                // 스케일 적용 후 크기 재측정
                const scaledBox = new THREE.Box3().setFromObject(prefab);
                const scaledSize = new THREE.Vector3();
                scaledBox.getSize(scaledSize);

                // 바운딩 박스 중심 계산 (XZ 평면에서 원점 오프셋)
                const center = new THREE.Vector3();
                scaledBox.getCenter(center);

                // 그림자 설정 및 머티리얼을 조명 반응형으로 강제 교체
                prefab.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // 모든 material을 MeshLambertMaterial로 강제 교체 (조명 반응)
                        const convertMaterial = (mat) => {
                            return new THREE.MeshLambertMaterial({
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                                map: mat.map || null,
                                transparent: mat.transparent || false,
                                opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                            });
                        };

                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(m => convertMaterial(m));
                        } else {
                            child.material = convertMaterial(child.material);
                        }
                    }
                });

                buildingPrefabs[name] = {
                    prefab,
                    width: tileWidth,
                    depth: tileDepth,
                    height: scaledSize.y,
                    minY: scaledBox.min.y,
                    centerOffsetX: center.x,  // 중심 오프셋 저장
                    centerOffsetZ: center.z,
                    scale: scale,
                    size: targetSize,  // "1x1" 또는 "2x2"
                };

                console.log(`Building loaded: ${name}, size: ${tileWidth}x${tileDepth} tiles`);
                resolve();
            }, undefined, reject);
        });
    }

    // 모든 건물 모델 로드 (새 구조)
    async function loadAllBuildingModels() {
        const loadPromises = [];
        let totalModels = 0;

        // 새 civil building 모델 로드
        for (const [zoneType, tiers] of Object.entries(CIVIL_BUILDING_MODELS)) {
            for (const [tier, sizes] of Object.entries(tiers)) {
                for (const [size, models] of Object.entries(sizes)) {
                    for (const modelName of models) {
                        const path = getCivilBuildingPath(zoneType, parseInt(tier), size, modelName);
                        const uniqueName = `${zoneType}_${tier}_${size}_${modelName}`;
                        totalModels++;
                        console.log(`Loading: ${uniqueName} from ${path}`);
                        loadPromises.push(
                            loadBuildingPrefab(path, uniqueName, size)
                                .catch(err => console.warn(`Failed to load ${uniqueName} from ${path}:`, err))
                        );
                    }
                }
            }
        }

        console.log(`Attempting to load ${totalModels} civil building models...`);
        await Promise.all(loadPromises);

        // 빈틈 채움용 1x1 기본 건물 생성 (각 구역별) - 폴백용
        createFillerBuilding('Filler_Residential', 0x8fbc8f, 1.2);  // 연두색
        createFillerBuilding('Filler_Commercial', 0x6495ed, 1.5);   // 파란색
        createFillerBuilding('Filler_Industrial', 0xdaa520, 1.0);   // 갈색

        // 공공시설 모델 로드 (학교, 경찰서, 소방서, 공원)
        await loadPublicBuildingModels();

        console.log('All building models loaded:', Object.keys(buildingPrefabs).length, 'models');
        console.log('Loaded prefabs:', Object.keys(buildingPrefabs));
    }

    // 공공시설 프리팹 저장소 (별도 관리)
    const publicBuildingPrefabs = {};

    // 공공시설 모델 정보 (효과 범위 및 땅값 보너스 포함)
    const PUBLIC_BUILDING_MODELS = {
        school: {
            path: '/models/school/Group 7.glb',
            size: '2x2',
            tileWidth: 2,   // 명시적 타일 크기
            tileDepth: 2,
            cost: 4000,
            name: '학교',
            icon: '🏫',
            description: '시민들에게 교육 서비스를 제공하여 중류층 전환율을 높입니다.',
            maintenanceCost: 80,   // 시간당 운영비
            effectRadius: 10,      // 효과 범위 (타일)
            landValueBonus: 150,   // 중심부 땅값 상승
            effectColor: 0x44cc66  // 초록색 (이로운 효과)
        },
        police: {
            path: '/models/PoliceStations/Group 5.glb',
            size: '1x1',
            tileWidth: 1,
            tileDepth: 1,
            cost: 3000,
            name: '경찰서',
            icon: '🚔',
            description: '범죄를 예방하고 치안을 유지하여 시민들의 안전을 보장합니다.',
            maintenanceCost: 60,   // 시간당 운영비
            effectRadius: 8,
            landValueBonus: 100,
            effectColor: 0x44cc66  // 초록색 (이로운 효과)
        },
        fire: {
            path: '/models/FireStation/Group 6.glb',
            size: '1x1',
            tileWidth: 1,
            tileDepth: 1,
            cost: 3000,
            name: '소방서',
            icon: '🚒',
            description: '화재 예방 및 신속한 진압으로 건물과 시민을 보호합니다.',
            maintenanceCost: 50,   // 시간당 운영비
            effectRadius: 8,
            landValueBonus: 100,
            effectColor: 0x44cc66  // 초록색 (이로운 효과)
        },
        park: {
            paths: [
                '/models/Park/2x2/Group.glb',
                '/models/Park/2x2/Group 1.glb',
                '/models/Park/2x2/Group 2.glb',
                '/models/Park/2x2/Group 3.glb',
                '/models/Park/2x2/Group 4.glb',
            ],
            size: '2x2',
            tileWidth: 2,
            tileDepth: 2,
            cost: 1000,
            name: '공원',
            icon: '🌳',
            description: '녹지 공간을 제공하여 시민들의 행복도를 높입니다.',
            maintenanceCost: 20,   // 시간당 운영비
            effectRadius: 5,
            landValueBonus: 80,
            effectColor: 0x44cc66  // 초록색 (이로운 효과)
        },
        hospital: {
            path: '/models/Hospital/Hospital 2x2.glb',
            size: '2x2',
            tileWidth: 2,
            tileDepth: 2,
            cost: 6000,
            name: '병원',
            icon: '🏥',
            description: '시민들에게 의료 서비스를 제공하여 상류층 전환율을 높이고 행복도를 증가시킵니다.',
            maintenanceCost: 100,   // 시간당 운영비
            effectRadius: 12,       // 효과 범위 (타일)
            landValueBonus: 200,    // 중심부 땅값 상승
            effectColor: 0x44cc66   // 초록색 (이로운 효과)
        },
        // 발전소 (전력 공급)
        powerplant_coal: {
            path: '/models/school/Group 7.glb',  // 임시 2x2 모델 (학교 모델 사용)
            size: '2x2',
            tileWidth: 2,
            tileDepth: 2,
            cost: 5000,
            name: '화력 발전소',
            icon: '🏭',
            description: '석탄을 태워 전기를 생산합니다. 대용량이지만 오염을 유발합니다.',
            maintenanceCost: 100,
            powerOutput: 500,       // 전력 생산량
            effectRadius: 15,       // 전력 공급 범위
            landValueBonus: -50,    // 오염으로 땅값 하락
            effectColor: 0xffcc00,  // 노란색 (전력)
            isPowerPlant: true
        },
        powerplant_wind: {
            path: '/models/PoliceStations/Group 5.glb',  // 임시 1x1 모델 (경찰서 모델 사용)
            size: '1x1',
            tileWidth: 1,
            tileDepth: 1,
            cost: 3000,
            name: '풍력 발전기',
            icon: '💨',
            description: '바람으로 전기를 생산합니다. 친환경이지만 소용량입니다.',
            maintenanceCost: 30,
            powerOutput: 100,
            effectRadius: 8,
            landValueBonus: 20,     // 친환경으로 땅값 소폭 상승
            effectColor: 0xffcc00,
            isPowerPlant: true
        },
        // 수도 시설 (수도 공급)
        water_tower: {
            path: '/models/Hospital/Hospital 2x2.glb',  // 임시 2x2 모델 (병원 모델 사용)
            size: '2x2',
            tileWidth: 2,
            tileDepth: 2,
            cost: 4000,
            name: '급수탑',
            icon: '🏗️',
            description: '물을 저장하고 공급합니다. 대용량 수도 시설입니다.',
            maintenanceCost: 60,
            waterOutput: 400,       // 수도 생산량
            effectRadius: 12,       // 수도 공급 범위
            landValueBonus: 30,
            effectColor: 0x87CEEB,  // 하늘색 (수도)
            isWaterFacility: true
        },
        water_pump: {
            path: '/models/FireStation/Group 6.glb',  // 임시 1x1 모델 (소방서 모델 사용)
            size: '1x1',
            tileWidth: 1,
            tileDepth: 1,
            cost: 2000,
            name: '펌프장',
            icon: '💧',
            description: '지하수를 퍼올려 수도를 공급합니다. 소용량이지만 저렴합니다.',
            maintenanceCost: 25,
            waterOutput: 150,
            effectRadius: 8,
            landValueBonus: 10,
            effectColor: 0x87CEEB,
            isWaterFacility: true
        }
    };

    // 공공시설 모델 로드
    async function loadPublicBuildingModels() {
        const loadPromises = [];

        for (const [type, config] of Object.entries(PUBLIC_BUILDING_MODELS)) {
            // 명시적 타일 크기 사용
            const tileW = config.tileWidth || (config.size === '2x2' ? 2 : 1);
            const tileD = config.tileDepth || (config.size === '2x2' ? 2 : 1);

            if (config.paths) {
                // 여러 모델이 있는 경우 (공원)
                config.paths.forEach((path, index) => {
                    const prefabName = `public_${type}_${index}`;
                    loadPromises.push(
                        loadBuildingPrefab(path, prefabName, config.size, tileW, tileD)
                            .then(() => {
                                if (!publicBuildingPrefabs[type]) {
                                    publicBuildingPrefabs[type] = [];
                                }
                                publicBuildingPrefabs[type].push(prefabName);
                            })
                            .catch(err => console.warn(`Failed to load ${prefabName}:`, err))
                    );
                });
            } else {
                // 단일 모델
                const prefabName = `public_${type}`;
                loadPromises.push(
                    loadBuildingPrefab(config.path, prefabName, config.size, tileW, tileD)
                        .then(() => {
                            publicBuildingPrefabs[type] = [prefabName];
                        })
                        .catch(err => console.warn(`Failed to load ${prefabName}:`, err))
                );
            }
        }

        await Promise.all(loadPromises);
    }

    // 공공시설 랜덤 프리팹 선택
    function getRandomPublicPrefab(type) {
        const prefabs = publicBuildingPrefabs[type];
        if (!prefabs || prefabs.length === 0) return null;
        const prefabName = prefabs[Math.floor(Math.random() * prefabs.length)];
        return buildingPrefabs[prefabName];
    }

    // 공공시설 첫 번째 프리팹 가져오기 (미리보기용)
    function getFirstPublicPrefab(type) {
        const prefabs = publicBuildingPrefabs[type];
        if (!prefabs || prefabs.length === 0) return null;
        return buildingPrefabs[prefabs[0]];
    }

    /* =========================================================
     * BUILDING PLACEMENT PREVIEW
     * 설치 모드에서 마우스 위치에 미리보기 건물 표시
     * ========================================================= */
    const buildingPreviewGroup = new THREE.Group();
    buildingPreviewGroup.visible = false;
    let currentPreviewBuilding = null;
    let currentPreviewType = null;
    let placementRotation = 0;  // 0, 90, 180, 270도 (라디안으로 저장)

    // 부드러운 프리뷰 이동을 위한 변수
    const previewTargetPos = new THREE.Vector3();
    const previewCurrentPos = new THREE.Vector3();
    let previewInitialized = false;
    const PREVIEW_LERP_SPEED = 0.25;  // 보간 속도 (0~1, 높을수록 빠름)

    // 미리보기용 흰색 반투명 머티리얼
    const previewMaterialWhite = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,
    });

    // 배치 가능 시 초록색, 불가능 시 빨간색
    const previewMaterialValid = new THREE.MeshStandardMaterial({
        color: 0x44ff66,
        transparent: true,
        opacity: 0.6,
    });

    const previewMaterialInvalid = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        transparent: true,
        opacity: 0.6,
    });

    // 미리보기 건물 업데이트
    function updateBuildingPreview(type, gx, gy) {
        // 타입이 변경되면 미리보기 건물 재생성
        if (type !== currentPreviewType) {
            // 기존 미리보기 제거
            while (buildingPreviewGroup.children.length > 0) {
                buildingPreviewGroup.remove(buildingPreviewGroup.children[0]);
            }

            const prefabData = getFirstPublicPrefab(type);
            if (!prefabData || !prefabData.prefab) {
                buildingPreviewGroup.visible = false;
                currentPreviewBuilding = null;
                currentPreviewType = null;
                return;
            }

            // 프리팹 복제
            currentPreviewBuilding = prefabData.prefab.clone();
            currentPreviewBuilding.userData.prefabData = prefabData;

            // 흰색 머티리얼 적용
            currentPreviewBuilding.traverse((child) => {
                if (child.isMesh) {
                    child.material = previewMaterialWhite.clone();
                    child.castShadow = false;
                    child.receiveShadow = false;
                }
            });

            buildingPreviewGroup.add(currentPreviewBuilding);
            currentPreviewType = type;
        }

        if (!currentPreviewBuilding) return;

        const prefabData = currentPreviewBuilding.userData.prefabData;
        const width = prefabData.width || 2;
        const depth = prefabData.depth || 2;

        // 목표 위치 설정 (부드러운 이동을 위해)
        const worldX = ORIGIN_X + gx + width / 2;
        const worldZ = ORIGIN_Z + gy + depth / 2;
        previewTargetPos.set(
            worldX - (prefabData.centerOffsetX || 0),
            -(prefabData.minY || 0),
            worldZ - (prefabData.centerOffsetZ || 0)
        );

        // 첫 번째 위치 설정 시 즉시 이동
        if (!previewInitialized) {
            previewCurrentPos.copy(previewTargetPos);
            buildingPreviewGroup.position.copy(previewCurrentPos);
            previewInitialized = true;
        }

        // 도로 방향으로 자동 회전 (앞면이 도로를 향하도록)
        const roadDirection = findNearestRoadDirection(gx, gy, width, depth);
        buildingPreviewGroup.rotation.y = roadDirection;

        // 배치 가능 여부 확인하고 색상 변경
        const canPlace = canPlacePublicBuilding(gx, gy, type);
        const targetMaterial = canPlace ? previewMaterialValid : previewMaterialInvalid;

        currentPreviewBuilding.traverse((child) => {
            if (child.isMesh) {
                child.material = targetMaterial.clone();
            }
        });

        buildingPreviewGroup.visible = true;
    }

    // 미리보기 회전 (90도씩)
    function rotatePlacementPreview(direction) {
        placementRotation += direction * (Math.PI / 2);
        // 0 ~ 2π 범위로 정규화
        if (placementRotation >= Math.PI * 2) placementRotation -= Math.PI * 2;
        if (placementRotation < 0) placementRotation += Math.PI * 2;

        // 미리보기 건물에 즉시 적용
        if (buildingPreviewGroup.visible) {
            buildingPreviewGroup.rotation.y = placementRotation;
        }
    }

    // 미리보기 숨기기
    function hideBuildingPreview() {
        buildingPreviewGroup.visible = false;
        previewInitialized = false;  // 다음 표시 시 즉시 이동하도록 초기화
    }

    // 프리뷰 부드러운 이동 업데이트 (매 프레임 호출)
    function updateBuildingPreviewPosition() {
        if (!buildingPreviewGroup.visible || !previewInitialized) return;

        // 현재 위치를 목표 위치로 부드럽게 보간
        previewCurrentPos.lerp(previewTargetPos, PREVIEW_LERP_SPEED);
        buildingPreviewGroup.position.copy(previewCurrentPos);
    }

    // 배치 가능 여부 확인 (비용 제외)
    function canPlacePublicBuilding(gx, gy, type) {
        const prefabData = getFirstPublicPrefab(type);
        if (!prefabData) return false;

        const width = prefabData.width || 2;
        const depth = prefabData.depth || 2;

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const cx = gx + dx;
                const cy = gy + dy;
                if (cx < 0 || cx >= GRID_W || cy < 0 || cy >= GRID_H) {
                    return false;
                }
                const cell = grid[cx][cy];
                if (cell !== CELL.EMPTY && cell !== CELL.ZONE_RESIDENTIAL &&
                    cell !== CELL.ZONE_COMMERCIAL && cell !== CELL.ZONE_INDUSTRIAL) {
                    return false;
                }
                // 이미 배치된 공공시설 확인 (참조 타일 포함)
                const key = `${cx},${cy}`;
                if (placedPublicBuildings.has(key)) {
                    return false;  // 참조든 실제든 이미 타일이 사용 중
                }
            }
        }

        // 도로 인접 여부 확인 (건물 외곽 타일 중 하나라도 도로에 인접해야 함)
        let hasAdjacentRoad = false;
        for (let dx = 0; dx < width && !hasAdjacentRoad; dx++) {
            for (let dy = 0; dy < depth && !hasAdjacentRoad; dy++) {
                const cx = gx + dx;
                const cy = gy + dy;
                if (isAdjacentToRoad(cx, cy)) {
                    hasAdjacentRoad = true;
                }
            }
        }
        if (!hasAdjacentRoad) {
            return false;  // 도로에 인접하지 않음
        }

        return true;
    }

    /* =========================================================
     * SERVICE EFFECT VISUALIZATION
     * 서비스 시설 설치 모드에서 땅값 상승 효과 범위 표시
     * 원형으로 중심에서 멀어질수록 옅어지는 효과
     * ========================================================= */
    const serviceEffectGroup = new THREE.Group();
    serviceEffectGroup.visible = false;

    // 원형 효과 메시 생성 (단색 원)
    function createCircularEffectMesh(centerX, centerY, radius, color, opacity = 0.5, buildingWidth = 2, buildingDepth = 2) {
        const maxRadius = radius * TILE_SIZE;

        // 단일 원형 메시 생성
        const geometry = new THREE.CircleGeometry(maxRadius, 64);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: opacity,
            side: THREE.DoubleSide,
            depthWrite: false,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;  // 바닥에 눕히기

        // 건물 크기에 따라 중심 계산
        mesh.position.set(
            ORIGIN_X + centerX + buildingWidth / 2,
            0.05,  // 약간 띄우기
            ORIGIN_Z + centerY + buildingDepth / 2
        );

        return mesh;
    }

    // 건물 타입에서 크기 파싱 (예: '1x1' -> {width: 1, depth: 1})
    function parseBuildingSize(sizeStr) {
        if (!sizeStr) return { width: 2, depth: 2 };
        const parts = sizeStr.split('x');
        return {
            width: parseInt(parts[0]) || 2,
            depth: parseInt(parts[1]) || 2
        };
    }

    // 서비스 타입별 효과 표시
    function showServiceEffects(serviceType) {
        // 기존 효과 제거
        clearServiceEffects();

        const config = PUBLIC_BUILDING_MODELS[serviceType];
        if (!config) return;

        const effectColor = config.effectColor;
        const effectRadius = config.effectRadius;

        // 해당 타입의 모든 배치된 시설 효과 표시
        placedPublicBuildings.forEach((building, key) => {
            if (building.ref) return;  // 참조는 스킵
            if (building.type !== serviceType) return;

            // 저장된 건물 크기 사용
            const bWidth = building.width || 2;
            const bDepth = building.depth || 2;

            const mesh = createCircularEffectMesh(
                building.x,
                building.y,
                effectRadius,
                effectColor,
                0.4,
                bWidth,
                bDepth
            );
            mesh.userData.isServiceEffect = true;
            serviceEffectGroup.add(mesh);
        });

        serviceEffectGroup.visible = true;
    }

    // 미리보기 위치에 효과 표시 (설치 전 미리보기)
    function showPreviewEffect(serviceType, gx, gy) {
        const config = PUBLIC_BUILDING_MODELS[serviceType];
        if (!config) return;

        // 건물 크기 파싱
        const size = parseBuildingSize(config.size);

        // 미리보기 효과 메시 생성 (더 투명하게)
        const mesh = createCircularEffectMesh(
            gx,
            gy,
            config.effectRadius,
            config.effectColor,
            0.25,  // 미리보기는 더 투명
            size.width,
            size.depth
        );
        mesh.userData.isPreviewEffect = true;
        serviceEffectGroup.add(mesh);
    }

    // 미리보기 효과만 제거
    function clearPreviewEffect() {
        for (let i = serviceEffectGroup.children.length - 1; i >= 0; i--) {
            const child = serviceEffectGroup.children[i];
            if (child.userData.isPreviewEffect) {
                serviceEffectGroup.remove(child);
                // 그룹인 경우 내부 메시들도 정리
                if (child.isGroup) {
                    child.traverse((obj) => {
                        if (obj.isMesh) {
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        }
                    });
                } else {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
            }
        }
    }

    // 모든 효과 제거
    function clearServiceEffects() {
        while (serviceEffectGroup.children.length > 0) {
            const child = serviceEffectGroup.children[0];
            serviceEffectGroup.remove(child);
            // 그룹인 경우 내부 메시들도 정리
            if (child.isGroup) {
                child.traverse((obj) => {
                    if (obj.isMesh) {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    }
                });
            } else {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }
        }
        serviceEffectGroup.visible = false;
    }

    // 서비스 효과 업데이트 (미리보기 포함)
    function updateServiceEffectVisualization(serviceType, previewX, previewY) {
        // 기존 효과 제거
        clearServiceEffects();

        const config = PUBLIC_BUILDING_MODELS[serviceType];
        if (!config) return;

        const effectColor = config.effectColor;
        const effectRadius = config.effectRadius;
        const size = parseBuildingSize(config.size);

        // 해당 타입의 모든 배치된 시설 효과 표시
        placedPublicBuildings.forEach((building, key) => {
            if (building.ref) return;
            if (building.type !== serviceType) return;

            // 저장된 건물 크기 사용
            const bWidth = building.width || size.width;
            const bDepth = building.depth || size.depth;

            const mesh = createCircularEffectMesh(
                building.x,
                building.y,
                effectRadius,
                effectColor,
                0.4,
                bWidth,
                bDepth
            );
            mesh.userData.isServiceEffect = true;
            serviceEffectGroup.add(mesh);
        });

        // 미리보기 위치에도 효과 표시
        if (previewX !== undefined && previewY !== undefined) {
            const previewMesh = createCircularEffectMesh(
                previewX,
                previewY,
                effectRadius,
                effectColor,
                0.25,
                size.width,
                size.depth
            );
            previewMesh.userData.isPreviewEffect = true;
            serviceEffectGroup.add(previewMesh);
        }

        serviceEffectGroup.visible = true;
    }

    // 1x1 채움용 건물 생성
    function createFillerBuilding(name, color, height) {
        const geometry = new THREE.BoxGeometry(TILE_SIZE * 0.8, height, TILE_SIZE * 0.8);
        const material = new THREE.MeshStandardMaterial({ color: color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        const prefab = new THREE.Group();
        prefab.add(mesh);
        mesh.position.y = height / 2;

        buildingPrefabs[name] = {
            prefab,
            width: 1,
            depth: 1,
            height: height,
            minY: 0,
            centerOffsetX: 0,
            centerOffsetZ: 0,
            scale: 1,
        };

        console.log(`Filler building created: ${name}, size: 1x1 tiles`);
    }

    // 타일 프리팹 저장소
    const tilePrefabs = {
        grass: null,
        bridge: null,
        road: { straight: null, corner: null, t: null, cross: null },
        road4lane: { straight: null, corner: null, t: null, cross: null },
        water: { straight: null, corner: null, t: null, cross: null },
        trees: [],  // 나무 프리팹 배열 (trees.010, trees.011)
    };

    // 하위 호환성
    const roadPrefabs = tilePrefabs.road;
    const road4lanePrefabs = tilePrefabs.road4lane;

    // 4차선 도로 원점 추적 (2x2 타일의 좌하단 원점)
    // key: "x,y" (원점 좌표), value: { variant: 'straight'|'corner'|'t'|'cross', rotY: number }
    const road4laneOrigins = new Map();

    const tileMinY = {
        grass: 0,
        bridge: 0,
        road: { straight: 0, corner: 0, t: 0, cross: 0 },
        road4lane: { straight: 0, corner: 0, t: 0, cross: 0, straight_side_full: 0, straight_side_single: 0, straight_side_single_reversed: 0, straight_side_corner: 0, straight_side_corner_reversed: 0, straight_both_sides: 0 },
        water: { straight: 0, corner: 0, t: 0, cross: 0 },
    };
    const roadMinY = tileMinY.road;

    // 일반 타일 로드 함수
    async function loadTilePrefab(category, key, url) {
        return new Promise((resolve, reject) => {
            loader.load(url, (gltf) => {
                const prefab = gltf.scene;
                prefab.scale.set(1, 1, 1);
                prefab.updateMatrixWorld(true);

                // 디버그: 도로 타일의 객체 이름 로그
                if (category === 'road' || category === 'road4lane') {
                    const names = [];
                    prefab.traverse((c) => { if (c.name) names.push(c.name); });
                    console.log(`[Road] ${category}/${key || 'base'} objects:`, names.slice(0, 20).join(', '));
                }

                prefab.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // 모든 material을 MeshLambertMaterial로 강제 교체 (조명 반응)
                        const convertMaterial = (mat) => {
                            return new THREE.MeshLambertMaterial({
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                                map: mat.map || null,
                                transparent: mat.transparent || false,
                                opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                            });
                        };

                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(m => convertMaterial(m));
                        } else {
                            child.material = convertMaterial(child.material);
                        }
                    }
                });

                const box0 = new THREE.Box3().setFromObject(prefab);
                const size0 = new THREE.Vector3();
                box0.getSize(size0);

                // 4차선 도로는 2x2 타일에 맞게 스케일, 나머지는 1x1 타일
                const targetSize = (category === 'road4lane') ? TILE_SIZE * 2 : TILE_SIZE;
                const s = targetSize / Math.max(size0.x, size0.z);
                prefab.scale.setScalar(s);
                prefab.updateMatrixWorld(true);

                const box = new THREE.Box3().setFromObject(prefab);

                if (key) {
                    tilePrefabs[category][key] = prefab;
                    tileMinY[category][key] = box.min.y;
                    // 도로 센터 오프셋 계산
                    if (roadCenterOffset[key]) {
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        roadCenterOffset[key].set(center.x, 0, center.z);
                    }
                    // 4차선 도로 센터 오프셋 계산
                    if (road4laneCenterOffset[key]) {
                        const center = new THREE.Vector3();
                        box.getCenter(center);
                        road4laneCenterOffset[key].set(center.x, 0, center.z);
                    }
                } else {
                    tilePrefabs[category] = prefab;
                    tileMinY[category] = box.min.y;
                }

                resolve();
            }, undefined, (err) => {
                console.warn(`Failed to load tile: ${category}/${key || 'base'}`, err);
                resolve(); // 실패해도 계속 진행
            });
        });
    }

    // 도로 전용 로드 함수 (하위 호환)
    async function loadRoadPrefabFitToTile(key, url) {
        return loadTilePrefab('road', key, url);
    }

    // 모든 타일 모델 로딩
    await Promise.all([
        // 잔디 타일
        loadTilePrefab('grass', null, TILE_MODELS.grass),
        // 다리 타일
        loadTilePrefab('bridge', null, TILE_MODELS.bridge),
        // 도로 타일 (2차로)
        loadTilePrefab('road', 'straight', TILE_MODELS.road.straight),
        loadTilePrefab('road', 'corner', TILE_MODELS.road.corner),
        loadTilePrefab('road', 't', TILE_MODELS.road.t),
        loadTilePrefab('road', 'cross', TILE_MODELS.road.cross),
        // 4차로 도로 타일
        loadTilePrefab('road4lane', 'straight', TILE_MODELS.road4lane.straight),
        loadTilePrefab('road4lane', 'corner', TILE_MODELS.road4lane.corner),
        loadTilePrefab('road4lane', 't', TILE_MODELS.road4lane.t),
        loadTilePrefab('road4lane', 'cross', TILE_MODELS.road4lane.cross),
        // 4차선 2차선 연결용 모델
        loadTilePrefab('road4lane', 'straight_side_full', TILE_MODELS.road4lane.straight_side_full),
        loadTilePrefab('road4lane', 'straight_side_single', TILE_MODELS.road4lane.straight_side_single),
        loadTilePrefab('road4lane', 'straight_side_single_reversed', TILE_MODELS.road4lane.straight_side_single_reversed),
        loadTilePrefab('road4lane', 'straight_side_corner', TILE_MODELS.road4lane.straight_side_corner),
        loadTilePrefab('road4lane', 'straight_side_corner_reversed', TILE_MODELS.road4lane.straight_side_corner_reversed),
        loadTilePrefab('road4lane', 'straight_both_sides', TILE_MODELS.road4lane.straight_both_sides),
        // 수로 타일
        loadTilePrefab('water', 'straight', TILE_MODELS.water.straight),
        loadTilePrefab('water', 'corner', TILE_MODELS.water.corner),
        loadTilePrefab('water', 't', TILE_MODELS.water.t),
        loadTilePrefab('water', 'cross', TILE_MODELS.water.cross),
    ]);

    // 나무 모델 로딩 (별도 처리 - 배열에 저장)
    async function loadTreePrefabs() {
        const treePromises = TILE_MODELS.trees.map((url, index) => {
            return new Promise((resolve) => {
                loader.load(url, (gltf) => {
                    const prefab = gltf.scene;
                    // 나무 스케일 조정 (타일 크기에 맞게)
                    prefab.scale.setScalar(0.8);  // 나무 크기 조정
                    prefab.updateMatrixWorld(true);

                    prefab.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            // Lambert 재질로 변환
                            const convertMaterial = (mat) => {
                                return new THREE.MeshLambertMaterial({
                                    color: mat.color ? mat.color.clone() : new THREE.Color(0x228B22),
                                    map: mat.map || null,
                                    transparent: mat.transparent || false,
                                    opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                    side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                                });
                            };
                            if (Array.isArray(child.material)) {
                                child.material = child.material.map(m => convertMaterial(m));
                            } else {
                                child.material = convertMaterial(child.material);
                            }
                        }
                    });

                    tilePrefabs.trees[index] = prefab;
                    console.log(`[Trees] Loaded tree model ${index}: ${url}`);
                    resolve();
                }, undefined, (err) => {
                    console.warn(`[Trees] Failed to load tree: ${url}`, err);
                    resolve();
                });
            });
        });
        await Promise.all(treePromises);
        console.log(`[Trees] All tree models loaded: ${tilePrefabs.trees.filter(t => t).length}/${TILE_MODELS.trees.length}`);
    }

    // 나무 모델 로딩 실행
    await loadTreePrefabs();

    /* =========================================================
     * DIRECTION & ROAD VARIANTS
     * ========================================================= */
    const DIR = {
        N: { dx: 0, dy: -1, bit: 1 },
        E: { dx: 1, dy: 0,  bit: 2 },
        S: { dx: 0, dy: 1,  bit: 4 },
        W: { dx: -1,dy: 0,  bit: 8 },
    };

    function inBounds(x, y) {
        return x >= 0 && y >= 0 && x < GRID_W && y < GRID_H;
    }

    function isAnyRoad(x, y) {
        if (!inBounds(x, y)) return false;
        return isRoad(x, y);
    }

    function getRoadMask(x, y) {
        if (!isAnyRoad(x, y)) return 0;
        let m = 0;
        if (isAnyRoad(x + DIR.N.dx, y + DIR.N.dy)) m |= DIR.N.bit;
        if (isAnyRoad(x + DIR.E.dx, y + DIR.E.dy)) m |= DIR.E.bit;
        if (isAnyRoad(x + DIR.S.dx, y + DIR.S.dy)) m |= DIR.S.bit;
        if (isAnyRoad(x + DIR.W.dx, y + DIR.W.dy)) m |= DIR.W.bit;
        return m;
    }

    function pickRoadVariant(mask) {
        const count =
            ((mask & 1) ? 1 : 0) +
            ((mask & 2) ? 1 : 0) +
            ((mask & 4) ? 1 : 0) +
            ((mask & 8) ? 1 : 0);

        if (count <= 1) {
            const rot = (mask === 2 || mask === 8) ? Math.PI : Math.PI / 2;
            return { key: "straight", rotY: rot };
        }
        if (count === 4) return { key: "cross", rotY: 0 };
        if (count === 3) {
            // T자: 180도 회전 적용
            if (!(mask & 4)) return { key: "t", rotY: Math.PI };      // 남쪽 없음
            if (!(mask & 2)) return { key: "t", rotY: -Math.PI / 2 }; // 동쪽 없음
            if (!(mask & 1)) return { key: "t", rotY: 0 };            // 북쪽 없음
            if (!(mask & 8)) return { key: "t", rotY: Math.PI / 2 };  // 서쪽 없음
        }
        if (count === 2) {
            if (mask === 10) return { key: "straight", rotY: 0 };
            if (mask === 5) return { key: "straight", rotY: Math.PI / 2 };
            // 커브: N=1, E=2, S=4, W=8
            if (mask === 3)  return { key:"corner", rotY: 0 };           // N+E
            if (mask === 6)  return { key:"corner", rotY: -Math.PI/2 };  // S+E
            if (mask === 12) return { key:"corner", rotY: Math.PI };     // S+W
            if (mask === 9)  return { key:"corner", rotY: Math.PI/2 };   // N+W
        }
        return { key: "straight", rotY: 0 };
    }

    // 수로용 변형 선택 (직선 90도 추가 회전, 커브 반대)
    function pickWaterVariant(mask) {
        const count =
            ((mask & 1) ? 1 : 0) +
            ((mask & 2) ? 1 : 0) +
            ((mask & 4) ? 1 : 0) +
            ((mask & 8) ? 1 : 0);

        if (count <= 1) {
            // 수로 직선: 90도 추가 회전
            const rot = (mask === 2 || mask === 8) ? Math.PI / 2 : 0;
            return { key: "straight", rotY: rot };
        }
        if (count === 4) return { key: "cross", rotY: 0 };
        if (count === 3) {
            // 수로 T자: 180도 회전 적용
            if (!(mask & 4)) return { key: "t", rotY: Math.PI / 2 };   // 남쪽 없음
            if (!(mask & 2)) return { key: "t", rotY: Math.PI };       // 동쪽 없음
            if (!(mask & 1)) return { key: "t", rotY: -Math.PI / 2 };  // 북쪽 없음
            if (!(mask & 8)) return { key: "t", rotY: 0 };             // 서쪽 없음
        }
        if (count === 2) {
            // 수로 직선: 90도 추가 회전
            if (mask === 10) return { key: "straight", rotY: Math.PI / 2 };
            if (mask === 5) return { key: "straight", rotY: 0 };
            // 수로 커브 (원본)
            if (mask === 9)  return { key:"corner", rotY: Math.PI };
            if (mask === 12) return { key:"corner", rotY: -Math.PI/2 };
            if (mask === 6)  return { key:"corner", rotY: 0 };
            if (mask === 3)  return { key:"corner", rotY: Math.PI/2 };
        }
        return { key: "straight", rotY: Math.PI / 2 };
    }

    /* =========================================================
     * THREE.JS SETUP
     * ========================================================= */
    // 캐시된 렌더러 rect (성능 최적화 - resize에서 업데이트)
    let cachedRendererRect = null;

    const scene = new THREE.Scene();

    // ===== SKYBOX SYSTEM (낮/일출일몰/밤 3단계 블렌딩) =====
    const cubeTextureLoader = new THREE.CubeTextureLoader();
    const skyboxPath = '/textures/ExtractedSkybox/';

    // 낮 스카이박스 (SunlessCirruscover4k)
    const daySkybox = cubeTextureLoader.load([
        skyboxPath + 'SunlessCirruscover4k_px.png',
        skyboxPath + 'SunlessCirruscover4k_nx.png',
        skyboxPath + 'SunlessCirruscover4k_py.png',
        skyboxPath + 'SunlessCirruscover4k_ny.png',
        skyboxPath + 'SunlessCirruscover4k_pz.png',
        skyboxPath + 'SunlessCirruscover4k_nz.png',
    ]);

    // 일출/일몰 스카이박스 (CloudedSunGlow4k)
    const sunsetSkybox = cubeTextureLoader.load([
        skyboxPath + 'CloudedSunGlow4k_px.png',
        skyboxPath + 'CloudedSunGlow4k_nx.png',
        skyboxPath + 'CloudedSunGlow4k_py.png',
        skyboxPath + 'CloudedSunGlow4k_ny.png',
        skyboxPath + 'CloudedSunGlow4k_pz.png',
        skyboxPath + 'CloudedSunGlow4k_nz.png',
    ]);

    // 밤 스카이박스 (CoriolisNight4k)
    const nightSkybox = cubeTextureLoader.load([
        skyboxPath + 'CoriolisNight4k_px.png',
        skyboxPath + 'CoriolisNight4k_nx.png',
        skyboxPath + 'CoriolisNight4k_py.png',
        skyboxPath + 'CoriolisNight4k_ny.png',
        skyboxPath + 'CoriolisNight4k_pz.png',
        skyboxPath + 'CoriolisNight4k_nz.png',
    ]);

    // 커스텀 스카이박스 셰이더 (3개 큐브맵 블렌딩: 낮 ↔ 일출/일몰 ↔ 밤)
    const skyboxBlendShader = {
        uniforms: {
            tCubeDay: { value: daySkybox },
            tCubeSunset: { value: sunsetSkybox },
            tCubeNight: { value: nightSkybox },
            tBlendDaySunset: { value: 0.0 },  // 0 = 낮, 1 = 일출/일몰
            tBlendSunsetNight: { value: 0.0 } // 0 = 일출/일몰, 1 = 밤
        },
        vertexShader: `
            varying vec3 vWorldDirection;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldDirection = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                gl_Position.z = gl_Position.w;
            }
        `,
        fragmentShader: `
            uniform samplerCube tCubeDay;
            uniform samplerCube tCubeSunset;
            uniform samplerCube tCubeNight;
            uniform float tBlendDaySunset;
            uniform float tBlendSunsetNight;
            varying vec3 vWorldDirection;

            void main() {
                vec3 direction = normalize(vWorldDirection);

                vec4 dayColor = textureCube(tCubeDay, direction);
                vec4 sunsetColor = textureCube(tCubeSunset, direction);
                vec4 nightColor = textureCube(tCubeNight, direction);

                // 3단계 블렌딩: 낮 → 일몰 → 밤
                // tBlendDaySunset: 낮(0) ↔ 일출/일몰(1)
                // tBlendSunsetNight: 일출/일몰(0) ↔ 밤(1)
                vec4 daySunsetMix = mix(dayColor, sunsetColor, tBlendDaySunset);
                vec4 finalColor = mix(daySunsetMix, nightColor, tBlendSunsetNight);

                gl_FragColor = finalColor;
            }
        `
    };

    // 스카이박스 메쉬 생성
    const skyboxGeometry = new THREE.BoxGeometry(10000, 10000, 10000);
    const skyboxMaterial = new THREE.ShaderMaterial({
        uniforms: skyboxBlendShader.uniforms,
        vertexShader: skyboxBlendShader.vertexShader,
        fragmentShader: skyboxBlendShader.fragmentShader,
        side: THREE.BackSide,
        depthWrite: false
    });
    const skyboxMesh = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
    scene.add(skyboxMesh);

    // 초기 환경맵 설정 (건물/차량 반사용)
    scene.environment = daySkybox;

    // 스카이박스 블렌드 상태
    let skyboxBlendDaySunset = 0;     // 0 = 낮, 1 = 일몰
    let skyboxBlendSunsetNight = 0;   // 0 = 일몰, 1 = 밤
    let targetBlendDaySunset = 0;
    let targetBlendSunsetNight = 0;

    // Three.quarks 파티클 렌더러 초기화
    const batchRenderer = new BatchedParticleRenderer();
    scene.add(batchRenderer);

    // 파티클 애니메이션용 Clock
    const particleClock = new THREE.Clock();

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // Tone Mapping - 화사한 룩
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;  // 더 밝게

    // 그림자 렌더링 활성화 (향상된 설정)
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // 부드러운 그림자

    // 원근 투영 카메라 설정 (Perspective)
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE.PerspectiveCamera(65, aspect, 0.1, 500);
    // 초기 위치
    const CAMERA_START = { x: 30, y: 30, z: 30 };
    const CAMERA_END = { x: 15, y: 15, z: 15 };
    camera.position.set(CAMERA_START.x, CAMERA_START.y, CAMERA_START.z);
    camera.updateProjectionMatrix();

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 0.1;   // 최소 거리 (가까이)
    controls.maxDistance = 80;   // 최대 거리 (멀리)
    controls.enableZoom = false;  // 기본 줌 비활성화, 커스텀 줌 사용
    controls.enablePan = false;   // 기본 팬 비활성화, 커스텀 팬 사용
    controls.panSpeed = 0.8;
    controls.rotateSpeed = 0.5;
    controls.target.set(0, 0, 0);
    controls.enabled = false; // 애니메이션 중 컨트롤 비활성화

    // 카메라 각도 제한 (minPolarAngle은 updateCameraPolarAngle에서 동적으로 조절)
    controls.minPolarAngle = 10 * Math.PI / 180;  // 초기 최소 각도 (10도 - 동적 조절됨)
    controls.maxPolarAngle = 89 * Math.PI / 180; // 최대 각도 (89도)

    // 마우스 버튼 설정: 좌클릭=회전, 우클릭=커스텀 팬
    controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: null  // 커스텀 핸들링
    };
    // 터치 제스처 설정
    controls.touches = {
        ONE: THREE.TOUCH.ROTATE,
        TWO: THREE.TOUCH.DOLLY_PAN
    };
    controls.update();

    // ===== 커스텀 카메라 이동 (지면 기준) - 우클릭 =====
    let isRightDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    const panSensitivity = 0.002;  // 감도 낮춤
    let isPanEnabled = true;  // 건설 모드에서 비활성화용

    renderer.domElement.addEventListener('mousedown', (e) => {
        if (e.button === 2 && !cameraIntroActive && isPanEnabled) {  // 우클릭
            isRightDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
        if (!isRightDragging || !controls.enabled || !isPanEnabled) return;

        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;

        // 카메라의 수평 방향 벡터 계산 (Y축 회전만 고려)
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);

        // 지면에 투영된 전방 벡터 (Y=0)
        const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
        // 오른쪽 벡터 (전방과 Y축의 외적)
        const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();

        // 현재 카메라 거리에 따른 이동 속도 조절 (멀수록 빠르게)
        const cameraDistance = camera.position.distanceTo(controls.target);
        const zoomFactor = cameraDistance / 20;  // 거리 기준 속도 조절
        const speedFactor = zoomFactor * panSensitivity * 15;

        // 마우스 드래그 방향과 같은 방향으로 이동 (반전)
        const moveX = deltaX * speedFactor;
        const moveZ = deltaY * speedFactor;

        // 지면 기준으로 이동 (오른쪽/왼쪽 + 전방/후방)
        const offset = new THREE.Vector3();
        offset.addScaledVector(right, moveX);
        offset.addScaledVector(forward, moveZ);

        camera.position.add(offset);
        controls.target.add(offset);
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
        if (e.button === 2) {
            isRightDragging = false;
        }
    });

    renderer.domElement.addEventListener('mouseleave', () => {
        isRightDragging = false;
    });

    // 우클릭 컨텍스트 메뉴 방지
    renderer.domElement.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });

    // ===== 그래픽 품질 설정 =====
    const GRAPHICS_SETTINGS = {
        bloomEnabled: true,         // Bloom 효과 활성화 (false시 GPU 부하 감소)
        bloomResolutionScale: 0.35, // Bloom 해상도 (0.5→0.35 최적화)
        tiltShiftEnabled: true,     // 틸트-시프트 미니어처 효과
        shadowMapEnabled: true,     // 그림자 (renderer.shadowMap)
    };

    // 그래픽 품질 토글 함수 (개발자 패널/설정에서 호출)
    window.toggleBloom = function(enabled) {
        GRAPHICS_SETTINGS.bloomEnabled = enabled;
        bloomPass.enabled = enabled;
        console.log(`[Graphics] Bloom: ${enabled ? 'ON' : 'OFF'}`);
    };

    window.toggleTiltShift = function(enabled) {
        GRAPHICS_SETTINGS.tiltShiftEnabled = enabled;
        tiltShiftPass.enabled = enabled;
        console.log(`[Graphics] TiltShift: ${enabled ? 'ON' : 'OFF'}`);
    };

    // ===== POST-PROCESSING 설정 =====
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // Bloom 효과 (빛 번짐) - 야간 조명/네온 효과용
    // 해상도를 더 낮춰 성능 최적화 (0.5→0.35)
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(
            Math.floor(window.innerWidth * GRAPHICS_SETTINGS.bloomResolutionScale),
            Math.floor(window.innerHeight * GRAPHICS_SETTINGS.bloomResolutionScale)
        ),
        0.25,   // strength - 블룸 강도 (0.3→0.25 최적화)
        0.3,    // radius - 블룸 반경 (0.4→0.3 최적화)
        0.9     // threshold - 밝기 임계값 (0.85→0.9 더 밝은 부분만)
    );
    bloomPass.enabled = GRAPHICS_SETTINGS.bloomEnabled;
    composer.addPass(bloomPass);

    // 색상 보정 패스 (채도, 밝기, 대비 향상)
    const colorCorrectionPass = new ShaderPass(ColorCorrectionShader);
    composer.addPass(colorCorrectionPass);

    // 틸트-시프트 패스 (미니어처 효과)
    const tiltShiftPass = new ShaderPass(TiltShiftShader);
    tiltShiftPass.enabled = GRAPHICS_SETTINGS.tiltShiftEnabled;
    composer.addPass(tiltShiftPass);

    // Output Pass (최종 출력)
    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // 블룸 설정을 시간대별로 조절하기 위한 변수
    let currentBloomStrength = 0.25;
    let targetBloomStrength = 0.25;

    // ===== 안개 효과 (대기 원근감) =====
    // 낮: 연한 하늘색 안개, 밤: 짙은 파란 안개
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.008);  // 지수 안개

    // 커스텀 부드러운 휠 줌 (원근 카메라용 - 카메라 거리 조절)
    let targetCameraDistance = camera.position.distanceTo(controls.target);
    renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();

        // 설치 모드에서는 휠 줌 비활성화
        if (isPlacementMode(currentMode)) {
            return;
        }

        // 원근 카메라 줌 (카메라 거리 조절)
        const zoomSpeed = 3;  // 줌 속도
        const delta = e.deltaY > 0 ? 1 : -1;  // 스크롤 방향 (위로=확대=가까이)
        const MIN_ZOOM_DISTANCE = 0.1;  // 최소 거리 하드 리밋
        targetCameraDistance = Math.max(
            MIN_ZOOM_DISTANCE,
            Math.min(controls.maxDistance, targetCameraDistance + delta * zoomSpeed)
        );
    }, { passive: false });

    // 부드러운 줌 애니메이션 (원근 카메라용)
    function updateSmoothZoom() {
        const currentDistance = camera.position.distanceTo(controls.target);
        const diff = targetCameraDistance - currentDistance;
        if (Math.abs(diff) > 0.01) {
            // 카메라를 타겟 방향으로 이동
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            const newDistance = currentDistance + diff * 0.1;  // 보간 속도
            camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
        }

        // 틸트-시프트 효과 업데이트 (가까울수록 강해짐)
        const zoomLevel = 1 - (currentDistance - controls.minDistance) / (controls.maxDistance - controls.minDistance);
        updateTiltShiftEffect(zoomLevel);

        // 카메라 각도 제한 업데이트 (줌인 시 수직 방지)
        updateCameraPolarAngle(currentDistance);
    }

    // 카메라 거리에 따른 동적 polar angle 제한 (최대 줌인 시 수직 방지)
    function updateCameraPolarAngle(cameraDistance) {
        const MIN_DISTANCE_FOR_ANGLE = 0.5;   // 이 거리 이하에서 각도 제한 시작
        const MAX_DISTANCE_FOR_ANGLE = 10.0;  // 이 거리 이상에서 각도 제한 없음
        const MIN_POLAR_CLOSE = 60 * Math.PI / 180;  // 가까울 때 최소 polar angle (60도)
        const MIN_POLAR_FAR = 10 * Math.PI / 180;    // 멀 때 최소 polar angle (10도)

        if (cameraDistance <= MAX_DISTANCE_FOR_ANGLE) {
            // 10에서 0.5로 갈수록 최소 각도가 10도에서 60도로 증가
            const t = Math.max(0, Math.min(1, (MAX_DISTANCE_FOR_ANGLE - cameraDistance) / (MAX_DISTANCE_FOR_ANGLE - MIN_DISTANCE_FOR_ANGLE)));
            const dynamicMinPolar = MIN_POLAR_FAR + t * (MIN_POLAR_CLOSE - MIN_POLAR_FAR);
            controls.minPolarAngle = dynamicMinPolar;
        } else {
            controls.minPolarAngle = MIN_POLAR_FAR;
        }
    }

    // 틸트-시프트 (미니어처) 효과 업데이트
    // 줌 레벨이 높을수록(가까울수록) 블러가 진해짐
    function updateTiltShiftEffect(zoomLevel) {
        const BLUR_THRESHOLD = 0.3;  // 이 줌 레벨 이하일 때만 블러 적용
        const MAX_BLUR = 0.35;       // 최대 블러 강도

        let blurStrength = 0;
        let focusRange = 0.5;

        if (zoomLevel <= BLUR_THRESHOLD) {
            // 줌아웃할수록 블러 강해짐 (미니어처 효과)
            const normalized = 1 - (zoomLevel / BLUR_THRESHOLD);  // 0~1 (0.3에서 0, 0에서 1)
            blurStrength = normalized * MAX_BLUR;
            focusRange = 0.5 - normalized * 0.2;  // 멀어질수록 초점 범위 좁아짐
            tiltShiftPass.uniforms.focusCenter.value = 0.5;  // 중앙 초점
        } else {
            // 줌인하면 블러 없음
            blurStrength = 0;
            focusRange = 0.5;
            tiltShiftPass.uniforms.focusCenter.value = 0.5;
        }

        tiltShiftPass.uniforms.blurAmount.value = blurStrength;
        tiltShiftPass.uniforms.focusRange.value = focusRange;
    }

    // 카메라 줌인 애니메이션
    let cameraIntroActive = false;
    let cameraIntroStart = 0;
    let cameraRestoredFromSave = false;  // 저장된 카메라 상태가 복원되었는지 여부
    const CAMERA_INTRO_DURATION = 2000; // 2초

    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    function startCameraIntro() {
        cameraIntroActive = true;
        cameraIntroStart = performance.now();
    }

    function updateCameraIntro() {
        if (!cameraIntroActive) return;

        const elapsed = performance.now() - cameraIntroStart;
        const progress = Math.min(elapsed / CAMERA_INTRO_DURATION, 1);
        const eased = easeOutCubic(progress);

        // 위치 애니메이션 (원근 카메라)
        camera.position.x = CAMERA_START.x + (CAMERA_END.x - CAMERA_START.x) * eased;
        camera.position.y = CAMERA_START.y + (CAMERA_END.y - CAMERA_START.y) * eased;
        camera.position.z = CAMERA_START.z + (CAMERA_END.z - CAMERA_START.z) * eased;

        if (progress >= 1) {
            cameraIntroActive = false;
            controls.enabled = true; // 애니메이션 끝나면 컨트롤 활성화
            // 카메라 거리를 현재 거리로 동기화
            targetCameraDistance = camera.position.distanceTo(controls.target);
        }
    }

    // 카메라 이동 제한 함수 (맵 범위 내, 땅 위)
    function clampCameraPosition() {
        // 맵 범위 계산 (여유 공간 포함)
        const mapPadding = 5;  // 맵 가장자리 여유
        const halfW = (GRID_W * TILE_SIZE) / 2 + mapPadding;
        const halfH = (GRID_H * TILE_SIZE) / 2 + mapPadding;

        // 카메라 타겟 위치 제한 (맵 범위 내)
        controls.target.x = Math.max(-halfW, Math.min(halfW, controls.target.x));
        controls.target.z = Math.max(-halfH, Math.min(halfH, controls.target.z));
        controls.target.y = Math.max(0, controls.target.y);  // 땅 아래로 못 감

        // 카메라 위치도 땅 아래로 못 가게 (최소 높이 1)
        if (camera.position.y < 1) {
            camera.position.y = 1;
        }

        // 카메라가 맵 범위를 너무 벗어나지 않도록 제한
        const maxCameraDistance = halfW * 2;
        camera.position.x = Math.max(-maxCameraDistance, Math.min(maxCameraDistance, camera.position.x));
        camera.position.z = Math.max(-maxCameraDistance, Math.min(maxCameraDistance, camera.position.z));
    }

    // 조명 시스템 (낮/밤 전환 지원) - 대비감 강화
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);  // 약하게 (그림자 대비 강화)
    scene.add(hemiLight);

    const dir = new THREE.DirectionalLight(0xffffff, 2.5);  // 더 밝게 (그림자 강조)
    dir.position.set(25, 40, 25);  // 낮은 각도로 (그림자 더 길게)

    // 그림자 설정 - 선명한 그림자
    dir.castShadow = true;
    dir.shadow.mapSize.width = 4096;
    dir.shadow.mapSize.height = 4096;
    dir.shadow.camera.near = 0.5;
    dir.shadow.camera.far = 150;
    dir.shadow.camera.left = -60;
    dir.shadow.camera.right = 60;
    dir.shadow.camera.top = 60;
    dir.shadow.camera.bottom = -60;
    dir.shadow.bias = -0.0003;
    dir.shadow.normalBias = 0.005;
    dir.shadow.radius = 1;  // 그림자 선명도 (1=선명)

    scene.add(dir);

    // 밤하늘 ambient light (달빛 효과)
    const nightAmbient = new THREE.AmbientLight(0x4466aa, 0.4);
    scene.add(nightAmbient);

    /* =========================================================
     * TIME CYCLE SYSTEM (12분 = 1일)
     * ========================================================= */
    const TIME_CONFIG = {
        dayDurationMs: 12 * 60 * 1000,  // 12분 = 1일 (720,000ms)
        startHour: 6,                    // 시작 시간 (오전 6시)
    };

    const timeState = {
        gameTime: 6 * 3600,  // 현재 게임 시간 (초 단위, 6:00 AM 시작)
        gameDay: 1,          // 현재 게임 일수
        speed: 1,            // 게임 속도 (0=정지, 1=보통, 2=빠름, 4=매우빠름)
        lastUpdate: Date.now(),
    };

    // 가로등 조명 배열 (밤에 켜짐)
    const streetLights = [];

    // UI 요소
    const clockDisplay = document.getElementById('clockDisplay');
    const dateDisplay = document.getElementById('dateDisplay');
    const btnSpeed1 = document.getElementById('btnSpeed1');
    const btnSpeed2 = document.getElementById('btnSpeed2');
    const btnSpeed3 = document.getElementById('btnSpeed3');
    const btnDayNight = document.getElementById('btnDayNight');

    // 시간을 HH:MM 형식으로 변환
    function formatGameTime(seconds) {
        const hours = Math.floor(seconds / 3600) % 24;
        const minutes = Math.floor((seconds % 3600) / 60);
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    }

    // 게임 속도 설정
    function setGameSpeed(speed) {
        timeState.speed = speed;
        timeState.lastUpdate = Date.now();

        // 버튼 상태 업데이트
        if (btnSpeed1) btnSpeed1.classList.toggle('active', speed === 1);
        if (btnSpeed2) btnSpeed2.classList.toggle('active', speed === 2);
        if (btnSpeed3) btnSpeed3.classList.toggle('active', speed === 3);
    }

    // 속도 버튼 이벤트
    if (btnSpeed1) btnSpeed1.addEventListener('click', () => setGameSpeed(1));
    if (btnSpeed2) btnSpeed2.addEventListener('click', () => setGameSpeed(2));
    if (btnSpeed3) btnSpeed3.addEventListener('click', () => setGameSpeed(3));
    if (btnDayNight) btnDayNight.addEventListener('click', toggleDayNight);

    // ===== BGM 시스템 =====
    const btnBgm = document.getElementById('btnBgm');
    const bgmVolumeSlider = document.getElementById('bgmVolume');
    const bgmAudio = new Audio(encodeURI('/mp3/SimCity Soundtrack (Full) [5GCoc893Vt8].mp3'));
    bgmAudio.loop = true;
    bgmAudio.volume = 0.3;  // 기본 볼륨 30%
    let isBgmPlaying = false;

    function toggleBgm() {
        if (isBgmPlaying) {
            bgmAudio.pause();
            isBgmPlaying = false;
            btnBgm.textContent = '🔇';
            btnBgm.classList.remove('playing');
        } else {
            bgmAudio.play().then(() => {
                isBgmPlaying = true;
                btnBgm.textContent = '🔊';
                btnBgm.classList.add('playing');
            }).catch(err => {
                console.warn('BGM 재생 실패:', err);
                toast({ title: 'BGM 오류', desc: '재생 실패 - 페이지를 클릭 후 다시 시도하세요' });
            });
        }
    }

    function setBgmVolume(value) {
        const volume = value / 100;
        bgmAudio.volume = volume;
        // 볼륨 슬라이더 그라데이션 업데이트
        if (bgmVolumeSlider) {
            bgmVolumeSlider.style.background = `linear-gradient(to right, #4caf50 ${value}%, #ddd ${value}%)`;
        }
        // 볼륨에 따라 아이콘 변경
        if (isBgmPlaying) {
            if (volume === 0) {
                btnBgm.textContent = '🔇';
            } else if (volume < 0.5) {
                btnBgm.textContent = '🔉';
            } else {
                btnBgm.textContent = '🔊';
            }
        }
    }

    if (btnBgm) {
        btnBgm.addEventListener('click', toggleBgm);
    }

    if (bgmVolumeSlider) {
        bgmVolumeSlider.addEventListener('input', (e) => setBgmVolume(e.target.value));
        // 초기 그라데이션 설정
        setBgmVolume(bgmVolumeSlider.value);
    }

    // BGM 자동 재생 (첫 사용자 상호작용 후)
    let bgmAutoPlayAttempted = false;
    function tryAutoPlayBgm() {
        if (bgmAutoPlayAttempted || isBgmPlaying) return;
        bgmAutoPlayAttempted = true;

        bgmAudio.play().then(() => {
            isBgmPlaying = true;
            if (btnBgm) {
                btnBgm.textContent = '🔊';
                btnBgm.classList.add('playing');
            }
            console.log('[BGM] Auto-play started');
        }).catch(err => {
            console.warn('[BGM] Auto-play failed:', err);
            bgmAutoPlayAttempted = false;  // 다음 상호작용에서 재시도
        });
    }

    // 첫 사용자 상호작용 시 BGM 자동 재생
    const autoPlayEvents = ['click', 'keydown', 'touchstart'];
    function onFirstInteraction() {
        tryAutoPlayBgm();
        // 한 번만 실행 후 이벤트 리스너 제거
        autoPlayEvents.forEach(evt => {
            document.removeEventListener(evt, onFirstInteraction);
        });
    }
    autoPlayEvents.forEach(evt => {
        document.addEventListener(evt, onFirstInteraction, { once: false });
    });

    // 키프레임 기반 환경 설정 (부드러운 보간)
    // nightAmbientIntensity: 달빛 강도 (밤에 높음, 낮에 낮음)
    // bloomStrength: 0으로 설정 - bloom 대신 실제 PointLight/SpotLight 사용
    const ENV_KEYFRAMES = [
        { hour: 0,  background: 0x2a3545, hemiIntensity: 0.65, hemiSkyColor: 0x6a7590, hemiGroundColor: 0x3a4555, dirIntensity: 0.55, dirColor: 0x99aacc, sunAngle: -20, exposure: 1.15, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x3a4555, fogDensity: 0.006, nightAmbientIntensity: 0.85 },
        { hour: 5,  background: 0x3a4555, hemiIntensity: 0.60, hemiSkyColor: 0x6a7590, hemiGroundColor: 0x3a4555, dirIntensity: 0.50, dirColor: 0x99aacc, sunAngle: -15, exposure: 1.1, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x3a4555, fogDensity: 0.006, nightAmbientIntensity: 0.75 },
        { hour: 6,  background: 0xffa070, hemiIntensity: 0.5, hemiSkyColor: 0xffccaa, hemiGroundColor: 0x665544, dirIntensity: 0.8, dirColor: 0xff8844, sunAngle: 5, exposure: 0.95, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0xffa080, fogDensity: 0.006, nightAmbientIntensity: 0.25 },
        { hour: 8,  background: 0x87ceeb, hemiIntensity: 0.85, hemiSkyColor: 0xaaddff, hemiGroundColor: 0x667755, dirIntensity: 1.8, dirColor: 0xfffaf0, sunAngle: 35, exposure: 1.2, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x87ceeb, fogDensity: 0.004, nightAmbientIntensity: 0.05 },
        { hour: 12, background: 0x9ed8f8, hemiIntensity: 1.0, hemiSkyColor: 0xaaddff, hemiGroundColor: 0x778866, dirIntensity: 2.2, dirColor: 0xffffff, sunAngle: 80, exposure: 1.3, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x9ed8f8, fogDensity: 0.003, nightAmbientIntensity: 0.05 },
        { hour: 16, background: 0x87ceeb, hemiIntensity: 0.85, hemiSkyColor: 0xaaddff, hemiGroundColor: 0x667755, dirIntensity: 1.8, dirColor: 0xfff8e0, sunAngle: 40, exposure: 1.2, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x87ceeb, fogDensity: 0.004, nightAmbientIntensity: 0.05 },
        { hour: 18, background: 0xff9966, hemiIntensity: 0.6, hemiSkyColor: 0xffaa77, hemiGroundColor: 0x554433, dirIntensity: 1.2, dirColor: 0xff6622, sunAngle: 10, exposure: 1.05, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0xcc6644, fogDensity: 0.008, nightAmbientIntensity: 0.15 },
        { hour: 20, background: 0x665566, hemiIntensity: 0.45, hemiSkyColor: 0x665577, hemiGroundColor: 0x554455, dirIntensity: 0.35, dirColor: 0x886688, sunAngle: -10, exposure: 0.95, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x554455, fogDensity: 0.009, nightAmbientIntensity: 0.55 },
        { hour: 22, background: 0x2a3545, hemiIntensity: 0.65, hemiSkyColor: 0x6a7590, hemiGroundColor: 0x3a4555, dirIntensity: 0.55, dirColor: 0x99aacc, sunAngle: -20, exposure: 1.15, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x3a4555, fogDensity: 0.006, nightAmbientIntensity: 0.85 },
        { hour: 24, background: 0x2a3545, hemiIntensity: 0.65, hemiSkyColor: 0x6a7590, hemiGroundColor: 0x3a4555, dirIntensity: 0.55, dirColor: 0x99aacc, sunAngle: -20, exposure: 1.15, bloomStrength: 0, bloomThreshold: 0.9, fogColor: 0x3a4555, fogDensity: 0.006, nightAmbientIntensity: 0.85 },
    ];

    // 색상 보간 함수
    function lerpColor(color1, color2, t) {
        const c1 = new THREE.Color(color1);
        const c2 = new THREE.Color(color2);
        return c1.lerp(c2, Math.max(0, Math.min(1, t))).getHex();
    }

    // 숫자 보간 함수
    function lerpValue(v1, v2, t) {
        return v1 + (v2 - v1) * t;
    }

    // 키프레임 기반 환경 설정 (부드러운 RGB 보간)
    function getTimeOfDayConfig(hour) {
        // 현재 시간에 해당하는 키프레임 구간 찾기
        let prev = ENV_KEYFRAMES[ENV_KEYFRAMES.length - 2];
        let next = ENV_KEYFRAMES[0];

        for (let i = 0; i < ENV_KEYFRAMES.length - 1; i++) {
            if (hour >= ENV_KEYFRAMES[i].hour && hour < ENV_KEYFRAMES[i + 1].hour) {
                prev = ENV_KEYFRAMES[i];
                next = ENV_KEYFRAMES[i + 1];
                break;
            }
        }

        // 보간 비율 계산
        const duration = next.hour - prev.hour;
        const t = duration > 0 ? (hour - prev.hour) / duration : 0;

        // 모든 값 부드럽게 보간
        return {
            background: lerpColor(prev.background, next.background, t),
            hemiIntensity: lerpValue(prev.hemiIntensity, next.hemiIntensity, t),
            hemiSkyColor: lerpColor(prev.hemiSkyColor, next.hemiSkyColor, t),
            hemiGroundColor: lerpColor(prev.hemiGroundColor, next.hemiGroundColor, t),
            dirIntensity: lerpValue(prev.dirIntensity, next.dirIntensity, t),
            dirColor: lerpColor(prev.dirColor, next.dirColor, t),
            sunAngle: lerpValue(prev.sunAngle, next.sunAngle, t),
            exposure: lerpValue(prev.exposure, next.exposure, t),
            bloomStrength: lerpValue(prev.bloomStrength, next.bloomStrength, t),
            bloomThreshold: lerpValue(prev.bloomThreshold, next.bloomThreshold, t),
            fogColor: lerpColor(prev.fogColor, next.fogColor, t),
            fogDensity: lerpValue(prev.fogDensity, next.fogDensity, t),
            nightAmbientIntensity: lerpValue(prev.nightAmbientIntensity, next.nightAmbientIntensity, t),
        };
    }

    // 환경 업데이트 (시네마틱)
    function updateEnvironment() {
        const hour = (timeState.gameTime / 3600) % 24;
        const config = getTimeOfDayConfig(hour);
        const isNight = hour >= 20 || hour < 5;
        const isStreetLightTime = hour >= 18 || hour < 6;  // 가로등은 18시부터 켜짐

        // ===== SKYBOX 3단계 블렌딩 (낮 ↔ 일출/일몰 ↔ 밤) =====
        // MegaSun(낮), FluffballDay(일출/일몰), CosmicCoolCloud(밤)
        // tBlendDaySunset: 낮(0) ↔ 일출/일몰(1)
        // tBlendSunsetNight: 일출/일몰(0) ↔ 밤(1)

        if (hour >= 7 && hour < 17) {
            // 낮 (07:00 ~ 17:00)
            targetBlendDaySunset = 0;
            targetBlendSunsetNight = 0;
        } else if (hour >= 17 && hour < 18.5) {
            // 낮 → 일몰 전환 (17:00 ~ 18:30)
            targetBlendDaySunset = (hour - 17) / 1.5;  // 0 → 1
            targetBlendSunsetNight = 0;
        } else if (hour >= 18.5 && hour < 20) {
            // 일몰 → 밤 전환 (18:30 ~ 20:00)
            targetBlendDaySunset = 1;
            targetBlendSunsetNight = (hour - 18.5) / 1.5;  // 0 → 1
        } else if (hour >= 20 || hour < 5) {
            // 밤 (20:00 ~ 05:00)
            targetBlendDaySunset = 1;
            targetBlendSunsetNight = 1;
        } else if (hour >= 5 && hour < 6) {
            // 밤 → 일출 전환 (05:00 ~ 06:00)
            targetBlendDaySunset = 1;
            targetBlendSunsetNight = 1 - (hour - 5);  // 1 → 0
        } else {
            // 일출 → 낮 전환 (06:00 ~ 07:00)
            targetBlendDaySunset = 1 - (hour - 6);  // 1 → 0
            targetBlendSunsetNight = 0;
        }

        // 부드러운 블렌드 전환
        skyboxBlendDaySunset += (targetBlendDaySunset - skyboxBlendDaySunset) * 0.02;
        skyboxBlendSunsetNight += (targetBlendSunsetNight - skyboxBlendSunsetNight) * 0.02;

        // 스카이박스 셰이더 블렌드 값 업데이트 (Zone 모드가 아닐 때만)
        if (!isZoneModeActive) {
            skyboxMaterial.uniforms.tBlendDaySunset.value = skyboxBlendDaySunset;
            skyboxMaterial.uniforms.tBlendSunsetNight.value = skyboxBlendSunsetNight;
            skyboxMesh.visible = true;

            // 환경맵도 현재 상태에 따라 전환
            if (skyboxBlendSunsetNight > 0.5) {
                scene.environment = nightSkybox;
            } else if (skyboxBlendDaySunset > 0.5) {
                scene.environment = sunsetSkybox;
            } else {
                scene.environment = daySkybox;
            }
        }

        // 태양 위치 계산 (DirectionalLight용)
        const sunAngleRad = THREE.MathUtils.degToRad(config.sunAngle);
        const azimuthRad = THREE.MathUtils.degToRad((hour - 6) * 15);
        const sunDistance = 50;

        // 주변광 (하늘/지면 색상 포함)
        hemiLight.intensity = config.hemiIntensity;
        if (config.hemiSkyColor) hemiLight.color.setHex(config.hemiSkyColor);
        if (config.hemiGroundColor) hemiLight.groundColor.setHex(config.hemiGroundColor);

        // 태양광 (Directional Light)
        dir.intensity = config.dirIntensity;
        dir.color.setHex(config.dirColor);

        // 태양 위치 계산
        dir.position.set(
            Math.cos(azimuthRad) * Math.cos(sunAngleRad) * sunDistance,
            Math.sin(sunAngleRad) * sunDistance,
            Math.sin(azimuthRad) * Math.cos(sunAngleRad) * sunDistance
        );

        // 밤 ambient (달빛 효과 - 부드러운 보간)
        nightAmbient.intensity = config.nightAmbientIntensity;

        // Tone Mapping Exposure (밝기 조절)
        if (config.exposure !== undefined) {
            renderer.toneMappingExposure = config.exposure;
        }

        // Bloom 설정 (부드러운 전환)
        if (config.bloomStrength !== undefined) {
            targetBloomStrength = config.bloomStrength;
        }
        if (config.bloomThreshold !== undefined) {
            bloomPass.threshold = config.bloomThreshold;
        }
        // 부드러운 블룸 전환
        currentBloomStrength += (targetBloomStrength - currentBloomStrength) * 0.05;
        bloomPass.strength = currentBloomStrength;

        // 안개 설정
        if (config.fogColor !== undefined) {
            scene.fog.color.setHex(config.fogColor);
        }
        if (config.fogDensity !== undefined) {
            scene.fog.density = config.fogDensity;
        }

        // 야간 건물 발광 업데이트
        updateBuildingEmissive(isNight);

        // 가로등 조명 업데이트 (18시부터)
        updateStreetLights(isStreetLightTime);

        // 시간대별 오브젝트 색감 적용 (수치 모드 및 배치 모드가 아닐 때만)
        if (!isZoneModeActive && !isPlacementModeActive) {
            updateSceneColorTint(hour, isNight);
        }

        // UI 업데이트
        if (clockDisplay) clockDisplay.textContent = formatGameTime(timeState.gameTime);
        if (dateDisplay) dateDisplay.textContent = i18n.t('game.day', { day: timeState.gameDay });

        // 밤/낮 버튼 아이콘 업데이트
        if (btnDayNight) {
            const isNight = hour >= 20 || hour < 6;
            const icon = btnDayNight.querySelector('.icon');
            const label = btnDayNight.querySelector('.label');
            if (icon) icon.textContent = isNight ? '☀️' : '🌙';
            if (label) label.textContent = isNight ? i18n.t('toolbar.day') : i18n.t('toolbar.night');
        }
    }

    // 가로등 조명 켜기/끄기 (LOD 시스템)
    let lastStreetLightState = null;
    const MAX_ACTIVE_STREET_LIGHTS = 30;  // 동시 활성화 PointLight 최대 개수
    const STREET_LIGHT_LOD_DISTANCE = 15;  // PointLight 활성화 거리

    function updateStreetLights(isStreetLightTime) {
        // 모든 가로등 emissive 업데이트 (상태 변경 시에만)
        if (lastStreetLightState !== isStreetLightTime) {
            lastStreetLightState = isStreetLightTime;
            console.log(`[StreetLights] isStreetLightTime: ${isStreetLightTime}, count: ${streetLights.length}`);

            streetLights.forEach(item => {
                if (item.mesh && item.mesh.material && item.mesh.material.emissive) {
                    if (isStreetLightTime) {
                        item.mesh.material.emissive.setHex(0xffffaa);
                        item.mesh.material.emissiveIntensity = 3.0;
                    } else {
                        item.mesh.material.emissiveIntensity = 0;
                    }
                }
            });
        }

        // PointLight LOD 업데이트 (밤에만)
        if (isStreetLightTime && streetLights.length > 0) {
            updateStreetLightLOD();
        } else {
            // 낮에는 모든 PointLight 끄기
            streetLights.forEach(item => {
                if (item.pointLight) {
                    item.pointLight.visible = false;
                }
            });
        }
    }

    // 카메라 근처 가로등만 PointLight 활성화 (LOD)
    let streetLightLODLogOnce = false;
    function updateStreetLightLOD() {
        if (!streetLightLODLogOnce && streetLights.length > 0) {
            console.log(`[StreetLightLOD] Total street lights: ${streetLights.length}`);
            streetLightLODLogOnce = true;
        }
        const cameraPos = camera.position;
        const maxDistSq = STREET_LIGHT_LOD_DISTANCE * STREET_LIGHT_LOD_DISTANCE;

        // 거리 계산 및 정렬
        const lightsWithDist = [];
        for (const item of streetLights) {
            if (!item.mesh) continue;

            // worldPos가 없으면 초기화
            if (!item.worldPos) {
                item.worldPos = new THREE.Vector3();
            }

            // PointLight가 없으면 동적 생성
            if (!item.pointLight) {
                const pointLight = new THREE.PointLight(0xffffaa, 0.8, 3);
                pointLight.castShadow = false;
                pointLight.visible = false;
                item.mesh.add(pointLight);
                pointLight.position.set(0, 0.1, 0);
                item.pointLight = pointLight;
            }

            // 월드 좌표 업데이트
            item.mesh.getWorldPosition(item.worldPos);
            const distSq = item.worldPos.distanceToSquared(cameraPos);
            item.distSq = distSq;

            if (distSq < maxDistSq) {
                lightsWithDist.push(item);
            } else {
                // 범위 밖은 끄기
                item.pointLight.visible = false;
            }
        }

        // 거리순 정렬하여 가까운 것 우선 활성화
        lightsWithDist.sort((a, b) => a.distSq - b.distSq);

        // 최대 개수만큼 활성화
        for (let i = 0; i < lightsWithDist.length; i++) {
            const item = lightsWithDist[i];
            if (i < MAX_ACTIVE_STREET_LIGHTS) {
                item.pointLight.visible = true;
            } else {
                item.pointLight.visible = false;
            }
        }
    }

    // 야간 건물 발광 효과 - 비활성화 (성능 최적화)
    function updateBuildingEmissive(isNight) {
        // 발광 효과 비활성화
    }

    // 시간대별 오브젝트 색감 적용
    let lastColorTintHour = -1;
    const originalObjectColors = new Map();

    function updateSceneColorTint(hour, isNight) {
        // 1시간 단위로만 업데이트 (성능 최적화)
        const hourInt = Math.floor(hour);
        if (hourInt === lastColorTintHour) return;
        lastColorTintHour = hourInt;

        // 시간대별 색조 계산
        let tintColor;
        let tintIntensity;

        if (hour >= 5 && hour < 7) {
            // 일출 - 따뜻한 주황빛
            tintColor = new THREE.Color(0xffddaa);
            tintIntensity = 0.15;
        } else if (hour >= 7 && hour < 17) {
            // 낮 - 자연색
            tintColor = new THREE.Color(0xffffff);
            tintIntensity = 0;
        } else if (hour >= 17 && hour < 20) {
            // 일몰 - 주황/빨간빛
            const t = (hour - 17) / 3;
            tintColor = new THREE.Color().lerpColors(
                new THREE.Color(0xffffff),
                new THREE.Color(0xff8866),
                t
            );
            tintIntensity = t * 0.2;
        } else if (hour >= 20 && hour < 22) {
            // 박명 - 일몰에서 밤으로 부드러운 전환
            const t = (hour - 20) / 2;
            tintColor = new THREE.Color().lerpColors(
                new THREE.Color(0xff8866),
                new THREE.Color(0x6688aa),
                t
            );
            tintIntensity = 0.2 + t * 0.15;
        } else {
            // 밤 - 파란빛
            tintColor = new THREE.Color(0x6688aa);
            tintIntensity = 0.35;
        }

        // 초원, 수로, 건물, 차량에 색조 적용 (지연 참조)
        const getGroups = () => {
            const result = [];
            if (typeof grassGroup !== 'undefined' && grassGroup) result.push(grassGroup);
            if (typeof waterGroup !== 'undefined' && waterGroup) result.push(waterGroup);
            if (typeof buildingGroup !== 'undefined' && buildingGroup) result.push(buildingGroup);
            // 차량 그룹도 포함
            if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
                result.push(trafficManager.vehicleGroup);
            }
            return result;
        };

        const groups = getGroups();
        groups.forEach(group => {
            group.traverse((child) => {
                if (child.isMesh && child.material) {
                    // 폐건물인지 확인 - 폐건물은 색상 변경 안함
                    let parentObj = child;
                    while (parentObj.parent && !parentObj.userData?.isAbandoned) {
                        parentObj = parentObj.parent;
                    }
                    if (parentObj.userData?.isAbandoned) return;

                    const materials = Array.isArray(child.material) ? child.material : [child.material];

                    materials.forEach(mat => {
                        // color 속성이 있는 모든 머티리얼에 적용 (타입 체크 완화)
                        if (!mat.color || typeof mat.color.lerp !== 'function') return;

                        // 원본 색상 저장
                        if (!originalObjectColors.has(mat.uuid)) {
                            originalObjectColors.set(mat.uuid, mat.color.clone());
                        }

                        // 색조 적용
                        if (tintIntensity > 0) {
                            const original = originalObjectColors.get(mat.uuid);
                            mat.color.copy(original).lerp(tintColor, tintIntensity);
                        } else {
                            const original = originalObjectColors.get(mat.uuid);
                            if (original) mat.color.copy(original);
                        }
                    });
                }
            });
        });
    }

    // 시간 진행
    function updateGameTime() {
        const now = Date.now();
        const deltaMs = now - timeState.lastUpdate;
        timeState.lastUpdate = now;

        if (timeState.speed === 0) return;

        // 실제 시간 -> 게임 시간 변환
        // 12분(720초) = 24시간(86400초)
        // 1 실제초 = 120 게임초
        const gameSecondsPerRealMs = 86400 / TIME_CONFIG.dayDurationMs;
        const deltaGameSeconds = deltaMs * gameSecondsPerRealMs * timeState.speed;

        timeState.gameTime += deltaGameSeconds;

        // 하루가 지났으면
        if (timeState.gameTime >= 86400) {
            timeState.gameTime -= 86400;
            timeState.gameDay++;
        }

        updateEnvironment();
    }

    // 시간 점프 (낮/밤 전환)
    function toggleDayNight() {
        const hour = (timeState.gameTime / 3600) % 24;
        if (hour >= 6 && hour < 20) {
            // 낮이면 -> 밤 (21시)
            timeState.gameTime = 21 * 3600;
        } else {
            // 밤이면 -> 낮 (9시)
            timeState.gameTime = 9 * 3600;
        }
        updateEnvironment();
    }

    // 전역 함수로 등록
    window.toggleDayNight = toggleDayNight;
    window.setGameSpeed = setGameSpeed;

    // 초기 환경 설정은 INIT 섹션에서 호출

    /* =========================================================
     * GRID DATA
     * ========================================================= */
    const CELL = {
        EMPTY: 0,           // 빈 땅 (잔디)
        ROAD: 1,            // 도로
        LOCKED_ROAD: 2,     // 잠긴 도로
        // 주거 건물 (시민 자동 생성) - 서버에서만 사용
        RESIDENTIAL_LOW: 3,
        RESIDENTIAL_MID: 4,
        RESIDENTIAL_HIGH: 5,
        // 상업/공업 건물 (시민 자동 생성) - 서버에서만 사용
        COMMERCIAL_BUILDING: 6,
        INDUSTRIAL_BUILDING: 7,
        // 구역 지정 (플레이어가 지정)
        ZONE_RESIDENTIAL: 8,  // 주거구역 (초록)
        ZONE_COMMERCIAL: 9,   // 상업구역 (파랑)
        ZONE_INDUSTRIAL: 10,  // 공업구역 (노랑)
        // 수로 시스템
        WATER: 11,            // 수로
        BRIDGE: 12,           // 다리 (수로 위 도로)
        // 4차로 도로 시스템
        ROAD_4LANE: 13,       // 4차로 도로
        LOCKED_ROAD_4LANE: 14, // 잠긴 4차로 도로
    };

    // 구역 색상 정의
    const ZONE_COLORS = {
        [CELL.ZONE_RESIDENTIAL]: 0x4ade80,  // 초록
        [CELL.ZONE_COMMERCIAL]: 0x60a5fa,   // 파랑
        [CELL.ZONE_INDUSTRIAL]: 0xfbbf24,   // 노랑
    };

    const ZONE_NAMES = {
        [CELL.ZONE_RESIDENTIAL]: '주거구역',
        [CELL.ZONE_COMMERCIAL]: '상업구역',
        [CELL.ZONE_INDUSTRIAL]: '공업구역',
    };

    // ===== 공사 시스템 =====
    const CONSTRUCTION_STATE = {
        WAITING_VEHICLE: 'waiting_vehicle',  // 차량 대기 중
        UNDER_CONSTRUCTION: 'under_construction',  // 공사 중
        COMPLETED: 'completed'  // 완료
    };

    // 공사 현장 맵 (key: "x,y", value: constructionData)
    const constructionSites = new Map();

    // 공사 소요 시간 (1분 - 테스트용)
    const CONSTRUCTION_DURATION = 60000;

    // ===== 입주 시스템 =====
    // 건물 레벨별 수용 인원 (차량 1대 = 가족 1가구)
    const BUILDING_CAPACITY = {
        // 1x1 건물
        "1x1_low": 2,      // 저층 주거: 2가구
        "1x1_mid": 3,      // 중층 주거: 3가구
        "1x1_high": 4,     // 고층 주거: 4가구
        // 2x2 건물
        "2x2_low": 6,      // 저층 아파트: 6가구
        "2x2_mid": 10,     // 중층 아파트: 10가구
        "2x2_high": 16,    // 고층 아파트: 16가구
    };

    // 입주 대기 맵 (key: "x,y", value: { capacity, movedIn, buildingX, buildingY, size, tier })
    const pendingMoveIns = new Map();
    let lastMoveInSpawnTime = 0;

    // ===== 행복도 시스템 =====
    // 행복도 3단계: 0-33 = 하(low), 34-66 = 중(mid), 67-100 = 상(high)
    const HAPPINESS_THRESHOLDS = {
        LOW: 33,    // 0-33
        MID: 66,    // 34-66
        HIGH: 100   // 67-100
    };

    // 낮은 행복도 지속 시간 추적 (폐건물 전환용)
    const buildingLowHappinessTime = new Map();  // key: "x,y", value: { startTime, abandonTime }
    const ABANDON_HAPPINESS_THRESHOLD = 20;  // 행복도 20 이하일 때만 폐건물 가능
    const MIN_ABANDON_TIME = 30000;  // 최소 30초
    const MAX_ABANDON_TIME = 90000;  // 최대 90초 (랜덤 편차)

    // 시민 한마디 (행복도 & 건물 타입별)
    const CITIZEN_QUOTES = {
        residential: {
            low: [
                "여기서 벗어날 거에요!",
                "이런 곳에서 못 살겠어요...",
                "매일 걱정뿐이에요.",
                "이사 갈 곳을 찾고 있어요."
            ],
            mid: [
                "그럭저럭 살만합니다.",
                "나쁘지 않은 동네예요.",
                "평범한 일상이에요.",
                "조금만 더 좋아지면..."
            ],
            high: [
                "살기 정말 좋은 곳이에요!",
                "이 동네 최고예요!",
                "매일이 행복해요!",
                "이사 올 때 잘한 선택이었어요."
            ],
            // RCI 부족 상황 멘트
            noJobs: [
                "일자리가 없어요!",
                "직장을 구할 수가 없어요.",
                "일할 곳이 부족해요.",
                "취업이 너무 어려워요."
            ]
        },
        commercial: {
            low: [
                "손님이 없어요...",
                "폐업을 고민 중이에요.",
                "장사가 안 돼요.",
                "임대료도 못 내겠어요."
            ],
            mid: [
                "그럭저럭 장사하고 있어요.",
                "손님이 좀 있어요.",
                "먹고 살만해요.",
                "조금만 더 번창하면..."
            ],
            high: [
                "장사가 아주 잘됩니다!",
                "손님이 끊이질 않아요!",
                "확장을 고려 중이에요!",
                "매출이 최고예요!"
            ],
            // RCI 부족 상황 멘트
            noWorkers: [
                "일할 사람이 없어요!",
                "직원을 구할 수가 없어요.",
                "인력이 부족해요.",
                "알바생도 못 구해요."
            ],
            noSupply: [
                "납품받을 물건이 없어요!",
                "공급이 부족해요.",
                "공장에서 물건이 안 와요.",
                "재고가 바닥이에요."
            ]
        },
        industrial: {
            low: [
                "주문이 없어요...",
                "공장 가동률이 바닥이에요.",
                "직원들 월급도 걱정이에요.",
                "이러다 문 닫겠어요."
            ],
            mid: [
                "생산량이 적당해요.",
                "그럭저럭 돌아가요.",
                "직원들 괜찮아요.",
                "안정적으로 운영 중이에요."
            ],
            high: [
                "주문이 밀려요!",
                "풀가동 중이에요!",
                "직원 더 뽑아야겠어요!",
                "사업이 번창하고 있어요!"
            ],
            // RCI 부족 상황 멘트
            noWorkers: [
                "일할 사람이 없어요!",
                "직원을 구할 수가 없어요.",
                "인력이 부족해요.",
                "생산라인 가동이 어려워요."
            ],
            noShops: [
                "납품할 매장이 없어요!",
                "물건을 팔 곳이 없어요.",
                "상점이 부족해요.",
                "재고가 쌓여가요."
            ]
        }
    };

    // ===== 행복도 효과 원인 시스템 =====
    // 효과 타입 정의
    const HAPPINESS_EFFECT_TYPES = {
        // 서비스 시설 버프 (긍정)
        POLICE: 'police',       // 경찰서
        FIRE: 'fire',           // 소방서
        SCHOOL: 'school',       // 학교
        PARK: 'park',           // 공원
        HOSPITAL: 'hospital',   // 병원
        // RCI 부족 너프 (부정)
        NO_JOBS: 'noJobs',           // 일자리 부족
        NO_WORKERS: 'noWorkers',     // 일할 사람 부족
        NO_SUPPLY: 'noSupply',       // 물건 공급 부족
        NO_SHOPS: 'noShops',         // 납품 매장 부족
        // 기타
        LOW_LAND_VALUE: 'lowLandValue',  // 낮은 땅값
        NONE: 'none'                      // 효과 없음
    };

    // 효과 타입별 시민 멘트
    const EFFECT_QUOTES = {
        // 서비스 시설 버프 멘트
        police: [
            "경찰서가 옆에 있어 든든해요!",
            "치안이 좋아서 안심이에요.",
            "밤에도 안전하게 다닐 수 있어요!",
            "범죄 걱정이 없어요."
        ],
        fire: [
            "소방서가 가까워서 안심이에요!",
            "화재 걱정이 없어요.",
            "소방관 아저씨들 덕분에 안전해요!",
            "비상시 빠른 대응이 가능해요."
        ],
        school: [
            "좋은 학교가 근처에 있어요!",
            "아이들 교육 걱정이 없어요.",
            "교육 환경이 훌륭해요!",
            "학군이 좋아서 만족해요."
        ],
        park: [
            "공원에서 산책하기 좋아요!",
            "녹지가 많아서 쾌적해요.",
            "공원 덕분에 여유로워요!",
            "자연과 가까워서 행복해요."
        ],
        hospital: [
            "병원이 가까워서 안심이에요!",
            "의료 시설이 잘 갖춰져 있어요.",
            "건강 관리하기 좋은 동네예요!",
            "응급 상황에도 걱정 없어요."
        ],
        // RCI 부족 너프 멘트
        noJobs: [
            "일자리가 부족해요!",
            "직장을 구하기 어려워요.",
            "취업이 너무 힘들어요.",
            "일할 곳이 없어요."
        ],
        noWorkers: [
            "일할 사람이 없어요!",
            "직원을 구할 수가 없어요.",
            "인력이 부족해요.",
            "사람을 못 구하겠어요."
        ],
        noSupply: [
            "물건 공급이 부족해요!",
            "납품받을 물건이 없어요.",
            "공장에서 물건이 안 와요.",
            "재고가 바닥이에요."
        ],
        noShops: [
            "납품할 매장이 부족해요!",
            "물건을 팔 곳이 없어요.",
            "상점이 부족해요.",
            "생산품이 쌓여가요."
        ],
        // 기타
        lowLandValue: [
            "이 지역은 좀 낙후됐어요.",
            "주변 환경이 별로예요.",
            "개발이 필요한 지역이에요.",
            "인프라가 부족해요."
        ]
    };

    // 건물별 현재 적용 중인 주요 효과 (가장 최근 또는 가장 큰 효과)
    const buildingHappinessEffect = new Map();  // key: "x,y", value: { type: string, value: number, isPositive: boolean }

    // ===== RCI 부족 시스템 =====
    // 부족 영향을 받는 건물 목록 (랜덤 선정)
    const rciShortageAffectedBuildings = {
        residential: new Set(),  // 주민 부족 → 상업/산업 영향
        commercial: new Set(),   // 상업 부족 → 주거/산업 영향
        industrial: new Set()    // 산업 부족 → 주거/상업 영향
    };

    // 부족 상황 저장 (건물별로 어떤 부족의 영향을 받는지)
    const buildingShortageEffect = new Map();  // key: "x,y", value: { type: 'noJobs'|'noWorkers'|'noSupply'|'noShops', penalty: number }

    const RCI_SHORTAGE_PENALTY = 30;  // 부족 시 행복도 감소량 (고정)
    const RCI_SHORTAGE_UPDATE_INTERVAL = 10000;  // 10초마다 영향 건물 재선정
    let lastRCIShortageUpdate = 0;

    /**
     * RCI 부족에 따른 영향 건물 선정 및 업데이트
     * - 주민(R) 부족: 상업/산업 건물에 영향 (일할 사람이 없어요)
     * - 상업(C) 부족: 주거(일자리 부족), 산업(납품 매장 부족)에 영향
     * - 산업(I) 부족: 주거(일자리 부족), 상업(물건 공급 부족)에 영향
     */
    function updateRCIShortageEffects() {
        const now = Date.now();
        if (now - lastRCIShortageUpdate < RCI_SHORTAGE_UPDATE_INTERVAL) return;
        lastRCIShortageUpdate = now;

        // 이전 영향 초기화
        buildingShortageEffect.clear();

        if (typeof placedBuildings === 'undefined' || typeof cityStats === 'undefined') return;

        // 건물을 타입별로 분류
        const buildingsByType = {
            residential: [],
            commercial: [],
            industrial: []
        };

        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const userData = building.instance?.userData;
            if (!userData || userData.isAbandoned) continue;

            const zoneType = userData.zoneType || '';
            if (zoneType.includes('resident')) {
                buildingsByType.residential.push({ key, x: building.x, y: building.y });
            } else if (zoneType.includes('commercial')) {
                buildingsByType.commercial.push({ key, x: building.x, y: building.y });
            } else if (zoneType.includes('industrial')) {
                buildingsByType.industrial.push({ key, x: building.x, y: building.y });
            }
        }

        // RCI 수요 확인 (음수 = 해당 구역 부족)
        const rDemand = cityStats.residentialDemand || 0;  // 양수: 주거 필요, 음수: 주거 과잉
        const cDemand = cityStats.commercialDemand || 0;
        const iDemand = cityStats.industrialDemand || 0;

        // 부족량을 영향받는 건물 수로 변환 (부족 10당 건물 1개)
        const shortageToBuildingCount = (shortage) => Math.max(0, Math.floor(Math.abs(shortage) / 10));

        // 1. 주민(R) 부족 (rDemand > 0 = 주민이 더 필요) → 상업/산업에 영향
        if (rDemand > 0) {
            const affectedCount = shortageToBuildingCount(rDemand);

            // 상업 건물 영향 (일할 사람이 없어요)
            const commercialToAffect = shuffleArray([...buildingsByType.commercial]).slice(0, Math.ceil(affectedCount / 2));
            commercialToAffect.forEach(b => {
                buildingShortageEffect.set(b.key, { type: 'noWorkers', penalty: RCI_SHORTAGE_PENALTY });
            });

            // 산업 건물 영향 (일할 사람이 없어요)
            const industrialToAffect = shuffleArray([...buildingsByType.industrial]).slice(0, Math.ceil(affectedCount / 2));
            industrialToAffect.forEach(b => {
                buildingShortageEffect.set(b.key, { type: 'noWorkers', penalty: RCI_SHORTAGE_PENALTY });
            });
        }

        // 2. 상업(C) 부족 (cDemand > 0 = 상점이 더 필요) → 주거(일자리)/산업(납품처)에 영향
        if (cDemand > 0) {
            const affectedCount = shortageToBuildingCount(cDemand);

            // 주거 건물 영향 (일자리 부족)
            const residentialToAffect = shuffleArray([...buildingsByType.residential]).slice(0, Math.ceil(affectedCount / 2));
            residentialToAffect.forEach(b => {
                if (!buildingShortageEffect.has(b.key)) {
                    buildingShortageEffect.set(b.key, { type: 'noJobs', penalty: RCI_SHORTAGE_PENALTY });
                }
            });

            // 산업 건물 영향 (납품 매장 부족)
            const industrialToAffect = shuffleArray([...buildingsByType.industrial]).slice(0, Math.ceil(affectedCount / 2));
            industrialToAffect.forEach(b => {
                if (!buildingShortageEffect.has(b.key)) {
                    buildingShortageEffect.set(b.key, { type: 'noShops', penalty: RCI_SHORTAGE_PENALTY });
                }
            });
        }

        // 3. 산업(I) 부족 (iDemand > 0 = 공장이 더 필요) → 주거(일자리)/상업(물건 공급)에 영향
        if (iDemand > 0) {
            const affectedCount = shortageToBuildingCount(iDemand);

            // 주거 건물 영향 (일자리 부족)
            const residentialToAffect = shuffleArray([...buildingsByType.residential]).slice(0, Math.ceil(affectedCount / 2));
            residentialToAffect.forEach(b => {
                if (!buildingShortageEffect.has(b.key)) {
                    buildingShortageEffect.set(b.key, { type: 'noJobs', penalty: RCI_SHORTAGE_PENALTY });
                }
            });

            // 상업 건물 영향 (물건 공급 부족)
            const commercialToAffect = shuffleArray([...buildingsByType.commercial]).slice(0, Math.ceil(affectedCount / 2));
            commercialToAffect.forEach(b => {
                if (!buildingShortageEffect.has(b.key)) {
                    buildingShortageEffect.set(b.key, { type: 'noSupply', penalty: RCI_SHORTAGE_PENALTY });
                }
            });
        }
    }

    // 배열 섞기 (Fisher-Yates)
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // 건물별 행복도 계산
    function calculateBuildingHappiness(x, y) {
        // 땅값 기반 행복도 계산 (서비스 시설 영향 + 폐건물 페널티)
        const totalLandValue = typeof getTotalLandValue === 'function' ? getTotalLandValue(x, y) : 0;

        // 땅값을 행복도로 변환 (0 ~ 200 → 0 ~ 100 스케일)
        // 땅값 0 = 행복도 30, 땅값 100 = 행복도 80
        let happiness = 30 + totalLandValue * 0.5;

        // RCI 부족 페널티 적용
        const key = `${x},${y}`;
        const shortageEffect = buildingShortageEffect.get(key);
        if (shortageEffect) {
            happiness -= shortageEffect.penalty;
        }

        // 세금 페널티 적용 (세금율에 비례해 행복도 감소)
        // 기본 세금율 10%에서 페널티 없음, 20%면 최대 -20 페널티
        if (typeof budgetSystem !== 'undefined') {
            const avgTaxRate = (budgetSystem.taxRates.residential +
                               budgetSystem.taxRates.commercial +
                               budgetSystem.taxRates.industrial) / 3;
            // 10% 초과분에 대해 2배의 페널티 (10% = 0, 15% = -10, 20% = -20)
            const taxPenalty = Math.max(0, (avgTaxRate - 10) * 2);
            happiness -= taxPenalty;
        }

        return Math.round(Math.max(0, Math.min(100, happiness)));
    }

    // 세금 페널티 계산 (UI 표시용)
    function getTaxHappinessPenalty() {
        if (typeof budgetSystem === 'undefined') return 0;
        const avgTaxRate = (budgetSystem.taxRates.residential +
                           budgetSystem.taxRates.commercial +
                           budgetSystem.taxRates.industrial) / 3;
        return Math.round(Math.max(0, (avgTaxRate - 10) * 2));
    }

    // 건물의 RCI 부족 영향 상태 가져오기
    function getBuildingShortageEffect(x, y) {
        const key = `${x},${y}`;
        return buildingShortageEffect.get(key) || null;
    }

    // 행복도 레벨 문자열 반환
    function getHappinessLevel(happiness) {
        if (happiness <= HAPPINESS_THRESHOLDS.LOW) return 'low';
        if (happiness <= HAPPINESS_THRESHOLDS.MID) return 'mid';
        return 'high';
    }

    // 행복도 레벨 한글 반환
    function getHappinessLevelText(level) {
        switch (level) {
            case 'low': return '하';
            case 'mid': return '중';
            case 'high': return '상';
            default: return '중';
        }
    }

    /**
     * 건물의 주요 행복도 효과 분석
     * 가장 큰 영향을 주는 효과를 반환 (너프 우선)
     */
    function analyzeBuildingEffect(x, y) {
        if (x === undefined || y === undefined) return null;

        const effects = [];

        // 1. RCI 부족 너프 체크 (최우선)
        const shortageEffect = getBuildingShortageEffect(x, y);
        if (shortageEffect) {
            effects.push({
                type: shortageEffect.type,
                value: -shortageEffect.penalty,
                isPositive: false
            });
        }

        // 2. 서비스 시설 버프 체크
        if (typeof placedPublicBuildings !== 'undefined') {
            const serviceEffects = {
                police: 0,
                fire: 0,
                school: 0,
                park: 0,
                hospital: 0
            };

            placedPublicBuildings.forEach((building) => {
                if (building.ref) return;

                const config = PUBLIC_BUILDING_MODELS[building.type];
                if (!config) return;

                const bx = building.x;
                const by = building.y;
                const bw = building.width || 2;
                const bd = building.depth || 2;

                // 건물 중심 좌표
                const centerX = bx + bw / 2;
                const centerY = by + bd / 2;

                // 타일 중심과의 거리 계산
                const dx = (x + 0.5) - centerX;
                const dy = (y + 0.5) - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 효과 범위 내에 있으면 버프 계산
                if (distance <= config.effectRadius) {
                    const falloff = 1 - (distance / config.effectRadius);
                    const bonus = config.landValueBonus * falloff;

                    // 건물 타입에 따른 효과 분류
                    const buildingType = building.type.toLowerCase();
                    if (buildingType.includes('police')) {
                        serviceEffects.police += bonus;
                    } else if (buildingType.includes('fire')) {
                        serviceEffects.fire += bonus;
                    } else if (buildingType.includes('school')) {
                        serviceEffects.school += bonus;
                    } else if (buildingType.includes('park')) {
                        serviceEffects.park += bonus;
                    } else if (buildingType.includes('hospital')) {
                        serviceEffects.hospital += bonus;
                    }
                }
            });

            // 가장 큰 서비스 효과 추가
            for (const [service, value] of Object.entries(serviceEffects)) {
                if (value > 0) {
                    effects.push({
                        type: service,
                        value: value,
                        isPositive: true
                    });
                }
            }
        }

        // 3. 낮은 땅값 너프 체크
        const baseLandValue = typeof getLandValue === 'function' ? getLandValue(x, y) : 0;
        if (baseLandValue < -30) {
            effects.push({
                type: 'lowLandValue',
                value: baseLandValue,
                isPositive: false
            });
        }

        // 효과 정렬 (부정적 효과 우선, 그 다음 효과 크기순)
        effects.sort((a, b) => {
            // 부정적 효과 우선
            if (!a.isPositive && b.isPositive) return -1;
            if (a.isPositive && !b.isPositive) return 1;
            // 같은 유형이면 절대값 크기순
            return Math.abs(b.value) - Math.abs(a.value);
        });

        return effects.length > 0 ? effects[0] : null;
    }

    // 시민 한마디 가져오기 (효과 원인 기반)
    function getCitizenQuote(zoneType, happinessLevel, x, y) {
        let type = 'residential';
        if (zoneType.includes('commercial')) type = 'commercial';
        else if (zoneType.includes('industrial')) type = 'industrial';

        // 건물 효과 분석
        if (x !== undefined && y !== undefined) {
            const effect = analyzeBuildingEffect(x, y);
            if (effect) {
                // 효과 타입에 따른 멘트 가져오기
                const effectQuotes = EFFECT_QUOTES[effect.type];
                if (effectQuotes && effectQuotes.length > 0) {
                    return effectQuotes[Math.floor(Math.random() * effectQuotes.length)];
                }
            }
        }

        // 효과가 없으면 기본 행복도 멘트
        const quotes = CITIZEN_QUOTES[type][happinessLevel] || CITIZEN_QUOTES[type].mid;
        return quotes[Math.floor(Math.random() * quotes.length)];
    }

    // ===== 화재 시스템 =====
    // 화재 상태 관리
    const burningBuildings = new Map();  // key: "x,y", value: { startTime, intensity, effects: { flames, smoke } }
    const FIRE_CHECK_INTERVAL = 10000;    // 10초마다 화재 발생 체크
    const FIRE_BASE_CHANCE = 0.001;       // 기본 화재 발생 확률 0.1%
    const FIRE_INDUSTRIAL_MULTIPLIER = 3; // 공장 화재 확률 3배
    const FIRE_SPREAD_CHANCE = 0.1;       // 인접 건물 화재 전파 확률 10%
    const FIRE_DURATION = 60000;          // 화재 지속 시간 60초 (소방서 없을 때)
    const FIRE_SUPPRESS_RATE = 0.8;       // 소방서 범위 내 진압 속도 80% 빠름
    let lastFireCheck = 0;

    // ===== 일일 통계 시스템 =====
    const dailyStats = {
        // 화재 통계
        fire: {
            totalFires: 0,              // 하루에 발생한 화재
            extinguishedFires: 0,       // 하루에 진압한 화재
            hazmatFires: 0,             // 하루에 진압한 위험물 화재 (공장)
            burnedBuildings: 0,         // 하루에 불에 탄 건물
            lastReset: Date.now()
        },
        // 범죄 통계
        crime: {
            totalCrimes: 0,             // 하루에 발생한 범죄
            arrestedCriminals: 0,       // 하루에 체포한 범죄자
            escapedCriminals: 0,        // 잡히지 않은 범죄자
            lastReset: Date.now()
        },
        // 의료 통계
        medical: {
            totalEmergencies: 0,        // 하루에 발생한 응급환자
            savedPatients: 0,           // 하루에 구조한 환자
            deadPatients: 0,            // 하루에 사망한 환자
            dischargedPatients: 0,      // 하루에 퇴원한 환자
            lastReset: Date.now()
        },
        // 경고 임계치
        thresholds: {
            burnedBuildings: 3,         // 전소 건물 경고 임계치
            escapedCriminals: 5,        // 도주 범죄자 경고 임계치
            deadPatients: 3             // 사망 환자 경고 임계치
        },
        // 경고 발송 여부 (중복 방지)
        warningsSent: {
            fire: false,
            crime: false,
            medical: false
        }
    };

    // 일일 통계 리셋 (게임 내 하루 기준)
    function resetDailyStats(type) {
        if (type === 'fire' || type === 'all') {
            dailyStats.fire.totalFires = 0;
            dailyStats.fire.extinguishedFires = 0;
            dailyStats.fire.hazmatFires = 0;
            dailyStats.fire.burnedBuildings = 0;
            dailyStats.fire.lastReset = Date.now();
            dailyStats.warningsSent.fire = false;
        }
        if (type === 'crime' || type === 'all') {
            dailyStats.crime.totalCrimes = 0;
            dailyStats.crime.arrestedCriminals = 0;
            dailyStats.crime.escapedCriminals = 0;
            dailyStats.crime.lastReset = Date.now();
            dailyStats.warningsSent.crime = false;
        }
        if (type === 'medical' || type === 'all') {
            dailyStats.medical.totalEmergencies = 0;
            dailyStats.medical.savedPatients = 0;
            dailyStats.medical.deadPatients = 0;
            dailyStats.medical.dischargedPatients = 0;
            dailyStats.medical.lastReset = Date.now();
            dailyStats.warningsSent.medical = false;
        }
    }

    // 통계 패널 업데이트
    function updateDailyStatsPanel() {
        // 화재 통계 패널
        const fireStatsPanel = document.getElementById('fireStatsPanel');
        if (fireStatsPanel && fireStatsPanel.style.display !== 'none') {
            document.getElementById('statBurnedBuildings').textContent = dailyStats.fire.burnedBuildings;
            document.getElementById('statExtinguishedFires').textContent = dailyStats.fire.extinguishedFires;
            document.getElementById('statTotalFires').textContent = dailyStats.fire.totalFires;
            document.getElementById('statHazmatFires').textContent = dailyStats.fire.hazmatFires;
        }

        // 범죄 통계 패널
        const crimeStatsPanel = document.getElementById('crimeStatsPanel');
        if (crimeStatsPanel && crimeStatsPanel.style.display !== 'none') {
            document.getElementById('statTotalCrimes').textContent = dailyStats.crime.totalCrimes;
            document.getElementById('statEscapedCriminals').textContent = dailyStats.crime.escapedCriminals;
            document.getElementById('statArrestedCriminals').textContent = dailyStats.crime.arrestedCriminals;
            document.getElementById('statPrisoners').textContent = getTotalPrisoners();
        }

        // 의료 통계 패널
        const medicalStatsPanel = document.getElementById('medicalStatsPanel');
        if (medicalStatsPanel && medicalStatsPanel.style.display !== 'none') {
            document.getElementById('statTotalEmergencies').textContent = dailyStats.medical.totalEmergencies;
            document.getElementById('statSavedPatients').textContent = dailyStats.medical.savedPatients;
            document.getElementById('statDeadPatients').textContent = dailyStats.medical.deadPatients;
            document.getElementById('statHospitalPatients').textContent = getTotalHospitalPatients();
            document.getElementById('statHospitalCapacity').textContent = getTotalHospitalCapacity();
        }
    }

    // 임계치 초과 경고 체크
    function checkDailyStatsWarnings() {
        // 화재 경고 - 전소 건물이 임계치 초과
        if (!dailyStats.warningsSent.fire && dailyStats.fire.burnedBuildings >= dailyStats.thresholds.burnedBuildings) {
            dailyStats.warningsSent.fire = true;
            toast({
                title: '⚠️ 화재 경고!',
                desc: `화재구역에 소방차가 제때 도착하지 못하여 ${dailyStats.fire.burnedBuildings}개 건물이 전소되었습니다. 소방서를 늘리세요!`,
                ms: 8000
            });
        }

        // 범죄 경고 - 도주 범죄자가 임계치 초과
        if (!dailyStats.warningsSent.crime && dailyStats.crime.escapedCriminals >= dailyStats.thresholds.escapedCriminals) {
            dailyStats.warningsSent.crime = true;
            toast({
                title: '⚠️ 치안 경고!',
                desc: `${dailyStats.crime.escapedCriminals}명의 범죄자가 도주했습니다. 경찰서를 늘리거나 감옥 정원을 확인하세요!`,
                ms: 8000
            });
        }

        // 의료 경고 - 사망 환자가 임계치 초과
        if (!dailyStats.warningsSent.medical && dailyStats.medical.deadPatients >= dailyStats.thresholds.deadPatients) {
            dailyStats.warningsSent.medical = true;
            toast({
                title: '⚠️ 의료 경고!',
                desc: `${dailyStats.medical.deadPatients}명의 환자가 제때 치료를 받지 못해 사망했습니다. 병원을 늘리세요!`,
                ms: 8000
            });
        }
    }

    // 화재 파티클 그룹
    const fireEffectsGroup = new THREE.Group();
    fireEffectsGroup.name = 'fireEffects';

    // ===== Three.quarks 화재 텍스처 생성 =====
    const textureLoader = new THREE.TextureLoader();

    // 불꽃 텍스처 (원형 그라데이션)
    function createFireTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 200, 50, 1)');
        gradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const fireTexture = createFireTexture();

    // 연기 텍스처 로드
    const smokeTextureSheet = textureLoader.load('/textures/msVFX_Stylized Smoke 1_Texture.png');
    smokeTextureSheet.colorSpace = THREE.SRGBColorSpace;

    // 연기 텍스처 (단일 프레임용)
    function createSmokeTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
        gradient.addColorStop(0.5, 'rgba(80, 80, 80, 0.5)');
        gradient.addColorStop(1, 'rgba(60, 60, 60, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const smokeTexture = createSmokeTexture();

    // ===== 물 이펙트 텍스처 생성 =====
    function createWaterTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(150, 200, 255, 1)');
        gradient.addColorStop(0.3, 'rgba(100, 180, 255, 0.9)');
        gradient.addColorStop(0.6, 'rgba(50, 150, 255, 0.6)');
        gradient.addColorStop(1, 'rgba(30, 120, 255, 0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const waterTexture = createWaterTexture();

    // 활성 물 이펙트 추적
    const activeWaterEffects = new Map();

    /**
     * 소방차 물 뿌리기 이펙트 생성
     */
    function createWaterSprayEffect(vehicle) {
        if (!vehicle || !vehicle.mesh) return null;

        const waterGroup = new THREE.Group();
        waterGroup.name = `water_spray_${vehicle.id}`;

        // ===== 물줄기 파티클 시스템 =====
        const waterSystem = new ParticleSystem({
            duration: 0,  // 무한 반복
            looping: true,
            startLife: new IntervalValue(0.4, 0.7),
            startSpeed: new IntervalValue(2.5, 4.0),
            startSize: new IntervalValue(0.08, 0.15),
            startRotation: new IntervalValue(0, Math.PI * 2),
            startColor: new RandomColor(
                new THREE.Vector4(0.6, 0.85, 1, 0.9),     // 밝은 하늘색
                new THREE.Vector4(0.4, 0.7, 1, 0.8)       // 파란색
            ),
            emissionOverTime: new ConstantValue(30),  // 60 -> 30 (성능 최적화)
            shape: new ConeEmitter({
                radius: 0.05,
                arc: Math.PI * 2,
                thickness: 0.5,
                angle: Math.PI / 12  // 좁은 원뿔 (물줄기)
            }),
            material: new THREE.MeshBasicMaterial({
                map: waterTexture,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            }),
            renderMode: RenderMode.BillBoard,
            renderOrder: 8,
            worldSpace: true
        });

        // 물줄기 행동 추가
        const waterSizeCurve = new Array(new Array(new Bezier(0.5, 0.8, 1, 0.3), 0));
        waterSystem.addBehavior(new SizeOverLife(new PiecewiseBezier(waterSizeCurve)));

        const waterColorStops = new Array(
            new Array(new THREE.Vector3(0.7, 0.9, 1), 0),
            new Array(new THREE.Vector3(0.5, 0.8, 1), 0.5),
            new Array(new THREE.Vector3(0.3, 0.6, 0.9), 1)
        );
        const waterAlphaStops = new Array(
            new Array(0.8, 0),
            new Array(0.6, 0.5),
            new Array(0, 1)
        );
        waterSystem.addBehavior(new ColorOverLife(new Gradient(waterColorStops, waterAlphaStops)));

        // 중력 효과 (물이 아래로 떨어지게)
        waterSystem.addBehavior(new ForceOverLife(
            new ConstantValue(0),
            new ConstantValue(-3),  // 중력
            new ConstantValue(0)
        ));

        waterSystem.emitter.name = 'water_stream';
        // 소방차 앞쪽 위에서 발사
        waterSystem.emitter.position.set(0, 0.4, 0.3);
        waterSystem.emitter.rotation.set(-Math.PI / 4, 0, 0);  // 45도 각도로 발사

        batchRenderer.addSystem(waterSystem);
        waterGroup.add(waterSystem.emitter);

        // ===== 물방울 튀김 파티클 =====
        const splashSystem = new ParticleSystem({
            duration: 0,
            looping: true,
            startLife: new IntervalValue(0.3, 0.5),
            startSpeed: new IntervalValue(0.5, 1.5),
            startSize: new IntervalValue(0.03, 0.08),
            startRotation: new IntervalValue(0, Math.PI * 2),
            startColor: new RandomColor(
                new THREE.Vector4(0.8, 0.95, 1, 0.7),
                new THREE.Vector4(0.6, 0.85, 1, 0.5)
            ),
            emissionOverTime: new ConstantValue(12),  // 25 -> 12 (성능 최적화)
            shape: new SphereEmitter({
                radius: 0.3,
                arc: Math.PI * 2,
                thickness: 1
            }),
            material: new THREE.MeshBasicMaterial({
                map: waterTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            }),
            renderMode: RenderMode.BillBoard,
            renderOrder: 7,
            worldSpace: true
        });

        const splashSizeCurve = new Array(new Array(new Bezier(1, 0.5, 0.2, 0), 0));
        splashSystem.addBehavior(new SizeOverLife(new PiecewiseBezier(splashSizeCurve)));

        splashSystem.addBehavior(new ForceOverLife(
            new IntervalValue(-0.3, 0.3),
            new ConstantValue(-2),
            new IntervalValue(-0.3, 0.3)
        ));

        splashSystem.emitter.name = 'water_splash';
        // 물이 떨어지는 지점 (소방차 앞 1.5칸)
        splashSystem.emitter.position.set(0, 0.1, 1.2);

        batchRenderer.addSystem(splashSystem);
        waterGroup.add(splashSystem.emitter);

        // 이펙트 데이터 저장
        waterGroup.userData.waterSystem = waterSystem;
        waterGroup.userData.splashSystem = splashSystem;
        waterGroup.userData.vehicleId = vehicle.id;

        return { group: waterGroup, waterSystem, splashSystem };
    }

    /**
     * 소방차에 물 이펙트 시작
     */
    function startWaterEffect(vehicle) {
        if (!vehicle || !vehicle.mesh) return;
        if (activeWaterEffects.has(vehicle.id)) return;  // 이미 이펙트 있음

        const effect = createWaterSprayEffect(vehicle);
        if (!effect) return;

        vehicle.mesh.add(effect.group);
        activeWaterEffects.set(vehicle.id, effect);

        // 화재 건물 방향으로 물줄기 회전
        if (vehicle.fireTarget) {
            const fireWorldX = (ORIGIN_X + vehicle.fireTarget.x + 0.5) * TILE_SIZE;
            const fireWorldZ = (ORIGIN_Z + vehicle.fireTarget.y + 0.5) * TILE_SIZE;

            // 소방차 월드 위치
            const vehicleWorldPos = new THREE.Vector3();
            vehicle.mesh.getWorldPosition(vehicleWorldPos);

            // 화재 방향 계산 (소방차 → 화재)
            const dirX = fireWorldX - vehicleWorldPos.x;
            const dirZ = fireWorldZ - vehicleWorldPos.z;

            // 소방차 메시의 현재 회전값 고려하여 상대 각도 계산
            const fireAngle = Math.atan2(dirX, dirZ);
            const vehicleAngle = vehicle.mesh.rotation.y;
            const relativeAngle = fireAngle - vehicleAngle;

            // 물줄기 그룹을 화재 방향으로 회전
            effect.group.rotation.y = relativeAngle;
        }

        console.log(`[Water] Started water spray effect for firetruck ${vehicle.id}`);
    }

    /**
     * 소방차 물 이펙트 중지
     */
    function stopWaterEffect(vehicle) {
        if (!vehicle) return;

        const effect = activeWaterEffects.get(vehicle.id);
        if (!effect) return;

        // 파티클 시스템 정지 및 제거
        if (effect.waterSystem) {
            effect.waterSystem.emitter.visible = false;
            batchRenderer.deleteSystem(effect.waterSystem);
        }
        if (effect.splashSystem) {
            effect.splashSystem.emitter.visible = false;
            batchRenderer.deleteSystem(effect.splashSystem);
        }

        // 그룹 제거
        if (vehicle.mesh && effect.group.parent === vehicle.mesh) {
            vehicle.mesh.remove(effect.group);
        }

        activeWaterEffects.delete(vehicle.id);

        console.log(`[Water] Stopped water spray effect for firetruck ${vehicle.id}`);
    }

    /**
     * Three.quarks 화재 이펙트 생성 (불꽃 + 연기 + 라이트)
     */
    function createFireEffect(x, y, buildingHeight = 1) {
        const fireGroup = new THREE.Group();
        fireGroup.name = `fire_${x}_${y}`;

        const worldPos = tileToWorldCenter(x, y);

        // ===== 불꽃 파티클 시스템 (Three.quarks) =====
        const flameSystem = new ParticleSystem({
            duration: 0,  // 무한 반복
            looping: true,
            startLife: new IntervalValue(0.3, 0.8),
            startSpeed: new IntervalValue(0.8, 1.5),
            startSize: new IntervalValue(0.15, 0.35),
            startRotation: new IntervalValue(0, Math.PI * 2),
            startColor: new RandomColor(
                new THREE.Vector4(1, 0.9, 0.3, 1),      // 밝은 노랑
                new THREE.Vector4(1, 0.3, 0, 1)         // 주황-빨강
            ),
            emissionOverTime: new ConstantValue(25),  // 40 -> 25 (성능 최적화)
            shape: new ConeEmitter({
                radius: 0.3,
                arc: Math.PI * 2,
                thickness: 1,
                angle: Math.PI / 8  // 좁은 원뿔
            }),
            material: new THREE.MeshBasicMaterial({
                map: fireTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            }),
            renderMode: RenderMode.BillBoard,
            renderOrder: 10,
            worldSpace: false
        });

        // 불꽃 행동 추가 (Thymeleaf 중첩배열 충돌 방지를 위해 Array() 사용)
        const flameSizeCurve = new Array(new Array(new Bezier(1, 0.8, 0.3, 0), 0));
        flameSystem.addBehavior(new SizeOverLife(new PiecewiseBezier(flameSizeCurve)));
        const flameColorStops = new Array(
            new Array(new THREE.Vector3(1, 1, 0.5), 0),           // 시작: 밝은 노랑
            new Array(new THREE.Vector3(1, 0.5, 0), 0.3),         // 중간: 주황
            new Array(new THREE.Vector3(1, 0.2, 0), 0.7),         // 끝: 빨강
            new Array(new THREE.Vector3(0.5, 0.1, 0), 1)          // 페이드: 어두운 빨강
        );
        const flameAlphaStops = new Array(
            new Array(1, 0),
            new Array(0.9, 0.5),
            new Array(0.3, 1)
        );
        flameSystem.addBehavior(new ColorOverLife(new Gradient(flameColorStops, flameAlphaStops)));
        const flameSpeedCurve = new Array(new Array(new Bezier(1, 0.5, 0.2, 0), 0));
        flameSystem.addBehavior(new SpeedOverLife(new PiecewiseBezier(flameSpeedCurve)));

        flameSystem.emitter.name = 'flames';
        flameSystem.emitter.position.set(0, buildingHeight, 0);
        flameSystem.emitter.rotation.set(-Math.PI / 2, 0, 0);  // 위를 향하게

        batchRenderer.addSystem(flameSystem);
        fireGroup.add(flameSystem.emitter);

        // ===== 연기 파티클 시스템 (Three.quarks) =====
        const smokeSystem = new ParticleSystem({
            duration: 0,
            looping: true,
            startLife: new IntervalValue(1.5, 3.0),
            startSpeed: new IntervalValue(0.3, 0.6),
            startSize: new IntervalValue(0.2, 0.5),
            startRotation: new IntervalValue(0, Math.PI * 2),
            startColor: new RandomColor(
                new THREE.Vector4(0.3, 0.3, 0.3, 0.6),
                new THREE.Vector4(0.5, 0.5, 0.5, 0.4)
            ),
            emissionOverTime: new ConstantValue(8),
            shape: new ConeEmitter({
                radius: 0.2,
                arc: Math.PI * 2,
                thickness: 1,
                angle: Math.PI / 6
            }),
            material: new THREE.MeshBasicMaterial({
                map: smokeTexture,
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            }),
            renderMode: RenderMode.BillBoard,
            renderOrder: 5,
            worldSpace: false
        });

        // 연기 행동 추가 (Thymeleaf 중첩배열 충돌 방지를 위해 Array() 사용)
        const smokeSizeCurve = new Array(new Array(new Bezier(0.5, 1, 1.5, 2), 0));
        smokeSystem.addBehavior(new SizeOverLife(new PiecewiseBezier(smokeSizeCurve)));
        const smokeColorStops = new Array(
            new Array(new THREE.Vector3(0.4, 0.4, 0.4), 0),
            new Array(new THREE.Vector3(0.3, 0.3, 0.3), 0.5),
            new Array(new THREE.Vector3(0.2, 0.2, 0.2), 1)
        );
        const smokeAlphaStops = new Array(
            new Array(0.5, 0),
            new Array(0.4, 0.5),
            new Array(0, 1)
        );
        smokeSystem.addBehavior(new ColorOverLife(new Gradient(smokeColorStops, smokeAlphaStops)));
        smokeSystem.addBehavior(new RotationOverLife(new IntervalValue(-0.5, 0.5)));
        smokeSystem.addBehavior(new ForceOverLife(
            new ConstantValue(0),
            new ConstantValue(0.1),  // 약간 위로
            new IntervalValue(-0.05, 0.05)  // 약간 흔들림
        ));

        smokeSystem.emitter.name = 'smoke';
        smokeSystem.emitter.position.set(0, buildingHeight + 0.3, 0);
        smokeSystem.emitter.rotation.set(-Math.PI / 2, 0, 0);

        batchRenderer.addSystem(smokeSystem);
        fireGroup.add(smokeSystem.emitter);

        // ===== 불빛 (PointLight) - 더 강한 주황색 =====
        const fireLight = new THREE.PointLight(0xff6600, 2.5, 5);  // 범위 축소 (성능 최적화)
        fireLight.position.set(0, buildingHeight + 0.5, 0);
        fireGroup.add(fireLight);

        // 불빛 깜빡임 효과용 데이터
        fireGroup.userData.light = fireLight;
        fireGroup.userData.flameSystem = flameSystem;
        fireGroup.userData.smokeSystem = smokeSystem;
        fireGroup.userData.baseIntensity = 2.5;

        // 위치 설정
        fireGroup.position.set(worldPos.x, 0, worldPos.z);

        return { group: fireGroup, flameSystem, smokeSystem };
    }

    /**
     * Three.quarks 화재 파티클 업데이트 (불빛 깜빡임만 처리)
     * 파티클 자체는 batchRenderer에서 자동 업데이트됨
     */
    function updateFireParticles(fireData) {
        // 불빛 깜빡임 효과
        if (fireData.effects && fireData.effects.group && fireData.effects.group.userData.light) {
            const light = fireData.effects.group.userData.light;
            const baseIntensity = fireData.effects.group.userData.baseIntensity || 3;
            // 랜덤 깜빡임 (2.5 ~ 4.0)
            light.intensity = baseIntensity * (0.8 + Math.random() * 0.4);
        }
    }

    // 소방차 출동 관련 상수
    const FIRE_BURNOUT_TIME = 30000;      // 전소까지 제한 시간 30초
    const dispatchedFiretrucks = new Map(); // key: fireKey, value: { vehicle, fireStationKey }
    const stationFiretruckCount = new Map(); // key: stationKey, value: 현재 출동 중인 소방차 수
    const MAX_FIRETRUCKS_PER_STATION = 2; // 소방서당 최대 소방차 수

    /**
     * 가장 가까운 소방서 찾기 (여유 있는 소방서 우선)
     */
    function findNearestFireStation(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return null;

        let nearest = null;
        let minDistance = Infinity;

        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type !== 'fire') continue;

            // 소방서 출동 가능 여부 확인 (최대 2대)
            const currentCount = stationFiretruckCount.get(key) || 0;
            if (currentCount >= MAX_FIRETRUCKS_PER_STATION) continue;

            const bx = building.x;
            const by = building.y;
            const bw = building.width || 2;
            const bd = building.depth || 2;

            const centerX = bx + bw / 2;
            const centerY = by + bd / 2;

            const dx = (x + 0.5) - centerX;
            const dy = (y + 0.5) - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < minDistance) {
                minDistance = distance;
                nearest = { key, x: bx, y: by, centerX, centerY, distance };
            }
        }

        return nearest;
    }

    /**
     * 긴급차량 사이렌 라이트 생성
     * @param {string} type - 'firetruck', 'police', 또는 'ambulance'
     * @returns {THREE.Group} 사이렌 라이트 그룹
     */
    function createSirenLights(type) {
        const sirenGroup = new THREE.Group();
        sirenGroup.name = 'sirenLights';

        // 라이트바 베이스 (검은색 박스)
        const barGeo = new THREE.BoxGeometry(0.08, 0.015, 0.03);
        const barMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const bar = new THREE.Mesh(barGeo, barMat);
        bar.position.set(0, 0.12, 0);
        sirenGroup.add(bar);

        // 타입별 색상 설정
        let leftColor, rightColor;
        if (type === 'police') {
            leftColor = 0x0066ff;   // 파랑
            rightColor = 0xff0000;  // 빨강
        } else if (type === 'ambulance') {
            leftColor = 0xff0000;   // 빨강
            rightColor = 0xffffff;  // 흰색
        } else {
            // firetruck (default)
            leftColor = 0xff0000;   // 빨강
            rightColor = 0xff6600;  // 주황
        }

        // 왼쪽 라이트
        const leftLightGeo = new THREE.SphereGeometry(0.012, 8, 8);
        const leftLightMat = new THREE.MeshBasicMaterial({
            color: leftColor,
            transparent: true,
            opacity: 1.0
        });
        const leftLight = new THREE.Mesh(leftLightGeo, leftLightMat);
        leftLight.position.set(-0.025, 0.12, 0);
        leftLight.name = 'sirenLeft';
        sirenGroup.add(leftLight);

        // 오른쪽 라이트
        const rightLightGeo = new THREE.SphereGeometry(0.012, 8, 8);
        const rightLightMat = new THREE.MeshBasicMaterial({
            color: rightColor,
            transparent: true,
            opacity: 0.3
        });
        const rightLight = new THREE.Mesh(rightLightGeo, rightLightMat);
        rightLight.position.set(0.025, 0.12, 0);
        rightLight.name = 'sirenRight';
        sirenGroup.add(rightLight);

        // 포인트 라이트 (실제 빛 효과)
        const pointLight = new THREE.PointLight(leftColor, 0.5, 1);
        pointLight.position.set(0, 0.15, 0);
        pointLight.name = 'sirenPointLight';
        sirenGroup.add(pointLight);

        // 사이렌 상태 저장
        sirenGroup.userData = {
            type: type,
            phase: 0,
            leftMat: leftLightMat,
            rightMat: rightLightMat,
            pointLight: pointLight,
            leftColor: leftColor,
            rightColor: rightColor
        };

        return sirenGroup;
    }

    /**
     * 사이렌 라이트 애니메이션 업데이트
     * @param {THREE.Group} sirenGroup - 사이렌 그룹
     * @param {number} deltaTime - 프레임 시간
     */
    function updateSirenLights(sirenGroup, deltaTime) {
        if (!sirenGroup || !sirenGroup.userData) return;

        const data = sirenGroup.userData;
        data.phase += deltaTime * 8;  // 빠른 깜빡임

        const flash = Math.sin(data.phase) > 0;

        // 왼쪽/오른쪽 번갈아 깜빡임
        data.leftMat.opacity = flash ? 1.0 : 0.2;
        data.rightMat.opacity = flash ? 0.2 : 1.0;

        // 포인트 라이트 색상 변경
        data.pointLight.color.setHex(flash ? data.leftColor : data.rightColor);
        data.pointLight.intensity = 0.3 + Math.abs(Math.sin(data.phase)) * 0.4;
    }

    /**
     * 소방차 출동
     */
    function dispatchFiretruck(fireX, fireY, fireStation) {
        if (!trafficManager || !trafficManager.initialized) {
            console.warn('[Fire] Traffic not initialized, cannot dispatch firetruck');
            return null;
        }

        // 소방서 인접 도로 찾기
        const stationRoad = trafficManager.findNearestRoad(fireStation.x, fireStation.y);
        if (!stationRoad) {
            console.warn('[Fire] No road near fire station');
            return null;
        }

        // 화재 건물 인접 도로 찾기
        const fireRoad = trafficManager.findNearestRoad(fireX, fireY);
        if (!fireRoad) {
            console.warn('[Fire] No road near fire location');
            return null;
        }

        // 경로 찾기
        const path = trafficManager.findPath(stationRoad.x, stationRoad.y, fireRoad.x, fireRoad.y);
        if (!path || path.length < 2) {
            console.warn('[Fire] No path to fire location');
            return null;
        }

        // 소방차 스폰
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) {
            console.warn('[Fire] No vehicle available');
            return null;
        }

        // 이전 사용에서 남은 속성 초기화
        vehicle.isMoveInVehicle = false;
        vehicle.isConstructionTruck = false;
        vehicle.constructionSite = null;
        vehicle.workStartTime = null;
        vehicle.isParked = false;
        vehicle.enterProgress = 0;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 소방차 타입으로 설정
        vehicle.vehicleTypeKey = 'firetruck';
        vehicle.type = 'firetruck';
        const vehicleTypeConfig = VEHICLE_TYPES['firetruck'];

        // 메쉬 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh('firetruck');
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 사이렌 라이트 추가
        const sirenLights = createSirenLights('firetruck');
        newMesh.add(sirenLights);
        vehicle.sirenLights = sirenLights;

        // 소방차 특수 속성
        vehicle.isFiretruck = true;
        vehicle.fireTarget = { x: fireX, y: fireY };
        vehicle.originBuilding = { x: fireStation.x, y: fireStation.y };
        vehicle.originStation = { x: fireStation.x, y: fireStation.y };  // 복귀용
        vehicle.stationKey = fireStation.key;  // 소방서 키 저장 (카운트 관리용)
        vehicle.destBuilding = { x: fireX, y: fireY };
        vehicle.activity = '🚒 화재 현장으로 출동 중!';
        vehicle.originTypeName = '소방서';
        vehicle.destTypeName = '화재 현장';
        vehicle.isReturning = false;

        // 소방서 출동 카운트 증가
        const currentCount = stationFiretruckCount.get(fireStation.key) || 0;
        stationFiretruckCount.set(fireStation.key, currentCount + 1);

        // 속도 설정 (소방차는 다른 차량보다 2배 빠름)
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 2.5;
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);  // 프리팹이 이미 내부 스케일 적용됨

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        console.log(`[Fire] Firetruck dispatched from (${fireStation.x},${fireStation.y}) to (${fireX},${fireY})`);
        return vehicle;
    }

    /**
     * 화재 발생
     */
    function startFire(x, y) {
        const key = `${x},${y}`;
        if (burningBuildings.has(key)) return;  // 이미 화재 중

        // 건물 높이 추정
        const building = placedBuildings.get(key);
        let buildingHeight = 1;
        if (building && building.instance) {
            const bbox = new THREE.Box3().setFromObject(building.instance);
            buildingHeight = bbox.max.y;
        }

        // 화재 이펙트 생성 (Three.quarks 파티클 시스템)
        const effects = createFireEffect(x, y, buildingHeight);
        fireEffectsGroup.add(effects.group);

        const fireData = {
            startTime: Date.now(),
            intensity: 1.0,
            effects: {
                group: effects.group,
                flameSystem: effects.flameSystem,
                smokeSystem: effects.smokeSystem
            },
            x, y,
            firetruckDispatched: false,
            firetruckArrived: false
        };

        burningBuildings.set(key, fireData);

        // 일일 통계 업데이트
        dailyStats.fire.totalFires++;
        updateDailyStatsPanel();

        console.log(`[Fire] Started at (${x}, ${y})`);

        // 소방서 찾아서 소방차 출동
        const nearestStation = findNearestFireStation(x, y);
        if (nearestStation) {
            const firetruck = dispatchFiretruck(x, y, nearestStation);
            if (firetruck) {
                fireData.firetruckDispatched = true;
                dispatchedFiretrucks.set(key, { vehicle: firetruck, stationKey: nearestStation.key });
            }
        }
    }

    /**
     * 건물 전소 처리 (폐건물로 전환)
     */
    function burnDownBuilding(x, y) {
        const key = `${x},${y}`;
        const building = placedBuildings.get(key);

        if (!building || !building.instance) return;

        // 폐건물로 전환
        const userData = building.instance.userData;
        if (userData) {
            userData.isAbandoned = true;
            userData.abandonedReason = '화재로 인해 전소되었습니다.';
            userData.abandonedTime = Date.now();
        }

        // 폐건물 아이콘 추가
        if (typeof addAbandonedIcon === 'function') {
            addAbandonedIcon(x, y);
        }

        // 폐건물 목록에 추가
        if (typeof abandonedBuildings !== 'undefined') {
            abandonedBuildings.add(key);
        }

        // 건물 색상을 검정색으로 변경 (전소 표시)
        building.instance.traverse((child) => {
            if (child.isMesh && child.material) {
                const burnedMaterial = child.material.clone();
                burnedMaterial.color.setHex(0x000000);  // 검정색
                child.material = burnedMaterial;
            }
        });

        console.log(`[Fire] Building burned down at (${x}, ${y})`);

        // 일일 통계 업데이트
        dailyStats.fire.burnedBuildings++;
        updateDailyStatsPanel();
        checkDailyStatsWarnings();
    }

    /**
     * 화재 진압 (소멸)
     */
    function extinguishFire(key, byFiretruck = false) {
        const fireData = burningBuildings.get(key);
        if (!fireData) return;

        // three.quarks 파티클 시스템 제거
        if (fireData.effects) {
            // 불꽃 파티클 시스템 제거
            if (fireData.effects.flameSystem) {
                batchRenderer.deleteSystem(fireData.effects.flameSystem);
                fireData.effects.flameSystem = null;
            }
            // 연기 파티클 시스템 제거
            if (fireData.effects.smokeSystem) {
                batchRenderer.deleteSystem(fireData.effects.smokeSystem);
                fireData.effects.smokeSystem = null;
            }
            // 그룹 (라이트 포함) 제거
            if (fireData.effects.group) {
                const group = fireData.effects.group;

                // 라이트 제거
                if (group.userData.light) {
                    group.remove(group.userData.light);
                    group.userData.light = null;
                }

                // 씬에서 그룹 제거
                fireEffectsGroup.remove(group);
                fireData.effects.group = null;
            }
        }

        // 출동 중인 소방차 정보 제거
        dispatchedFiretrucks.delete(key);

        burningBuildings.delete(key);
        console.log(`[Fire] Extinguished at ${key}` + (byFiretruck ? ' by firetruck' : ''));
    }

    /**
     * 소방차 도착 처리 - 잔화 작업 후 복귀
     */
    const FIRETRUCK_WORK_TIME = 5000;  // 잔화 작업 시간 (5초)

    function onFiretruckArrival(fireX, fireY, vehicle) {
        const key = `${fireX},${fireY}`;
        const fireData = burningBuildings.get(key);

        console.log(`[Fire] onFiretruckArrival called for (${fireX}, ${fireY}), fireData exists: ${!!fireData}`);

        if (!fireData) {
            // 이미 진압됨 - 잠시 대기 후 복귀 (잔화 작업 모션)
            console.log(`[Fire] Fire already extinguished at (${fireX}, ${fireY}), starting return after brief pause`);

            // 잠시 현장에서 대기 후 복귀
            if (vehicle && vehicle.mesh) {
                vehicle.state = 'working';
                vehicle.activity = '🔍 현장 확인 중...';
                vehicle.workStartTime = Date.now() - 3000;  // 2초만 대기 (5초 - 3초 = 2초)
                vehicle.isParked = true;
            } else {
                startFiretruckReturn(vehicle);
            }
            return;
        }

        fireData.firetruckArrived = true;

        // 즉시 화재 진압
        console.log(`[Fire] Extinguishing fire at (${fireX}, ${fireY})`);
        extinguishFire(key, true);

        // 일일 통계 업데이트
        dailyStats.fire.extinguishedFires++;

        // 위험물 화재 체크 (공장 건물)
        const building = placedBuildings.get(key);
        if (building && building.instance && building.instance.userData) {
            const zoneType = building.instance.userData.zoneType || '';
            if (zoneType.includes('industrial')) {
                dailyStats.fire.hazmatFires++;
            }
        }
        updateDailyStatsPanel();

        // 소방차를 갓길에 주차 (도로 옆으로 살짝 이동)
        if (vehicle && vehicle.mesh) {
            // 차량 상태를 작업 중으로 변경
            vehicle.state = 'working';
            vehicle.activity = '🧯 잔화 작업 중...';
            vehicle.workStartTime = Date.now();

            // 갓길 주차 - 현재 위치에서 도로 옆으로 살짝 이동
            const offsetX = Math.cos(vehicle.rotation) * 0.15;
            const offsetZ = Math.sin(vehicle.rotation) * 0.15;
            vehicle.parkPosition = {
                x: vehicle.position.x + offsetZ,
                z: vehicle.position.z + offsetX
            };
            vehicle.mesh.position.x = vehicle.parkPosition.x;
            vehicle.mesh.position.z = vehicle.parkPosition.z;

            // 비상등 깜빡임 효과를 위한 플래그
            vehicle.isParked = true;

            // 물 뿌리기 이펙트 시작
            startWaterEffect(vehicle);

            console.log(`[Fire] Firetruck parked at (${vehicle.parkPosition.x.toFixed(2)}, ${vehicle.parkPosition.z.toFixed(2)}), state: ${vehicle.state}`);
        } else {
            console.warn(`[Fire] Vehicle or mesh is null in onFiretruckArrival`);
        }
    }

    /**
     * 소방차 소방서 복귀 시작
     */
    function startFiretruckReturn(vehicle) {
        if (!vehicle || !vehicle.originStation) {
            if (vehicle) {
                stopWaterEffect(vehicle);  // 물 이펙트 정지
                trafficManager.despawnVehicle(vehicle);
            }
            return;
        }

        // 물 뿌리기 이펙트 중지
        stopWaterEffect(vehicle);

        const stationX = vehicle.originStation.x;
        const stationY = vehicle.originStation.y;

        // 현재 위치에서 가장 가까운 도로 타일 찾기
        const currentRoadTile = findNearestRoadTile(
            Math.floor(vehicle.position.x / TILE_SIZE + GRID_W / 2),
            Math.floor(vehicle.position.z / TILE_SIZE + GRID_H / 2)
        );

        if (!currentRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 소방서 주변 도로 찾기
        const stationRoadTile = findNearestRoadTile(stationX, stationY);
        if (!stationRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 경로 계산
        const returnPath = trafficManager.findPath(
            currentRoadTile.x, currentRoadTile.y,
            stationRoadTile.x, stationRoadTile.y
        );

        if (!returnPath || returnPath.length < 2) {
            console.log('[Fire] No return path found, despawning');
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 모드 설정
        vehicle.isReturning = true;
        vehicle.fireTarget = null;
        vehicle.path = returnPath;
        vehicle.pathIndex = 0;
        vehicle.currentTile = { x: returnPath[0].x, y: returnPath[0].y };
        vehicle.targetTile = { x: returnPath[1].x, y: returnPath[1].y };
        vehicle.progress = 0;
        vehicle.state = 'moving';
        vehicle.isParked = false;
        vehicle.activity = '🏠 소방서로 복귀 중';
        vehicle.destTypeName = '소방서';

        // 속도를 일반 속도로 낮춤
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 1.15;
        vehicle.targetSpeed = vehicle.speed;

        console.log(`[Fire] Firetruck returning to station at (${stationX}, ${stationY})`);
    }

    /**
     * 가장 가까운 도로 타일 찾기
     */
    function findNearestRoadTile(x, y) {
        // 주변 탐색 범위
        const searchRadius = 5;

        for (let r = 0; r <= searchRadius; r++) {
            for (let dx = -r; dx <= r; dx++) {
                for (let dy = -r; dy <= r; dy++) {
                    if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;

                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx < 0 || ny < 0 || nx >= GRID_W || ny >= GRID_H) continue;

                    // isRoad 함수 사용 (mapData 스코프 문제 해결)
                    if (typeof isRoad === 'function' && isRoad(nx, ny)) {
                        return { x: nx, y: ny };
                    }
                }
            }
        }
        return null;
    }

    /**
     * 건물이 소방서 범위 내에 있는지 확인
     * 소방서의 효과 범위는 전 지역 (소방서가 하나라도 있으면 true)
     */
    function isInFireStationRange(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return false;

        // 소방서가 하나라도 있으면 전 지역 커버
        for (const [, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'fire') {
                return true;
            }
        }
        return false;
    }

    /**
     * 화재 발생 체크 (주기적 호출)
     */
    function checkFireOutbreak() {
        if (typeof placedBuildings === 'undefined') return;

        const now = Date.now();
        if (now - lastFireCheck < FIRE_CHECK_INTERVAL) return;
        lastFireCheck = now;

        // 민간 건물 목록 수집
        const civilianBuildings = [];
        placedBuildings.forEach((building, key) => {
            if (building.ref) return;
            const userData = building.instance?.userData;
            if (!userData) return;
            if (userData.isAbandoned) return;

            const zoneType = userData.zoneType || '';
            if (zoneType.includes('resident') || zoneType.includes('commercial') || zoneType.includes('industrial')) {
                civilianBuildings.push({
                    key,
                    x: building.x,
                    y: building.y,
                    zoneType,
                    isIndustrial: zoneType.includes('industrial')
                });
            }
        });

        if (civilianBuildings.length === 0) return;

        // 각 건물에 대해 화재 발생 확률 체크
        for (const building of civilianBuildings) {
            const key = building.key;
            if (burningBuildings.has(key)) continue;  // 이미 화재 중

            // 화재 확률 계산
            let fireChance = FIRE_BASE_CHANCE;

            // 공장은 화재 확률 증가
            if (building.isIndustrial) {
                fireChance *= FIRE_INDUSTRIAL_MULTIPLIER;
            }

            // 소방서 범위 내면 화재 확률 대폭 감소
            if (isInFireStationRange(building.x, building.y)) {
                fireChance *= 0.1;  // 90% 감소
            }

            // 인접 건물이 화재 중이면 전파 확률 추가
            const neighbors = [
                `${building.x - 1},${building.y}`,
                `${building.x + 1},${building.y}`,
                `${building.x},${building.y - 1}`,
                `${building.x},${building.y + 1}`
            ];

            for (const neighborKey of neighbors) {
                if (burningBuildings.has(neighborKey)) {
                    fireChance += FIRE_SPREAD_CHANCE;
                    break;  // 인접 화재는 한 번만 적용
                }
            }

            // 확률 체크
            if (Math.random() < fireChance) {
                startFire(building.x, building.y);
            }
        }
    }

    /**
     * 화재 진행 업데이트 (제한시간 체크)
     */
    let lastFiretruckRetryTime = 0;
    const FIRETRUCK_RETRY_INTERVAL = 5000;  // 5초마다 소방차 출동 재시도

    function updateFireProgress() {
        const now = Date.now();

        burningBuildings.forEach((fireData, key) => {
            // 파티클 애니메이션 업데이트
            updateFireParticles(fireData);

            // 소방차가 도착했으면 이미 처리됨
            if (fireData.firetruckArrived) return;

            // 제한시간 체크 (소방차가 도착하지 못하면 전소)
            const elapsed = now - fireData.startTime;

            if (elapsed >= FIRE_BURNOUT_TIME) {
                // 건물 전소
                burnDownBuilding(fireData.x, fireData.y);
                extinguishFire(key);
            }
        });

        // 소방차 출동 재시도 (소방서가 생겼을 때를 위해)
        if (now - lastFiretruckRetryTime > FIRETRUCK_RETRY_INTERVAL) {
            lastFiretruckRetryTime = now;
            retryFiretruckDispatch();
        }
    }

    /**
     * 소방차 출동 재시도 (출동하지 않은 화재에 대해)
     */
    function retryFiretruckDispatch() {
        burningBuildings.forEach((fireData, key) => {
            // 이미 소방차가 출동했거나 도착했으면 스킵
            if (fireData.firetruckDispatched || fireData.firetruckArrived) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            // 소방서 찾기
            const nearestStation = findNearestFireStation(x, y);
            if (!nearestStation) return;

            // 소방차 출동
            const firetruck = dispatchFiretruck(x, y, nearestStation);
            if (firetruck) {
                fireData.firetruckDispatched = true;
                dispatchedFiretrucks.set(key, { vehicle: firetruck, stationKey: nearestStation.key });
                console.log(`[Fire] Retry dispatched firetruck to fire at (${x}, ${y})`);

                toast({
                    title: '🚒 소방차 출동!',
                    desc: `(${x}, ${y}) 화재에 소방차가 출동했습니다!`,
                    ms: 3000
                });
            }
        });
    }

    /**
     * 화재 시스템 전체 업데이트 (animate에서 호출)
     */
    function updateFireSystem() {
        checkFireOutbreak();
        updateFireProgress();
    }

    /**
     * 소방서 설치 시 기존 화재에 소방차 출동
     * (소방차가 아직 출동하지 않은 화재에 대해 출동)
     */
    function dispatchFiretrucksToExistingFires() {
        if (!burningBuildings || burningBuildings.size === 0) return;

        let dispatched = 0;

        burningBuildings.forEach((fireData, key) => {
            // 이미 소방차가 출동한 화재는 스킵
            if (fireData.firetruckDispatched) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            // 소방서 찾기
            const nearestStation = findNearestFireStation(x, y);
            if (!nearestStation) return;

            // 소방차 출동
            const firetruck = dispatchFiretruck(x, y, nearestStation);
            if (firetruck) {
                fireData.firetruckDispatched = true;
                dispatchedFiretrucks.set(key, { vehicle: firetruck, stationKey: nearestStation.key });
                dispatched++;
                console.log(`[Fire] Dispatched firetruck to existing fire at (${x}, ${y})`);
            }
        });

        if (dispatched > 0) {
            toast({
                title: '🚒 소방차 출동!',
                desc: `${dispatched}건의 화재에 소방차가 출동했습니다!`,
                ms: 3000
            });
        }
    }

    // ===== 강도 사건 시스템 (CRIME SYSTEM) =====
    // 강도 사건 관련 상수
    const CRIME_BASE_CHANCE = 0.00002;          // 기본 발생 확률 (프레임당) - 대폭 감소
    const CRIME_COMMERCIAL_MULTIPLIER = 3.0;    // 상업 건물 발생 확률 배수
    const CRIME_RESOLUTION_TIME = 25000;        // 미해결 시 피해 시간 25초
    const CRIME_RETRY_INTERVAL = 5000;          // 경찰차 재출동 간격 5초
    const CRIME_POLICE_WORK_TIME = 4000;        // 현장 조사 시간 4초
    const CRIME_DAMAGE_HAPPINESS = -15;         // 미해결 시 행복도 피해
    const CRIME_DAMAGE_MONEY = 500;             // 미해결 시 자금 피해

    // 감옥 시스템 상수
    const MAX_PRISONERS_PER_STATION = 5;        // 경찰서당 최대 수감 인원
    const PRISONER_RELEASE_TIME = 30000;        // 수감자 석방 시간 (30초)

    // 강도 사건 데이터 구조
    const activeCrimes = new Map();             // key: "x,y", value: crimeData
    const dispatchedPoliceCars = new Map();     // key: crimeKey, value: { vehicle, stationKey }
    const stationPoliceCount = new Map();       // key: stationKey, value: 출동 중 경찰차 수
    const MAX_POLICE_PER_STATION = 2;           // 경찰서당 최대 경찰차 수
    const stationPrisoners = new Map();         // key: stationKey, value: [{ arrestTime }]
    let lastCrimeRetryTime = 0;
    let lastPrisonerReleaseCheck = 0;

    /**
     * 가장 가까운 경찰서 찾기 (여유 있는 경찰서 우선, 감옥 정원 체크)
     */
    function findNearestPoliceStation(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return null;

        let nearest = null;
        let minDistance = Infinity;

        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type !== 'police') continue;

            // 현재 출동 중인 경찰차 수 체크
            const currentCount = stationPoliceCount.get(key) || 0;
            if (currentCount >= MAX_POLICE_PER_STATION) continue;

            // 감옥 정원 체크 - 가득 차면 출동 불가
            const prisoners = stationPrisoners.get(key) || [];
            if (prisoners.length >= MAX_PRISONERS_PER_STATION) {
                console.log(`[Crime] Station ${key} prison full (${prisoners.length}/${MAX_PRISONERS_PER_STATION})`);
                continue;
            }

            // 경찰서 중심 좌표 계산
            const bx = building.x;
            const by = building.y;
            const centerX = bx + 1;  // 2x2 건물 중심
            const centerY = by + 1;

            const dx = centerX - x;
            const dy = centerY - y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < minDistance) {
                minDistance = distance;
                nearest = { key, x: bx, y: by, centerX, centerY, distance };
            }
        }

        return nearest;
    }

    /**
     * 경찰서에 수감자 추가
     */
    function addPrisoner(stationKey) {
        if (!stationKey) return;
        const prisoners = stationPrisoners.get(stationKey) || [];
        prisoners.push({ arrestTime: Date.now() });
        stationPrisoners.set(stationKey, prisoners);
        console.log(`[Crime] Prisoner added to ${stationKey} (${prisoners.length}/${MAX_PRISONERS_PER_STATION})`);
    }

    /**
     * 수감자 석방 (시간이 지난 수감자)
     */
    function releasePrisoners() {
        const now = Date.now();
        let totalReleased = 0;

        for (const [stationKey, prisoners] of stationPrisoners) {
            const remaining = prisoners.filter(p => (now - p.arrestTime) < PRISONER_RELEASE_TIME);
            const released = prisoners.length - remaining.length;
            if (released > 0) {
                stationPrisoners.set(stationKey, remaining);
                totalReleased += released;
                console.log(`[Crime] ${released} prisoner(s) released from ${stationKey} (${remaining.length}/${MAX_PRISONERS_PER_STATION})`);
            }
        }

        return totalReleased;
    }

    /**
     * 전체 수감자 수 계산
     */
    function getTotalPrisoners() {
        let total = 0;
        for (const [, prisoners] of stationPrisoners) {
            total += prisoners.length;
        }
        return total;
    }

    /**
     * 전체 감옥 정원 계산
     */
    function getTotalPrisonCapacity() {
        let capacity = 0;
        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'police') {
                capacity += MAX_PRISONERS_PER_STATION;
            }
        }
        return capacity;
    }

    /**
     * 경찰차 출동
     */
    function dispatchPoliceCar(crimeX, crimeY, policeStation) {
        if (!trafficManager || !trafficManager.initialized) {
            console.warn('[Crime] Traffic not initialized, cannot dispatch police');
            return null;
        }

        // 경찰서 인접 도로 찾기
        const stationRoad = trafficManager.findNearestRoad(policeStation.x, policeStation.y);
        if (!stationRoad) {
            console.warn('[Crime] No road near police station');
            return null;
        }

        // 범죄 현장 인접 도로 찾기
        const crimeRoad = trafficManager.findNearestRoad(crimeX, crimeY);
        if (!crimeRoad) {
            console.warn('[Crime] No road near crime location');
            return null;
        }

        // 경로 찾기
        const path = trafficManager.findPath(stationRoad.x, stationRoad.y, crimeRoad.x, crimeRoad.y);
        if (!path || path.length < 2) {
            console.warn('[Crime] No path to crime location');
            return null;
        }

        // 경찰차 스폰
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) {
            console.warn('[Crime] No vehicle available');
            return null;
        }

        // 이전 사용에서 남은 속성 초기화
        vehicle.isFiretruck = false;
        vehicle.isMoveInVehicle = false;
        vehicle.isConstructionTruck = false;
        vehicle.constructionSite = null;
        vehicle.fireTarget = null;
        vehicle.isReturning = false;
        vehicle.workStartTime = null;
        vehicle.isParked = false;
        vehicle.enterProgress = 0;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 경찰차 타입으로 설정
        vehicle.vehicleTypeKey = 'police';
        vehicle.type = 'police';
        const vehicleTypeConfig = VEHICLE_TYPES['police'];

        // 메쉬 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh('police');
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 사이렌 라이트 추가
        const sirenLights = createSirenLights('police');
        newMesh.add(sirenLights);
        vehicle.sirenLights = sirenLights;

        // 경찰차 특수 속성
        vehicle.isPoliceCar = true;
        vehicle.crimeTarget = { x: crimeX, y: crimeY };
        vehicle.originBuilding = { x: policeStation.x, y: policeStation.y };
        vehicle.originStation = { x: policeStation.x, y: policeStation.y };
        vehicle.stationKey = policeStation.key;
        vehicle.destBuilding = { x: crimeX, y: crimeY };
        vehicle.activity = '🚔 범죄 현장으로 출동 중!';
        vehicle.originTypeName = '경찰서';
        vehicle.destTypeName = '범죄 현장';
        vehicle.isReturning = false;

        // 경찰서 출동 카운트 증가
        const currentCount = stationPoliceCount.get(policeStation.key) || 0;
        stationPoliceCount.set(policeStation.key, currentCount + 1);

        // 속도 설정 (경찰차는 다른 차량보다 빠름)
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 2.3;
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        console.log(`[Crime] Police car dispatched from (${policeStation.x},${policeStation.y}) to (${crimeX},${crimeY})`);
        return vehicle;
    }

    /**
     * 강도 사건 발생
     */
    function startCrime(x, y, isCommercial = false) {
        const key = `${x},${y}`;
        if (activeCrimes.has(key)) return;  // 이미 사건 진행 중

        // 강도 사건 이펙트 생성
        const effects = createCrimeEffect(x, y);

        const crimeData = {
            startTime: Date.now(),
            effects: effects,
            x, y,
            isCommercial,
            policeDispatched: false,
            policeArrived: false
        };

        activeCrimes.set(key, crimeData);

        // 일일 통계 업데이트
        dailyStats.crime.totalCrimes++;
        updateDailyStatsPanel();

        console.log(`[Crime] Started at (${x}, ${y}), commercial: ${isCommercial}`);

        // 경찰서 찾아서 경찰차 출동
        const nearestStation = findNearestPoliceStation(x, y);
        if (nearestStation) {
            const policeCar = dispatchPoliceCar(x, y, nearestStation);
            if (policeCar) {
                crimeData.policeDispatched = true;
                dispatchedPoliceCars.set(key, { vehicle: policeCar, stationKey: nearestStation.key });
            }
        }
    }

    /**
     * 강도 사건 이펙트 생성 (수갑 아이콘)
     */
    function createCrimeEffect(x, y) {
        const group = new THREE.Group();

        // 건물 높이 추정
        const building = placedBuildings.get(`${x},${y}`);
        let buildingHeight = 1;
        if (building && building.instance) {
            const bbox = new THREE.Box3().setFromObject(building.instance);
            buildingHeight = bbox.max.y;
        }

        // 사이렌 아이콘 스프라이트 (빨간 배경 원 + 사이렌)
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = 128;
        iconCanvas.height = 128;
        const ctx = iconCanvas.getContext('2d');

        // 빨간 원 배경 (깜빡임용)
        ctx.beginPath();
        ctx.arc(64, 64, 56, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 4;
        ctx.stroke();

        // 사이렌 이모지
        ctx.font = '64px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('🚨', 64, 64);

        const texture = new THREE.CanvasTexture(iconCanvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(0.6, 0.6, 1);
        sprite.position.set(0, buildingHeight + 0.5, 0);
        sprite.name = 'crimeIcon';
        group.add(sprite);

        // 아이콘 애니메이션 데이터
        group.userData = {
            phase: 0,
            baseY: buildingHeight + 0.5,
            spriteMaterial: spriteMaterial
        };

        // 월드 좌표로 배치
        const worldPos = tileToWorldCenter(x, y);
        group.position.set(worldPos.x, 0, worldPos.z);

        // 이펙트 그룹에 추가
        if (typeof fireEffectsGroup !== 'undefined') {
            fireEffectsGroup.add(group);
        }

        return {
            group,
            sprite
        };
    }

    /**
     * 강도 사건 해결
     */
    function resolveCrime(key, byPolice = false) {
        const crimeData = activeCrimes.get(key);
        if (!crimeData) return;

        // 이펙트 제거
        if (crimeData.effects && crimeData.effects.group) {
            const group = crimeData.effects.group;

            // 먼저 모든 자식을 숨김 (렌더링 방지)
            group.traverse((child) => {
                child.visible = false;
            });

            // 씬에서 제거
            if (typeof fireEffectsGroup !== 'undefined') {
                fireEffectsGroup.remove(group);
            }

            // 다음 프레임에서 dispose (렌더링 완료 후)
            requestAnimationFrame(() => {
                group.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        // CanvasTexture는 dispose 후 가비지 컬렉터가 정리
                        // 재질만 명시적으로 dispose
                        child.material.dispose();
                    }
                });
            });

            // 참조 정리
            crimeData.effects.group = null;
            crimeData.effects.sprite = null;
        }

        // 출동 중인 경찰차 정보 제거
        dispatchedPoliceCars.delete(key);

        activeCrimes.delete(key);
        console.log(`[Crime] Resolved at ${key}` + (byPolice ? ' by police' : ' (escaped)'));
    }

    /**
     * 경찰차 도착 처리
     */
    function onPoliceCarArrival(crimeX, crimeY, vehicle) {
        const key = `${crimeX},${crimeY}`;
        const crimeData = activeCrimes.get(key);

        console.log(`[Crime] onPoliceCarArrival called for (${crimeX}, ${crimeY}), crimeData exists: ${!!crimeData}`);

        if (!crimeData) {
            // 이미 해결됨 - 잠시 대기 후 복귀
            console.log(`[Crime] Crime already resolved at (${crimeX}, ${crimeY})`);

            if (vehicle && vehicle.mesh) {
                vehicle.state = 'working';
                vehicle.activity = '🔍 현장 확인 중...';
                vehicle.workStartTime = Date.now() - 2000;  // 2초만 대기
                vehicle.isParked = true;
            } else {
                startPoliceCarReturn(vehicle);
            }
            return;
        }

        crimeData.policeArrived = true;

        // 범인 체포 (사건 해결)
        console.log(`[Crime] Resolving crime at (${crimeX}, ${crimeY})`);
        resolveCrime(key, true);

        // 수감자 추가 (범인 체포)
        if (vehicle && vehicle.stationKey) {
            addPrisoner(vehicle.stationKey);
        }

        // 일일 통계 업데이트 - 체포된 범죄자
        dailyStats.crime.arrestedCriminals++;
        updateDailyStatsPanel();

        // 경찰차 현장 조사 후 복귀
        if (vehicle && vehicle.mesh) {
            vehicle.state = 'working';
            vehicle.activity = '📋 현장 조사 중...';
            vehicle.workStartTime = Date.now();

            // 갓길 주차
            const offsetX = Math.cos(vehicle.rotation) * 0.15;
            const offsetZ = Math.sin(vehicle.rotation) * 0.15;
            vehicle.parkPosition = {
                x: vehicle.position.x + offsetZ,
                z: vehicle.position.z + offsetX
            };
            vehicle.mesh.position.x = vehicle.parkPosition.x;
            vehicle.mesh.position.z = vehicle.parkPosition.z;
            vehicle.isParked = true;

            console.log(`[Crime] Police car parked, state: ${vehicle.state}`);
        }
    }

    /**
     * 경찰차 경찰서 복귀 시작
     */
    function startPoliceCarReturn(vehicle) {
        if (!vehicle || !vehicle.originStation) {
            if (vehicle) trafficManager.despawnVehicle(vehicle);
            return;
        }

        const stationX = vehicle.originStation.x;
        const stationY = vehicle.originStation.y;

        // 현재 위치에서 가장 가까운 도로 타일 찾기
        const currentRoadTile = findNearestRoadTile(
            Math.floor(vehicle.position.x / TILE_SIZE + GRID_W / 2),
            Math.floor(vehicle.position.z / TILE_SIZE + GRID_H / 2)
        );

        if (!currentRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 경찰서 주변 도로 찾기
        const stationRoadTile = findNearestRoadTile(stationX, stationY);
        if (!stationRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 경로 계산
        const returnPath = trafficManager.findPath(
            currentRoadTile.x, currentRoadTile.y,
            stationRoadTile.x, stationRoadTile.y
        );

        if (!returnPath || returnPath.length < 2) {
            console.log('[Crime] No return path found, despawning');
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 모드 설정
        vehicle.isReturning = true;
        vehicle.crimeTarget = null;
        vehicle.path = returnPath;
        vehicle.pathIndex = 0;
        vehicle.currentTile = { x: returnPath[0].x, y: returnPath[0].y };
        vehicle.targetTile = { x: returnPath[1].x, y: returnPath[1].y };
        vehicle.progress = 0;
        vehicle.state = 'moving';
        vehicle.isParked = false;
        vehicle.activity = '🏠 경찰서로 복귀 중';
        vehicle.destTypeName = '경찰서';

        // 속도를 일반 속도로 낮춤
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 1.15;
        vehicle.targetSpeed = vehicle.speed;

        console.log(`[Crime] Police car returning to station at (${stationX}, ${stationY})`);
    }

    /**
     * 건물이 경찰서 범위 내에 있는지 확인
     */
    function isInPoliceStationRange(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return false;

        // 경찰서가 하나라도 있으면 범위 내로 간주 (전역 효과)
        for (const [, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'police') {
                return true;
            }
        }
        return false;
    }

    /**
     * 강도 사건 발생 체크 (확률 기반)
     */
    function checkCrimeOutbreak() {
        if (typeof placedBuildings === 'undefined') return;

        // 경찰서 범위 체크 - 경찰서가 있으면 발생 확률 크게 감소
        const hasPolice = isInPoliceStationRange(0, 0);
        const policeReduction = hasPolice ? 0.3 : 1.0;  // 경찰서 있으면 30%로 감소

        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData || userData.isAbandoned) continue;

            // 이미 사건 중이면 스킵
            if (activeCrimes.has(key)) continue;

            // 건물 타입 확인
            const zoneType = userData.zoneType || '';
            const isCommercial = zoneType.includes('commercial');
            const isResidential = zoneType.includes('resident');

            if (!isCommercial && !isResidential) continue;

            // 발생 확률 계산
            let crimeChance = CRIME_BASE_CHANCE * policeReduction;
            if (isCommercial) {
                crimeChance *= CRIME_COMMERCIAL_MULTIPLIER;  // 상업 건물은 3배 확률
            }

            // 확률 체크
            if (Math.random() < crimeChance) {
                startCrime(x, y, isCommercial);
            }
        }
    }

    /**
     * 강도 사건 진행 업데이트
     */
    function updateCrimeProgress() {
        const now = Date.now();

        activeCrimes.forEach((crimeData, key) => {
            // 이펙트 애니메이션 업데이트
            updateCrimeEffects(crimeData);

            // 경찰이 도착했으면 이미 처리됨
            if (crimeData.policeArrived) return;

            // 제한시간 체크 (경찰이 도착하지 못하면 범인 도주)
            const elapsed = now - crimeData.startTime;

            if (elapsed >= CRIME_RESOLUTION_TIME) {
                // 범인 도주 - 피해 발생
                applyCrimeDamage(crimeData.x, crimeData.y, crimeData.isCommercial);
                resolveCrime(key, false);
            }
        });

        // 경찰차 출동 재시도
        if (now - lastCrimeRetryTime > CRIME_RETRY_INTERVAL) {
            lastCrimeRetryTime = now;
            retryCrimeDispatch();
        }
    }

    /**
     * 범죄 피해 적용 (체포 실패 시 건물 폐건물화)
     */
    function applyCrimeDamage(x, y, isCommercial) {
        // 일일 통계 업데이트 - 도주한 범죄자
        dailyStats.crime.escapedCriminals++;
        updateDailyStatsPanel();
        checkDailyStatsWarnings();

        // 돈 피해 (상업 건물은 2배)
        const moneyDamage = isCommercial ? CRIME_DAMAGE_MONEY * 2 : CRIME_DAMAGE_MONEY;
        if (typeof economy !== 'undefined') {
            economy.money = Math.max(0, economy.money - moneyDamage);
        }

        // 건물을 폐건물로 전환 (강도 사건으로 인한 이탈)
        const key = `${x},${y}`;
        const building = placedBuildings.get(key);
        if (building && building.instance) {
            const userData = building.instance.userData;
            if (userData && !userData.isAbandoned) {
                // 폐건물 사유 저장
                userData.abandonedReason = '강도 사건 때문에 못살겠어요!';
                markBuildingAbandoned(building, key);
            }
        }

        console.log(`[Crime] Damage applied: building abandoned at (${x}, ${y}), money -${moneyDamage}`);
    }

    /**
     * 강도 사건 이펙트 업데이트 (애니메이션)
     */
    function updateCrimeEffects(crimeData) {
        if (!crimeData.effects || !crimeData.effects.group) return;

        const time = Date.now() / 1000;
        const userData = crimeData.effects.group.userData;
        if (!userData) return;

        // 수갑 아이콘 위아래 흔들림 + 깜빡임
        if (crimeData.effects.sprite) {
            const bobbing = Math.sin(time * 4) * 0.1;
            crimeData.effects.sprite.position.y = userData.baseY + bobbing;

            // 깜빡임 효과
            if (userData.spriteMaterial) {
                userData.spriteMaterial.opacity = 0.7 + Math.sin(time * 6) * 0.3;
            }
        }
    }

    /**
     * 경찰차 출동 재시도
     */
    function retryCrimeDispatch() {
        activeCrimes.forEach((crimeData, key) => {
            if (crimeData.policeDispatched || crimeData.policeArrived) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            const nearestStation = findNearestPoliceStation(x, y);
            if (!nearestStation) return;

            const policeCar = dispatchPoliceCar(x, y, nearestStation);
            if (policeCar) {
                crimeData.policeDispatched = true;
                dispatchedPoliceCars.set(key, { vehicle: policeCar, stationKey: nearestStation.key });
                console.log(`[Crime] Retry dispatched police to crime at (${x}, ${y})`);
            }
        });
    }

    /**
     * 경찰서 설치 시 기존 사건에 경찰차 출동
     */
    function dispatchPoliceToExistingCrimes() {
        if (!activeCrimes || activeCrimes.size === 0) return;

        let dispatched = 0;

        activeCrimes.forEach((crimeData, key) => {
            if (crimeData.policeDispatched) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            const nearestStation = findNearestPoliceStation(x, y);
            if (!nearestStation) return;

            const policeCar = dispatchPoliceCar(x, y, nearestStation);
            if (policeCar) {
                crimeData.policeDispatched = true;
                dispatchedPoliceCars.set(key, { vehicle: policeCar, stationKey: nearestStation.key });
                dispatched++;

                console.log(`[Crime] Dispatched police to existing crime at (${x}, ${y})`);
            }
        });

        if (dispatched > 0) {
            toast({
                title: '🚔 경찰차 출동!',
                desc: `${dispatched}건의 사건에 경찰차가 출동했습니다!`,
                ms: 3000
            });
        }
    }

    /**
     * 강도 사건 시스템 전체 업데이트
     */
    function updateCrimeSystem() {
        checkCrimeOutbreak();
        updateCrimeProgress();

        // 수감자 석방 체크 (5초마다)
        const now = Date.now();
        if (now - lastPrisonerReleaseCheck > 5000) {
            releasePrisoners();
            lastPrisonerReleaseCheck = now;
        }
    }

    // ===== 의료 응급 시스템 (MEDICAL EMERGENCY SYSTEM) =====
    // 의료 응급 관련 상수
    const MEDICAL_BASE_CHANCE = 0.000015;          // 기본 발생 확률 (프레임당)
    const MEDICAL_DEATH_TIME = 30000;               // 미치료 시 사망 시간 30초
    const MEDICAL_RETRY_INTERVAL = 5000;            // 구급차 재출동 간격 5초
    const MEDICAL_AMBULANCE_WORK_TIME = 5000;       // 환자 이송 준비 시간 5초
    const MEDICAL_DAMAGE_HAPPINESS = -20;           // 사망 시 행복도 피해

    // 병원 시스템 상수
    const MAX_PATIENTS_PER_HOSPITAL = 8;            // 병원당 최대 환자 수용
    const PATIENT_DISCHARGE_TIME = 45000;           // 환자 퇴원 시간 (45초)
    const MAX_AMBULANCES_PER_HOSPITAL = 2;          // 병원당 최대 구급차 수

    // 의료 응급 데이터 구조
    const activeMedicalEmergencies = new Map();     // key: "x,y", value: emergencyData
    const dispatchedAmbulances = new Map();         // key: emergencyKey, value: { vehicle, hospitalKey }
    const hospitalAmbulanceCount = new Map();       // key: hospitalKey, value: 출동 중 구급차 수
    const hospitalPatients = new Map();             // key: hospitalKey, value: [{ admitTime }]
    let lastMedicalRetryTime = 0;
    let lastPatientDischargeCheck = 0;

    /**
     * 가장 가까운 병원 찾기 (여유 있는 병원 우선, 환자 정원 체크)
     */
    function findNearestHospital(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return null;

        let nearest = null;
        let minDistance = Infinity;

        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type !== 'hospital') continue;

            // 현재 출동 중인 구급차 수 체크
            const currentCount = hospitalAmbulanceCount.get(key) || 0;
            if (currentCount >= MAX_AMBULANCES_PER_HOSPITAL) continue;

            // 환자 정원 체크 - 가득 차면 출동 불가
            const patients = hospitalPatients.get(key) || [];
            if (patients.length >= MAX_PATIENTS_PER_HOSPITAL) {
                console.log(`[Medical] Hospital ${key} full (${patients.length}/${MAX_PATIENTS_PER_HOSPITAL})`);
                continue;
            }

            // 병원 중심 좌표 계산
            const bx = building.x;
            const by = building.y;
            const centerX = bx + 1;  // 2x2 건물 중심
            const centerY = by + 1;

            const dx = centerX - x;
            const dy = centerY - y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < minDistance) {
                minDistance = distance;
                nearest = { key, x: bx, y: by, centerX, centerY, distance };
            }
        }

        return nearest;
    }

    /**
     * 병원에 환자 입원
     */
    function addPatientToHospital(hospitalKey) {
        if (!hospitalKey) return;
        const patients = hospitalPatients.get(hospitalKey) || [];
        patients.push({ admitTime: Date.now() });
        hospitalPatients.set(hospitalKey, patients);
        console.log(`[Medical] Patient admitted to ${hospitalKey} (${patients.length}/${MAX_PATIENTS_PER_HOSPITAL})`);
    }

    /**
     * 환자 퇴원 (입원 시간이 지난 환자)
     */
    function dischargePatients() {
        const now = Date.now();
        let totalDischarged = 0;

        for (const [hospitalKey, patients] of hospitalPatients) {
            const remaining = patients.filter(p => (now - p.admitTime) < PATIENT_DISCHARGE_TIME);
            const discharged = patients.length - remaining.length;
            if (discharged > 0) {
                hospitalPatients.set(hospitalKey, remaining);
                totalDischarged += discharged;
                dailyStats.medical.dischargedPatients += discharged;
                console.log(`[Medical] ${discharged} patient(s) discharged from ${hospitalKey} (${remaining.length}/${MAX_PATIENTS_PER_HOSPITAL})`);
            }
        }

        return totalDischarged;
    }

    /**
     * 전체 입원 환자 수 계산
     */
    function getTotalHospitalPatients() {
        let total = 0;
        for (const [, patients] of hospitalPatients) {
            total += patients.length;
        }
        return total;
    }

    /**
     * 전체 병원 정원 계산
     */
    function getTotalHospitalCapacity() {
        let capacity = 0;
        for (const [key, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'hospital') {
                capacity += MAX_PATIENTS_PER_HOSPITAL;
            }
        }
        return capacity;
    }

    /**
     * 전체 환자 수 계산
     */
    function getTotalPatients() {
        let total = 0;
        for (const [, patients] of hospitalPatients) {
            total += patients.length;
        }
        return total;
    }

    /**
     * 구급차 출동
     */
    function dispatchAmbulance(emergencyX, emergencyY, hospital) {
        if (!trafficManager || !trafficManager.initialized) {
            console.warn('[Medical] Traffic not initialized, cannot dispatch ambulance');
            return null;
        }

        // 병원 인접 도로 찾기
        const hospitalRoad = trafficManager.findNearestRoad(hospital.x, hospital.y);
        if (!hospitalRoad) {
            console.warn('[Medical] No road near hospital');
            return null;
        }

        // 응급 현장 인접 도로 찾기
        const emergencyRoad = trafficManager.findNearestRoad(emergencyX, emergencyY);
        if (!emergencyRoad) {
            console.warn('[Medical] No road near emergency location');
            return null;
        }

        // 경로 찾기
        const path = trafficManager.findPath(hospitalRoad.x, hospitalRoad.y, emergencyRoad.x, emergencyRoad.y);
        if (!path || path.length < 2) {
            console.warn('[Medical] No path to emergency location');
            return null;
        }

        // 구급차 스폰
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) {
            console.warn('[Medical] No vehicle available');
            return null;
        }

        // 이전 사용에서 남은 속성 초기화
        vehicle.isFiretruck = false;
        vehicle.isPoliceCar = false;
        vehicle.isMoveInVehicle = false;
        vehicle.isConstructionTruck = false;
        vehicle.constructionSite = null;
        vehicle.fireTarget = null;
        vehicle.crimeTarget = null;
        vehicle.isReturning = false;
        vehicle.workStartTime = null;
        vehicle.isParked = false;
        vehicle.enterProgress = 0;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 구급차 타입으로 설정
        vehicle.vehicleTypeKey = 'ambulance';
        vehicle.type = 'ambulance';
        const vehicleTypeConfig = VEHICLE_TYPES['ambulance'];

        // 메쉬 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh('ambulance');
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 사이렌 라이트 추가
        const sirenLights = createSirenLights('ambulance');
        newMesh.add(sirenLights);
        vehicle.sirenLights = sirenLights;

        // 구급차 특수 속성
        vehicle.isAmbulance = true;
        vehicle.emergencyTarget = { x: emergencyX, y: emergencyY };
        vehicle.originBuilding = { x: hospital.x, y: hospital.y };
        vehicle.originHospital = { x: hospital.x, y: hospital.y };
        vehicle.hospitalKey = hospital.key;
        vehicle.destBuilding = { x: emergencyX, y: emergencyY };
        vehicle.activity = '🚑 응급환자에게 출동 중!';
        vehicle.originTypeName = '병원';
        vehicle.destTypeName = '응급 현장';
        vehicle.isReturning = false;

        // 병원 출동 카운트 증가
        const currentCount = hospitalAmbulanceCount.get(hospital.key) || 0;
        hospitalAmbulanceCount.set(hospital.key, currentCount + 1);

        // 속도 설정 (구급차는 다른 차량보다 빠름)
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 2.3;
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        console.log(`[Medical] Ambulance dispatched from (${hospital.x},${hospital.y}) to (${emergencyX},${emergencyY})`);
        return vehicle;
    }

    /**
     * 의료 응급 발생
     */
    function startMedicalEmergency(x, y) {
        const key = `${x},${y}`;
        if (activeMedicalEmergencies.has(key)) return;  // 이미 응급 진행 중

        // 의료 응급 이펙트 생성
        const effects = createMedicalEffect(x, y);

        const emergencyData = {
            startTime: Date.now(),
            effects: effects,
            x, y,
            ambulanceDispatched: false,
            ambulanceArrived: false
        };

        activeMedicalEmergencies.set(key, emergencyData);

        // 일일 통계 업데이트
        dailyStats.medical.totalEmergencies++;
        updateDailyStatsPanel();

        console.log(`[Medical] Emergency started at (${x}, ${y})`);

        // 병원 찾아서 구급차 출동
        const nearestHospital = findNearestHospital(x, y);
        if (nearestHospital) {
            const ambulance = dispatchAmbulance(x, y, nearestHospital);
            if (ambulance) {
                emergencyData.ambulanceDispatched = true;
                dispatchedAmbulances.set(key, { vehicle: ambulance, hospitalKey: nearestHospital.key });
            }
        }
    }

    /**
     * 의료 응급 이펙트 생성 (하트 아이콘 + 깜빡임)
     */
    function createMedicalEffect(x, y) {
        const group = new THREE.Group();

        // 건물 높이 추정
        const building = placedBuildings.get(`${x},${y}`);
        let buildingHeight = 1;
        if (building && building.instance) {
            const bbox = new THREE.Box3().setFromObject(building.instance);
            buildingHeight = bbox.max.y;
        }

        // 하트 아이콘 스프라이트 (빨간 배경 원 + 하트)
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = 128;
        iconCanvas.height = 128;
        const ctx = iconCanvas.getContext('2d');

        // 흰색 원 배경
        ctx.beginPath();
        ctx.arc(64, 64, 56, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(220, 50, 50, 0.9)';
        ctx.lineWidth = 4;
        ctx.stroke();

        // 적십자 (Red Cross)
        ctx.fillStyle = 'rgba(220, 50, 50, 1)';
        // 가로 막대
        ctx.fillRect(24, 52, 80, 24);
        // 세로 막대
        ctx.fillRect(52, 24, 24, 80);

        const texture = new THREE.CanvasTexture(iconCanvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(0.6, 0.6, 1);
        sprite.position.set(0, buildingHeight + 0.5, 0);
        sprite.name = 'medicalIcon';
        group.add(sprite);

        // 아이콘 애니메이션 데이터
        group.userData = {
            phase: 0,
            baseY: buildingHeight + 0.5,
            spriteMaterial: spriteMaterial
        };

        // 월드 좌표로 배치
        const worldPos = tileToWorldCenter(x, y);
        group.position.set(worldPos.x, 0, worldPos.z);

        // 이펙트 그룹에 추가
        if (typeof fireEffectsGroup !== 'undefined') {
            fireEffectsGroup.add(group);
        }

        return {
            group,
            sprite
        };
    }

    /**
     * 의료 응급 해결
     */
    function resolveMedicalEmergency(key, byAmbulance = false) {
        const emergencyData = activeMedicalEmergencies.get(key);
        if (!emergencyData) return;

        // 이펙트 제거
        if (emergencyData.effects && emergencyData.effects.group) {
            const group = emergencyData.effects.group;

            // userData 참조 먼저 정리
            if (group.userData) {
                group.userData.spriteMaterial = null;
                group.userData = null;
            }

            // 스프라이트 visible 먼저 false
            if (emergencyData.effects.sprite) {
                emergencyData.effects.sprite.visible = false;
            }

            // 씬에서 제거
            if (typeof fireEffectsGroup !== 'undefined') {
                fireEffectsGroup.remove(group);
            }

            // 다음 프레임에서 dispose (렌더링 완료 후)
            requestAnimationFrame(() => {
                group.traverse((child) => {
                    if (child.geometry) {
                        child.geometry.dispose();
                    }
                    if (child.material) {
                        // CanvasTexture는 dispose 후 가비지 컬렉터가 정리
                        // 재질만 명시적으로 dispose
                        child.material.dispose();
                    }
                });
            });

            // effects 참조 정리
            emergencyData.effects.group = null;
            emergencyData.effects.sprite = null;
        }

        // 출동 중인 구급차 정보 제거
        dispatchedAmbulances.delete(key);

        activeMedicalEmergencies.delete(key);
        console.log(`[Medical] Emergency resolved at ${key}` + (byAmbulance ? ' by ambulance' : ' (patient died)'));
    }

    /**
     * 구급차 도착 처리
     */
    function onAmbulanceArrival(emergencyX, emergencyY, vehicle) {
        const key = `${emergencyX},${emergencyY}`;
        const emergencyData = activeMedicalEmergencies.get(key);

        console.log(`[Medical] onAmbulanceArrival called for (${emergencyX}, ${emergencyY}), emergencyData exists: ${!!emergencyData}`);

        if (!emergencyData) {
            // 이미 해결됨 - 잠시 대기 후 복귀
            console.log(`[Medical] Emergency already resolved at (${emergencyX}, ${emergencyY})`);

            if (vehicle && vehicle.mesh) {
                vehicle.state = 'working';
                vehicle.activity = '🔍 현장 확인 중...';
                vehicle.workStartTime = Date.now() - 3000;  // 2초만 대기
                vehicle.isParked = true;
            } else {
                startAmbulanceReturn(vehicle);
            }
            return;
        }

        emergencyData.ambulanceArrived = true;

        // 환자 구조 (응급 해결)
        console.log(`[Medical] Resolving emergency at (${emergencyX}, ${emergencyY})`);
        resolveMedicalEmergency(key, true);

        // 병원에 환자 입원
        if (vehicle && vehicle.hospitalKey) {
            addPatientToHospital(vehicle.hospitalKey);
        }

        // 일일 통계 업데이트 - 구조된 환자
        dailyStats.medical.savedPatients++;
        updateDailyStatsPanel();

        // 구급차 현장 이송 준비 후 복귀
        if (vehicle && vehicle.mesh) {
            vehicle.state = 'working';
            vehicle.activity = '🏥 환자 이송 준비 중...';
            vehicle.workStartTime = Date.now();

            // 갓길 주차
            const offsetX = Math.cos(vehicle.rotation) * 0.15;
            const offsetZ = Math.sin(vehicle.rotation) * 0.15;
            vehicle.parkPosition = {
                x: vehicle.position.x + offsetZ,
                z: vehicle.position.z + offsetX
            };
            vehicle.mesh.position.x = vehicle.parkPosition.x;
            vehicle.mesh.position.z = vehicle.parkPosition.z;
            vehicle.isParked = true;

            console.log(`[Medical] Ambulance parked, state: ${vehicle.state}`);
        }
    }

    /**
     * 구급차 병원 복귀 시작
     */
    function startAmbulanceReturn(vehicle) {
        if (!vehicle || !vehicle.originHospital) {
            if (vehicle) trafficManager.despawnVehicle(vehicle);
            return;
        }

        const hospitalX = vehicle.originHospital.x;
        const hospitalY = vehicle.originHospital.y;

        // 현재 위치에서 가장 가까운 도로 타일 찾기
        const currentRoadTile = findNearestRoadTile(
            Math.floor(vehicle.position.x / TILE_SIZE + GRID_W / 2),
            Math.floor(vehicle.position.z / TILE_SIZE + GRID_H / 2)
        );

        if (!currentRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 병원 주변 도로 찾기
        const hospitalRoadTile = findNearestRoadTile(hospitalX, hospitalY);
        if (!hospitalRoadTile) {
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 경로 계산
        const returnPath = trafficManager.findPath(
            currentRoadTile.x, currentRoadTile.y,
            hospitalRoadTile.x, hospitalRoadTile.y
        );

        if (!returnPath || returnPath.length < 2) {
            console.log('[Medical] No return path found, despawning');
            trafficManager.despawnVehicle(vehicle);
            return;
        }

        // 복귀 모드 설정
        vehicle.isReturning = true;
        vehicle.emergencyTarget = null;
        vehicle.path = returnPath;
        vehicle.pathIndex = 0;
        vehicle.currentTile = { x: returnPath[0].x, y: returnPath[0].y };
        vehicle.targetTile = { x: returnPath[1].x, y: returnPath[1].y };
        vehicle.progress = 0;
        vehicle.state = 'moving';
        vehicle.isParked = false;
        vehicle.activity = '🏠 병원으로 복귀 중';
        vehicle.destTypeName = '병원';

        // 복귀 시에도 긴급 속도 유지 (환자 이송 완료 후 다음 출동 대비)
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * 1.5;
        vehicle.targetSpeed = vehicle.speed;

        console.log(`[Medical] Ambulance returning to hospital at (${hospitalX}, ${hospitalY})`);
    }

    /**
     * 건물이 병원 범위 내에 있는지 확인
     */
    function isInHospitalRange(x, y) {
        if (typeof placedPublicBuildings === 'undefined') return false;

        // 병원이 하나라도 있으면 범위 내로 간주 (전역 효과)
        for (const [, building] of placedPublicBuildings) {
            if (building.ref) continue;
            if (building.type === 'hospital') {
                return true;
            }
        }
        return false;
    }

    /**
     * 의료 응급 발생 체크 (확률 기반)
     */
    function checkMedicalOutbreak() {
        if (typeof placedBuildings === 'undefined') return;

        // 병원 범위 체크 - 병원이 있으면 발생 확률 크게 감소
        const hasHospital = isInHospitalRange(0, 0);
        const hospitalReduction = hasHospital ? 0.4 : 1.0;  // 병원 있으면 40%로 감소

        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData || userData.isAbandoned) continue;

            // 이미 응급 중이면 스킵
            if (activeMedicalEmergencies.has(key)) continue;

            // 주거 건물에서만 응급환자 발생
            const zoneType = userData.zoneType || '';
            const isResidential = zoneType.includes('resident');

            if (!isResidential) continue;

            // 발생 확률 계산
            let medicalChance = MEDICAL_BASE_CHANCE * hospitalReduction;

            // 확률 체크
            if (Math.random() < medicalChance) {
                startMedicalEmergency(x, y);
            }
        }
    }

    /**
     * 의료 응급 진행 업데이트
     */
    function updateMedicalProgress() {
        const now = Date.now();

        activeMedicalEmergencies.forEach((emergencyData, key) => {
            // 이펙트 애니메이션 업데이트
            updateMedicalEffects(emergencyData);

            // 구급차가 도착했으면 이미 처리됨
            if (emergencyData.ambulanceArrived) return;

            // 제한시간 체크 (구급차가 도착하지 못하면 환자 사망)
            const elapsed = now - emergencyData.startTime;

            if (elapsed >= MEDICAL_DEATH_TIME) {
                // 환자 사망 - 피해 발생
                applyMedicalDeath(emergencyData.x, emergencyData.y);
                resolveMedicalEmergency(key, false);
            }
        });

        // 구급차 출동 재시도
        if (now - lastMedicalRetryTime > MEDICAL_RETRY_INTERVAL) {
            lastMedicalRetryTime = now;
            retryMedicalDispatch();
        }
    }

    /**
     * 환자 사망 피해 적용 (구급차 미도착 시)
     */
    function applyMedicalDeath(x, y) {
        // 일일 통계 업데이트 - 사망 환자
        dailyStats.medical.deadPatients++;
        updateDailyStatsPanel();
        checkDailyStatsWarnings();

        // 행복도 피해
        if (typeof cityStats !== 'undefined') {
            cityStats.happiness = Math.max(0, (cityStats.happiness || 50) + MEDICAL_DAMAGE_HAPPINESS);
        }

        console.log(`[Medical] Patient died at (${x}, ${y}), happiness ${MEDICAL_DAMAGE_HAPPINESS}`);
    }

    /**
     * 의료 응급 이펙트 업데이트 (애니메이션)
     */
    function updateMedicalEffects(emergencyData) {
        if (!emergencyData.effects || !emergencyData.effects.group) return;

        const time = Date.now() / 1000;
        const userData = emergencyData.effects.group.userData;
        if (!userData) return;

        // 하트 아이콘 위아래 흔들림 + 깜빡임 (더 빠르게)
        if (emergencyData.effects.sprite) {
            const bobbing = Math.sin(time * 5) * 0.1;
            emergencyData.effects.sprite.position.y = userData.baseY + bobbing;

            // 깜빡임 효과 (빠르게)
            if (userData.spriteMaterial) {
                userData.spriteMaterial.opacity = 0.6 + Math.sin(time * 8) * 0.4;
            }
        }
    }

    /**
     * 구급차 출동 재시도
     */
    function retryMedicalDispatch() {
        activeMedicalEmergencies.forEach((emergencyData, key) => {
            if (emergencyData.ambulanceDispatched || emergencyData.ambulanceArrived) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            const nearestHospital = findNearestHospital(x, y);
            if (!nearestHospital) return;

            const ambulance = dispatchAmbulance(x, y, nearestHospital);
            if (ambulance) {
                emergencyData.ambulanceDispatched = true;
                dispatchedAmbulances.set(key, { vehicle: ambulance, hospitalKey: nearestHospital.key });
                console.log(`[Medical] Retry dispatched ambulance to emergency at (${x}, ${y})`);
            }
        });
    }

    /**
     * 병원 설치 시 기존 응급에 구급차 출동
     */
    function dispatchAmbulanceToExistingEmergencies() {
        if (!activeMedicalEmergencies || activeMedicalEmergencies.size === 0) return;

        let dispatched = 0;

        activeMedicalEmergencies.forEach((emergencyData, key) => {
            if (emergencyData.ambulanceDispatched) return;

            const [xStr, yStr] = key.split(',');
            const x = parseInt(xStr);
            const y = parseInt(yStr);

            const nearestHospital = findNearestHospital(x, y);
            if (!nearestHospital) return;

            const ambulance = dispatchAmbulance(x, y, nearestHospital);
            if (ambulance) {
                emergencyData.ambulanceDispatched = true;
                dispatchedAmbulances.set(key, { vehicle: ambulance, hospitalKey: nearestHospital.key });
                dispatched++;

                console.log(`[Medical] Dispatched ambulance to existing emergency at (${x}, ${y})`);
            }
        });

        if (dispatched > 0) {
            toast({
                title: '🚑 구급차 출동!',
                desc: `${dispatched}건의 응급에 구급차가 출동했습니다!`,
                ms: 3000
            });
        }
    }

    /**
     * 의료 응급 시스템 전체 업데이트
     */
    function updateMedicalSystem() {
        checkMedicalOutbreak();
        updateMedicalProgress();

        // 환자 퇴원 체크 (5초마다)
        const now = Date.now();
        if (now - lastPatientDischargeCheck > 5000) {
            dischargePatients();
            lastPatientDischargeCheck = now;
        }
    }

    // ===== 도시 전체 행복도 시스템 =====
    let previousCityHappiness = 50;  // 이전 행복도 (추세 계산용)
    let cityHappinessHistory = [];   // 행복도 이력 (추세 계산용)
    const CITY_HAPPINESS_UPDATE_INTERVAL = 2000;  // 2초마다 업데이트
    let lastCityHappinessUpdate = 0;

    /**
     * 도시 전체 행복도 평균 계산 (인구 가중 평균)
     */
    function calculateCityHappiness() {
        if (typeof placedBuildings === 'undefined') return 50;

        let totalHappiness = 0;
        let totalPopulation = 0;

        // 최적화: Array 캐시 사용
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData || userData.isAbandoned) continue;

            // 주거 건물만 인구 가중치 적용
            const zoneType = userData.zoneType || '';
            const isResidential = zoneType.includes('resident');

            // 건물 행복도 계산
            const happiness = calculateBuildingHappiness(x, y);

            if (isResidential) {
                // 인구 가중 평균 (주거 건물)
                const size = userData.size || '1x1';
                const tier = userData.tier || 'low';
                const capacityKey = `${size}_${tier}`;
                const population = BUILDING_CAPACITY[capacityKey] || 2;

                totalHappiness += happiness * population;
                totalPopulation += population;
            } else {
                // 상업/산업 건물은 가중치 1
                totalHappiness += happiness;
                totalPopulation += 1;
            }
        }

        if (totalPopulation === 0) return 50;
        return Math.round(totalHappiness / totalPopulation);
    }

    // 행복도에 따른 그라데이션 색상 계산 (빨강 → 노랑 → 초록)
    function getHappinessColor(happiness) {
        // 0 = 빨강(#f87171), 50 = 노랑(#fbbf24), 100 = 초록(#4ade80)
        const h = Math.max(0, Math.min(100, happiness));

        if (h <= 50) {
            // 빨강 → 노랑 (0-50)
            const ratio = h / 50;
            const r = Math.round(248 + (251 - 248) * ratio);  // 248 → 251
            const g = Math.round(113 + (191 - 113) * ratio);  // 113 → 191
            const b = Math.round(113 + (36 - 113) * ratio);   // 113 → 36
            return `rgb(${r}, ${g}, ${b})`;
        } else {
            // 노랑 → 초록 (50-100)
            const ratio = (h - 50) / 50;
            const r = Math.round(251 + (74 - 251) * ratio);   // 251 → 74
            const g = Math.round(191 + (222 - 191) * ratio);  // 191 → 222
            const b = Math.round(36 + (128 - 36) * ratio);    // 36 → 128
            return `rgb(${r}, ${g}, ${b})`;
        }
    }

    /**
     * 도시 행복도 UI 업데이트
     */
    function updateCityHappinessDisplay() {
        const now = Date.now();
        if (now - lastCityHappinessUpdate < CITY_HAPPINESS_UPDATE_INTERVAL) return;
        lastCityHappinessUpdate = now;

        const happiness = calculateCityHappiness();

        // cityStats에도 저장
        cityStats.happiness = happiness;

        // UI 요소
        const iconEl = document.getElementById('cityHappinessIcon');
        const numberEl = document.getElementById('cityHappinessNumber');
        const trendEl = document.getElementById('cityHappinessTrend');

        if (!numberEl) return;

        // 숫자 업데이트 (정확한 정수 표시)
        numberEl.textContent = happiness;

        // 동적 색상 적용 (그라데이션)
        numberEl.style.color = getHappinessColor(happiness);

        // 이모지 업데이트 (더 세분화)
        if (iconEl) {
            if (happiness <= 20) {
                iconEl.textContent = '😭';
            } else if (happiness <= 35) {
                iconEl.textContent = '😢';
            } else if (happiness <= 45) {
                iconEl.textContent = '😟';
            } else if (happiness <= 55) {
                iconEl.textContent = '😐';
            } else if (happiness <= 75) {
                iconEl.textContent = '🙂';
            } else {
                iconEl.textContent = '😊';
            }
        }

        // 추세 업데이트 (이력 기반)
        if (trendEl) {
            cityHappinessHistory.push(happiness);
            if (cityHappinessHistory.length > 5) {
                cityHappinessHistory.shift();
            }

            if (cityHappinessHistory.length >= 2) {
                const oldAvg = cityHappinessHistory.slice(0, -1).reduce((a, b) => a + b, 0) / (cityHappinessHistory.length - 1);
                const diff = happiness - oldAvg;

                trendEl.classList.remove('up', 'down', 'stable');
                if (diff > 2) {
                    trendEl.textContent = '↑';
                    trendEl.classList.add('up');
                } else if (diff < -2) {
                    trendEl.textContent = '↓';
                    trendEl.classList.add('down');
                } else {
                    trendEl.textContent = '→';
                    trendEl.classList.add('stable');
                }
            }
        }

        previousCityHappiness = happiness;
    }

    // 낮은 행복도 건물 체크 및 폐건물 전환 (5초마다 호출)
    let lastHappinessCheckTime = 0;
    const HAPPINESS_CHECK_INTERVAL = 5000;  // 5초마다 체크

    function updateBuildingHappinessStatus() {
        const now = Date.now();
        if (now - lastHappinessCheckTime < HAPPINESS_CHECK_INTERVAL) return;
        lastHappinessCheckTime = now;

        if (typeof placedBuildings === 'undefined') return;

        placedBuildings.forEach((building, key) => {
            if (building.ref) return;  // 참조 건물 스킵

            const { x, y, instance } = building;
            const userData = instance?.userData;
            if (!userData) return;

            // 이미 폐건물이면 스킵
            if (userData.isAbandoned) return;

            // 행복도 계산
            const happiness = calculateBuildingHappiness(x, y);

            // 행복도 20 이하일 때만 폐건물 전환 가능
            if (happiness <= ABANDON_HAPPINESS_THRESHOLD) {
                // 낮은 행복도 시작 추적 (랜덤 폐건물화 시간 설정)
                if (!buildingLowHappinessTime.has(key)) {
                    // 각 건물마다 랜덤한 폐건물화 시간 설정
                    const randomAbandonTime = MIN_ABANDON_TIME + Math.random() * (MAX_ABANDON_TIME - MIN_ABANDON_TIME);
                    buildingLowHappinessTime.set(key, {
                        startTime: now,
                        abandonTime: randomAbandonTime,
                        building: building
                    });
                    console.log(`Building at (${x},${y}) entered critical happiness (${happiness}), abandon in ${Math.round(randomAbandonTime/1000)}s`);
                } else {
                    // 낮은 행복도 지속 시간 체크
                    const trackData = buildingLowHappinessTime.get(key);
                    const duration = now - trackData.startTime;

                    if (duration >= trackData.abandonTime) {
                        // 폐건물로 전환
                        const userData = building.instance?.userData;
                        if (userData) {
                            userData.abandonedReason = '행복도가 너무 낮아서 이사갑니다...';
                        }
                        convertToAbandonedBuilding(building, key);
                        buildingLowHappinessTime.delete(key);
                        console.log(`Building at (${x},${y}) converted to abandoned after ${Math.round(duration/1000)}s of low happiness (${happiness})`);
                    }
                }
            } else {
                // 행복도 회복 (20 초과) - 추적 중지
                if (buildingLowHappinessTime.has(key)) {
                    buildingLowHappinessTime.delete(key);
                    console.log(`Building at (${x},${y}) happiness recovered to ${happiness}`);
                }
            }
        });
    }

    // 건물을 폐건물로 전환
    function convertToAbandonedBuilding(building, key) {
        const { instance } = building;
        const userData = instance?.userData;
        if (!userData || userData.isAbandoned) return;

        userData.isAbandoned = true;
        building.isAbandoned = true;
        abandonedBuildings.add(key);

        // 회색 적용 (applyAbandonedMaterials와 동일)
        applyAbandonedMaterials(instance);

        // 폐건물 아이콘 표시
        showAbandonedIcon(building, building.x, building.y);

        // 입주민 퇴거 (인구 감소)
        if (userData.zoneType && userData.zoneType.includes('residential')) {
            const popKey = getBuildingKey(building.x, building.y, userData.size || '1x1');
            if (buildingPopulations && buildingPopulations.has(popKey)) {
                buildingPopulations.delete(popKey);
                cityStats.population = calculateTotalPopulation();
                updateStatsDisplay();
            }
        }
    }

    const grid = Array.from({ length: GRID_W }, () =>
        Array(GRID_H).fill(CELL.EMPTY)
    );

    const blocked = Array.from({ length: GRID_W }, () =>
        Array(GRID_H).fill(0)
    );

    function tileToWorldCenter(x, y) {
        return {
            x: (ORIGIN_X + x + 0.5) * TILE_SIZE,
            z: (ORIGIN_Z + y + 0.5) * TILE_SIZE,
        };
    }

    function worldToTile(wx, wz) {
        const gx = Math.floor(wx / TILE_SIZE - ORIGIN_X);
        const gy = Math.floor(wz / TILE_SIZE - ORIGIN_Z);
        if (gx < 0 || gy < 0 || gx >= GRID_W || gy >= GRID_H) return null;
        return { x: gx, y: gy };
    }

    // 3D 오브젝트 완전 삭제 (geometry, material, texture 모두 dispose)
    function disposeObject3D(object) {
        if (!object) return;

        object.traverse((child) => {
            if (child.geometry) {
                child.geometry.dispose();
            }
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(mat => {
                        if (mat.map) mat.map.dispose();
                        mat.dispose();
                    });
                } else {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
            }
        });

        // 자식들도 제거
        while (object.children.length > 0) {
            object.remove(object.children[0]);
        }
    }

    function isRoad(x, y) {
        if (!inBounds(x, y)) return false;
        const v = grid[x][y];
        return v === CELL.ROAD || v === CELL.LOCKED_ROAD || v === CELL.BRIDGE ||
               v === CELL.ROAD_4LANE || v === CELL.LOCKED_ROAD_4LANE;
    }

    function is4LaneRoad(x, y) {
        if (!inBounds(x, y)) return false;
        const v = grid[x][y];
        return v === CELL.ROAD_4LANE || v === CELL.LOCKED_ROAD_4LANE;
    }

    function is2LaneRoad(x, y) {
        if (!inBounds(x, y)) return false;
        const v = grid[x][y];
        return v === CELL.ROAD || v === CELL.LOCKED_ROAD || v === CELL.BRIDGE;
    }

    // 4차선 도로 원점인지 확인 (2x2의 좌하단)
    function is4LaneOrigin(x, y) {
        return road4laneOrigins.has(`${x},${y}`);
    }

    // grid에서 4차선 도로 원점 재구성 (로드 시 사용)
    function rebuild4LaneOrigins() {
        road4laneOrigins.clear();

        // 4차선 도로 타일을 스캔하여 원점 찾기
        // 원점은 2x2 영역의 좌하단 (가장 작은 x, y 좌표)
        const visited = new Set();

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const v = grid[x][y];
                if (v !== CELL.ROAD_4LANE && v !== CELL.LOCKED_ROAD_4LANE) continue;
                if (visited.has(`${x},${y}`)) continue;

                // 이 타일이 속한 2x2 영역의 원점 찾기
                // 원점은 가장 작은 x, y 좌표 (좌하단)
                // 중요: 이미 방문한 셀(다른 2x2 블록)은 원점 계산에서 제외
                let originX = x, originY = y;

                // 왼쪽 타일이 4차선이고 아직 방문하지 않은 경우에만 원점 후보
                const leftKey = `${x-1},${y}`;
                if (x > 0 && !visited.has(leftKey) &&
                    (grid[x-1][y] === CELL.ROAD_4LANE || grid[x-1][y] === CELL.LOCKED_ROAD_4LANE)) {
                    originX = x - 1;
                }
                // 아래 타일이 4차선이고 아직 방문하지 않은 경우에만 원점 후보
                const bottomKey = `${originX},${y-1}`;
                if (y > 0 && !visited.has(bottomKey) &&
                    (grid[originX][y-1] === CELL.ROAD_4LANE || grid[originX][y-1] === CELL.LOCKED_ROAD_4LANE)) {
                    originY = y - 1;
                }

                // 2x2 영역 검증 (모든 셀이 4차선이고 아직 방문하지 않음)
                let valid = true;
                for (let dx = 0; dx < 2 && valid; dx++) {
                    for (let dy = 0; dy < 2 && valid; dy++) {
                        const cx = originX + dx;
                        const cy = originY + dy;
                        if (cx >= GRID_W || cy >= GRID_H) {
                            valid = false;
                        } else if (visited.has(`${cx},${cy}`)) {
                            // 이미 다른 2x2 블록에 속한 셀
                            valid = false;
                        } else {
                            const cv = grid[cx][cy];
                            if (cv !== CELL.ROAD_4LANE && cv !== CELL.LOCKED_ROAD_4LANE) {
                                valid = false;
                            }
                        }
                    }
                }

                if (valid) {
                    // 원점 등록
                    road4laneOrigins.set(`${originX},${originY}`, { variant: 'straight', rotY: 0 });

                    // 2x2 영역 방문 표시
                    for (let dx = 0; dx < 2; dx++) {
                        for (let dy = 0; dy < 2; dy++) {
                            visited.add(`${originX + dx},${originY + dy}`);
                        }
                    }
                } else {
                    // 유효하지 않은 경우 현재 셀만 방문 표시 (무한 루프 방지)
                    visited.add(`${x},${y}`);
                }
            }
        }

        console.log(`4차선 도로 원점 재구성 완료: ${road4laneOrigins.size}개`);
    }

    // 저장된 4차선 도로 원점 복원
    function restore4LaneOrigins(origins) {
        road4laneOrigins.clear();

        for (const origin of origins) {
            const { x, y, variant, rotY } = origin;

            // 해당 위치가 실제로 4차선 도로인지 검증
            if (x >= 0 && x < GRID_W - 1 && y >= 0 && y < GRID_H - 1) {
                let valid = true;
                for (let dx = 0; dx < 2 && valid; dx++) {
                    for (let dy = 0; dy < 2 && valid; dy++) {
                        const cv = grid[x + dx][y + dy];
                        if (cv !== CELL.ROAD_4LANE && cv !== CELL.LOCKED_ROAD_4LANE) {
                            valid = false;
                        }
                    }
                }

                if (valid) {
                    road4laneOrigins.set(`${x},${y}`, {
                        variant: variant || 'straight',
                        rotY: rotY || 0
                    });
                }
            }
        }

        console.log(`4차선 도로 원점 복원 완료: ${road4laneOrigins.size}개`);
    }

    // 4차선 도로의 원점 찾기 (해당 셀이 속한 2x2의 원점)
    function find4LaneOrigin(x, y) {
        if (!is4LaneRoad(x, y)) return null;
        // 자신이 원점인지
        if (is4LaneOrigin(x, y)) return { x, y };
        // 좌하단으로 한 칸씩 체크
        if (is4LaneOrigin(x - 1, y)) return { x: x - 1, y };
        if (is4LaneOrigin(x, y - 1)) return { x, y: y - 1 };
        if (is4LaneOrigin(x - 1, y - 1)) return { x: x - 1, y: y - 1 };
        return null;
    }

    // 4차선 도로 2x2 배치 가능 여부 확인
    function canPlace4LaneRoad(x, y) {
        for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
                const cx = x + dx;
                const cy = y + dy;
                if (!inBounds(cx, cy)) return false;
                if (isLocked(cx, cy)) return false;
                // 2차선 도로(CELL.ROAD)는 덮어씌우기 허용
                const cellType = grid[cx][cy];
                if (isBlocked(cx, cy) && cellType !== CELL.ROAD) return false;
                // 공공시설 위에는 도로 설치 불가
                if (placedPublicBuildings && placedPublicBuildings.has(`${cx},${cy}`)) return false;
            }
        }

        // 나란히(평행) 도로 설치 방지 - 4면의 인접 셀에 도로가 있으면 설치 불가
        // 단, 4차선끼리 끝과 끝이 연결되는 경우는 허용 (연속 2개까지만)

        // 서쪽 면 체크 (x-1, y), (x-1, y+1)
        const westHasRoad = (inBounds(x-1, y) && isAnyRoad(x-1, y)) ||
                           (inBounds(x-1, y+1) && isAnyRoad(x-1, y+1));
        // 서쪽에 4차선이 연결된 경우는 허용 (원점이 x-2에 있으면 연결)
        const westIs4LaneConnection = road4laneOrigins.has(`${x-2},${y}`);
        // 단, 서쪽 4차선이 이미 같은 방향(서쪽)에 또 다른 4차선과 연결되어 있으면 불가
        const westHasChain = westIs4LaneConnection && road4laneOrigins.has(`${x-4},${y}`);
        if (westHasRoad && (!westIs4LaneConnection || westHasChain)) return false;

        // 동쪽 면 체크 (x+2, y), (x+2, y+1)
        const eastHasRoad = (inBounds(x+2, y) && isAnyRoad(x+2, y)) ||
                           (inBounds(x+2, y+1) && isAnyRoad(x+2, y+1));
        // 동쪽에 4차선이 연결된 경우는 허용 (원점이 x+2에 있으면 연결)
        const eastIs4LaneConnection = road4laneOrigins.has(`${x+2},${y}`);
        // 단, 동쪽 4차선이 이미 같은 방향(동쪽)에 또 다른 4차선과 연결되어 있으면 불가
        const eastHasChain = eastIs4LaneConnection && road4laneOrigins.has(`${x+4},${y}`);
        if (eastHasRoad && (!eastIs4LaneConnection || eastHasChain)) return false;

        // 남쪽 면 체크 (x, y-1), (x+1, y-1)
        const southHasRoad = (inBounds(x, y-1) && isAnyRoad(x, y-1)) ||
                            (inBounds(x+1, y-1) && isAnyRoad(x+1, y-1));
        // 남쪽에 4차선이 연결된 경우는 허용 (원점이 y-2에 있으면 연결)
        const southIs4LaneConnection = road4laneOrigins.has(`${x},${y-2}`);
        // 단, 남쪽 4차선이 이미 같은 방향(남쪽)에 또 다른 4차선과 연결되어 있으면 불가
        const southHasChain = southIs4LaneConnection && road4laneOrigins.has(`${x},${y-4}`);
        if (southHasRoad && (!southIs4LaneConnection || southHasChain)) return false;

        // 북쪽 면 체크 (x, y+2), (x+1, y+2)
        const northHasRoad = (inBounds(x, y+2) && isAnyRoad(x, y+2)) ||
                            (inBounds(x+1, y+2) && isAnyRoad(x+1, y+2));
        // 북쪽에 4차선이 연결된 경우는 허용 (원점이 y+2에 있으면 연결)
        const northIs4LaneConnection = road4laneOrigins.has(`${x},${y+2}`);
        // 단, 북쪽 4차선이 이미 같은 방향(북쪽)에 또 다른 4차선과 연결되어 있으면 불가
        const northHasChain = northIs4LaneConnection && road4laneOrigins.has(`${x},${y+4}`);
        if (northHasRoad && (!northIs4LaneConnection || northHasChain)) return false;

        return true;
    }

    // 4차선 도로 2x2 배치
    function place4LaneRoad(x, y) {
        if (!canPlace4LaneRoad(x, y)) return false;

        let zoneCleared = false;

        // 4개 셀 모두 ROAD_4LANE으로 설정
        for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
                const cx = x + dx;
                const cy = y + dy;
                // 기존 건물 철거
                if (typeof removeBuildingAt === 'function') {
                    removeBuildingAt(cx, cy, true);
                }
                // 나무 제거
                if (typeof removeTreeAt === 'function') {
                    removeTreeAt(cx, cy);
                }
                // 구역 지정 확인
                const cell = grid[cx][cy];
                if (cell === CELL.ZONE_RESIDENTIAL || cell === CELL.ZONE_COMMERCIAL || cell === CELL.ZONE_INDUSTRIAL) {
                    zoneCleared = true;
                }
                grid[cx][cy] = CELL.ROAD_4LANE;
            }
        }

        // 원점 등록 (variant와 rotY는 나중에 rebuildRoadModels에서 계산)
        road4laneOrigins.set(`${x},${y}`, { variant: 'straight', rotY: 0 });

        // 구역이 도로로 대체되었으면 구역 시각 업데이트
        if (zoneCleared) {
            rebuildZoneInstances(false);
        }

        // 디버깅: 설치된 4차선 도로 방향 출력
        const mask = get4LaneRoadMask(x, y);
        const isNS = (mask === 5 || mask === 1 || mask === 4);
        const isEW = (mask === 10 || mask === 2 || mask === 8);
        const direction = isNS ? '세로' : (isEW ? '가로' : '기타');
        console.log(`[4차선 설치] (${x},${y}) - ${direction} (mask: ${mask})`);

        return true;
    }

    // 4차선 도로 철거
    function remove4LaneRoad(x, y) {
        const origin = find4LaneOrigin(x, y);
        if (!origin) return false;

        // 4개 셀 모두 EMPTY로 설정
        for (let dx = 0; dx < 2; dx++) {
            for (let dy = 0; dy < 2; dy++) {
                const cx = origin.x + dx;
                const cy = origin.y + dy;
                if (inBounds(cx, cy)) {
                    grid[cx][cy] = CELL.EMPTY;
                }
            }
        }

        // 원점 삭제
        road4laneOrigins.delete(`${origin.x},${origin.y}`);

        return true;
    }

    // 4차선 도로의 variant 가져오기 (rebuildRoadModels 전에도 사용 가능)
    function get4LaneVariant(originX, originY) {
        const data = road4laneOrigins.get(`${originX},${originY}`);
        if (!data) return null;

        // 마스크 계산하여 variant 결정
        const mask = get4LaneRoadMask(originX, originY);
        const { key: variant } = pickRoadVariant(mask);
        return { variant, mask };
    }

    // 2차선 도로가 4차선 도로 옆에 배치 가능한지 검사
    // 반환: { valid: boolean, reason?: string }
    function validate2LaneNear4Lane(x, y) {
        // 인접한 4차선 도로 찾기
        const directions = [
            { dx: 0, dy: 1 },   // 북쪽
            { dx: 0, dy: -1 },  // 남쪽
            { dx: 1, dy: 0 },   // 동쪽
            { dx: -1, dy: 0 },  // 서쪽
        ];

        for (const dir of directions) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;

            if (!is4LaneRoad(nx, ny)) continue;

            const origin = find4LaneOrigin(nx, ny);
            if (!origin) continue;

            // 2차선이 4차선의 어느 면에 접하는지 계산
            let touchSide;
            if (x < origin.x) touchSide = 'W';
            else if (x >= origin.x + 2) touchSide = 'E';
            else if (y < origin.y) touchSide = 'S';
            else if (y >= origin.y + 2) touchSide = 'N';
            else continue;  // 4차선 내부

            const variantInfo = get4LaneVariant(origin.x, origin.y);
            if (!variantInfo) continue;

            const { variant, mask } = variantInfo;

            // 규칙 1: 직선 또는 끝부분 타일에만 연결 가능
            // mask: 5=남북직선, 10=동서직선, 1=북끝, 4=남끝, 2=동끝, 8=서끝
            const canConnect = (mask === 5 || mask === 10 || mask === 1 || mask === 4 || mask === 2 || mask === 8);
            if (!canConnect) {
                return {
                    valid: false,
                    reason: '2차선은 4차선 직선/끝 도로에만 연결할 수 있습니다'
                };
            }

            // 남북 방향 (직선 또는 끝): mask 5, 1, 4
            const isNorthSouthType = (mask === 5 || mask === 1 || mask === 4);
            // 동서 방향 (직선 또는 끝): mask 10, 2, 8
            const isEastWestType = (mask === 10 || mask === 2 || mask === 8);

            // 규칙 2: 옆면에만 연결 가능 (정면 불가)
            if (isNorthSouthType && (touchSide === 'N' || touchSide === 'S')) {
                return {
                    valid: false,
                    reason: '2차선은 4차선 도로의 정면에 연결할 수 없습니다 (옆면만 가능)'
                };
            }
            if (isEastWestType && (touchSide === 'E' || touchSide === 'W')) {
                return {
                    valid: false,
                    reason: '2차선은 4차선 도로의 정면에 연결할 수 없습니다 (옆면만 가능)'
                };
            }

            // 규칙 3: 4차선 타일 한 면에 인접한 두 타일 중 하나에만 2차선 배치 가능
            // 예: 서쪽 면은 (origin.x-1, origin.y)와 (origin.x-1, origin.y+1) 두 칸
            //     이 두 칸 중 하나에만 2차선을 놓을 수 있음
            let otherCellX, otherCellY;
            if (touchSide === 'W') {
                otherCellX = origin.x - 1;
                otherCellY = (y === origin.y) ? origin.y + 1 : origin.y;
            } else if (touchSide === 'E') {
                otherCellX = origin.x + 2;
                otherCellY = (y === origin.y) ? origin.y + 1 : origin.y;
            } else if (touchSide === 'S') {
                otherCellY = origin.y - 1;
                otherCellX = (x === origin.x) ? origin.x + 1 : origin.x;
            } else {  // touchSide === 'N'
                otherCellY = origin.y + 2;
                otherCellX = (x === origin.x) ? origin.x + 1 : origin.x;
            }

            if (is2LaneRoad(otherCellX, otherCellY)) {
                return {
                    valid: false,
                    reason: '4차선 도로의 한 면에는 2차선을 연속으로 배치할 수 없습니다'
                };
            }
        }

        return { valid: true };
    }

    // 2차선 도로가 2x2 블록을 형성하는지 검사
    // 2차선 도로끼리 2x2 정사각형으로 붙어있으면 안됨
    function validate2LaneNo2x2Block(x, y) {
        // (x, y)에 2차선을 놓았을 때 2x2 블록이 완성되는지 확인
        // 4가지 경우: (x,y)가 2x2 블록의 각 코너가 되는 경우
        const corners = [
            // (x, y)가 좌하단
            [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }],
            // (x, y)가 우하단
            [{ dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 1 }],
            // (x, y)가 좌상단
            [{ dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 1, dy: -1 }],
            // (x, y)가 우상단
            [{ dx: -1, dy: 0 }, { dx: 0, dy: -1 }, { dx: -1, dy: -1 }],
        ];

        for (const offsets of corners) {
            let allRoads = true;
            for (const off of offsets) {
                const nx = x + off.dx;
                const ny = y + off.dy;
                if (!is2LaneRoad(nx, ny)) {
                    allRoads = false;
                    break;
                }
            }
            if (allRoads) {
                return {
                    valid: false,
                    reason: '2차선 도로는 2x2 블록으로 배치할 수 없습니다'
                };
            }
        }

        return { valid: true };
    }

    // 경로 내에서 4차선 한 면에 연속 배치가 발생하는지 검사
    // path: [{x, y}, ...] 배열
    function validatePathNo4LaneConsecutive(path) {
        if (!path || path.length < 2) return { valid: true };

        // 경로의 각 셀이 어느 4차선의 어느 면에 인접한지 수집
        // key: "originX,originY,side", value: [{x, y}, ...]
        const sideMap = new Map();

        for (const pt of path) {
            // 이 셀 주변의 4차선 확인
            const directions = [
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
            ];

            for (const dir of directions) {
                const nx = pt.x + dir.dx;
                const ny = pt.y + dir.dy;

                if (!is4LaneRoad(nx, ny)) continue;

                const origin = find4LaneOrigin(nx, ny);
                if (!origin) continue;

                // 어느 면에 접하는지 계산
                let touchSide;
                if (pt.x < origin.x) touchSide = 'W';
                else if (pt.x >= origin.x + 2) touchSide = 'E';
                else if (pt.y < origin.y) touchSide = 'S';
                else if (pt.y >= origin.y + 2) touchSide = 'N';
                else continue;

                const key = `${origin.x},${origin.y},${touchSide}`;
                if (!sideMap.has(key)) {
                    sideMap.set(key, []);
                }
                sideMap.get(key).push(pt);
            }
        }

        // 같은 면에 2개 이상의 경로 셀이 있으면 오류
        for (const [key, cells] of sideMap) {
            if (cells.length >= 2) {
                return {
                    valid: false,
                    reason: '4차선 도로의 한 면에는 2차선을 연속으로 배치할 수 없습니다'
                };
            }
        }

        return { valid: true };
    }

    // 경로 내에서 기존 도로 옆에 연속으로 2칸 이상 배치되는지 검사
    // path: [{x, y}, ...] 배열
    function validatePathNoParallelToRoad(path) {
        if (!path || path.length < 2) return { valid: true };

        // 경로를 Set으로 변환 (빠른 조회용)
        const pathSet = new Set(path.map(p => `${p.x},${p.y}`));

        // 각 셀이 기존 도로(경로 제외)에 인접한지 확인
        function isAdjacentToExistingRoad(x, y) {
            const directions = [
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
            ];
            for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                // 경로에 포함된 셀은 제외
                if (pathSet.has(`${nx},${ny}`)) continue;
                // 기존 도로인지 확인 (2차선 또는 4차선)
                if (is2LaneRoad(nx, ny) || is4LaneRoad(nx, ny)) {
                    return true;
                }
            }
            return false;
        }

        // 경로에서 연속된 2개 셀이 모두 기존 도로에 인접하면 오류
        for (let i = 0; i < path.length - 1; i++) {
            const curr = path[i];
            const next = path[i + 1];

            // 두 셀이 서로 인접한지 확인
            const dx = Math.abs(curr.x - next.x);
            const dy = Math.abs(curr.y - next.y);
            const isAdjacent = (dx + dy === 1);

            if (isAdjacent) {
                const currAdj = isAdjacentToExistingRoad(curr.x, curr.y);
                const nextAdj = isAdjacentToExistingRoad(next.x, next.y);

                if (currAdj && nextAdj) {
                    return {
                        valid: false,
                        reason: '기존 도로 옆에 2칸 이상 연속으로 배치할 수 없습니다'
                    };
                }
            }
        }

        return { valid: true };
    }

    function isWater(x, y) {
        if (!inBounds(x, y)) return false;
        return grid[x][y] === CELL.WATER;
    }

    function isBridge(x, y) {
        if (!inBounds(x, y)) return false;
        return grid[x][y] === CELL.BRIDGE;
    }

    // 수로 또는 다리인지 확인 (다리 아래에도 수로가 있으므로)
    function isWaterOrBridge(x, y) {
        if (!inBounds(x, y)) return false;
        const v = grid[x][y];
        return v === CELL.WATER || v === CELL.BRIDGE;
    }

    function isLocked(x, y) {
        if (!inBounds(x, y)) return false;
        return grid[x][y] === CELL.LOCKED_ROAD;
    }

    function isBlocked(x, y) {
        if (!inBounds(x, y)) return true;
        return blocked[x][y] === 1;
    }

    function isZone(x, y) {
        if (!inBounds(x, y)) return false;
        const v = grid[x][y];
        return v === CELL.ZONE_RESIDENTIAL || v === CELL.ZONE_COMMERCIAL || v === CELL.ZONE_INDUSTRIAL;
    }

    // 수로 마스크 계산 (다리 아래에도 수로가 있으므로 함께 처리)
    function getWaterMask(x, y) {
        if (!isWaterOrBridge(x, y)) return 0;
        let mask = 0;
        for (const [, d] of Object.entries(DIR)) {
            const nx = x + d.dx;
            const ny = y + d.dy;
            if (inBounds(nx, ny) && isWaterOrBridge(nx, ny)) {
                mask |= d.bit;
            }
        }
        return mask;
    }

    // 다리 여부 확인 (도로가 수로 위에 있어야 하는지)
    function shouldBeBridge(x, y) {
        // 현재 위치가 수로인지 확인
        if (!isWater(x, y)) return false;
        return true; // 수로 위에 도로를 놓으면 다리
    }

    // 다리의 방향 확인 (인접 도로 방향 기준)
    function getBridgeRotation(x, y) {
        // 인접한 도로 방향 확인
        let roadMask = 0;
        for (const [, d] of Object.entries(DIR)) {
            const nx = x + d.dx;
            const ny = y + d.dy;
            if (inBounds(nx, ny)) {
                const v = grid[nx][ny];
                if (v === CELL.ROAD || v === CELL.LOCKED_ROAD || v === CELL.BRIDGE) {
                    roadMask |= d.bit;
                }
            }
        }
        // 도로가 남-북으로 연결되면 다리도 남-북
        if ((roadMask & 5) !== 0) return Math.PI / 2; // N=1, S=4 -> 세로
        if ((roadMask & 10) !== 0) return 0; // E=2, W=8 -> 가로
        return 0;
    }

    function getZoneType(x, y) {
        return grid[x][y];
    }

    // 도로에 인접한지 확인 (상하좌우)
    function isAdjacentToRoad(x, y) {
        const neighbors = [
            { dx: 0, dy: -1 },  // 북
            { dx: 1, dy: 0 },   // 동
            { dx: 0, dy: 1 },   // 남
            { dx: -1, dy: 0 },  // 서
        ];

        for (const { dx, dy } of neighbors) {
            const nx = x + dx;
            const ny = y + dy;
            if (inBounds(nx, ny) && isRoad(nx, ny)) {
                return true;
            }
        }
        return false;
    }

    // 구역 지정 가능 여부 확인
    function canPlaceZone(x, y) {
        if (!inBounds(x, y)) return false;
        if (isRoad(x, y)) return false;
        if (isWaterOrBridge(x, y)) return false;  // 수로/다리 위 구역지정 금지
        if (isZone(x, y)) return false;
        if (isBlocked(x, y)) return false;
        if (!isAdjacentToRoad(x, y)) return false;
        return true;
    }

    /**
     * 마우스 월드 좌표에서 가장 가까운 설치 가능한 구역 타일 찾기
     * @param {number} worldX - 마우스 월드 X 좌표
     * @param {number} worldZ - 마우스 월드 Z 좌표
     * @param {number} maxRadius - 최대 검색 반경 (타일 단위)
     * @returns {{x: number, y: number, dist: number} | null} 가장 가까운 설치 가능 타일
     */
    function findNearestPlaceableZoneTile(worldX, worldZ, maxRadius = 5) {
        let nearest = null;
        let nearestDist = Infinity;

        // 마우스 위치를 타일 좌표로 변환 (부동소수점)
        const tileX = worldX / TILE_SIZE + GRID_W / 2;
        const tileZ = worldZ / TILE_SIZE + GRID_H / 2;

        // 정수 타일 좌표
        const centerTileX = Math.floor(tileX);
        const centerTileZ = Math.floor(tileZ);

        // 검색 범위 내 타일 순회
        for (let dx = -maxRadius; dx <= maxRadius; dx++) {
            for (let dy = -maxRadius; dy <= maxRadius; dy++) {
                const tx = centerTileX + dx;
                const ty = centerTileZ + dy;

                if (!inBounds(tx, ty)) continue;
                if (!canPlaceZone(tx, ty)) continue;

                // 타일 중심과 마우스 위치 간의 거리 계산
                const tileCenterX = tx + 0.5;
                const tileCenterZ = ty + 0.5;
                const dist = Math.sqrt(
                    Math.pow(tileCenterX - tileX, 2) +
                    Math.pow(tileCenterZ - tileZ, 2)
                );

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = { x: tx, y: ty, dist: dist };
                }
            }
        }

        return nearest;
    }

    /* =========================================================
     * GROUND (투명 - 클릭 감지용)
     * ========================================================= */
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(GRID_W * TILE_SIZE, GRID_H * TILE_SIZE),
        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const gridHelper = new THREE.GridHelper(
        GRID_W * TILE_SIZE,
        GRID_W,
        0xaaaaaa,
        0xcccccc
    );
    gridHelper.position.y = 0.01;
    gridHelper.visible = false;  // 기본 숨김, 도로/수로 모드에서만 표시
    scene.add(gridHelper);

    /* =========================================================
     * INSTANCED MESHES
     * ========================================================= */
    const roadGeo = new THREE.BoxGeometry(TILE_SIZE, 0.08, TILE_SIZE);

    const roadMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
    const roadMesh = new THREE.InstancedMesh(roadGeo, roadMat, GRID_W * GRID_H);
    roadMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    roadMesh.castShadow = true;
    roadMesh.receiveShadow = true;
    scene.add(roadMesh);

    const lockedMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const lockedRoadMesh = new THREE.InstancedMesh(roadGeo, lockedMat, GRID_W * GRID_H);
    lockedRoadMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    lockedRoadMesh.castShadow = true;
    lockedRoadMesh.receiveShadow = true;
    scene.add(lockedRoadMesh);

    // 구역 시각화 메시 - 같은 구역끼리 이어지도록 전체 타일 크기 사용
    const zoneGeo = new THREE.BoxGeometry(TILE_SIZE, 0.15, TILE_SIZE);

    const residentialMat = new THREE.MeshStandardMaterial({
        color: ZONE_COLORS[CELL.ZONE_RESIDENTIAL],
        emissive: ZONE_COLORS[CELL.ZONE_RESIDENTIAL],
        emissiveIntensity: 0.5,
        transparent: false,
        opacity: 1.0,
        depthWrite: true,
    });
    const residentialMesh = new THREE.InstancedMesh(zoneGeo, residentialMat, GRID_W * GRID_H);
    residentialMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    residentialMesh.receiveShadow = true;
    residentialMesh.renderOrder = 2;  // z-fighting 방지
    scene.add(residentialMesh);

    const commercialMat = new THREE.MeshStandardMaterial({
        color: ZONE_COLORS[CELL.ZONE_COMMERCIAL],
        emissive: ZONE_COLORS[CELL.ZONE_COMMERCIAL],
        emissiveIntensity: 0.5,
        transparent: false,
        opacity: 1.0,
        depthWrite: true,
    });
    const commercialMesh = new THREE.InstancedMesh(zoneGeo, commercialMat, GRID_W * GRID_H);
    commercialMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    commercialMesh.receiveShadow = true;
    commercialMesh.renderOrder = 2;  // z-fighting 방지
    scene.add(commercialMesh);

    const industrialMat = new THREE.MeshStandardMaterial({
        color: ZONE_COLORS[CELL.ZONE_INDUSTRIAL],
        emissive: ZONE_COLORS[CELL.ZONE_INDUSTRIAL],
        emissiveIntensity: 0.5,
        transparent: false,
        opacity: 1.0,
        depthWrite: true,
    });
    const industrialMesh = new THREE.InstancedMesh(zoneGeo, industrialMat, GRID_W * GRID_H);
    industrialMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    industrialMesh.receiveShadow = true;
    industrialMesh.renderOrder = 2;  // z-fighting 방지
    scene.add(industrialMesh);

    // 구역 메시 초기 가시성 - 숨김 (구역 모드에서만 표시)
    residentialMesh.visible = false;
    commercialMesh.visible = false;
    industrialMesh.visible = false;

    /* =========================================================
     * LAND VALUE VISUALIZATION SYSTEM - 땅값 시각화 (2D 그라데이션)
     * 부드러운 픽셀 그라데이션으로 땅값 표현
     * 낮음=빨강, 중간=흰색, 높음=초록/청록
     * ========================================================= */
    const landValueGroup = new THREE.Group();
    landValueGroup.name = "landValueGroup";
    landValueGroup.visible = false;
    scene.add(landValueGroup);

    // 땅값 오버레이 텍스처 및 메시
    let landValueOverlayMesh = null;
    let landValueCanvas = null;
    let landValueCtx = null;
    let landValueTexture = null;

    // 건물 원본 머티리얼 저장 (땅값 뷰용)
    const buildingOriginalMaterialsForLandValue = new Map();
    // 차량 원본 머티리얼 저장 (땅값 뷰용)
    const vehicleOriginalMaterialsForLandValue = new Map();

    // 땅값 색상: -100=빨강, 0=흰색, 100=청색
    function getLandValueColor(value) {
        // 값 범위: -100 ~ 100 (0이 중간)
        const MIN_VAL = -100;
        const MAX_VAL = 100;
        const MID_VAL = 0;

        // 정규화
        const clamped = Math.max(MIN_VAL, Math.min(MAX_VAL, value));

        if (clamped <= MID_VAL) {
            // 빨강 -> 흰색 (-100 -> 0)
            const t = (clamped - MIN_VAL) / (MID_VAL - MIN_VAL);  // 0 ~ 1
            return {
                r: 255,
                g: Math.round(255 * t),
                b: Math.round(255 * t)
            };
        } else {
            // 흰색 -> 청색 (0 -> 100)
            const t = (clamped - MID_VAL) / (MAX_VAL - MID_VAL);  // 0 ~ 1
            return {
                r: Math.round(255 * (1 - t)),
                g: Math.round(255 * (1 - t)),
                b: 255
            };
        }
    }

    // THREE.Color용 땅값 색상
    function getLandValueColorThree(value) {
        const c = getLandValueColor(value);
        return new THREE.Color(c.r / 255, c.g / 255, c.b / 255);
    }

    // 땅값 데이터 배열 생성
    function createLandValueDataArray() {
        const data = [];
        for (let z = 0; z < GRID_H; z++) {
            data[z] = [];
            for (let x = 0; x < GRID_W; x++) {
                const baseLandValue = getLandValue(x, z);
                const serviceBonus = typeof getServiceBonus === 'function' ? getServiceBonus(x, z) : 0;
                data[z][x] = baseLandValue + serviceBonus;
            }
        }
        return data;
    }

    // Smoothstep 함수 (부드러운 보간)
    function smoothstep(edge0, edge1, x) {
        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
    }

    // 메타볼 스타일 영향력 계산 (부드러운 곡선 falloff)
    function metaballInfluence(dist, radius) {
        if (dist >= radius) return 0;
        // 부드러운 곡선 감쇠 (코사인 기반)
        const t = dist / radius;
        return Math.pow(1 - t * t, 2);  // Wendland 커널 변형
    }

    // 땅값 시각화 생성 (메타볼 스타일 곡선 영역)
    function createLandValueVisualization() {
        // 기존 오버레이 제거
        if (landValueOverlayMesh) {
            landValueGroup.remove(landValueOverlayMesh);
            if (landValueOverlayMesh.geometry) landValueOverlayMesh.geometry.dispose();
            if (landValueOverlayMesh.material) landValueOverlayMesh.material.dispose();
            if (landValueTexture) landValueTexture.dispose();
        }

        // 캔버스 생성 (고해상도)
        const resolution = 8;  // 타일당 픽셀 수 (높을수록 부드러움)
        const canvasW = GRID_W * resolution;
        const canvasH = GRID_H * resolution;

        landValueCanvas = document.createElement('canvas');
        landValueCanvas.width = canvasW;
        landValueCanvas.height = canvasH;
        landValueCtx = landValueCanvas.getContext('2d');

        // 땅값 데이터 생성
        const rawData = createLandValueDataArray();

        // 영향력 범위 (타일 단위)
        const influenceRadius = 3.5;

        // 캔버스에 메타볼 스타일 그라데이션 그리기
        const imageData = landValueCtx.createImageData(canvasW, canvasH);

        for (let py = 0; py < canvasH; py++) {
            for (let px = 0; px < canvasW; px++) {
                // 픽셀 좌표를 그리드 좌표로 변환
                const gx = (px + 0.5) / resolution;
                const gz = (py + 0.5) / resolution;

                // 주변 타일들의 영향력을 합산 (메타볼 방식)
                let weightedSum = 0;
                let totalWeight = 0;

                // 영향력 범위 내 타일들 검사
                const searchRadius = Math.ceil(influenceRadius) + 1;
                const centerX = Math.floor(gx);
                const centerZ = Math.floor(gz);

                for (let dz = -searchRadius; dz <= searchRadius; dz++) {
                    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                        const tx = centerX + dx;
                        const tz = centerZ + dz;

                        // 범위 체크
                        if (tx < 0 || tx >= GRID_W || tz < 0 || tz >= GRID_H) continue;

                        // 타일 중심까지의 거리
                        const tileCenterX = tx + 0.5;
                        const tileCenterZ = tz + 0.5;
                        const dist = Math.sqrt(
                            Math.pow(gx - tileCenterX, 2) +
                            Math.pow(gz - tileCenterZ, 2)
                        );

                        // 메타볼 영향력 계산
                        const influence = metaballInfluence(dist, influenceRadius);
                        if (influence > 0) {
                            weightedSum += rawData[tz][tx] * influence;
                            totalWeight += influence;
                        }
                    }
                }

                // 가중 평균 계산
                const value = totalWeight > 0 ? weightedSum / totalWeight : 0;

                const color = getLandValueColor(value);
                const idx = (py * canvasW + px) * 4;
                imageData.data[idx] = color.r;
                imageData.data[idx + 1] = color.g;
                imageData.data[idx + 2] = color.b;
                imageData.data[idx + 3] = 220;  // 선명하게
            }
        }

        landValueCtx.putImageData(imageData, 0, 0);

        // 텍스처 생성
        landValueTexture = new THREE.CanvasTexture(landValueCanvas);
        landValueTexture.minFilter = THREE.LinearFilter;
        landValueTexture.magFilter = THREE.LinearFilter;
        landValueTexture.needsUpdate = true;

        // 지면 오버레이 평면 생성
        const planeW = GRID_W * TILE_SIZE;
        const planeH = GRID_H * TILE_SIZE;
        const planeGeo = new THREE.PlaneGeometry(planeW, planeH);
        const planeMat = new THREE.MeshBasicMaterial({
            map: landValueTexture,
            transparent: true,
            opacity: 0.85,
            depthWrite: false,
            depthTest: true,
            side: THREE.DoubleSide,
        });

        landValueOverlayMesh = new THREE.Mesh(planeGeo, planeMat);
        landValueOverlayMesh.rotation.x = -Math.PI / 2;  // 수평으로 눕히기
        landValueOverlayMesh.position.set(0, 0.15, 0);  // 지면 위 (잔디보다 위)
        landValueOverlayMesh.renderOrder = 1;  // 렌더링 순서 조정
        landValueGroup.add(landValueOverlayMesh);

        // 건물 색상 적용
        applyLandValueToBuildings(rawData);
    }

    // 건물에 땅값 색상 적용
    function applyLandValueToBuildings(blurredData) {
        buildingOriginalMaterialsForLandValue.clear();

        buildingGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                // 원본 머티리얼 저장
                buildingOriginalMaterialsForLandValue.set(child.uuid, child.material);

                // 건물 위치에서 땅값 가져오기
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);

                // 월드 좌표 -> 그리드 좌표
                const gx = Math.floor(worldPos.x / TILE_SIZE + GRID_W / 2);
                const gz = Math.floor(worldPos.z / TILE_SIZE + GRID_H / 2);

                // 범위 체크
                const clampedX = Math.max(0, Math.min(GRID_W - 1, gx));
                const clampedZ = Math.max(0, Math.min(GRID_H - 1, gz));

                const value = blurredData[clampedZ][clampedX];
                const color = getLandValueColorThree(value);

                // 땅값 색상으로 머티리얼 교체
                child.material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    roughness: 0.8,
                    metalness: 0.0,
                });
            }
        });
    }

    // 차량 회색 재질 (공유, 성능 최적화)
    const vehicleGrayMaterial = new THREE.MeshStandardMaterial({
        color: 0x888888,
        roughness: 0.8,
        metalness: 0.0,
    });

    // 차량에 회색 적용 (땅값 뷰)
    function applyLandValueToVehicles() {
        vehicleOriginalMaterialsForLandValue.clear();

        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            trafficManager.vehicleGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    vehicleOriginalMaterialsForLandValue.set(child.uuid, child.material);
                    child.material = vehicleGrayMaterial;  // 공유 재질 사용 (성능 최적화)
                }
            });
        }
    }

    // 건물 원래 머티리얼 복원
    function restoreBuildingMaterialsFromLandValue() {
        const materialsToDispose = [];

        buildingGroup.traverse((child) => {
            if (child.isMesh && buildingOriginalMaterialsForLandValue.has(child.uuid)) {
                const originalMaterial = buildingOriginalMaterialsForLandValue.get(child.uuid);
                const currentMaterial = child.material;

                // 현재 재질이 원본과 다르면 (땅값 뷰 재질) 폐기 예약
                if (currentMaterial && currentMaterial !== originalMaterial) {
                    // 땅값 재질의 UUID를 색상 캐시에서 제거
                    const currentMats = Array.isArray(currentMaterial) ? currentMaterial : [currentMaterial];
                    currentMats.forEach(mat => {
                        if (mat && mat.uuid) {
                            originalObjectColors.delete(mat.uuid);
                        }
                        materialsToDispose.push(mat);
                    });
                }

                // 안전한 머티리얼 할당 사용
                safeAssignMaterial(child, originalMaterial);
            }
        });

        // 땅값 재질 dispose (복원 후에 안전하게)
        materialsToDispose.forEach(mat => {
            if (mat && mat.dispose) mat.dispose();
        });

        buildingOriginalMaterialsForLandValue.clear();

        // 차량 머티리얼도 복원 (공유 재질은 dispose하지 않음)
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            trafficManager.vehicleGroup.traverse((child) => {
                if (child.isMesh && vehicleOriginalMaterialsForLandValue.has(child.uuid)) {
                    const originalMaterial = vehicleOriginalMaterialsForLandValue.get(child.uuid);
                    safeAssignMaterial(child, originalMaterial);
                }
            });

            // 모든 차량도 명시적으로 복원 (vehicleGroup.traverse가 놓칠 수 있음)
            if (trafficManager.vehicles) {
                trafficManager.vehicles.forEach(vehicle => {
                    if (vehicle.mesh) {
                        vehicle.mesh.traverse((child) => {
                            if (child.isMesh && vehicleOriginalMaterialsForLandValue.has(child.uuid)) {
                                const originalMaterial = vehicleOriginalMaterialsForLandValue.get(child.uuid);
                                safeAssignMaterial(child, originalMaterial);
                            }
                        });
                    }
                });
            }
        }

        vehicleOriginalMaterialsForLandValue.clear();

        // 색상 틴트 강제 재계산
        lastColorTintHour = -1;
    }

    // 땅값 뷰 토글
    let isLandValueViewActive = false;

    /* =========================================================
     * SERVICE BUILDING VIEW MODE - 서비스 건물 범례 모드
     * 소방서, 경찰서, 학교, 병원, 공원 등의 건물을 초록색으로 하이라이트
     * ========================================================= */
    let activeServiceViewType = null;  // 현재 활성화된 서비스 뷰 타입
    const serviceViewOriginalMaterials = new Map();  // 원본 재질 저장

    // 서비스 건물 하이라이트용 재질 (초록색 반투명)
    const serviceHighlightMaterial = new THREE.MeshStandardMaterial({
        color: 0x44ff66,
        transparent: true,
        opacity: 0.85,
        emissive: 0x22aa44,
        emissiveIntensity: 0.3,
        roughness: 0.5,
        metalness: 0.0,
    });

    /**
     * 서비스 건물 뷰 모드 진입
     * @param {string} serviceType - 'fire', 'police', 'school', 'hospital', 'park'
     */
    function enterServiceBuildingView(serviceType) {
        // 이미 같은 뷰가 활성화되어 있으면 종료
        if (activeServiceViewType === serviceType) {
            exitServiceBuildingView();
            return;
        }

        // 다른 서비스 뷰가 활성화되어 있으면 먼저 종료
        if (activeServiceViewType) {
            exitServiceBuildingView();
        }

        activeServiceViewType = serviceType;

        // 구역 모드 효과 적용 (흰색/회색 배경)
        applyZoneModeEffect();

        // 서비스 효과 범위 표시
        showServiceEffects(serviceType);

        // 해당 타입의 건물들을 초록색으로 하이라이트
        highlightServiceBuildings(serviceType);

        // 서비스 뷰 범례 표시
        showServiceViewLegend(serviceType);

        console.log(`[ServiceView] Entered: ${serviceType}`);
    }

    /**
     * 서비스 건물 뷰 모드 종료
     */
    function exitServiceBuildingView() {
        if (!activeServiceViewType) return;

        const prevType = activeServiceViewType;
        activeServiceViewType = null;

        // 서비스 효과 범위 숨기기
        clearServiceEffects();

        // 구역 모드 효과 복원 (모든 건물을 원래 색상으로 한 번에 복원)
        restoreOriginalMaterials();

        // 서비스 뷰 원래 재질 맵 클리어
        serviceViewOriginalMaterials.clear();

        // 범례 숨기기
        hideServiceViewLegend();

        console.log(`[ServiceView] Exited: ${prevType}`);
    }

    /**
     * 해당 타입의 서비스 건물들을 초록색으로 하이라이트
     */
    function highlightServiceBuildings(serviceType) {
        serviceViewOriginalMaterials.clear();

        // placedPublicBuildings에서 해당 타입의 건물 찾기
        placedPublicBuildings.forEach((building, key) => {
            if (building.ref) return;  // 참조는 스킵
            if (building.type !== serviceType) return;
            if (!building.instance) return;

            // 건물의 모든 메시에 하이라이트 재질 적용
            building.instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    serviceViewOriginalMaterials.set(child.uuid, child.material);
                    child.material = serviceHighlightMaterial;
                }
            });
        });
    }

    /**
     * 서비스 건물 재질 복원
     */
    function restoreServiceBuildingMaterials() {
        placedPublicBuildings.forEach((building, key) => {
            if (building.ref) return;
            if (!building.instance) return;

            building.instance.traverse((child) => {
                if (child.isMesh && serviceViewOriginalMaterials.has(child.uuid)) {
                    const originalMaterial = serviceViewOriginalMaterials.get(child.uuid);
                    child.material = originalMaterial;
                }
            });
        });

        serviceViewOriginalMaterials.clear();
    }

    /**
     * 서비스 뷰 범례 표시
     */
    function showServiceViewLegend(serviceType) {
        const config = PUBLIC_BUILDING_MODELS[serviceType];
        if (!config || !dataViewLegend) return;

        // 범례 설정
        if (legendIcon) legendIcon.textContent = config.icon;
        if (legendTitle) legendTitle.textContent = config.name + ' 현황';

        // 통계 정보
        let buildingCount = 0;
        placedPublicBuildings.forEach((building, key) => {
            if (!building.ref && building.type === serviceType) buildingCount++;
        });

        if (legendStatLabel) legendStatLabel.textContent = '배치된 수';
        if (legendStatValue) legendStatValue.textContent = `${buildingCount}개`;

        // 모든 범례 아이템 숨기기
        if (legendLandValueItem) legendLandValueItem.style.display = 'none';
        if (legendBuildingValueItem) legendBuildingValueItem.style.display = 'none';
        if (legendPopulationItem) legendPopulationItem.style.display = 'none';
        if (legendTrafficItem) legendTrafficItem.style.display = 'none';

        dataViewLegend.classList.add('visible');
    }

    /**
     * 서비스 뷰 범례 숨기기
     */
    function hideServiceViewLegend() {
        if (dataViewLegend) {
            dataViewLegend.classList.remove('visible');
        }
    }

    /**
     * 서비스 뷰가 활성화되어 있는지 확인
     */
    function isServiceViewActive() {
        return activeServiceViewType !== null;
    }

    /* =========================================================
     * VIEW MODE MANAGER - 통합 범례 모드 관리
     * 모든 데이터 뷰 모드(땅값, 인구, 교통량, 전력, 수도)를 통합 관리
     * ========================================================= */
    const ViewModeManager = {
        // 현재 활성화된 뷰 모드
        activeMode: null,

        // 뷰 모드 타입 상수
        TYPES: {
            LAND_VALUE: 'landValue',
            POPULATION: 'population',
            TRAFFIC: 'traffic',
            POWER: 'power',
            WATER: 'water'
        },

        // 뷰 모드별 설정
        configs: {
            landValue: {
                isActiveFlag: () => isLandValueViewActive,
                setActiveFlag: (val) => { isLandValueViewActive = val; },
                group: () => landValueGroup,
                button: () => btnLandValue,
                legendType: 'landValue',
                restoreFn: () => restoreBuildingMaterialsFromLandValue(),
                animationFrameId: () => landValueAnimationFrameId,
                cancelAnimation: () => {
                    if (landValueAnimationFrameId) {
                        cancelAnimationFrame(landValueAnimationFrameId);
                        landValueAnimationFrameId = null;
                    }
                }
            },
            population: {
                isActiveFlag: () => isPopulationViewActive,
                setActiveFlag: (val) => { isPopulationViewActive = val; },
                group: () => populationGroup,
                button: () => btnPopulation,
                legendType: 'population',
                restoreFn: () => restoreOriginalMaterials(),
                animationFrameId: () => populationAnimationFrameId,
                cancelAnimation: () => {
                    if (populationAnimationFrameId) {
                        cancelAnimationFrame(populationAnimationFrameId);
                        populationAnimationFrameId = null;
                    }
                }
            },
            traffic: {
                isActiveFlag: () => isTrafficViewActive,
                setActiveFlag: (val) => { isTrafficViewActive = val; },
                group: () => trafficViewGroup,
                button: () => btnTrafficView,
                legendType: 'traffic',
                restoreFn: () => restoreOriginalMaterials(),
                cleanupFn: () => {
                    // 교통량 뷰 전용 정리
                    if (trafficViewGroup) {
                        while (trafficViewGroup.children.length > 0) {
                            const child = trafficViewGroup.children[0];
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (child.material.map) {
                                    child.material.map.dispose();
                                    child.material.map = null;
                                }
                                child.material.dispose();
                            }
                            trafficViewGroup.remove(child);
                        }
                    }
                    trafficTexture = null;
                    trafficTextureData = null;
                    trafficPlane = null;
                    trafficOutline = null;
                }
            },
            power: {
                isActiveFlag: () => powerManager?.isPowerViewActive,
                setActiveFlag: (val) => { if (powerManager) powerManager.isPowerViewActive = val; },
                group: () => powerManager?.powerLineGroup,
                iconGroup: () => powerManager?.powerIconGroup,
                button: () => null,
                restoreFn: () => { if (powerManager) powerManager.restorePowerViewMaterials(); }
            },
            water: {
                isActiveFlag: () => waterManager?.isWaterViewActive,
                setActiveFlag: (val) => { if (waterManager) waterManager.isWaterViewActive = val; },
                group: () => waterManager?.waterPipeGroup,
                iconGroup: () => waterManager?.waterIconGroup,
                button: () => null,
                restoreFn: () => { if (waterManager) waterManager.restoreWaterViewMaterials(); }
            }
        },

        // 특정 뷰 모드 종료
        exitViewMode(type) {
            const config = this.configs[type];
            if (!config) return;

            // 이미 비활성화 상태면 스킵
            if (!config.isActiveFlag()) return;

            // 플래그 비활성화
            config.setActiveFlag(false);

            // 애니메이션 취소
            if (config.cancelAnimation) config.cancelAnimation();

            // 그룹 숨기기
            const group = config.group();
            if (group) group.visible = false;

            // 아이콘 그룹도 숨기기 (전력/수도)
            if (config.iconGroup) {
                const iconGroup = config.iconGroup();
                if (iconGroup) iconGroup.visible = false;
            }

            // 머티리얼 복원
            if (config.restoreFn) config.restoreFn();

            // 인구 뷰 종료 시 주거 건물 반투명 복원
            if (type === 'population') {
                restoreResidentialTransparency();
            }

            // 추가 정리 (교통량 뷰 등)
            if (config.cleanupFn) config.cleanupFn();

            // 버튼 상태 업데이트
            const button = config.button();
            if (button) button.classList.remove('active');

            // 범례 패널 숨기기
            if (config.legendType) hideDataViewLegend();

            // Bloom 효과 복원 (다른 뷰 모드가 없을 때만)
            if (!this.isAnyViewActive()) {
                if (typeof bloomPass !== 'undefined' && GRAPHICS_SETTINGS.bloomEnabled) {
                    bloomPass.enabled = true;
                }
            }

            // 환경 효과 재적용
            forceUpdateEnvironmentEffects();

            // 활성 모드 해제
            if (this.activeMode === type) {
                this.activeMode = null;
            }

            console.log(`View Mode Exit: ${type}`);
        },

        // 모든 뷰 모드 종료
        exitAllViewModes() {
            Object.keys(this.configs).forEach(type => {
                this.exitViewMode(type);
            });
        },

        // 특정 타입 제외하고 모든 뷰 모드 종료
        exitAllExcept(exceptType) {
            Object.keys(this.configs).forEach(type => {
                if (type !== exceptType) {
                    this.exitViewMode(type);
                }
            });
        },

        // 현재 활성화된 뷰 모드 확인
        isAnyViewActive() {
            return Object.keys(this.configs).some(type => this.configs[type].isActiveFlag());
        },

        // 특정 뷰 모드 활성화 확인
        isViewActive(type) {
            const config = this.configs[type];
            return config ? config.isActiveFlag() : false;
        }
    };

    /* =========================================================
     * DATA VIEW LEGEND PANEL - 범례 패널 관리
     * ========================================================= */
    const dataViewLegend = document.getElementById('dataViewLegend');
    const legendIcon = document.getElementById('legendIcon');
    const legendTitle = document.getElementById('legendTitle');
    const legendStatLabel = document.getElementById('legendStatLabel');
    const legendStatValue = document.getElementById('legendStatValue');
    const legendLandValueItem = document.getElementById('legendLandValue');
    const legendBuildingValueItem = document.getElementById('legendBuildingValue');
    const legendPopulationItem = document.getElementById('legendPopulation');
    const legendTrafficItem = document.getElementById('legendTraffic');
    const legendClose = document.getElementById('legendClose');
    const legendTerrainColor = document.getElementById('legendTerrainColor');
    const legendBuildingColor = document.getElementById('legendBuildingColor');
    const legendPopColor = document.getElementById('legendPopColor');
    const legendTrafficColor = document.getElementById('legendTrafficColor');

    let currentLegendType = null;

    function showDataViewLegend(type) {
        if (!dataViewLegend) return;

        currentLegendType = type;

        // 모든 범례 아이템 숨기기
        if (legendLandValueItem) legendLandValueItem.style.display = 'none';
        if (legendBuildingValueItem) legendBuildingValueItem.style.display = 'none';
        if (legendPopulationItem) legendPopulationItem.style.display = 'none';
        if (legendTrafficItem) legendTrafficItem.style.display = 'none';

        if (type === 'landValue') {
            legendIcon.textContent = '💰';
            legendTitle.textContent = '땅값';
            legendStatLabel.textContent = '평균 땅값';

            // 평균 땅값 계산
            const avgLandValue = calculateAverageLandValue();
            legendStatValue.textContent = `₩${formatNumber(avgLandValue)}/칸`;

            // 범례 아이템 표시
            if (legendLandValueItem) legendLandValueItem.style.display = 'block';
            if (legendBuildingValueItem) legendBuildingValueItem.style.display = 'block';

        } else if (type === 'population') {
            legendIcon.textContent = '👥';
            legendTitle.textContent = '인구';
            legendStatLabel.textContent = '총 인구';
            legendStatValue.textContent = `${cityStats.population.toLocaleString()}명`;

            // 범례 아이템 표시
            if (legendPopulationItem) legendPopulationItem.style.display = 'block';

        } else if (type === 'traffic') {
            legendIcon.textContent = '🚗';
            legendTitle.textContent = '교통량';
            legendStatLabel.textContent = '평균 혼잡도';

            // 평균 교통량 계산
            const avgTraffic = calculateAverageTraffic();
            legendStatValue.textContent = `${avgTraffic}%`;

            // 범례 아이템 표시
            if (legendTrafficItem) legendTrafficItem.style.display = 'block';

        } else if (type === 'zone') {
            legendIcon.textContent = '🏘️';
            legendTitle.textContent = '구역 설정';
            legendStatLabel.textContent = '구역 타일 수';

            // 구역 타일 수 계산
            const tiles = countZoneTiles();
            legendStatValue.textContent = `주거 ${tiles.residential} / 상업 ${tiles.commercial} / 산업 ${tiles.industrial}`;

            // 구역 모드에서는 별도의 범례 아이템 없음 (구역 색상은 메시로 표시)
        }

        dataViewLegend.classList.add('visible');
    }

    function hideDataViewLegend() {
        if (!dataViewLegend) return;
        dataViewLegend.classList.remove('visible');
        currentLegendType = null;
    }

    // 평균 땅값 계산
    function calculateAverageLandValue() {
        let totalLandValue = 0;
        let tileCount = 0;

        for (let y = 0; y < GRID_H; y++) {
            for (let x = 0; x < GRID_W; x++) {
                const cell = grid[x][y];
                // 빈 타일과 도로 제외
                if (cell !== CELL.EMPTY && cell !== CELL.ROAD && cell !== CELL.LOCKED_ROAD) {
                    const baseLandValue = getLandValue(x, y);
                    const serviceBonus = getServiceBonus(x, y);
                    totalLandValue += baseLandValue + serviceBonus;
                    tileCount++;
                }
            }
        }

        return tileCount > 0 ? Math.round(totalLandValue / tileCount) : 0;
    }

    // 숫자 포맷 (천 단위 콤마)
    function formatNumber(num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // 평균 교통량 계산
    function calculateAverageTraffic() {
        if (!trafficManager || !trafficManager.initialized) return 0;

        let totalTraffic = 0;
        let roadCount = 0;

        for (let y = 0; y < GRID_H; y++) {
            for (let x = 0; x < GRID_W; x++) {
                const cell = grid[x][y];
                if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD) {
                    const traffic = trafficManager.getTrafficLevel(x, y);
                    totalTraffic += traffic;
                    roadCount++;
                }
            }
        }

        return roadCount > 0 ? Math.round(totalTraffic / roadCount) : 0;
    }

    // 범례 패널 닫기 버튼 이벤트
    if (legendClose) {
        legendClose.addEventListener('click', () => {
            // 현재 활성화된 뷰 종료
            if (isLandValueViewActive) {
                exitLandValueView();
            } else if (isPopulationViewActive) {
                exitPopulationView();
            } else if (isTrafficViewActive) {
                hideTrafficView();
                if (btnTrafficView) btnTrafficView.classList.remove('active');
                setMode(MODE.BUILD);
            }
        });
    }

    // 체크박스 이벤트 (선택적 기능 토글)
    if (legendTerrainColor) {
        legendTerrainColor.addEventListener('change', (e) => {
            if (landValueOverlayMesh) {
                landValueOverlayMesh.visible = e.target.checked;
            }
        });
    }

    if (legendBuildingColor) {
        legendBuildingColor.addEventListener('change', (e) => {
            // 건물 색상 토글 기능 (현재는 시각적 피드백용)
            // 실제 기능은 추후 구현 가능
        });
    }

    /* =========================================================
     * UTILITY LEGEND PANEL - 전력/수도 게이지 패널
     * ========================================================= */
    const utilityLegend = document.getElementById('utilityLegend');
    const utilityLegendIcon = document.getElementById('utilityLegendIcon');
    const utilityLegendTitle = document.getElementById('utilityLegendTitle');
    const utilityLegendClose = document.getElementById('utilityLegendClose');
    const gaugeNeedle = document.getElementById('gaugeNeedle');
    const gaugeValue = document.getElementById('gaugeValue');
    const gaugeMaxLabel = document.getElementById('gaugeMaxLabel');
    const utilityCurrentUsage = document.getElementById('utilityCurrentUsage');
    const utilityTotalCapacity = document.getElementById('utilityTotalCapacity');
    const utilityRemaining = document.getElementById('utilityRemaining');
    const utilityStatus = document.getElementById('utilityStatus');

    let currentUtilityType = null;  // 'power' or 'water'
    let utilityUpdateInterval = null;

    // 유틸리티 범례 표시
    function showUtilityLegend(type) {
        if (!utilityLegend) return;

        currentUtilityType = type;

        // 기존 업데이트 인터벌 정리
        if (utilityUpdateInterval) {
            clearInterval(utilityUpdateInterval);
        }

        // 타입별 설정
        utilityLegend.classList.remove('power', 'water');
        utilityLegend.classList.add(type);

        if (type === 'power') {
            utilityLegendIcon.textContent = '⚡';
            utilityLegendTitle.textContent = '전력';
        } else if (type === 'water') {
            utilityLegendIcon.textContent = '💧';
            utilityLegendTitle.textContent = '수도';
        }

        // 초기 업데이트
        updateUtilityGauge();

        // 주기적 업데이트 (1초마다)
        utilityUpdateInterval = setInterval(updateUtilityGauge, 1000);

        utilityLegend.classList.add('visible');
    }

    // 유틸리티 범례 숨기기
    function hideUtilityLegend() {
        if (!utilityLegend) return;

        utilityLegend.classList.remove('visible');
        currentUtilityType = null;

        if (utilityUpdateInterval) {
            clearInterval(utilityUpdateInterval);
            utilityUpdateInterval = null;
        }
    }

    // 게이지 업데이트
    function updateUtilityGauge() {
        if (!currentUtilityType) return;

        let usage = 0;
        let capacity = 0;
        let unit = '';

        if (currentUtilityType === 'power') {
            usage = cityStats.powerUsage || 0;
            capacity = cityStats.powerCapacity || 0;
            unit = 'kW';
        } else if (currentUtilityType === 'water') {
            usage = cityStats.waterUsage || 0;
            capacity = cityStats.waterCapacity || 0;
            unit = 'L';
        }

        // 백분율 계산 (용량이 0이면 0%, 초과하면 100% 이상 가능)
        const percentage = capacity > 0 ? Math.min((usage / capacity) * 100, 120) : 0;
        const displayPercentage = Math.round(percentage);

        // 바늘 회전 (0% = -90도, 100% = 90도, 선형 보간)
        // 0% -> -90도, 50% -> 0도, 100% -> 90도
        const needleAngle = -90 + (percentage / 100) * 180;
        if (gaugeNeedle) {
            gaugeNeedle.setAttribute('transform', `rotate(${needleAngle}, 100, 100)`);
        }

        // 값 표시 업데이트
        if (gaugeValue) {
            gaugeValue.textContent = `${displayPercentage}%`;
        }

        if (gaugeMaxLabel) {
            gaugeMaxLabel.textContent = capacity.toLocaleString();
        }

        if (utilityCurrentUsage) {
            utilityCurrentUsage.textContent = `${usage.toLocaleString()} ${unit}`;
        }

        if (utilityTotalCapacity) {
            utilityTotalCapacity.textContent = `${capacity.toLocaleString()} ${unit}`;
        }

        const remaining = capacity - usage;
        if (utilityRemaining) {
            utilityRemaining.textContent = `${remaining.toLocaleString()} ${unit}`;
        }

        // 상태 업데이트
        updateUtilityStatus(percentage, remaining);
    }

    // 상태 표시 업데이트
    function updateUtilityStatus(percentage, remaining) {
        if (!utilityStatus) return;

        const highlightRow = utilityRemaining?.closest('.utility-stat-row');

        utilityStatus.classList.remove('warning', 'danger');
        if (highlightRow) highlightRow.classList.remove('warning', 'danger');

        const statusIcon = utilityStatus.querySelector('.utility-status-icon');
        const statusText = utilityStatus.querySelector('.utility-status-text');

        if (percentage >= 100) {
            // 용량 초과
            utilityStatus.classList.add('danger');
            if (highlightRow) highlightRow.classList.add('danger');
            if (statusIcon) statusIcon.textContent = '⚠️';
            if (statusText) statusText.textContent = '용량 초과! 시설 추가 필요';
        } else if (percentage >= 80) {
            // 경고 상태
            utilityStatus.classList.add('warning');
            if (highlightRow) highlightRow.classList.add('warning');
            if (statusIcon) statusIcon.textContent = '⚠️';
            if (statusText) statusText.textContent = '용량 부족 주의';
        } else {
            // 정상 상태
            if (statusIcon) statusIcon.textContent = '✓';
            if (statusText) statusText.textContent = '정상 공급 중';
        }
    }

    // 유틸리티 범례 닫기 버튼
    if (utilityLegendClose) {
        utilityLegendClose.addEventListener('click', () => {
            hideUtilityLegend();
            // 관련 모드 종료
            if (currentMode === MODE.POWER_VIEW ||
                currentMode === MODE.PLACE_POWER_COAL ||
                currentMode === MODE.PLACE_POWER_WIND) {
                setMode(MODE.CAMERA);
            } else if (currentMode === MODE.WATER_VIEW ||
                       currentMode === MODE.PLACE_WATER_TOWER ||
                       currentMode === MODE.PLACE_WATER_PUMP) {
                setMode(MODE.CAMERA);
            }
        });
    }

    function toggleLandValueView() {
        if (isLandValueViewActive) {
            exitLandValueView();
        } else {
            enterLandValueView();
        }
    }

    let landValueAnimationFrameId = null;

    function enterLandValueView() {
        if (isLandValueViewActive) return;

        // 인구 뷰가 켜져있으면 끄기
        if (typeof isPopulationViewActive !== 'undefined' && isPopulationViewActive) {
            exitPopulationView();
        }

        isLandValueViewActive = true;

        // Bloom 효과 끄기
        if (typeof bloomPass !== 'undefined') {
            bloomPass.enabled = false;
        }

        // 땅값 시각화 생성 및 표시
        createLandValueVisualization();
        landValueGroup.visible = true;

        // 차량도 회색으로 변경 (땅값 뷰에서 시각적 일관성)
        applyLandValueToVehicles();

        // 페이드인 애니메이션
        animateLandValueFadeIn();

        // 모드 변경
        setMode(MODE.LAND_VALUE_VIEW);

        // 버튼 상태 업데이트
        if (btnLandValue) btnLandValue.classList.add('active');
        if (btnPopulation) btnPopulation.classList.remove('active');

        // 범례 패널 표시
        showDataViewLegend('landValue');

        console.log("Land Value View: ON");
    }

    function exitLandValueView() {
        // ViewModeManager에 위임
        ViewModeManager.exitViewMode('landValue');
    }

    // 땅값 뷰 페이드인 애니메이션
    function animateLandValueFadeIn() {
        if (landValueAnimationFrameId) {
            cancelAnimationFrame(landValueAnimationFrameId);
        }

        const animationDuration = 400;  // 0.4초
        const startTime = performance.now();

        if (landValueOverlayMesh) {
            landValueOverlayMesh.material.opacity = 0;
        }

        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);

            // easeOutCubic 이징
            const eased = 1 - Math.pow(1 - progress, 3);

            if (landValueOverlayMesh) {
                landValueOverlayMesh.material.opacity = 0.7 * eased;
            }

            if (progress < 1) {
                landValueAnimationFrameId = requestAnimationFrame(animate);
            } else {
                landValueAnimationFrameId = null;
            }
        }

        landValueAnimationFrameId = requestAnimationFrame(animate);
    }

    /* =========================================================
     * POPULATION SYSTEM - 인구 시스템
     * 건물 크기에 따른 인구 배정 (1x1 빌라: 작음, 2x2 아파트: 큼)
     * ========================================================= */

    // 건물별 인구 데이터 저장 (buildingKey -> population)
    const buildingPopulations = new Map();

    // 인구 범위 설정
    const POPULATION_RANGES = {
        "1x1": { min: 5, max: 15 },    // 빌라: 5-15명
        "2x2": { min: 30, max: 60 }    // 아파트: 30-60명
    };

    // 건물에 인구 배정 (랜덤하게)
    function assignBuildingPopulation(buildingKey, size) {
        if (buildingPopulations.has(buildingKey)) {
            return buildingPopulations.get(buildingKey);
        }

        const range = POPULATION_RANGES[size] || POPULATION_RANGES["1x1"];
        const population = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        buildingPopulations.set(buildingKey, population);
        return population;
    }

    // 건물 키 생성 (좌표 기반)
    function getBuildingKey(x, y, size) {
        return `${x},${y},${size}`;
    }

    // 총 인구 계산
    function calculateTotalPopulation() {
        let total = 0;
        buildingPopulations.forEach(pop => total += pop);
        return total;
    }

    /* =========================================================
     * BUILDING NAME SYSTEM - 건물 이름 생성
     * ========================================================= */

    // 건물별 이름 데이터 저장 (buildingKey -> name)
    const buildingNames = new Map();

    // 건물 이름 조합용 데이터
    const BUILDING_NAME_PREFIXES = {
        residential: ['해피', '그린', '블루', '골든', '스마트', '파크', '선샤인', '레이크', '힐', '스카이'],
        commercial: ['플라자', '센터', '마트', '타운', '스퀘어', '몰', '파크', '스트리트', '에비뉴', '코너'],
        industrial: ['테크', '스틸', '파워', '메탈', '프라임', '글로벌', '메가', '퍼스트', '유니온', '월드']
    };

    const BUILDING_NAME_SUFFIXES = {
        residential: ['빌라', '하우스', '팰리스', '맨션', '아파트', '타워', '레지던스', '힐스', '파크', '테라스'],
        commercial: ['마켓', '슈퍼', '스토어', '샵', '백화점', '편의점', '쇼핑몰', '상가', '시장', '마트'],
        industrial: ['공장', '웨어하우스', '팩토리', '센터', '산업', '물류', '제조', '창고', '단지', '플랜트']
    };

    // 랜덤 건물 이름 생성
    function generateBuildingName(zoneType) {
        const type = zoneType.includes('residential') ? 'residential' :
                     zoneType.includes('commercial') ? 'commercial' : 'industrial';

        const prefixes = BUILDING_NAME_PREFIXES[type];
        const suffixes = BUILDING_NAME_SUFFIXES[type];

        const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
        const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];

        // 1-999 사이의 랜덤 숫자 (간혹 추가)
        const addNumber = Math.random() > 0.5;
        const number = addNumber ? ` ${Math.floor(Math.random() * 999) + 1}` : '';

        return prefix + ' ' + suffix + number;
    }

    // 건물에 이름 배정 (없으면 새로 생성)
    function assignBuildingName(buildingKey, zoneType) {
        if (buildingNames.has(buildingKey)) {
            return buildingNames.get(buildingKey);
        }

        const name = generateBuildingName(zoneType);
        buildingNames.set(buildingKey, name);
        return name;
    }

    /* =========================================================
     * POPULATION VISUALIZATION SYSTEM - 인구 시각화
     * ========================================================= */
    const populationGroup = new THREE.Group();
    populationGroup.name = "populationGroup";
    populationGroup.visible = false;
    scene.add(populationGroup);

    let isPopulationViewActive = false;
    let populationAnimationFrameId = null;

    // 인구 수치 시각화 생성
    function createPopulationVisualization() {
        // 기존 시각화 제거
        while (populationGroup.children.length > 0) {
            const child = populationGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
            populationGroup.remove(child);
        }

        // 건물 그룹에서 주거 건물만 찾아서 그래프 생성
        const maxPopulation = POPULATION_RANGES["2x2"].max;  // 최대 인구로 정규화

        console.log(`Population View: buildingGroup has ${buildingGroup.children.length} children`);

        buildingGroup.children.forEach(building => {
            // 주거 건물만 처리 (zoneType이 'residential'로 시작하면 OK)
            const zoneType = building.userData?.zoneType || '';
            if (!zoneType.includes('residential')) return;

            const size = building.userData.size || "1x1";
            const x = building.userData.tileX;
            const y = building.userData.tileY;
            const key = getBuildingKey(x, y, size);

            // 인구 배정 (없으면 새로 생성)
            const population = assignBuildingPopulation(key, size);

            // 그래프 높이 계산 (최대 2.0 유닛)
            const targetHeight = (population / maxPopulation) * 2.0;

            // 초록색 그래프 생성 (처음에는 높이 0으로) - 반투명
            const geo = new THREE.BoxGeometry(TILE_SIZE * 0.4, 0.01, TILE_SIZE * 0.4);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x4ade80,  // 초록색
                transparent: true,
                opacity: 0.85,
                emissive: 0x2a8050,
                emissiveIntensity: 0.5,
            });

            const bar = new THREE.Mesh(geo, mat);

            // 2x2 건물은 중앙에, 1x1은 타일 중심에
            const offsetX = size === "2x2" ? 1 : 0.5;
            const offsetZ = size === "2x2" ? 1 : 0.5;

            bar.position.set(
                (x - GRID_W / 2 + offsetX) * TILE_SIZE,
                0.01,  // 애니메이션 시작 높이
                (y - GRID_H / 2 + offsetZ) * TILE_SIZE
            );

            // 애니메이션용 데이터 저장
            bar.userData.targetHeight = targetHeight;
            bar.userData.currentHeight = 0.01;
            bar.userData.population = population;

            populationGroup.add(bar);
        });

        console.log(`Population View: created ${populationGroup.children.length} bars`);

        // 그래프 높이 애니메이션 시작
        animatePopulationBars();
    }

    // 그래프 애니메이션 (0에서 원래 높이까지)
    function animatePopulationBars() {
        if (populationAnimationFrameId) {
            cancelAnimationFrame(populationAnimationFrameId);
        }

        const animationDuration = 500;  // 0.5초
        const startTime = performance.now();

        function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);

            // easeOutCubic 이징
            const eased = 1 - Math.pow(1 - progress, 3);

            populationGroup.children.forEach(bar => {
                const targetHeight = bar.userData.targetHeight;
                const newHeight = 0.01 + (targetHeight - 0.01) * eased;

                // 스케일로 높이 조절
                bar.scale.y = newHeight / 0.01;
                bar.position.y = newHeight / 2;
            });

            if (progress < 1) {
                populationAnimationFrameId = requestAnimationFrame(animate);
            } else {
                populationAnimationFrameId = null;
            }
        }

        populationAnimationFrameId = requestAnimationFrame(animate);
    }

    // 인구 뷰 토글
    function togglePopulationView() {
        if (isPopulationViewActive) {
            exitPopulationView();
        } else {
            enterPopulationView();
        }
    }

    function enterPopulationView() {
        if (isPopulationViewActive) return;

        // 땅값 뷰가 켜져있으면 끄기
        if (isLandValueViewActive) {
            exitLandValueView();
        }

        isPopulationViewActive = true;

        // Bloom 효과 끄기
        if (typeof bloomPass !== 'undefined') {
            bloomPass.enabled = false;
        }

        // 구역 모드 효과 적용 (흰색)
        applyZoneModeEffect();

        // 주거 건물 반투명 처리
        applyResidentialTransparency();

        // 인구 시각화 생성 및 표시
        createPopulationVisualization();
        populationGroup.visible = true;

        // 모드 변경
        setMode(MODE.POPULATION_VIEW);

        // 버튼 상태 업데이트
        if (btnPopulation) btnPopulation.classList.add('active');
        if (btnLandValue) btnLandValue.classList.remove('active');

        // 범례 패널 표시
        showDataViewLegend('population');

        console.log("Population View: ON");
    }

    // 주거 건물 반투명 처리 (인구 뷰용)
    function applyResidentialTransparency() {
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            if (!building.instance) continue;

            // 주거 건물만 반투명 처리
            const isResidential = building.zoneType === CELL.ZONE_RESIDENTIAL;
            if (isResidential) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            mat.transparent = true;
                            mat.opacity = 0.4;
                            mat.needsUpdate = true;
                        });
                    }
                });
            }
        }
    }

    // 주거 건물 반투명 복원
    function restoreResidentialTransparency() {
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            if (!building.instance) continue;

            const isResidential = building.zoneType === CELL.ZONE_RESIDENTIAL;
            if (isResidential) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            mat.transparent = false;
                            mat.opacity = 1.0;
                            mat.needsUpdate = true;
                        });
                    }
                });
            }
        }
    }

    function exitPopulationView() {
        // ViewModeManager에 위임
        ViewModeManager.exitViewMode('population');
    }

    /* =========================================================
     * GRAPH HOVER TOOLTIP - 그래프 호버 시 툴팁 표시
     * ========================================================= */
    const graphRaycaster = new THREE.Raycaster();
    const graphMouse = new THREE.Vector2();

    function handleGraphHover(e) {
        if (!graphTooltip) return;

        // 마우스 좌표를 정규화된 디바이스 좌표로 변환
        const rect = renderer.domElement.getBoundingClientRect();
        graphMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        graphMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        graphRaycaster.setFromCamera(graphMouse, camera);

        // 인구 뷰 모드
        if (currentMode === MODE.POPULATION_VIEW && populationGroup.visible) {
            const intersects = graphRaycaster.intersectObjects(populationGroup.children);

            if (intersects.length > 0) {
                const bar = intersects[0].object;
                const population = bar.userData?.population;

                if (population !== undefined) {
                    graphTooltip.querySelector('.label').textContent = '인구: ';
                    graphTooltip.querySelector('.value').textContent = `${population}명`;
                    graphTooltip.className = '';
                    graphTooltip.style.display = 'block';
                    graphTooltip.style.left = (e.clientX + 15) + 'px';
                    graphTooltip.style.top = (e.clientY + 15) + 'px';
                    return;
                }
            }
        }

        // 땅값 뷰 모드 (2D 오버레이에서 좌표 기반으로 값 계산)
        if (currentMode === MODE.LAND_VALUE_VIEW && landValueGroup.visible && landValueOverlayMesh) {
            const intersects = graphRaycaster.intersectObject(landValueOverlayMesh);

            if (intersects.length > 0) {
                const point = intersects[0].point;

                // 월드 좌표 -> 그리드 좌표
                const gx = Math.floor(point.x / TILE_SIZE + GRID_W / 2);
                const gz = Math.floor(point.z / TILE_SIZE + GRID_H / 2);

                // 범위 체크
                if (gx >= 0 && gx < GRID_W && gz >= 0 && gz < GRID_H) {
                    const baseLandValue = getLandValue(gx, gz);
                    const serviceBonus = typeof getServiceBonus === 'function' ? getServiceBonus(gx, gz) : 0;
                    const totalValue = baseLandValue + serviceBonus;

                    graphTooltip.querySelector('.label').textContent = '땅값: ';
                    graphTooltip.querySelector('.value').textContent = `${Math.round(totalValue)}`;
                    graphTooltip.className = 'landvalue';
                    graphTooltip.style.display = 'block';
                    graphTooltip.style.left = (e.clientX + 15) + 'px';
                    graphTooltip.style.top = (e.clientY + 15) + 'px';
                    return;
                }
            }
        }

        // 호버하지 않으면 숨김
        graphTooltip.style.display = 'none';
    }

    /* =========================================================
     * ZONE MODE MATERIAL SYSTEM
     * 수치 모드 진입 시 모든 오브젝트를 흰색으로 변경
     * 건물은 반투명, 지형/도로는 불투명
     * ========================================================= */
    const originalMaterials = new Map();  // mesh uuid -> original material(s)
    let isZoneModeActive = false;

    // 폴백 머티리얼 (복원 실패 시 사용)
    const fallbackMaterial = new THREE.MeshLambertMaterial({
        color: 0x888888,
        transparent: false,
    });

    // 머티리얼 유효성 검사 및 안전한 복원 헬퍼
    function isValidMaterial(mat) {
        if (!mat) return false;
        // 기본적인 머티리얼 속성 확인
        if (typeof mat !== 'object') return false;
        // isMaterial 체크 (Three.js 머티리얼인지 확인)
        if (!mat.isMaterial) return false;
        // map이 있는 경우 유효한 텍스처인지 확인
        if (mat.map) {
            // 이미 disposed된 텍스처 확인 (source나 image가 없으면 disposed됨)
            if (!mat.map.source && !mat.map.image) {
                mat.map = null;  // disposed된 map 제거
                mat.needsUpdate = true;  // 머티리얼 업데이트 필요
            }
        }
        return true;
    }

    function safeAssignMaterial(mesh, material) {
        if (!mesh) return false;

        try {
            if (!material) {
                mesh.material = fallbackMaterial.clone();
                return false;
            }

            if (Array.isArray(material)) {
                const validMaterials = material.filter(m => isValidMaterial(m));
                if (validMaterials.length > 0) {
                    mesh.material = validMaterials;
                    return true;
                } else {
                    mesh.material = fallbackMaterial.clone();
                    return false;
                }
            } else if (isValidMaterial(material)) {
                mesh.material = material;
                return true;
            } else {
                mesh.material = fallbackMaterial.clone();
                return false;
            }
        } catch (e) {
            console.warn('Material assignment failed:', e);
            mesh.material = fallbackMaterial.clone();
            return false;
        }
    }

    // 토대(잔디)용 흰색 머티리얼 (불투명) - 구역 모드에서 흰색 배경
    const whiteMaterialSolid = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.5,
        roughness: 0.9,
        metalness: 0.0,
        transparent: false,
    });

    // 도로/수로/다리용 회색 머티리얼 (불투명) - 토대와 구분
    const grayMaterialSolid = new THREE.MeshStandardMaterial({
        color: 0x888888,
        emissive: 0xaaaaaa,
        emissiveIntensity: 0.3,
        roughness: 0.9,
        metalness: 0.0,
        transparent: false,
    });

    // 건물용 회색 머티리얼 (불투명) - 구역 색상과 구분
    const grayMaterialBuilding = new THREE.MeshStandardMaterial({
        color: 0x666666,
        emissive: 0x888888,
        emissiveIntensity: 0.25,
        roughness: 0.9,
        metalness: 0.0,
        transparent: false,
    });

    // 데이터 뷰 모드 진입 전 환경 설정 저장용
    let savedEnvironment = null;

    function applyZoneModeEffect() {
        if (isZoneModeActive) return;
        isZoneModeActive = true;
        originalMaterials.clear();

        // 현재 환경 설정 저장 (밤일 때 복원용)
        savedEnvironment = {
            skyboxVisible: skyboxMesh.visible,
            skyboxBlendDaySunset: skyboxBlendDaySunset,
            skyboxBlendSunsetNight: skyboxBlendSunsetNight,
            sceneEnvironment: scene.environment,
            hemiIntensity: hemiLight.intensity,
            hemiSkyColor: hemiLight.color.getHex(),
            hemiGroundColor: hemiLight.groundColor.getHex(),
            dirIntensity: dir.intensity,
            dirColor: dir.color.getHex(),
            nightAmbientIntensity: nightAmbient.intensity,
            exposure: renderer.toneMappingExposure,
            fogColor: scene.fog.color.getHex(),
            fogDensity: scene.fog.density,
            bloomStrength: bloomPass.strength,
        };

        // 데이터 뷰용 밝은 환경 설정
        skyboxMesh.visible = false;  // Skybox 숨김
        scene.background = new THREE.Color(0xf0f0f0);  // 밝은 회색 배경
        scene.environment = null;  // 환경맵 비활성화
        hemiLight.intensity = 1.2;
        hemiLight.color.setHex(0xffffff);
        hemiLight.groundColor.setHex(0xffffff);
        dir.intensity = 1.0;
        dir.color.setHex(0xffffff);
        nightAmbient.intensity = 0.3;
        renderer.toneMappingExposure = 1.2;
        scene.fog.color.setHex(0xf0f0f0);
        scene.fog.density = 0.005;
        bloomPass.strength = 0.1;

        // 토대(잔디)는 흰색
        grassGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                originalMaterials.set(child.uuid, child.material);
                child.material = whiteMaterialSolid.clone();
            }
        });

        // 나무도 흰색 (데이터 뷰에서 잘 보이도록)
        treeGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                originalMaterials.set(child.uuid, child.material);
                child.material = whiteMaterialSolid.clone();
            }
        });

        // 도로, 수로, 다리는 회색 (토대와 구분)
        const grayGroups = [roadGroup, waterGroup, bridgeGroup];
        grayGroups.forEach(group => {
            group.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialSolid;  // 공유 재질 사용 (성능 최적화)
                }
            });
        });

        // 건물은 해당 구역 타입 색상으로 표시
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building } of buildingsArray) {
            if (!building.instance) continue;

            // 구역 타입에 따른 색상 결정
            let buildingColor = 0x888888; // 기본 회색
            if (building.zoneType === CELL.ZONE_RESIDENTIAL) {
                buildingColor = ZONE_COLORS[CELL.ZONE_RESIDENTIAL]; // 초록
            } else if (building.zoneType === CELL.ZONE_COMMERCIAL) {
                buildingColor = ZONE_COLORS[CELL.ZONE_COMMERCIAL]; // 파랑
            } else if (building.zoneType === CELL.ZONE_INDUSTRIAL) {
                buildingColor = ZONE_COLORS[CELL.ZONE_INDUSTRIAL]; // 노랑
            }

            const zoneMat = new THREE.MeshLambertMaterial({
                color: buildingColor,
                transparent: true,
                opacity: 0.85
            });

            building.instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = zoneMat;
                }
            });
        }

        // 공공시설은 회색으로 표시
        placedPublicBuildings.forEach((building) => {
            if (building.ref || !building.instance) return;
            building.instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialBuilding;
                }
            });
        });

        // 차량도 회색 (교통 시스템이 초기화된 경우)
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            trafficManager.vehicleGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialBuilding;  // 공유 재질 사용 (성능 최적화)
                }
            });
        }
    }

    function restoreOriginalMaterials() {
        if (!isZoneModeActive) return;
        isZoneModeActive = false;

        // 저장된 환경 설정 복원
        if (savedEnvironment) {
            // Skybox 상태 복원
            skyboxMesh.visible = savedEnvironment.skyboxVisible;
            skyboxBlendDaySunset = savedEnvironment.skyboxBlendDaySunset;
            skyboxBlendSunsetNight = savedEnvironment.skyboxBlendSunsetNight;
            skyboxMaterial.uniforms.tBlendDaySunset.value = skyboxBlendDaySunset;
            skyboxMaterial.uniforms.tBlendSunsetNight.value = skyboxBlendSunsetNight;
            scene.background = null;  // Skybox가 배경 담당
            scene.environment = savedEnvironment.sceneEnvironment;
            // 조명 설정 복원
            hemiLight.intensity = savedEnvironment.hemiIntensity;
            hemiLight.color.setHex(savedEnvironment.hemiSkyColor);
            hemiLight.groundColor.setHex(savedEnvironment.hemiGroundColor);
            dir.intensity = savedEnvironment.dirIntensity;
            dir.color.setHex(savedEnvironment.dirColor);
            nightAmbient.intensity = savedEnvironment.nightAmbientIntensity;
            renderer.toneMappingExposure = savedEnvironment.exposure;
            scene.fog.color.setHex(savedEnvironment.fogColor);
            scene.fog.density = savedEnvironment.fogDensity;
            bloomPass.strength = savedEnvironment.bloomStrength;
            savedEnvironment = null;
        }

        const groups = [grassGroup, treeGroup, roadGroup, waterGroup, bridgeGroup, buildingGroup];

        // 차량 그룹도 추가
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            groups.push(trafficManager.vehicleGroup);
        }

        // 머티리얼 복원 헬퍼 함수
        function restoreMeshMaterial(child) {
            if (child.isMesh && originalMaterials.has(child.uuid)) {
                // 폐건물인지 확인 - 폐건물은 회색 유지
                let parentObj = child;
                while (parentObj.parent && !parentObj.userData?.isAbandoned) {
                    parentObj = parentObj.parent;
                }
                if (parentObj.userData?.isAbandoned) {
                    // 폐건물은 회색으로 유지
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        if (mat.color) mat.color.setHex(ABANDONED_GRAY);
                    });
                    return;
                }

                const currentMaterial = child.material;
                const originalMaterial = originalMaterials.get(child.uuid);

                // 현재 재질 (흰색 재질)의 UUID를 색상 캐시에서 제거
                if (currentMaterial && currentMaterial !== originalMaterial) {
                    const currentMats = Array.isArray(currentMaterial) ? currentMaterial : [currentMaterial];
                    currentMats.forEach(mat => {
                        if (mat && mat.uuid) {
                            originalObjectColors.delete(mat.uuid);
                        }
                    });
                }

                // 안전한 머티리얼 할당 사용
                safeAssignMaterial(child, originalMaterial);
            }
        }

        groups.forEach(group => {
            group.traverse(restoreMeshMaterial);
        });

        // 모든 차량(활성/비활성 포함) 명시적 복원
        // vehicleGroup.traverse가 비활성 차량을 놓칠 수 있으므로 명시적으로 처리
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicles) {
            trafficManager.vehicles.forEach(vehicle => {
                if (vehicle.mesh) {
                    vehicle.mesh.traverse(restoreMeshMaterial);
                }
            });
        }

        originalMaterials.clear();

        // 색상 틴트 강제 재계산
        lastColorTintHour = -1;

        // 복원 후 시간대별 색감 다시 적용
        forceUpdateEnvironmentEffects();
    }

    // 환경 효과 강제 업데이트 (통계 모드 종료 시 호출)
    function forceUpdateEnvironmentEffects() {
        lastColorTintHour = -1;  // 강제 업데이트
        const hour = (timeState.gameTime / 3600) % 24;
        const isNight = hour >= 20 || hour < 5;
        updateSceneColorTint(hour, isNight);

        // 건물 발광도 다시 적용
        lastEmissiveState = null;
        updateBuildingEmissive(isNight);
    }

    /* =========================================================
     * PUBLIC BUILDING PLACEMENT MODE EFFECT
     * 건물 설치 모드 진입 시 같은 종류는 초록색, 나머지는 흰색
     * ========================================================= */
    // placedPublicBuildings는 상단에서 초기화됨 (TDZ 방지)

    const placementOriginalMaterials = new Map();
    let isPlacementModeActive = false;
    let currentPlacementType = null;

    // 설치 모드용 초록색 머티리얼 (같은 종류 건물)
    const greenMaterialPlacement = new THREE.MeshStandardMaterial({
        color: 0x44ff66,
        transparent: true,
        opacity: 0.8,
    });

    // 설치 모드용 회색 머티리얼 (건물/차량용)
    const grayMaterialPlacement = new THREE.MeshStandardMaterial({
        color: 0x666666,
        emissive: 0x888888,
        emissiveIntensity: 0.25,
        transparent: false,
    });

    function applyPlacementModeEffect(buildingType) {
        if (isPlacementModeActive) {
            restorePlacementModeEffect();
        }

        isPlacementModeActive = true;
        currentPlacementType = buildingType;
        placementOriginalMaterials.clear();

        // 공공시설 메시 UUID 수집 (나중에 buildingGroup에서 제외하기 위해)
        const publicBuildingMeshUuids = new Set();
        placedPublicBuildings.forEach((building, key) => {
            if (building.instance) {
                building.instance.traverse((child) => {
                    if (child.isMesh) {
                        publicBuildingMeshUuids.add(child.uuid);
                    }
                });
            }
        });

        // 토대(잔디) - 흰색
        grassGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                placementOriginalMaterials.set(child.uuid, child.material);
                child.material = whiteMaterialSolid.clone();
            }
        });

        // 나무 - 흰색
        treeGroup.traverse((child) => {
            if (child.isMesh && child.material) {
                placementOriginalMaterials.set(child.uuid, child.material);
                child.material = whiteMaterialSolid.clone();
            }
        });

        // 도로, 수로, 다리 - 회색 (토대와 구분)
        const grayGroups = [roadGroup, waterGroup, bridgeGroup];
        grayGroups.forEach(group => {
            group.traverse((child) => {
                if (child.isMesh && child.material) {
                    placementOriginalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialSolid.clone();
                }
            });
        });

        // 일반 건물 - 회색 (공공시설 제외)
        buildingGroup.traverse((child) => {
            if (child.isMesh && child.material && !publicBuildingMeshUuids.has(child.uuid)) {
                placementOriginalMaterials.set(child.uuid, child.material);
                child.material = grayMaterialPlacement.clone();
            }
        });

        // 배치된 공공시설 - 같은 종류는 초록색, 다른 종류는 회색
        placedPublicBuildings.forEach((building, key) => {
            if (building.instance) {
                building.instance.traverse((child) => {
                    if (child.isMesh && child.material) {
                        placementOriginalMaterials.set(child.uuid, child.material);
                        if (building.type === buildingType) {
                            // 같은 종류 - 초록색
                            child.material = greenMaterialPlacement.clone();
                        } else {
                            // 다른 종류 - 회색
                            child.material = grayMaterialPlacement.clone();
                        }
                    }
                });
            }
        });

        // 차량 - 회색
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            trafficManager.vehicleGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    placementOriginalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialPlacement.clone();
                }
            });
        }
    }

    function restorePlacementModeEffect() {
        if (!isPlacementModeActive) return;
        isPlacementModeActive = false;
        currentPlacementType = null;

        const groups = [grassGroup, treeGroup, roadGroup, waterGroup, bridgeGroup, buildingGroup];

        // 차량 그룹도 추가
        if (typeof trafficManager !== 'undefined' && trafficManager.vehicleGroup) {
            groups.push(trafficManager.vehicleGroup);
        }

        // 안전한 머티리얼 복원 헬퍼 함수
        function safeRestorePlacementMaterial(child) {
            if (child.isMesh && placementOriginalMaterials.has(child.uuid)) {
                const originalMaterial = placementOriginalMaterials.get(child.uuid);
                safeAssignMaterial(child, originalMaterial);
            }
        }

        // 일반 그룹 복원
        groups.forEach(group => {
            group.traverse(safeRestorePlacementMaterial);
        });

        // 공공시설 복원
        placedPublicBuildings.forEach((building, key) => {
            if (building.instance) {
                building.instance.traverse(safeRestorePlacementMaterial);
            }
        });

        placementOriginalMaterials.clear();

        // 복원 후 시간대별 색감 다시 적용
        lastColorTintHour = -1;
        const hour = (timeState.gameTime / 3600) % 24;
        const isNight = hour >= 20 || hour < 5;
        updateSceneColorTint(hour, isNight);
        lastEmissiveState = null;
        updateBuildingEmissive(isNight);
    }

    // 플로팅 금액 표시
    function showFloatingCost(cost, clientX, clientY) {
        const floater = document.createElement('div');
        floater.className = 'floating-cost';
        floater.textContent = `-₩${cost.toLocaleString()}`;
        floater.style.left = clientX + 'px';
        floater.style.top = clientY + 'px';
        document.body.appendChild(floater);

        // 애니메이션 후 제거
        setTimeout(() => {
            floater.remove();
        }, 1200);
    }

    // 카메라 흔들림 이펙트
    function shakeCamera(intensity = 0.15, duration = 400) {
        const startTime = Date.now();
        const originalY = camera.position.y;

        function animateShake() {
            const elapsed = Date.now() - startTime;
            if (elapsed >= duration) {
                camera.position.y = originalY;
                return;
            }

            const progress = elapsed / duration;
            const decay = 1 - progress;  // 점점 감소
            const shake = Math.sin(progress * Math.PI * 2) * intensity * decay;
            camera.position.y = originalY + shake;

            requestAnimationFrame(animateShake);
        }

        animateShake();
    }

    // 건물 낙하 이펙트
    function animateBuildingDrop(instance, targetY, onComplete) {
        const startY = targetY + 3;  // 3유닛 위에서 시작
        instance.position.y = startY;

        const duration = 400;  // 0.4초
        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            if (elapsed >= duration) {
                instance.position.y = targetY;
                if (onComplete) onComplete();
                return;
            }

            // easeOutBounce 효과
            const progress = elapsed / duration;
            const eased = 1 - Math.pow(1 - progress, 3);  // easeOutCubic
            instance.position.y = startY + (targetY - startY) * eased;

            requestAnimationFrame(animate);
        }

        animate();
    }

    // 서비스 효과 물결 이모지 표시 - 카메라 이동 시에도 건물 위에 고정
    const activeServiceEmojis = [];  // 활성 이모지 추적 배열

    function showServiceEffectRipple(centerX, centerY, effectRadius, isPositive = true) {
        const emoji = isPositive ? '😊' : '😢';
        const affectedBuildings = [];

        // 효과 범위 내 민간건물 찾기
        placedBuildings.forEach((building, key) => {
            // 참조 타일은 스킵
            if (building.ref) return;

            const bx = building.x;
            const by = building.y;
            const bCenterX = bx + (building.width || 1) / 2;
            const bCenterY = by + (building.depth || 1) / 2;

            const dx = bCenterX - centerX;
            const dy = bCenterY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= effectRadius && distance > 0) {
                affectedBuildings.push({
                    instance: building.instance,
                    x: bx,
                    y: by,
                    width: building.width || 1,
                    depth: building.depth || 1,
                    distance: distance
                });
            }
        });

        // 거리순 정렬 (가까운 것부터)
        affectedBuildings.sort((a, b) => a.distance - b.distance);

        // 물결처럼 순차적으로 이모지 표시
        affectedBuildings.forEach((building, index) => {
            const delay = building.distance * 50;  // 거리에 비례한 딜레이 (1칸당 50ms)

            setTimeout(() => {
                // 건물 인스턴스의 실제 3D 위치 사용
                if (!building.instance) return;

                // 건물 머리 위 위치 계산 (건물 높이 + 오프셋)
                const bbox = new THREE.Box3().setFromObject(building.instance);
                const buildingHeight = bbox.max.y;

                const worldPos = new THREE.Vector3(
                    building.instance.position.x,
                    buildingHeight + 0.5,  // 건물 꼭대기 위
                    building.instance.position.z
                );

                // 이모지 요소 생성
                const emojiEl = document.createElement('div');
                emojiEl.className = 'service-emoji';
                emojiEl.textContent = emoji;
                document.body.appendChild(emojiEl);

                // 활성 이모지 추적에 등록
                const emojiData = {
                    element: emojiEl,
                    worldPos: worldPos,
                    startTime: performance.now(),
                    duration: 1500
                };
                activeServiceEmojis.push(emojiData);

                // 초기 위치 업데이트
                updateServiceEmojiPosition(emojiData);

                // 애니메이션 후 제거
                setTimeout(() => {
                    const idx = activeServiceEmojis.indexOf(emojiData);
                    if (idx > -1) activeServiceEmojis.splice(idx, 1);
                    emojiEl.remove();
                }, 1500);
            }, delay);
        });
    }

    // 개별 이모지 위치 업데이트
    function updateServiceEmojiPosition(emojiData) {
        const screenPos = emojiData.worldPos.clone().project(camera);

        // 카메라 뒤에 있으면 숨김
        if (screenPos.z > 1) {
            emojiData.element.style.display = 'none';
            return;
        }

        const clientX = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const clientY = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

        // 화면 밖이면 숨김
        if (clientX < -50 || clientX > window.innerWidth + 50 || clientY < -50 || clientY > window.innerHeight + 50) {
            emojiData.element.style.display = 'none';
            return;
        }

        emojiData.element.style.display = 'block';
        emojiData.element.style.left = clientX + 'px';
        emojiData.element.style.top = clientY + 'px';
    }

    // 모든 활성 이모지 위치 업데이트 (렌더 루프에서 호출)
    function updateAllServiceEmojis() {
        activeServiceEmojis.forEach(emojiData => {
            updateServiceEmojiPosition(emojiData);
        });
    }

    /* =========================================================
     * ROAD CONNECTIVITY CHECK (도로 연결 체크)
     * ========================================================= */
    // disconnectIcons는 더 이상 사용하지 않음 - 통합 상태 아이콘 시스템 사용
    const disconnectIcons = new Map();  // 레거시 호환용 (빈 맵)
    let connectedRoads = new Set();     // 외곽 도로에 연결된 도로들
    const disconnectedBuildings = new Set();  // 연결 끊긴 건물 추적

    // 도로 끊김 폐건물화 시스템
    const buildingRoadDisconnectTime = new Map();  // 건물별 도로 끊긴 시작 시간 (key: "x,y", value: timestamp)
    const buildingRoadAbandonTime = new Map();     // 건물별 폐건물화 예정 시간 (랜덤, 정규분포)
    const ROAD_DISCONNECT_ABANDON_MEAN = 45000;    // 도로 끊김 폐건물 평균 시간 (45초)
    const ROAD_DISCONNECT_ABANDON_STDDEV = 15000;  // 폐건물화 시간 표준편차 (15초)

    // 외곽 도로(LOCKED_ROAD, LOCKED_ROAD_4LANE)에서 BFS로 연결된 모든 도로 찾기
    function findConnectedRoads() {
        connectedRoads.clear();
        const queue = [];

        // 외곽 도로(LOCKED_ROAD, LOCKED_ROAD_4LANE)에서 시작
        for (let gx = 0; gx < GRID_W; gx++) {
            for (let gy = 0; gy < GRID_H; gy++) {
                const cell = grid[gx][gy];
                if (cell === CELL.LOCKED_ROAD || cell === CELL.LOCKED_ROAD_4LANE) {
                    const key = `${gx},${gy}`;
                    connectedRoads.add(key);
                    queue.push({ x: gx, y: gy });
                }
            }
        }

        // BFS로 연결된 도로 탐색 (2차선 및 4차선 도로 포함)
        const directions = [ [0, 1], [0, -1], [1, 0], [-1, 0] ];
        while (queue.length > 0) {
            const { x, y } = queue.shift();

            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;

                const key = `${nx},${ny}`;
                if (connectedRoads.has(key)) continue;

                const cell = grid[nx][ny];
                // 2차선 및 4차선 도로 모두 체크
                if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD ||
                    cell === CELL.ROAD_4LANE || cell === CELL.LOCKED_ROAD_4LANE) {
                    connectedRoads.add(key);
                    queue.push({ x: nx, y: ny });
                }
            }
        }
    }

    // 건물이 연결된 도로에 인접해 있는지 체크
    function isBuildingConnectedToRoad(building) {
        const width = building.width || 1;
        const depth = building.depth || 1;
        const directions = [ [0, 1], [0, -1], [1, 0], [-1, 0] ];

        // 건물의 모든 타일 주변 체크
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const bx = building.x + dx;
                const by = building.y + dy;

                for (const [ddx, ddy] of directions) {
                    const nx = bx + ddx;
                    const ny = by + ddy;
                    const key = `${nx},${ny}`;

                    if (connectedRoads.has(key)) {
                        return true;  // 연결된 도로에 인접
                    }
                }
            }
        }
        return false;
    }

    // 끊김 상태 추가 (통합 시스템 사용)
    function createDisconnectIcon(building, buildingKey) {
        const [x, y] = buildingKey.split(',').map(Number);
        disconnectedBuildings.add(buildingKey);
        addBuildingStatus(x, y, 'NO_ROAD', building);
    }

    // 끊김 상태 제거 (통합 시스템 사용)
    function removeDisconnectIcon(buildingKey) {
        const [x, y] = buildingKey.split(',').map(Number);
        disconnectedBuildings.delete(buildingKey);
        removeBuildingStatus(x, y, 'NO_ROAD');
    }

    // 레거시 호환 함수 (더 이상 개별 위치 업데이트 필요 없음)
    function updateDisconnectIconPosition(iconData) {
        // 통합 시스템에서 처리
    }

    // 레거시 호환 함수
    function updateAllDisconnectIcons() {
        // 통합 시스템의 updateAllStatusIcons()에서 처리
    }

    // 도로 연결 상태 체크 및 상태 업데이트
    function updateRoadConnectivity() {
        // 연결된 도로 찾기
        findConnectedRoads();

        const now = Date.now();

        // 모든 건물 체크 (최적화: Array 캐시 사용)
        const buildingsArray = getPlacedBuildingsArray();
        for (const { building, key } of buildingsArray) {
            const isConnected = isBuildingConnectedToRoad(building);
            const wasDisconnected = disconnectedBuildings.has(key);

            if (!isConnected && !wasDisconnected) {
                // 연결 안됨 + 상태 없음 → 상태 추가
                createDisconnectIcon(building, key);

                // 도로 끊김 시작 시간 기록 + 랜덤 폐건물화 시간 설정
                if (!buildingRoadDisconnectTime.has(key)) {
                    buildingRoadDisconnectTime.set(key, now);
                    // 정규분포 랜덤 시간 (Box-Muller 변환)
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    const abandonTime = Math.max(15000, ROAD_DISCONNECT_ABANDON_MEAN + z * ROAD_DISCONNECT_ABANDON_STDDEV);
                    buildingRoadAbandonTime.set(key, abandonTime);
                }
            } else if (isConnected && wasDisconnected) {
                // 연결됨 + 상태 있음 → 상태 제거
                removeDisconnectIcon(key);
                // 폐건물화 타이머 초기화
                buildingRoadDisconnectTime.delete(key);
                buildingRoadAbandonTime.delete(key);
            }
        }

        // 삭제된 건물의 아이콘 정리
        disconnectIcons.forEach((iconData, key) => {
            if (!placedBuildings.has(key)) {
                removeDisconnectIcon(key);
            }
        });

        // 도로 끊김으로 인한 폐건물 체크
        checkRoadDisconnectAbandonment();
    }

    // 도로 끊김으로 인한 폐건물 체크
    function checkRoadDisconnectAbandonment() {
        const now = Date.now();

        buildingRoadDisconnectTime.forEach((startTime, key) => {
            const building = placedBuildings.get(key);
            if (!building || building.ref) return;

            // 이미 폐건물이면 스킵
            if (building.isAbandoned || building.instance?.userData?.isAbandoned) return;

            const abandonTime = buildingRoadAbandonTime.get(key) || ROAD_DISCONNECT_ABANDON_MEAN;
            const elapsed = now - startTime;

            if (elapsed >= abandonTime) {
                // 폐건물로 전환
                abandonBuildingByRoadDisconnect(building, key);
                // 타이머 정리
                buildingRoadDisconnectTime.delete(key);
                buildingRoadAbandonTime.delete(key);
            }
        });
    }

    // 건물을 폐건물로 전환 (도로 끊김)
    function abandonBuildingByRoadDisconnect(building, key) {
        const [x, y] = key.split(',').map(Number);

        if (!building.instance || !building.instance.userData) return;
        if (building.instance.userData.isAbandoned) return;

        // 폐건물 사유 및 시간 저장
        const userData = building.instance.userData;
        userData.abandonedReason = '도로가 끊겨서 살 수 없어요...';

        // 폐건물 상태 설정
        userData.isAbandoned = true;
        building.isAbandoned = true;
        building.abandonedReason = userData.abandonedReason;

        // 폐건물 목록에 추가
        abandonedBuildings.add(key);

        // 폐건물 색상 적용
        applyAbandonedMaterials(building.instance);

        // 도로 끊김 상태 아이콘 제거 (폐건물 아이콘으로 대체됨)
        removeBuildingStatus(x, y, 'NO_ROAD');
        disconnectedBuildings.delete(key);

        // 폐건물 상태 아이콘 표시 (통합 시스템)
        addBuildingStatus(x, y, 'ABANDONED', building);

        console.log(`[RoadDisconnect] Building abandoned at ${key}: 도로 끊김`);
        markDirty();
    }

    // 공공시설 배치
    function placePublicBuilding(gx, gy, type, clientX = null, clientY = null) {
        const prefabData = getRandomPublicPrefab(type);
        if (!prefabData) {
            console.warn(`No prefab found for ${type}`);
            return false;
        }

        const width = prefabData.width || 2;
        const depth = prefabData.depth || 2;

        // 배치 가능 여부 확인 (도로, 수로, 공공시설은 거부, 민간건물은 철거)
        const civilBuildingsToRemove = [];

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const cx = gx + dx;
                const cy = gy + dy;
                if (cx < 0 || cx >= GRID_W || cy < 0 || cy >= GRID_H) {
                    toast({ title: '배치 불가', desc: '맵 경계를 벗어납니다.' });
                    return false;
                }
                const cell = grid[cx][cy];

                // 도로나 수로 위에는 배치 불가
                if (cell === CELL.ROAD || cell === CELL.LOCKED_ROAD ||
                    cell === CELL.WATER || cell === CELL.BRIDGE) {
                    toast({ title: '배치 불가', desc: '도로나 수로 위에는 건설할 수 없습니다.' });
                    return false;
                }

                // 이미 배치된 공공시설 확인 (참조 타일 포함)
                const key = `${cx},${cy}`;
                if (placedPublicBuildings.has(key)) {
                    toast({ title: '배치 불가', desc: '이미 공공시설이 있습니다.' });
                    return false;
                }

                // 민간건물이 있으면 철거 목록에 추가
                const civilBuilding = typeof findBuildingAt === 'function' ? findBuildingAt(cx, cy) : null;
                if (civilBuilding && !civilBuildingsToRemove.includes(civilBuilding)) {
                    civilBuildingsToRemove.push(civilBuilding);
                }
            }
        }

        // 도로 인접 여부 확인 (건물 외곽 타일 중 하나라도 도로에 인접해야 함)
        let hasAdjacentRoad = false;
        for (let dx = 0; dx < width && !hasAdjacentRoad; dx++) {
            for (let dy = 0; dy < depth && !hasAdjacentRoad; dy++) {
                const cx = gx + dx;
                const cy = gy + dy;
                if (isAdjacentToRoad(cx, cy)) {
                    hasAdjacentRoad = true;
                }
            }
        }
        if (!hasAdjacentRoad) {
            toast({ title: '배치 불가', desc: '도로에 인접한 곳에만 건설할 수 있습니다.' });
            return false;
        }

        // 비용 확인 및 차감
        const cost = PUBLIC_BUILDING_MODELS[type]?.cost || 1000;
        if (!trySpend(cost, PUBLIC_BUILDING_MODELS[type]?.name || type)) {
            return false;
        }

        // 민간건물 철거
        for (const building of civilBuildingsToRemove) {
            if (typeof removeBuildingAt === 'function') {
                removeBuildingAt(building.x, building.y);
            }
        }

        // 나무 제거 (공공시설 영역 내)
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                removeTreeAt(gx + dx, gy + dy);
            }
        }

        // 구역 지정 삭제 (서비스 건물이 들어서는 타일)
        let zoneCleared = false;
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const cx = gx + dx;
                const cy = gy + dy;
                const cell = grid[cx][cy];
                if (cell === CELL.ZONE_RESIDENTIAL || cell === CELL.ZONE_COMMERCIAL || cell === CELL.ZONE_INDUSTRIAL) {
                    grid[cx][cy] = CELL.EMPTY;
                    zoneCleared = true;
                }
            }
        }
        // 구역이 삭제되었으면 시각적 업데이트
        if (zoneCleared) {
            rebuildZoneInstances(false);  // 건물 유지
        }

        // 건물이 차지하는 모든 타일에서 잔디 제거
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                removeGrassTileAt(gx + dx, gy + dy);
            }
        }

        // 플로팅 금액 표시
        if (clientX !== null && clientY !== null) {
            showFloatingCost(cost, clientX, clientY);
        }

        // 모델 인스턴스 생성
        const instance = prefabData.prefab.clone();

        // 머티리얼을 조명 반응형으로 강제 교체
        instance.traverse((child) => {
            if (child.isMesh && child.material) {
                const convertMaterial = (mat) => {
                    const newMat = new THREE.MeshLambertMaterial({
                        color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                        map: mat.map || null,
                        transparent: mat.transparent || false,
                        opacity: mat.opacity !== undefined ? mat.opacity : 1,
                        side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                    });
                    return newMat;
                };

                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => convertMaterial(m));
                } else {
                    child.material = convertMaterial(child.material);
                }
            }
        });

        // 위치 계산
        const worldX = ORIGIN_X + gx + width / 2;
        const worldZ = ORIGIN_Z + gy + depth / 2;
        const targetY = -(prefabData.minY || 0);

        instance.position.set(
            worldX - (prefabData.centerOffsetX || 0),
            targetY,
            worldZ - (prefabData.centerOffsetZ || 0)
        );

        // 도로 방향으로 자동 회전 (앞면이 도로를 향하도록)
        const roadDirection = findNearestRoadDirection(gx, gy, width, depth);
        instance.rotation.y = roadDirection;

        // 그림자 설정
        instance.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        // 공공시설 userData 설정 (클릭 감지용)
        instance.userData = {
            isPublicBuilding: true,
            publicBuildingType: type,
            tileX: gx,
            tileY: gy,
            width: width,
            depth: depth,
            name: PUBLIC_BUILDING_MODELS[type]?.name || type
        };

        // 씬에 추가
        buildingGroup.add(instance);

        // 구역 모드 중 추가된 건물은 원래 머티리얼 저장 후 회색으로 변경
        if (isZoneModeActive) {
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialBuilding.clone();
                }
            });
        }

        // 낙하 이펙트 + 카메라 흔들림
        animateBuildingDrop(instance, targetY, () => {
            shakeCamera(0.12, 250);
        });

        // 차지하는 타일들
        const tiles = [];
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                tiles.push(`${gx + dx},${gy + dy}`);
            }
        }

        // 추적 정보 저장
        const primaryKey = `${gx},${gy}`;
        placedPublicBuildings.set(primaryKey, { type, instance, tiles, x: gx, y: gy, width, depth });

        // 참조 키 추가
        for (const tileKey of tiles) {
            if (tileKey !== primaryKey) {
                placedPublicBuildings.set(tileKey, { ref: primaryKey });
            }
        }

        markDirty();
        toast({ title: '건설 완료', desc: `${PUBLIC_BUILDING_MODELS[type]?.name || type} 설치됨`, success: true });

        // 예산 업데이트
        updateBudgetDisplay();

        // 서비스 효과 물결 이모지 표시 (이로운 시설 = 스마일)
        const config = PUBLIC_BUILDING_MODELS[type];
        if (config && config.effectRadius) {
            const centerX = gx + width / 2;
            const centerY = gy + depth / 2;
            // 모든 공공시설은 이로운 효과 (isPositive = true)
            // 나쁜 효과 시설이 있으면 isNegativeEffect 속성 확인
            const isPositive = !config.isNegativeEffect;
            setTimeout(() => {
                showServiceEffectRipple(centerX, centerY, config.effectRadius, isPositive);
            }, 400);  // 건물 낙하 후 표시
        }

        // 소방서 설치 시 기존 화재에 소방차 출동
        if (type === 'fire') {
            setTimeout(() => {
                dispatchFiretrucksToExistingFires();
            }, 500);  // 건물 설치 완료 후
        }

        // 경찰서 설치 시 기존 사건에 경찰차 출동
        if (type === 'police') {
            setTimeout(() => {
                dispatchPoliceToExistingCrimes();
            }, 500);  // 건물 설치 완료 후
        }

        // 병원 설치 시 기존 응급환자에 구급차 출동
        if (type === 'hospital') {
            setTimeout(() => {
                dispatchAmbulanceToExistingEmergencies();
            }, 500);  // 건물 설치 완료 후
        }

        // 발전소 설치 시 전력망에 등록
        if (config && config.isPowerPlant) {
            powerManager.addPowerPlant(gx, gy, type, config);
        } else {
            // 일반 건물은 전력망 재계산 (소비량 변경)
            if (powerManager.initialized) {
                powerManager.recalculatePowerGrid();
            }
        }

        // 수도시설 설치 시 수도망에 등록
        if (config && config.isWaterFacility) {
            waterManager.addWaterFacility(gx, gy, type, config);
        } else {
            // 일반 건물은 수도망 재계산 (소비량 변경)
            if (waterManager.initialized) {
                waterManager.recalculateWaterGrid();
            }
        }

        // 설치 후 색상 효과 재적용
        if (isPlacementModeActive) {
            // 새 건물에 색상 적용
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    placementOriginalMaterials.set(child.uuid, child.material.clone());
                    if (type === currentPlacementType) {
                        child.material = greenMaterialPlacement.clone();
                    } else {
                        child.material = grayMaterialPlacement.clone();
                    }
                }
            });
        }

        // 전력 뷰 모드일 때 새 건물에 회색 머티리얼 적용 및 원본 저장
        if (powerManager && powerManager.isPowerViewActive) {
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    // 원본 머티리얼 저장 (복원용)
                    powerManager.powerViewOriginalMaterials.set(child.uuid, child.material);
                    // 회색 적용
                    child.material = grayMat.clone();
                }
            });
        }

        // 수도 뷰 모드일 때 새 건물에 회색 머티리얼 적용 및 원본 저장
        if (waterManager && waterManager.isWaterViewActive) {
            const grayMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    // 원본 머티리얼 저장 (복원용)
                    waterManager.waterViewOriginalMaterials.set(child.uuid, child.material);
                    // 회색 적용
                    child.material = grayMat.clone();
                }
            });
        }

        return true;
    }

    // 공공시설 찾기
    function findPublicBuildingAt(gx, gy) {
        const key = `${gx},${gy}`;
        const entry = placedPublicBuildings.get(key);
        if (!entry) return null;
        if (entry.ref) {
            return placedPublicBuildings.get(entry.ref);
        }
        return entry;
    }

    // 공공시설 삭제 (철거 애니메이션 포함)
    const demolishingPublicBuildings = new Set();

    function removePublicBuilding(gx, gy) {
        const building = findPublicBuildingAt(gx, gy);
        if (!building || building.ref) return false;

        // 이미 철거 중이면 무시
        const buildingKey = `${building.x},${building.y}`;
        if (demolishingPublicBuildings.has(buildingKey)) return false;
        demolishingPublicBuildings.add(buildingKey);

        // 선택된 건물이면 팝업과 아웃라인 제거
        if (selectedBuilding === building.instance) {
            hideBuildingPopup();
        }

        // 모든 상태 아이콘 제거 (통합 시스템)
        clearAllBuildingStatuses(building.x, building.y);

        // 서비스 효과 물결 이모지 표시 (철거 시 반대 효과)
        const config = PUBLIC_BUILDING_MODELS[building.type];
        if (config && config.effectRadius) {
            const centerX = building.x + (building.width || 2) / 2;
            const centerY = building.y + (building.depth || 2) / 2;
            // 이로운 시설 철거 = 슬픔, 나쁜 시설 철거 = 기쁨
            const isPositive = config.isNegativeEffect === true;
            showServiceEffectRipple(centerX, centerY, config.effectRadius, isPositive);
        }

        // 발전소 제거 시 전력망에서 등록 해제
        if (config && config.isPowerPlant) {
            powerManager.removePowerPlant(building.x, building.y);
        } else if (powerManager.initialized) {
            // 일반 건물 제거 시 전력망 재계산
            powerManager.recalculatePowerGrid();
        }

        // 수도시설 제거 시 수도망에서 등록 해제
        if (config && config.isWaterFacility) {
            waterManager.removeWaterFacility(building.x, building.y);
        } else if (waterManager.initialized) {
            // 일반 건물 제거 시 수도망 재계산
            waterManager.recalculateWaterGrid();
        }

        // 추적에서 먼저 제거 (재배치 방지)
        const primaryKey = `${building.x},${building.y}`;
        for (const tileKey of building.tiles) {
            placedPublicBuildings.delete(tileKey);
        }
        placedPublicBuildings.delete(primaryKey);

        // 철거 애니메이션 실행
        if (building.instance) {
            animateDemolish(building, () => {
                // 애니메이션 완료 후 씬에서 제거 및 메모리 해제
                buildingGroup.remove(building.instance);
                disposeObject3D(building.instance);

                // 잔디 타일 복구 (시각적)
                const width = building.width || 2;
                const depth = building.depth || 2;
                for (let dx = 0; dx < width; dx++) {
                    for (let dy = 0; dy < depth; dy++) {
                        addGrassTileAt(building.x + dx, building.y + dy);
                    }
                }

                // 철거 완료
                demolishingPublicBuildings.delete(buildingKey);

                // 교통 시스템에 건물 변경 알림
                if (trafficManager.initialized) {
                    trafficManager.onBuildingChange();
                }
            });
        } else {
            demolishingPublicBuildings.delete(buildingKey);
        }

        markDirty();

        // 예산 업데이트
        updateBudgetDisplay();

        return true;
    }

    // 저장된 공공시설 복원 (로드 시 사용 - 비용 없음, 애니메이션 없음)
    function restorePublicBuilding(gx, gy, type, savedRotation = null) {
        const prefabData = getRandomPublicPrefab(type);
        if (!prefabData) {
            console.warn(`No prefab found for ${type}`);
            return false;
        }

        const width = prefabData.width || 2;
        const depth = prefabData.depth || 2;

        // 이미 배치된 공공시설 확인
        const primaryKey = `${gx},${gy}`;
        if (placedPublicBuildings.has(primaryKey)) {
            return false;
        }

        // 건물이 차지하는 모든 타일에서 잔디 제거
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                removeGrassTileAt(gx + dx, gy + dy);
            }
        }

        // 모델 인스턴스 생성
        const instance = prefabData.prefab.clone();

        // 머티리얼을 조명 반응형으로 강제 교체
        instance.traverse((child) => {
            if (child.isMesh && child.material) {
                const convertMaterial = (mat) => {
                    const newMat = new THREE.MeshLambertMaterial({
                        color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                        map: mat.map || null,
                        transparent: mat.transparent || false,
                        opacity: mat.opacity !== undefined ? mat.opacity : 1,
                        side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                    });
                    return newMat;
                };

                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => convertMaterial(m));
                } else {
                    child.material = convertMaterial(child.material);
                }
            }
        });

        // 위치 계산
        const worldX = ORIGIN_X + gx + width / 2;
        const worldZ = ORIGIN_Z + gy + depth / 2;
        const targetY = -(prefabData.minY || 0);

        instance.position.set(
            worldX - (prefabData.centerOffsetX || 0),
            targetY,
            worldZ - (prefabData.centerOffsetZ || 0)
        );

        // 회전 복원 (저장된 값이 있으면 사용, 없으면 도로 방향으로)
        if (savedRotation !== null && savedRotation !== undefined) {
            instance.rotation.y = savedRotation;
        } else {
            const roadDirection = findNearestRoadDirection(gx, gy, width, depth);
            instance.rotation.y = roadDirection;
        }

        // 그림자 설정
        instance.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        // userData 설정
        instance.userData = {
            isPublicBuilding: true,
            publicBuildingType: type,
            tileX: gx,
            tileY: gy,
            width: width,
            depth: depth,
            name: PUBLIC_BUILDING_MODELS[type]?.name || type
        };

        // 씬에 추가
        buildingGroup.add(instance);

        // 차지하는 타일들
        const tiles = [];
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                tiles.push(`${gx + dx},${gy + dy}`);
            }
        }

        // 추적 정보 저장
        placedPublicBuildings.set(primaryKey, { type, instance, tiles, x: gx, y: gy, width, depth });

        // 참조 키 추가
        for (const tileKey of tiles) {
            if (tileKey !== primaryKey) {
                placedPublicBuildings.set(tileKey, { ref: primaryKey });
            }
        }

        // 발전소인 경우 전력망에 등록
        const config = PUBLIC_BUILDING_MODELS[type];
        if (config && config.isPowerPlant && powerManager.initialized) {
            powerManager.addPowerPlant(gx, gy, config.powerOutput, config.effectRadius);
        }

        // 수도시설인 경우 수도망에 등록
        if (config && config.isWaterFacility && waterManager.initialized) {
            waterManager.addWaterFacility(gx, gy, config.waterOutput, config.effectRadius);
        }

        console.log(`Restored public building: ${type} at (${gx},${gy})`);
        return true;
    }

    // 저장된 모든 공공시설 복원
    function restoreAllPublicBuildings(publicBuildingsData) {
        if (!publicBuildingsData || !Array.isArray(publicBuildingsData)) return;

        console.log(`Restoring ${publicBuildingsData.length} public buildings...`);

        for (const buildingData of publicBuildingsData) {
            restorePublicBuilding(
                buildingData.x,
                buildingData.y,
                buildingData.type,
                buildingData.rotation  // 저장된 회전값 전달
            );
        }

        // 전력망/수도망 재계산
        if (powerManager.initialized) {
            powerManager.recalculatePowerGrid();
        }
        if (waterManager.initialized) {
            waterManager.recalculateWaterGrid();
        }
    }

    // 기존 프리뷰 메시 (폴백용)
    const previewMat = new THREE.MeshStandardMaterial({
        color: 0x00aa88,
        transparent: true,
        opacity: 0.35,
    });
    const previewMesh = new THREE.InstancedMesh(roadGeo, previewMat, GRID_W * GRID_H);
    previewMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    previewMesh.visible = false;  // 기본 숨김

    // 모델 기반 프리뷰 그룹
    const previewGroup = new THREE.Group();
    scene.add(previewGroup);

    roadMesh.visible = false;
    lockedRoadMesh.visible = false;

    /* =========================================================
     * GHOST TILE
     * ========================================================= */
    const ghost = new THREE.Mesh(
        new THREE.BoxGeometry(TILE_SIZE, 0.08, TILE_SIZE),
        new THREE.MeshStandardMaterial({ transparent: true, opacity: 0.35 })
    );
    ghost.visible = false;
    ghost.castShadow = true;
    scene.add(ghost);

    const tmp = new THREE.Object3D();

    /* =========================================================
     * TILE GROUPS (잔디, 도로, 수로, 다리, 나무)
     * ========================================================= */
    const grassGroup = new THREE.Group();
    const roadGroup = new THREE.Group();
    const waterGroup = new THREE.Group();
    const bridgeGroup = new THREE.Group();
    const treeGroup = new THREE.Group();  // 나무 그룹
    scene.add(grassGroup);
    scene.add(waterGroup);
    scene.add(roadGroup);
    scene.add(bridgeGroup);
    scene.add(treeGroup);  // 나무는 도로/다리 위에 렌더링
    scene.add(buildingGroup);
    scene.add(buildingPreviewGroup);  // 건물 설치 미리보기
    scene.add(serviceEffectGroup);    // 서비스 시설 효과 범위 표시
    scene.add(fireEffectsGroup);      // 화재 이펙트

    // 나무 데이터 저장소 (key: "x,y", value: { modelIndex, offsetX, offsetZ, rotation, scale, mesh })
    const placedTrees = new Map();

    // ========== 배경 산 모델 ==========
    let mountainModel = null;
    const mountainDefaults = { scale: 1.0, y: 0, x: 0, z: -30 };

    loader.load('/models/ExtremeLowPolyMountain.glb', (gltf) => {
        mountainModel = gltf.scene;
        mountainModel.position.set(mountainDefaults.x, mountainDefaults.y, mountainDefaults.z);
        mountainModel.scale.setScalar(mountainDefaults.scale);

        // 그림자 설정
        mountainModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        scene.add(mountainModel);
        console.log('[Mountain] Background mountain loaded');

        // 슬라이더 초기값 설정
        const scaleSlider = document.getElementById('mountainScaleSlider');
        const heightSlider = document.getElementById('mountainHeightSlider');
        const posXSlider = document.getElementById('mountainPosXSlider');
        const posZSlider = document.getElementById('mountainPosZSlider');
        if (scaleSlider) scaleSlider.value = mountainDefaults.scale;
        if (heightSlider) heightSlider.value = mountainDefaults.y;
        if (posXSlider) posXSlider.value = mountainDefaults.x;
        if (posZSlider) posZSlider.value = mountainDefaults.z;
        updateMountainSliderLabels();
    }, undefined, (error) => {
        console.error('[Mountain] Failed to load mountain model:', error);
    });

    function updateMountainSliderLabels() {
        const scaleVal = document.getElementById('mountainScaleValue');
        const heightVal = document.getElementById('mountainHeightValue');
        const posXVal = document.getElementById('mountainPosXValue');
        const posZVal = document.getElementById('mountainPosZValue');
        const scaleSlider = document.getElementById('mountainScaleSlider');
        const heightSlider = document.getElementById('mountainHeightSlider');
        const posXSlider = document.getElementById('mountainPosXSlider');
        const posZSlider = document.getElementById('mountainPosZSlider');

        if (scaleVal && scaleSlider) scaleVal.textContent = parseFloat(scaleSlider.value).toFixed(1);
        if (heightVal && heightSlider) heightVal.textContent = parseFloat(heightSlider.value).toFixed(1);
        if (posXVal && posXSlider) posXVal.textContent = parseInt(posXSlider.value);
        if (posZVal && posZSlider) posZVal.textContent = parseInt(posZSlider.value);
    }

    function clearTileGroup(group) {
        for (let i = group.children.length - 1; i >= 0; i--) {
            group.remove(group.children[i]);
        }
    }

    function clearRoadGroup() {
        clearTileGroup(roadGroup);
        // 가로등 조명 배열 초기화
        streetLights.length = 0;
        lastStreetLightState = null;  // 상태 리셋
    }

    function clearWaterGroup() {
        clearTileGroup(waterGroup);
    }

    function clearGrassGroup() {
        clearTileGroup(grassGroup);
    }

    function clearBridgeGroup() {
        clearTileGroup(bridgeGroup);
    }

    // 잔디 타일 배치
    function addGrassTileAt(x, y) {
        const prefab = tilePrefabs.grass;
        if (!prefab) return;

        const tile = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = false;
                child.receiveShadow = true;
                child.material = child.material.clone();
            }
        });

        // 그리드 좌표 저장 (나중에 찾아서 제거할 수 있도록)
        tile.userData.gridX = x;
        tile.userData.gridY = y;

        tile.position.set(c.x, -tileMinY.grass, c.z);
        grassGroup.add(tile);
    }

    // 특정 위치의 잔디 타일 제거
    function removeGrassTileAt(x, y) {
        for (let i = grassGroup.children.length - 1; i >= 0; i--) {
            const tile = grassGroup.children[i];
            if (tile.userData.gridX === x && tile.userData.gridY === y) {
                grassGroup.remove(tile);
                return true;
            }
        }
        return false;
    }

    // 수로 타일 배치 (높이 절반 내림)
    const WATER_HEIGHT_OFFSET = -0.15;  // 수로 높이 오프셋
    function addWaterTileAt(x, y, key, rotY) {
        const prefab = tilePrefabs.water[key];
        if (!prefab) return;

        const tile = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = false;
                child.receiveShadow = true;
                child.material = child.material.clone();
            }
        });

        tile.position.set(c.x, -tileMinY.water[key] + WATER_HEIGHT_OFFSET, c.z);
        tile.rotation.y = rotY;
        waterGroup.add(tile);
    }

    // 다리 타일 배치 (수로 위에 다리 모델 사용)
    const BRIDGE_HEIGHT_OFFSET = -0.15;  // 수로와 동일한 높이
    function addBridgeTileAt(x, y, rotY) {
        // 다리 전용 모델 사용
        const prefab = tilePrefabs.bridge;
        if (!prefab) return;

        const tile = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.receiveShadow = true;
                child.material = child.material.clone();
            }
        });

        // 수로 위 높이에 배치
        tile.position.set(c.x, -tileMinY.bridge + BRIDGE_HEIGHT_OFFSET, c.z);
        tile.rotation.y = rotY + Math.PI / 2;  // 90도 추가 회전
        bridgeGroup.add(tile);
    }

    // 모든 잔디 타일 재구성
    function rebuildGrassTiles() {
        clearGrassGroup();
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const v = grid[x][y];
                // 빈 땅, 구역만 잔디 표시 (도로, 수로, 다리 제외)
                if (v === CELL.EMPTY || isZone(x, y)) {
                    addGrassTileAt(x, y);
                }
            }
        }
    }

    // 모든 수로 타일 재구성 (다리 위치에는 수로 없음)
    function rebuildWaterTiles() {
        clearWaterGroup();
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                // 수로만 렌더링 (다리 위치는 제외)
                if (!isWater(x, y)) continue;
                const mask = getWaterMask(x, y);
                const { key, rotY } = pickWaterVariant(mask);
                addWaterTileAt(x, y, key, rotY);
            }
        }
    }

    // 모든 다리 타일 재구성
    function rebuildBridgeTiles() {
        clearBridgeGroup();
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (!isBridge(x, y)) continue;
                const rotY = getBridgeRotation(x, y);
                addBridgeTileAt(x, y, rotY);
            }
        }
    }

    // 모든 타일 재구성
    function rebuildAllTiles() {
        rebuildGrassTiles();
        rebuildWaterTiles();
        rebuildBridgeTiles();
        rebuildRoadModels();
    }

    /* =========================================================
     * TREE SYSTEM - 나무 배치 시스템
     * ========================================================= */

    // 시드 기반 난수 생성기 (Mulberry32)
    function mulberry32(seed) {
        return function() {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
    }

    // 나무 그룹 초기화
    function clearTreeGroup() {
        for (let i = treeGroup.children.length - 1; i >= 0; i--) {
            treeGroup.remove(treeGroup.children[i]);
        }
        placedTrees.clear();
    }

    // 특정 타일에 나무 추가
    function addTreeAt(x, y, modelIndex, offsetX = 0, offsetZ = 0) {
        if (!tilePrefabs.trees[modelIndex]) return null;

        const key = `${x},${y}`;
        // 이미 있으면 제거
        if (placedTrees.has(key)) {
            removeTreeAt(x, y);
        }

        const prefab = tilePrefabs.trees[modelIndex];
        const tree = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        // 타일 내 오프셋 적용 (타일 경계 내에서 랜덤 위치)
        const offsetLimit = TILE_SIZE * 0.4;  // 타일 중심에서 최대 40% 이동
        tree.position.set(
            c.x + offsetX * offsetLimit,
            0,  // 지면 높이
            c.z + offsetZ * offsetLimit
        );
        // 회전은 항상 랜덤 (DB 저장 안 함)
        tree.rotation.y = Math.random() * Math.PI * 2;
        // 스케일도 항상 랜덤 0.5~0.65 (DB 저장 안 함)
        const scale = 0.5 + Math.random() * 0.15;
        tree.scale.setScalar(scale);

        // 랜덤으로 일부 나무 색상을 약간 짙게 (30% 확률, DB 저장 안 함)
        const isDarker = Math.random() < 0.3;
        const darkenFactor = isDarker ? (0.6 + Math.random() * 0.25) : 1.0;  // 0.6~0.85 어둡게

        // 그림자 설정 및 색상 조정
        tree.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material = child.material.clone();
                    // 짙은 색상 적용
                    if (isDarker && child.material.color) {
                        child.material.color.multiplyScalar(darkenFactor);
                    }
                }
            }
        });

        // 그리드 좌표 저장
        tree.userData.gridX = x;
        tree.userData.gridY = y;

        treeGroup.add(tree);

        // 데이터 저장 (rotation, scale 제외 - DB 사용량 감소)
        placedTrees.set(key, {
            modelIndex,
            offsetX,
            offsetZ,
            mesh: tree
        });

        return tree;
    }

    // 특정 타일의 나무 제거
    function removeTreeAt(x, y) {
        const key = `${x},${y}`;
        const treeData = placedTrees.get(key);
        if (treeData && treeData.mesh) {
            treeGroup.remove(treeData.mesh);
            placedTrees.delete(key);
            return true;
        }
        return false;
    }

    // 타일이 나무를 배치할 수 있는지 확인
    function canPlaceTreeAt(x, y) {
        if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return false;
        const cell = grid[x][y];
        // 빈 땅(잔디)에만 나무 배치 가능
        return cell === CELL.EMPTY;
    }

    // 시드 기반 나무 배치 생성 (새 맵 생성 시 호출)
    function generateTreesWithSeed(seed = Date.now()) {
        console.log(`[Trees] Generating trees with seed: ${seed}`);
        clearTreeGroup();

        const rng = mulberry32(seed);

        // 클러스터 설정 (2배 증가)
        const numClusters = Math.floor(30 + rng() * 20);  // 30-50개 클러스터
        const clusters = [];

        // 클러스터 중심점 생성
        for (let i = 0; i < numClusters; i++) {
            const cx = Math.floor(rng() * (GRID_W - 4)) + 2;  // 외곽 제외
            const cy = Math.floor(rng() * (GRID_H - 4)) + 2;
            const size = Math.floor(2 + rng() * 4);  // 2-5 범위
            const density = 0.3 + rng() * 0.4;  // 30-70% 밀도
            clusters.push({ cx, cy, size, density });
        }

        // 각 클러스터에 나무 배치
        let totalTrees = 0;
        for (const cluster of clusters) {
            for (let dx = -cluster.size; dx <= cluster.size; dx++) {
                for (let dy = -cluster.size; dy <= cluster.size; dy++) {
                    const x = cluster.cx + dx;
                    const y = cluster.cy + dy;

                    // 클러스터 중심에서의 거리
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > cluster.size) continue;

                    // 확률 계산 (중심에 가까울수록 높음)
                    const falloff = 1 - (dist / cluster.size);
                    const chance = cluster.density * falloff;

                    if (rng() < chance && canPlaceTreeAt(x, y)) {
                        // 나무 속성 랜덤 생성 (rotation, scale 제외 - 로드 시 랜덤 생성)
                        const modelIndex = Math.floor(rng() * tilePrefabs.trees.length);
                        const offsetX = (rng() - 0.5) * 2;  // -1 ~ 1
                        const offsetZ = (rng() - 0.5) * 2;

                        addTreeAt(x, y, modelIndex, offsetX, offsetZ);
                        totalTrees++;
                    }
                }
            }
        }

        // 추가로 흩뿌려진 나무 (20-40% - 2배 증가)
        const scatteredCount = Math.floor(totalTrees * (0.2 + rng() * 0.2));
        for (let i = 0; i < scatteredCount; i++) {
            const x = Math.floor(rng() * GRID_W);
            const y = Math.floor(rng() * GRID_H);

            if (canPlaceTreeAt(x, y) && !placedTrees.has(`${x},${y}`)) {
                const modelIndex = Math.floor(rng() * tilePrefabs.trees.length);
                const offsetX = (rng() - 0.5) * 2;
                const offsetZ = (rng() - 0.5) * 2;

                addTreeAt(x, y, modelIndex, offsetX, offsetZ);
                totalTrees++;
            }
        }

        console.log(`[Trees] Generated ${totalTrees} trees in ${clusters.length} clusters`);
        return totalTrees;
    }

    // 저장된 나무 데이터에서 복원
    function restoreTreesFromData(treesData) {
        if (!treesData || !Array.isArray(treesData) || treesData.length === 0) {
            console.log('[Trees] No saved tree data to restore');
            return;
        }

        clearTreeGroup();
        let restoredCount = 0;

        for (const tree of treesData) {
            const { x, y, modelIndex, offsetX, offsetZ } = tree;

            // 해당 타일이 여전히 잔디인지 확인
            if (canPlaceTreeAt(x, y)) {
                // rotation, scale은 addTreeAt에서 랜덤 생성 (DB 저장 안 함)
                addTreeAt(x, y, modelIndex, offsetX || 0, offsetZ || 0);
                restoredCount++;
            }
        }

        console.log(`[Trees] Restored ${restoredCount}/${treesData.length} trees`);
    }

    // 타일 변경 시 해당 위치의 나무 제거 체크
    function checkAndRemoveTreeAtTile(x, y) {
        if (!canPlaceTreeAt(x, y)) {
            const removed = removeTreeAt(x, y);
            if (removed) {
                console.log(`[Trees] Tree removed at (${x}, ${y}) - tile changed`);
            }
        }
    }

    // 나무 데이터 추출 (저장용 - rotation, scale 제외하여 DB 사용량 감소)
    function extractTreesData() {
        const treesData = [];
        placedTrees.forEach((data, key) => {
            const [x, y] = key.split(',').map(Number);
            treesData.push({
                x,
                y,
                modelIndex: data.modelIndex,
                offsetX: data.offsetX,
                offsetZ: data.offsetZ
            });
        });
        return treesData;
    }

    function addRoadModelAt(x, y, key, rotY, is4Lane = false) {
        const prefab = is4Lane ? road4lanePrefabs[key] : roadPrefabs[key];
        if (!prefab) return;

        const tile = prefab.clone(true);
        const c = tileToWorldCenter(x, y);

        // 복제된 모델에 그림자 설정 적용 및 머티리얼 복제
        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.receiveShadow = true;
                child.material = child.material.clone();
                // emissive 색상 초기화 (혼잡도 시각화 제거)
                child.material.emissive = new THREE.Color(0x000000);
                child.material.emissiveIntensity = 0;
            }
        });

        tile.position.set(c.x, 0, c.z);
        tile.rotation.y = rotY;
        tile.updateMatrixWorld(true);

        const minYRef = is4Lane ? tileMinY.road4lane : roadMinY;
        const centerOffsetRef = is4Lane ? road4laneCenterOffset : roadCenterOffset;

        tile.position.y -= minYRef[key];

        const offset = centerOffsetRef[key].clone();
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
        tile.position.x -= offset.x;
        tile.position.z -= offset.z;
        tile.position.y -= 0.02;  // 도로 높이 조정

        // 타일 좌표 저장 (철거 모드 하이라이트용)
        tile.userData.tileX = x;
        tile.userData.tileY = y;
        tile.userData.isRoad = true;
        tile.userData.is4Lane = is4Lane;

        // 가로등 위치 등록 - PointLight 추가 (LOD 시스템으로 관리)
        // 'light' 또는 'lamp' 또는 'stolb' 이름의 객체 찾기
        tile.traverse((child) => {
            const name = child.name?.toLowerCase() || '';
            if (name.includes('light') || name.includes('lamp') || name.includes('stolb') || name.includes('lantern')) {
                // 가로등 객체 내부의 모든 Mesh 찾기
                child.traverse((subChild) => {
                    if (subChild.isMesh && subChild.material) {
                        // MeshBasicMaterial/MeshLambertMaterial은 emissive 미지원 - MeshStandardMaterial로 변환
                        if (subChild.material.isMeshBasicMaterial || subChild.material.isMeshLambertMaterial) {
                            const oldMat = subChild.material;
                            subChild.material = new THREE.MeshStandardMaterial({
                                color: oldMat.color || 0xffffcc,
                                emissive: 0x000000,
                                emissiveIntensity: 0,
                                map: oldMat.map || null
                            });
                        }
                        // emissive 속성이 있는지 확인하고 초기화
                        if (subChild.material.emissive) {
                            subChild.material.emissive.setHex(0x000000);
                            subChild.material.emissiveIntensity = 0;
                        }

                        // PointLight 생성 (가로등 발광체 위치에)
                        const pointLight = new THREE.PointLight(0xffffaa, 0.8, 3);  // 따뜻한 노란빛, 강도, 범위
                        pointLight.castShadow = false;  // 그림자 비활성화 (성능)
                        pointLight.visible = false;  // 초기에는 비활성화
                        subChild.add(pointLight);
                        pointLight.position.set(0, 0.1, 0);  // 발광체 약간 위

                        streetLights.push({
                            mesh: subChild,
                            tile: tile,
                            pointLight: pointLight,
                            worldPos: new THREE.Vector3()  // 월드 좌표 캐싱용
                        });
                    }
                });
            }
        });

        roadGroup.add(tile);
    }

    // 4차선 도로 2x2 모델 추가 (원점 좌표 기준)
    function addRoad4LaneModelAt(originX, originY, key, rotY) {
        const prefab = road4lanePrefabs[key];
        if (!prefab) return;

        const tile = prefab.clone(true);

        // 2x2 타일 중앙 위치 계산
        // 원점(originX, originY)부터 2x2 영역의 중앙은 (originX+1, originY+1) 코너
        const worldX = (ORIGIN_X + originX + 1) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + originY + 1) * TILE_SIZE;

        // 복제된 모델에 그림자 설정 적용 및 머티리얼 복제
        tile.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.receiveShadow = true;
                child.material = child.material.clone();
                child.material.emissive = new THREE.Color(0x000000);
                child.material.emissiveIntensity = 0;
            }
        });

        // 센터 오프셋 적용
        const offset = road4laneCenterOffset[key].clone();
        offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);

        tile.position.set(worldX - offset.x, 0, worldZ - offset.z);
        tile.rotation.y = rotY;
        tile.updateMatrixWorld(true);

        // minY 적용
        tile.position.y -= (tileMinY.road4lane[key] || 0);
        tile.position.y -= 0.02;

        // 타일 좌표 저장 (철거 모드 하이라이트용)
        tile.userData.originX = originX;
        tile.userData.originY = originY;
        tile.userData.isRoad = true;
        tile.userData.is4Lane = true;
        // 4차선이 차지하는 타일들 (2x2)
        tile.userData.tiles = [
            {x: originX, y: originY},
            {x: originX + 1, y: originY},
            {x: originX, y: originY + 1},
            {x: originX + 1, y: originY + 1}
        ];

        // 가로등 위치 등록 - PointLight 추가 (LOD 시스템으로 관리)
        // 'light' 또는 'lamp' 또는 'stolb' 이름의 객체 찾기
        tile.traverse((child) => {
            const name = child.name?.toLowerCase() || '';
            if (name.includes('light') || name.includes('lamp') || name.includes('stolb') || name.includes('lantern')) {
                // 가로등 객체 내부의 모든 Mesh 찾기
                child.traverse((subChild) => {
                    if (subChild.isMesh && subChild.material) {
                        // MeshBasicMaterial/MeshLambertMaterial은 emissive 미지원 - MeshStandardMaterial로 변환
                        if (subChild.material.isMeshBasicMaterial || subChild.material.isMeshLambertMaterial) {
                            const oldMat = subChild.material;
                            subChild.material = new THREE.MeshStandardMaterial({
                                color: oldMat.color || 0xffffcc,
                                emissive: 0x000000,
                                emissiveIntensity: 0,
                                map: oldMat.map || null
                            });
                        }
                        // emissive 속성이 있는지 확인하고 초기화
                        if (subChild.material.emissive) {
                            subChild.material.emissive.setHex(0x000000);
                            subChild.material.emissiveIntensity = 0;
                        }

                        // PointLight 생성 (가로등 발광체 위치에)
                        const pointLight = new THREE.PointLight(0xffffaa, 0.8, 3);
                        pointLight.castShadow = false;
                        pointLight.visible = false;
                        subChild.add(pointLight);
                        pointLight.position.set(0, 0.1, 0);

                        streetLights.push({
                            mesh: subChild,
                            tile: tile,
                            pointLight: pointLight,
                            worldPos: new THREE.Vector3()
                        });
                    }
                });
            }
        });

        roadGroup.add(tile);
    }

    // 4차선 도로 연결 마스크 계산 (2x2 타일 기준)
    // 4차선 도로 형태는 오직 다른 4차선 도로와의 연결만 고려 (2차선 무시)
    function get4LaneRoadMask(originX, originY) {
        let mask = 0;

        // 북쪽 (y+2): 상단에 4차선 도로가 있는지 확인
        if (is4LaneRoad(originX, originY + 2) || is4LaneRoad(originX + 1, originY + 2)) {
            mask |= DIR.N.bit;
        }
        // 남쪽 (y-1): 하단에 4차선 도로가 있는지 확인
        if (is4LaneRoad(originX, originY - 1) || is4LaneRoad(originX + 1, originY - 1)) {
            mask |= DIR.S.bit;
        }
        // 동쪽 (x+2): 우측에 4차선 도로가 있는지 확인
        if (is4LaneRoad(originX + 2, originY) || is4LaneRoad(originX + 2, originY + 1)) {
            mask |= DIR.E.bit;
        }
        // 서쪽 (x-1): 좌측에 4차선 도로가 있는지 확인
        if (is4LaneRoad(originX - 1, originY) || is4LaneRoad(originX - 1, originY + 1)) {
            mask |= DIR.W.bit;
        }

        return mask;
    }

    // 4차선 타일의 각 위치에 2차선이 연결되어 있는지 확인
    // 위치 번호 (좌상단부터 시계방향): 1=좌상단, 2=우상단, 4=우하단, 3=좌하단
    // +---+---+
    // | 1 | 2 |  (oy+1)
    // +---+---+
    // | 3 | 4 |  (oy)
    // +---+---+
    //  ox  ox+1
    function get4Lane2LaneConnections(originX, originY, roadMask) {
        const ox = originX;
        const oy = originY;

        // 각 위치의 2차선 연결 여부
        let conn = { 1: false, 2: false, 3: false, 4: false };

        // 남북 방향 도로 (직선 또는 끝부분) - 동서 면에서 2차선 연결 가능
        // mask 5 = N+S (직선), mask 1 = N only (북쪽 끝), mask 4 = S only (남쪽 끝)
        const isNorthSouthType = (roadMask === 5 || roadMask === 1 || roadMask === 4);

        // 동서 방향 도로 (직선 또는 끝부분) - 남북 면에서 2차선 연결 가능
        // mask 10 = E+W (직선), mask 2 = E only (동쪽 끝), mask 8 = W only (서쪽 끝)
        const isEastWestType = (roadMask === 10 || roadMask === 2 || roadMask === 8);

        if (isNorthSouthType) {
            conn[1] = is2LaneRoad(ox - 1, oy + 1); // 위치1의 서쪽
            conn[3] = is2LaneRoad(ox - 1, oy);     // 위치3의 서쪽
            conn[2] = is2LaneRoad(ox + 2, oy + 1); // 위치2의 동쪽
            conn[4] = is2LaneRoad(ox + 2, oy);     // 위치4의 동쪽
        } else if (isEastWestType) {
            conn[1] = is2LaneRoad(ox, oy + 2);     // 위치1의 북쪽
            conn[2] = is2LaneRoad(ox + 1, oy + 2); // 위치2의 북쪽
            conn[3] = is2LaneRoad(ox, oy - 1);     // 위치3의 남쪽
            conn[4] = is2LaneRoad(ox + 1, oy - 1); // 위치4의 남쪽
        }

        const hasAny = conn[1] || conn[2] || conn[3] || conn[4];
        if (!hasAny) return null;

        return conn;
    }

    // 2차선 연결에 따른 4차선 모델 및 회전 결정
    // 기본 모델: 3,4 연결 = road_tile_2x2_1, 2,4 연결 = road_tile_2x2_7, 4만 = road_tile_2x2_3
    // 기본 모델들은 모두 180도 회전 적용
    function get4LaneModelFor2LaneConnection(roadMask, conn) {
        if (!conn) return null;

        // 디버깅: 연결 위치 출력 (연결이 있을 때만)
        const connectedPositions = [];
        if (conn[1]) connectedPositions.push('1');
        if (conn[2]) connectedPositions.push('2');
        if (conn[3]) connectedPositions.push('3');
        if (conn[4]) connectedPositions.push('4');
        const isNS = (roadMask === 5 || roadMask === 1 || roadMask === 4);
        const isEW = (roadMask === 10 || roadMask === 2 || roadMask === 8);
        const direction = isNS ? '세로' : (isEW ? '가로' : '기타');
        if (connectedPositions.length > 0) {
            console.log(`[4차선 연결] ${direction} - ${connectedPositions.join(', ')}`);
        }

        // 남북 방향 도로 (직선 또는 끝부분): mask 5, 1, 4
        const isNorthSouthType = (roadMask === 5 || roadMask === 1 || roadMask === 4);
        // 동서 방향 도로 (직선 또는 끝부분): mask 10, 2, 8
        const isEastWestType = (roadMask === 10 || roadMask === 2 || roadMask === 8);

        // 남북 방향: 서쪽면(1,3) 또는 동쪽면(2,4) 연결
        if (isNorthSouthType) {
            const westAny = conn[1] || conn[3];  // 서쪽에 1개 이상 연결
            const eastAny = conn[2] || conn[4];  // 동쪽에 1개 이상 연결
            const westFull = conn[1] && conn[3]; // 서쪽 둘 다 연결
            const eastFull = conn[2] && conn[4]; // 동쪽 둘 다 연결

            // 양쪽 모두 연결 (서쪽에 1개 이상 AND 동쪽에 1개 이상)
            if (westAny && eastAny) {
                // 평행 연결: 같은 행 (1-2 상단행, 3-4 하단행)
                const parallelTop = conn[1] && conn[2];    // 상단행 평행
                const parallelBottom = conn[3] && conn[4]; // 하단행 평행
                // 대각선 연결: 다른 행 (1-4, 3-2)
                const diagonal14 = conn[1] && conn[4] && !conn[2] && !conn[3]; // 좌상-우하
                const diagonal32 = conn[3] && conn[2] && !conn[1] && !conn[4]; // 좌하-우상

                if (diagonal14) {
                    // 대각선 1-4 (좌상-우하): road_tile_2x2_7 모델 사용
                    return { variant: 'straight_side_corner', rotY: Math.PI + Math.PI / 2 };
                } else if (diagonal32) {
                    // 대각선 3-2 (우상-좌하): road_tile_2x2_7 reversal 모델 사용
                    return { variant: 'straight_side_corner_reversed', rotY: Math.PI + Math.PI / 2 };
                } else {
                    // 평행 또는 복합 연결: road_tile_2x2_1 모델 사용
                    // 아래쪽(3,4)에만 연결된 경우 180도 추가 회전
                    const bottomOnly = (conn[3] || conn[4]) && !conn[1] && !conn[2];
                    const baseRotY = Math.PI / 2 + Math.PI;
                    return { variant: 'straight_both_sides', rotY: bottomOnly ? baseRotY + Math.PI : baseRotY };
                }
            } else if (eastFull) {
                // 동쪽 양쪽 연결 (2,4): road_tile_2x2_7 기본 + 180도
                return { variant: 'straight_side_corner', rotY: Math.PI +Math.PI /2 };
            } else if (westFull) {
                // 서쪽 양쪽 연결 (1,3): road_tile_2x2_7 + 360도 (180+180)
                return { variant: 'straight_side_corner', rotY: Math.PI * 2+Math.PI /2 };
            } else if (conn[4]) {
                // 위치4만 (동쪽 하단): road_tile_2x2_3 reversal + 180도 + 180도
                return { variant: 'straight_side_single_reversed', rotY: Math.PI + Math.PI /2 + Math.PI};
            } else if (conn[2]) {
                // 위치2만 (동쪽 상단): road_tile_2x2_3 기본 + 180도
                return { variant: 'straight_side_single', rotY: Math.PI + Math.PI /2};
            } else if (conn[3]) {
                // 위치3만 (서쪽 하단): road_tile_2x2_3 기본 + 180도 + 180도
                return { variant: 'straight_side_single', rotY: Math.PI + Math.PI /2 + Math.PI};
            } else if (conn[1]) {
                // 위치1만 (서쪽 상단): road_tile_2x2_3 reversal + 180도
                return { variant: 'straight_side_single_reversed', rotY: Math.PI + Math.PI /2};
            }
        }
        // 동서 방향: 북쪽면(1,2) 또는 남쪽면(3,4) 연결
        else if (isEastWestType) {
            const northAny = conn[1] || conn[2];  // 북쪽에 1개 이상 연결
            const southAny = conn[3] || conn[4];  // 남쪽에 1개 이상 연결
            const northFull = conn[1] && conn[2]; // 북쪽 둘 다 연결
            const southFull = conn[3] && conn[4]; // 남쪽 둘 다 연결

            // 양쪽 모두 연결 (북쪽에 1개 이상 AND 남쪽에 1개 이상)
            if (northAny && southAny) {
                // 평행 연결: 같은 열 (1-3 좌측열, 2-4 우측열)
                const parallelLeft = conn[1] && conn[3];   // 좌측열 평행
                const parallelRight = conn[2] && conn[4];  // 우측열 평행
                // 대각선 연결: 다른 열 (1-4, 2-3)
                const diagonal14 = conn[1] && conn[4] && !conn[2] && !conn[3]; // 좌상-우하
                const diagonal23 = conn[2] && conn[3] && !conn[1] && !conn[4]; // 우상-좌하

                if (diagonal14) {
                    // 대각선 1-4 (좌상-우하): road_tile_2x2_7 reversal 모델 사용
                    return { variant: 'straight_side_corner_reversed', rotY: Math.PI };
                } else if (diagonal23) {
                    // 대각선 2-3 (우상-좌하): road_tile_2x2_7 모델 사용
                    return { variant: 'straight_side_corner', rotY: Math.PI };
                } else {
                    // 평행 또는 복합 연결: road_tile_2x2_1 모델 사용
                    // 우측(2,4)에만 연결된 경우 180도 추가 회전 (가로 도로 기준)
                    const rightOnly = (conn[2] || conn[4]) && !conn[1] && !conn[3];
                    const baseRotY = Math.PI;
                    return { variant: 'straight_both_sides', rotY: rightOnly ? baseRotY + Math.PI : baseRotY };
                }
            } else if (southFull) {
                // 남쪽 양쪽 연결 (3,4): road_tile_2x2_1 기본 + 180도
                return { variant: 'straight_side_full', rotY: Math.PI +Math.PI /2};
            } else if (northFull) {
                // 북쪽 양쪽 연결 (1,2): road_tile_2x2_1 + 360도 (180+180)
                return { variant: 'straight_side_full', rotY: Math.PI * 2 +Math.PI /2};
            } else if (conn[4]) {
                // 위치4만: road_tile_2x2_3 기본 + 180도 + 180도 + 90도 + 180도 (가로, 반전)
                return { variant: 'straight_side_single', rotY: Math.PI + Math.PI /2 + Math.PI + Math.PI /2 + Math.PI};
            } else if (conn[3]) {
                // 위치3만: road_tile_2x2_3 reversal + 180도 + 180도 + 90도 (가로, 반전)
                return { variant: 'straight_side_single_reversed', rotY: Math.PI + Math.PI /2 + Math.PI + Math.PI /2};
            } else if (conn[2]) {
                // 위치2만: road_tile_2x2_3 reversal + 180도 + 90도 (가로, 반전)
                return { variant: 'straight_side_single_reversed', rotY: Math.PI + Math.PI /2 + Math.PI /2};
            } else if (conn[1]) {
                // 위치1만: road_tile_2x2_3 기본 + 180도 + 90도 + 180도 (가로, 반전)
                return { variant: 'straight_side_single', rotY: Math.PI + Math.PI /2 + Math.PI /2 + Math.PI};
            }
        }

        return null;
    }

    function rebuildRoadModels() {
        clearRoadGroup();

        // 2차선 도로 렌더링 (1x1 타일)
        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (!is2LaneRoad(x, y)) continue;

                const mask = getRoadMask(x, y);
                let { key, rotY } = pickRoadVariant(mask);

                // 직선 도로: 가로등이 한쪽에만 있으므로 홀짝으로 번갈아 180도 회전
                if (key === 'straight' && (x + y) % 2 === 1) {
                    rotY += Math.PI;
                }

                addRoadModelAt(x, y, key, rotY, false);
            }
        }

        // 4차선 도로 렌더링 (2x2 타일, 원점에서만)
        for (const [key, data] of road4laneOrigins) {
            const [originX, originY] = key.split(',').map(Number);
            const mask = get4LaneRoadMask(originX, originY);
            let { key: variant, rotY } = pickRoadVariant(mask);

            // 4차선 코너는 90도 추가 회전
            if (variant === 'corner') {
                rotY += Math.PI / 2*3;
                // 북서(N+W, mask=9), 남동(S+E, mask=6) 코너는 추가 180도 회전
                if (mask === 9 || mask === 6) {
                    rotY += Math.PI;
                }
            }
            // 4차선 T자는 180도 추가 회전
            if (variant === 't') {
                rotY += 2*Math.PI;
                // 동쪽만 열린 T자(N+S+E, mask=7), 서쪽만 열린 T자(N+S+W, mask=13)는 추가 180도 회전
                if (mask === 7 || mask === 13) {
                    rotY += Math.PI;
                }
            }

            // 직선 또는 끝부분 도로일 때 2차선 연결 체크
            // mask: 5=남북직선, 10=동서직선, 1=북끝, 4=남끝, 2=동끝, 8=서끝
            const canHave2LaneConnection = (mask === 5 || mask === 10 || mask === 1 || mask === 4 || mask === 2 || mask === 8);
            if (canHave2LaneConnection) {
                const conn = get4Lane2LaneConnections(originX, originY, mask);
                const connModel = get4LaneModelFor2LaneConnection(mask, conn);
                if (connModel) {
                    variant = connModel.variant;
                    rotY = connModel.rotY;
                }
            }

            // 원점 데이터 업데이트
            data.variant = variant;
            data.rotY = rotY;

            addRoad4LaneModelAt(originX, originY, variant, rotY);
        }
    }

    function rebuildRoadInstances() {
        let playerCount = 0;
        let lockedCount = 0;

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const v = grid[x][y];
                // 도로만 처리 (2차선 + 4차선, 구역 제외)
                const is2Lane = v === CELL.ROAD || v === CELL.LOCKED_ROAD;
                const is4Lane = v === CELL.ROAD_4LANE || v === CELL.LOCKED_ROAD_4LANE;
                if (!is2Lane && !is4Lane) continue;

                const c = tileToWorldCenter(x, y);
                tmp.position.set(c.x, 0.04, c.z);
                tmp.rotation.set(0, 0, 0);
                tmp.updateMatrix();

                if (v === CELL.LOCKED_ROAD || v === CELL.LOCKED_ROAD_4LANE) {
                    lockedRoadMesh.setMatrixAt(lockedCount++, tmp.matrix);
                } else {
                    roadMesh.setMatrixAt(playerCount++, tmp.matrix);
                }
            }
        }

        roadMesh.count = playerCount;
        roadMesh.instanceMatrix.needsUpdate = true;
        lockedRoadMesh.count = lockedCount;
        lockedRoadMesh.instanceMatrix.needsUpdate = true;

        // 교통 시스템에 도로 변경 알림
        if (trafficManager.initialized) {
            trafficManager.onRoadChange();
        }

        // 도로 연결 상태 체크
        updateRoadConnectivity();
    }

    // rebuildBuildings: 건물 재구성 여부
    // restoreOnlyFromSaved: true면 저장된 건물만 복원 (로드 시), false면 모든 구역에 자동 생성
    function rebuildZoneInstances(rebuildBuildings = true, restoreOnlyFromSaved = false) {
        let residentialCount = 0;
        let commercialCount = 0;
        let industrialCount = 0;

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                const v = grid[x][y];
                if (v !== CELL.ZONE_RESIDENTIAL && v !== CELL.ZONE_COMMERCIAL && v !== CELL.ZONE_INDUSTRIAL) continue;

                const c = tileToWorldCenter(x, y);
                tmp.position.set(c.x, 0.10, c.z);  // 구역 표시 높이 (z-fighting 방지)
                tmp.rotation.set(0, 0, 0);
                tmp.updateMatrix();

                if (v === CELL.ZONE_RESIDENTIAL) {
                    residentialMesh.setMatrixAt(residentialCount++, tmp.matrix);
                } else if (v === CELL.ZONE_COMMERCIAL) {
                    commercialMesh.setMatrixAt(commercialCount++, tmp.matrix);
                } else if (v === CELL.ZONE_INDUSTRIAL) {
                    industrialMesh.setMatrixAt(industrialCount++, tmp.matrix);
                }
            }
        }

        residentialMesh.count = residentialCount;
        residentialMesh.instanceMatrix.needsUpdate = true;
        commercialMesh.count = commercialCount;
        commercialMesh.instanceMatrix.needsUpdate = true;
        industrialMesh.count = industrialCount;
        industrialMesh.instanceMatrix.needsUpdate = true;

        // 구역 변경 시 건물 재구성 (삭제 모드에서는 건물 유지)
        if (rebuildBuildings) {
            rebuildAllBuildings(restoreOnlyFromSaved);
            // 수치 모드일 때 새 건물에도 흰색 효과 적용
            if (isZoneModeActive) {
                applyWhiteEffectToNewBuildings();
            }
            // 건물 재구성 후 도로 연결 체크
            updateRoadConnectivity();
        }
    }

    // 새로 생성된 건물에 흰색 효과 적용 (기존 효과가 적용되지 않은 건물만)
    function applyWhiteEffectToNewBuildings() {
        const whiteMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.35,
        });

        buildingGroup.traverse((child) => {
            if (child.isMesh && child.material && !originalMaterials.has(child.uuid)) {
                originalMaterials.set(child.uuid, child.material);
                child.material = whiteMat.clone();
            }
        });
    }

    /* =========================================================
     * BUILDING PLACEMENT SYSTEM
     * ========================================================= */

    // 현재 도시 계층 (추후 동적으로 변경 가능)
    let currentCityTier = TIER.MIDDLE;  // 기본값: 중산층

    // 구역 타입을 문자열로 변환
    function getZoneTypeString(zoneType) {
        if (zoneType === CELL.ZONE_RESIDENTIAL) return 'residential';
        if (zoneType === CELL.ZONE_COMMERCIAL) return 'commercial';
        if (zoneType === CELL.ZONE_INDUSTRIAL) return 'industrial';
        return null;
    }

    // 구역 타입, 계층, 크기에 맞는 건물 목록 가져오기
    function getBuildingsForZone(zoneType, tier, size) {
        const zoneStr = getZoneTypeString(zoneType);
        if (!zoneStr || !CIVIL_BUILDING_MODELS[zoneStr]) return [];

        const tierData = CIVIL_BUILDING_MODELS[zoneStr][tier];
        if (!tierData || !tierData[size]) return [];

        // 프리팹 이름 생성 및 필터링
        return tierData[size]
            .map(modelName => `${zoneStr}_${tier}_${size}_${modelName}`)
            .filter(name => buildingPrefabs[name] != null);
    }

    // 구역 타입에 맞는 전체 건물 목록 (2x2 먼저, 1x1 나중에)
    function getBuildingsForZoneType(zoneType) {
        const tier = currentCityTier;
        const buildings2x2 = getBuildingsForZone(zoneType, tier, "2x2");
        const buildings1x1 = getBuildingsForZone(zoneType, tier, "1x1");

        // 빈 경우 폴백 추가
        const result = [...buildings2x2, ...buildings1x1];

        // 건물이 없으면 Filler 추가
        if (result.length === 0) {
            if (zoneType === CELL.ZONE_RESIDENTIAL) result.push('Filler_Residential');
            else if (zoneType === CELL.ZONE_COMMERCIAL) result.push('Filler_Commercial');
            else if (zoneType === CELL.ZONE_INDUSTRIAL) result.push('Filler_Industrial');
        }

        return result;
    }

    // 연속된 구역 블록 찾기 (Flood Fill)
    function findZoneBlocks() {
        const visited = Array.from({ length: GRID_W }, () => Array(GRID_H).fill(false));
        const blocks = [];

        for (let x = 0; x < GRID_W; x++) {
            for (let y = 0; y < GRID_H; y++) {
                if (visited[x][y]) continue;
                if (!isZone(x, y)) continue;

                const zoneType = grid[x][y];
                const block = {
                    zoneType,
                    tiles: [],
                    minX: x, maxX: x,
                    minY: y, maxY: y,
                };

                // BFS로 연속된 같은 타입의 구역 찾기
                const queue = [{ x, y }];
                visited[x][y] = true;

                while (queue.length > 0) {
                    const curr = queue.shift();

                    // 공공시설이 있는 타일은 건물 배치 대상에서 제외
                    if (!placedPublicBuildings.has(`${curr.x},${curr.y}`)) {
                        block.tiles.push(curr);
                    }

                    block.minX = Math.min(block.minX, curr.x);
                    block.maxX = Math.max(block.maxX, curr.x);
                    block.minY = Math.min(block.minY, curr.y);
                    block.maxY = Math.max(block.maxY, curr.y);

                    // 4방향 탐색
                    const neighbors = [
                        { x: curr.x - 1, y: curr.y },
                        { x: curr.x + 1, y: curr.y },
                        { x: curr.x, y: curr.y - 1 },
                        { x: curr.x, y: curr.y + 1 },
                    ];

                    for (const n of neighbors) {
                        if (!inBounds(n.x, n.y)) continue;
                        if (visited[n.x][n.y]) continue;
                        if (grid[n.x][n.y] !== zoneType) continue;

                        visited[n.x][n.y] = true;
                        queue.push(n);
                    }
                }

                blocks.push(block);
            }
        }

        return blocks;
    }

    // 2x2 건물 배치 가능 여부 확인 (기존 1x1 건물 흡수 가능)
    // 조건:
    // 1. 2x2 영역 내에 도로/수로가 없어야 함
    // 2. 도로 인접 2타일이 같은 구역
    // 3. 뒤쪽 2타일이 같은 구역 또는 빈 땅(잔디)
    // 모든 도로 방향(상/하/좌/우)을 시도하여 하나라도 조건 만족하면 배치 가능
    function canPlace2x2Building(x, y, zoneType, tileSet, placed2x2Set) {
        // 2x2 영역 확인
        const tiles2x2 = [
            { x: x, y: y }, { x: x + 1, y: y },
            { x: x, y: y + 1 }, { x: x + 1, y: y + 1 }
        ];

        // 모든 타일이 범위 내인지, 2x2로 이미 배치되었는지 확인
        for (const t of tiles2x2) {
            if (!inBounds(t.x, t.y)) return { canPlace: false };
            const key = `${t.x},${t.y}`;
            // 이미 2x2로 배치된 곳은 불가
            if (placed2x2Set && placed2x2Set.has(key)) return { canPlace: false };

            // 공공시설이 있으면 배치 불가
            if (placedPublicBuildings.has(key)) return { canPlace: false };

            // 2x2 영역 내에 도로, 수로, 다리가 있으면 배치 불가
            const cellValue = grid[t.x][t.y];
            if (cellValue === CELL.ROAD || cellValue === CELL.LOCKED_ROAD ||
                cellValue === CELL.WATER || cellValue === CELL.BRIDGE) {
                return { canPlace: false };
            }
        }

        // 도로가 있는 방향 찾기 (정면) - 2x2 경계 바로 바깥 확인
        const roadCounts = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };

        // 위쪽 (y - 1)
        if (inBounds(x, y - 1) && isRoad(x, y - 1)) roadCounts.top++;
        if (inBounds(x + 1, y - 1) && isRoad(x + 1, y - 1)) roadCounts.top++;

        // 아래쪽 (y + 2)
        if (inBounds(x, y + 2) && isRoad(x, y + 2)) roadCounts.bottom++;
        if (inBounds(x + 1, y + 2) && isRoad(x + 1, y + 2)) roadCounts.bottom++;

        // 왼쪽 (x - 1)
        if (inBounds(x - 1, y) && isRoad(x - 1, y)) roadCounts.left++;
        if (inBounds(x - 1, y + 1) && isRoad(x - 1, y + 1)) roadCounts.left++;

        // 오른쪽 (x + 2)
        if (inBounds(x + 2, y) && isRoad(x + 2, y)) roadCounts.right++;
        if (inBounds(x + 2, y + 1) && isRoad(x + 2, y + 1)) roadCounts.right++;

        // 도로가 있는 방향들 (도로 수가 많은 순으로 정렬)
        const directionsWithRoads = Object.entries(roadCounts)
            .filter(([dir, count]) => count > 0)
            .sort((a, b) => b[1] - a[1])
            .map(([dir]) => dir);

        // 도로가 없으면 배치 불가
        if (directionsWithRoads.length === 0) {
            return { canPlace: false };
        }

        // 각 도로 방향에 대해 front/back 조건 검사
        const directionConfigs = {
            top: {
                frontTiles: [{ x: x, y: y }, { x: x + 1, y: y }],
                backTiles: [{ x: x, y: y + 1 }, { x: x + 1, y: y + 1 }]
            },
            bottom: {
                frontTiles: [{ x: x, y: y + 1 }, { x: x + 1, y: y + 1 }],
                backTiles: [{ x: x, y: y }, { x: x + 1, y: y }]
            },
            left: {
                frontTiles: [{ x: x, y: y }, { x: x, y: y + 1 }],
                backTiles: [{ x: x + 1, y: y }, { x: x + 1, y: y + 1 }]
            },
            right: {
                frontTiles: [{ x: x + 1, y: y }, { x: x + 1, y: y + 1 }],
                backTiles: [{ x: x, y: y }, { x: x, y: y + 1 }]
            }
        };

        // 모든 도로 방향을 시도하여 조건을 만족하는 방향 찾기
        for (const roadDir of directionsWithRoads) {
            const { frontTiles, backTiles } = directionConfigs[roadDir];

            // 도로 인접 2타일(앞)이 같은 구역인지 확인
            let frontValid = true;
            for (const t of frontTiles) {
                const key = `${t.x},${t.y}`;
                if (!tileSet.has(key)) {
                    frontValid = false;
                    break;
                }
            }
            if (!frontValid) continue;

            // 뒤쪽 2타일이 같은 구역이거나 빈 땅(잔디)인지 확인
            // 도로, 수로, 다른 타입의 구역이면 불가
            let backValid = true;
            for (const t of backTiles) {
                const key = `${t.x},${t.y}`;
                const cellValue = grid[t.x][t.y];  // grid[x][y] 형식
                const isEmptyGrass = (cellValue === CELL.EMPTY);
                const isSameZone = tileSet.has(key);

                // 다른 타입의 구역인지 확인 (예: 주거구역에 상업/공업구역이 있으면 불가)
                const isOtherZone = (cellValue === CELL.ZONE_RESIDENTIAL ||
                                     cellValue === CELL.ZONE_COMMERCIAL ||
                                     cellValue === CELL.ZONE_INDUSTRIAL) && !isSameZone;

                if (isOtherZone || (!isEmptyGrass && !isSameZone)) {
                    backValid = false;
                    break;
                }
            }
            if (!backValid) continue;

            // 조건을 만족하는 방향을 찾음
            const existingBuildings = [];
            for (const t of tiles2x2) {
                const existingBuilding = findBuildingAt(t.x, t.y);
                if (existingBuilding && existingBuilding.width === 1 && existingBuilding.depth === 1) {
                    existingBuildings.push({ x: t.x, y: t.y });
                }
            }
            return { canPlace: true, roadDir, existingBuildings };
        }

        // 어떤 방향도 조건을 만족하지 않음
        return { canPlace: false };
    }

    // 블록 내 타일에 건물 배치 (2x2 우선, 그 다음 1x1)
    function placeBuildingsInBlock(block) {
        const zoneType = block.zoneType;
        const zoneStr = getZoneTypeString(zoneType);

        // 타일을 그리드로 변환 (배치 추적용)
        const placed = new Set();
        const placements = [];

        // 타일 집합 생성
        const tileSet = new Set(block.tiles.map(t => `${t.x},${t.y}`));

        // 티어별 건물 목록 캐시 (이름과 건물 객체 함께 반환)
        function getBuildingsByTier(tier, size) {
            let names = getBuildingsForZone(zoneType, tier, size);
            if (names.length === 0) {
                // 다른 계층에서 찾기
                const otherTier = tier === TIER.MIDDLE ? TIER.HIGH : TIER.MIDDLE;
                names = getBuildingsForZone(zoneType, otherTier, size);
            }
            return names
                .map(name => ({ name, building: buildingPrefabs[name] }))
                .filter(item => item.building != null);
        }

        // 2x2 건물 목록 (양쪽 티어)
        const buildings2x2High = getBuildingsByTier(TIER.HIGH, "2x2");
        const buildings2x2Middle = getBuildingsByTier(TIER.MIDDLE, "2x2");

        // 1x1 건물 목록 (양쪽 티어)
        const buildings1x1High = getBuildingsByTier(TIER.HIGH, "1x1");
        const buildings1x1Middle = getBuildingsByTier(TIER.MIDDLE, "1x1");

        console.log(`Zone ${zoneStr}: HIGH 2x2=${buildings2x2High.length}, 1x1=${buildings1x1High.length} | MIDDLE 2x2=${buildings2x2Middle.length}, 1x1=${buildings1x1Middle.length}`);

        // 폴백 건물
        let fillerName = null;
        if (zoneType === CELL.ZONE_RESIDENTIAL) fillerName = 'Filler_Residential';
        else if (zoneType === CELL.ZONE_COMMERCIAL) fillerName = 'Filler_Commercial';
        else if (zoneType === CELL.ZONE_INDUSTRIAL) fillerName = 'Filler_Industrial';
        const fillerBuilding = fillerName ? buildingPrefabs[fillerName] : null;

        // 왼쪽 위부터 순회
        const sortedTiles = [...block.tiles].sort((a, b) => {
            if (a.y !== b.y) return a.y - b.y;
            return a.x - b.x;
        });

        // 2x2로 배치된 타일 추적 (기존 건물 흡수용)
        const placed2x2 = new Set();

        // 1단계: 2x2 건물 배치 시도 (땅값 충족 시에만)
        // 레벨 1(TIER.MIDDLE)일 때는 2x2 건물을 배치하지 않음 - 업그레이드 시스템을 통해서만 2x2 생성
        for (const tile of sortedTiles) {
            const key = `${tile.x},${tile.y}`;
            if (placed2x2.has(key)) continue;

            // 해당 타일의 땅값으로 티어 결정
            const tileTier = getTierByLandValue(tile.x, tile.y);

            // 레벨 1 (TIER.MIDDLE)인 경우 2x2 건물 배치 안함
            // 2x2 건물은 레벨 2 (TIER.HIGH) 땅값 달성 후 업그레이드를 통해서만 생성됨
            if (tileTier !== TIER.HIGH) continue;

            const buildings2x2 = buildings2x2High;

            if (buildings2x2.length === 0) continue;

            // 4가지 가능한 2x2 시작 위치 (현재 타일이 각각 좌상, 우상, 좌하, 우하에 위치)
            const possibleStarts = [
                { x: tile.x, y: tile.y },         // 현재 타일이 좌상단
                { x: tile.x - 1, y: tile.y },     // 현재 타일이 우상단
                { x: tile.x, y: tile.y - 1 },     // 현재 타일이 좌하단
                { x: tile.x - 1, y: tile.y - 1 }  // 현재 타일이 우하단
            ];

            let placed2x2Success = false;
            for (const start of possibleStarts) {
                if (placed2x2Success) break;

                // 이 시작 위치의 4타일이 이미 배치되었는지 확인
                let anyPlaced = false;
                for (let dx = 0; dx < 2; dx++) {
                    for (let dy = 0; dy < 2; dy++) {
                        if (placed2x2.has(`${start.x + dx},${start.y + dy}`)) {
                            anyPlaced = true;
                            break;
                        }
                    }
                    if (anyPlaced) break;
                }
                if (anyPlaced) continue;

                const result = canPlace2x2Building(start.x, start.y, zoneType, tileSet, placed2x2);
                if (result.canPlace) {
                    // 기존 1x1 건물들 제거 (2x2로 흡수되므로 재건축 스킵)
                    if (result.existingBuildings && result.existingBuildings.length > 0) {
                        for (const eb of result.existingBuildings) {
                            removeBuildingAt(eb.x, eb.y, true);  // skipRebuild = true
                        }
                        console.log(`2x2 absorbed ${result.existingBuildings.length} existing buildings at (${start.x},${start.y})`);
                    }

                    // 위치 기반 랜덤 선택
                    const idx = (start.x * 7 + start.y * 13) % buildings2x2.length;
                    const { name: prefabName, building } = buildings2x2[idx];

                    // 2x2 타일 모두 배치 완료로 표시
                    for (let dx = 0; dx < 2; dx++) {
                        for (let dy = 0; dy < 2; dy++) {
                            placed.add(`${start.x + dx},${start.y + dy}`);
                            placed2x2.add(`${start.x + dx},${start.y + dy}`);
                        }
                    }

                    placements.push({
                        building,
                        prefabName,  // 건물 모델 이름 저장
                        displayName: getBuildingDisplayName(prefabName),  // 건물 표시 이름
                        x: start.x,
                        y: start.y,
                        width: 2,
                        depth: 2,
                        zoneStr: zoneStr,  // 인구 시스템용 구역 타입
                        size: "2x2",
                    });

                    placed2x2Success = true;
                }
            }
        }

        // 2단계: 남은 공간에 1x1 건물 배치
        for (const tile of sortedTiles) {
            const key = `${tile.x},${tile.y}`;
            if (placed.has(key)) continue;

            // 공공시설이 있으면 스킵
            if (placedPublicBuildings.has(key)) continue;

            // 해당 타일의 땅값으로 티어 결정
            const tileTier = getTierByLandValue(tile.x, tile.y);
            let buildings1x1 = tileTier === TIER.HIGH ? buildings1x1High : buildings1x1Middle;

            // 1x1이 없으면 filler 사용
            if (buildings1x1.length === 0 && fillerBuilding) {
                buildings1x1 = [{ name: fillerName, building: fillerBuilding }];
            }

            if (buildings1x1.length === 0) continue;

            // 위치 기반 랜덤 선택
            const idx = (tile.x * 11 + tile.y * 17) % buildings1x1.length;
            const { name: prefabName, building } = buildings1x1[idx];

            placed.add(key);

            placements.push({
                building,
                prefabName,  // 건물 모델 이름 저장
                displayName: getBuildingDisplayName(prefabName),  // 건물 표시 이름
                x: tile.x,
                y: tile.y,
                width: 1,
                depth: 1,
                zoneStr: zoneStr,  // 인구 시스템용 구역 타입
                size: "1x1",
            });
        }

        return placements;
    }

    // 건물 주변에서 도로 방향 찾기 (정면이 도로를 향하도록 회전값 반환)
    function findNearestRoadDirection(x, y, width, depth) {
        // 4방향 체크: 위(북), 오른쪽(동), 아래(남), 왼쪽(서)
        // 모델의 기본 정면이 어느 방향인지에 따라 회전값 조정 필요
        // 기본 정면이 -Z 방향(북쪽)이라고 가정

        // 각 방향에서 도로 타일 수 카운트
        let topRoads = 0, bottomRoads = 0, leftRoads = 0, rightRoads = 0;

        // 위쪽 (y - 1)
        for (let dx = 0; dx < width; dx++) {
            if (inBounds(x + dx, y - 1) && isRoad(x + dx, y - 1)) topRoads++;
        }
        // 아래쪽 (y + depth)
        for (let dx = 0; dx < width; dx++) {
            if (inBounds(x + dx, y + depth) && isRoad(x + dx, y + depth)) bottomRoads++;
        }
        // 왼쪽 (x - 1)
        for (let dy = 0; dy < depth; dy++) {
            if (inBounds(x - 1, y + dy) && isRoad(x - 1, y + dy)) leftRoads++;
        }
        // 오른쪽 (x + width)
        for (let dy = 0; dy < depth; dy++) {
            if (inBounds(x + width, y + dy) && isRoad(x + width, y + dy)) rightRoads++;
        }

        // 가장 많은 도로가 있는 방향으로 회전
        const max = Math.max(topRoads, bottomRoads, leftRoads, rightRoads);

        if (max === 0) {
            // 도로가 없으면 기본 방향 (위쪽)
            return 0;
        }

        // 정면이 도로를 향하도록 회전값 반환
        // 모델 기본 정면이 -Z (화면 위쪽)라고 가정
        if (topRoads === max) return 0;                    // 위쪽 도로 → 회전 없음
        if (bottomRoads === max) return Math.PI;           // 아래쪽 도로 → 180도
        if (leftRoads === max) return -Math.PI / 2;        // 왼쪽 도로 → -90도
        if (rightRoads === max) return Math.PI / 2;        // 오른쪽 도로 → 90도

        return 0;
    }

    // 건물 인스턴스 생성 및 배치
    function addBuildingInstance(placement) {
        const { building, x, y, width, depth, zoneStr, size, prefabName } = placement;
        const { prefab, minY, centerOffsetX = 0, centerOffsetZ = 0 } = building;

        // 건물이 차지하는 모든 타일에서 잔디 제거
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                removeGrassTileAt(x + dx, y + dy);
            }
        }

        const instance = prefab.clone(true);

        // 그림자 설정 및 머티리얼을 조명 반응형으로 강제 교체
        instance.traverse((child) => {
            if (child.isMesh && child.material) {
                child.castShadow = true;
                child.receiveShadow = true;

                // 모든 material을 MeshLambertMaterial로 강제 교체 (조명 반응)
                const convertMaterial = (mat) => {
                    const newMat = new THREE.MeshLambertMaterial({
                        color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                        map: mat.map || null,
                        transparent: mat.transparent || false,
                        opacity: mat.opacity !== undefined ? mat.opacity : 1,
                        side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                    });
                    return newMat;
                };

                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => convertMaterial(m));
                } else {
                    child.material = convertMaterial(child.material);
                }
            }
        });

        // 건물 중심 위치 계산 (타일 그리드 기준)
        // 1x1: 타일 중심 (x+0.5, y+0.5)
        // 2x2: 4타일 교차점 (x+1, y+1) - 타일들이 만나는 모서리
        const worldX = (ORIGIN_X + x + width / 2) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + y + depth / 2) * TILE_SIZE;

        // 건물 위치 조정 (바닥에 맞춤 + 모델 중심 오프셋 보정)
        instance.position.set(
            worldX - centerOffsetX,
            -minY,
            worldZ - centerOffsetZ
        );

        // 도로 방향으로 건물 회전 (정면이 도로를 향하도록)
        const roadDirection = findNearestRoadDirection(x, y, width, depth);
        instance.rotation.y = roadDirection;

        // 1x1 상업 건물은 90도 시계방향 추가 회전
        const isCommercial1x1 = (zoneStr && zoneStr.includes('commercial')) && (width === 1 && depth === 1);
        if (isCommercial1x1) {
            instance.rotation.y += Math.PI / 2;  // 90도 시계방향
        }

        // 건물 레벨 결정 (2x2 = Level 2, 1x1 = Level 1)
        const buildingSize = size || (width === 2 ? "2x2" : "1x1");
        let buildingLevel = buildingSize === "2x2" ? 2 : 1;
        let buildingTier = buildingLevel === 2 ? TIER.HIGH : TIER.MIDDLE;
        let isAbandoned = false;
        const currentLandValue = getTotalLandValue(x, y);

        // 저장된 건물 데이터가 있으면 적용
        let abandonedReason = null;
        const savedData = findSavedBuildingData(x, y);
        if (savedData && savedData.x === x && savedData.y === y) {
            buildingLevel = savedData.level || buildingLevel;
            buildingTier = savedData.tier || buildingTier;
            isAbandoned = savedData.isAbandoned || false;
            abandonedReason = savedData.abandonedReason || null;
        }

        // 인구 시스템용 userData 저장
        instance.userData = {
            zoneType: zoneStr || 'residential',
            size: buildingSize,
            tileX: x,
            tileY: y,
            // 업그레이드 시스템 필드
            level: buildingLevel,
            tier: buildingTier,
            isAbandoned: isAbandoned,
            abandonedReason: abandonedReason,  // 폐건물 이유 저장
            originalMaterials: null,
            currentLandValue: currentLandValue,
        };

        buildingGroup.add(instance);

        // 구역 모드 중 추가된 건물은 원래 머티리얼 저장 후 회색으로 변경
        if (isZoneModeActive) {
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child.uuid, child.material);
                    child.material = grayMaterialBuilding.clone();
                }
            });
        }

        // 건물 위치 추적에 등록
        const tiles = [];
        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                tiles.push(`${x + dx},${y + dy}`);
            }
        }
        const primaryKey = `${x},${y}`;
        const displayName = placement.displayName || getBuildingDisplayName(prefabName);
        const buildingEntry = {
            instance, tiles, x, y, width, depth,
            zoneType: zoneStr || 'residential',
            level: buildingLevel,
            tier: buildingTier,
            isAbandoned: isAbandoned,
            abandonedReason: abandonedReason,  // 폐건물 이유 저장
            prefabName: prefabName || null,  // 건물 모델 이름 저장
            displayName: displayName || null // 건물 표시 이름 저장
        };
        placedBuildings.set(primaryKey, buildingEntry);

        // 폐건물이면 텍스처 적용 및 아이콘 표시
        if (isAbandoned) {
            applyAbandonedMaterials(instance);
            showAbandonedIcon(buildingEntry, x, y);
        }

        // 모든 타일에서 이 건물을 찾을 수 있도록 추가 매핑
        for (const tileKey of tiles) {
            if (tileKey !== primaryKey) {
                placedBuildings.set(tileKey, { ref: primaryKey });
            }
        }

        // 건물 배열 캐시 무효화
        invalidateBuildingsCache();
    }

    // 특정 위치의 건물 찾기
    function findBuildingAt(gx, gy) {
        const key = `${gx},${gy}`;
        const entry = placedBuildings.get(key);
        if (!entry) return null;

        // 참조인 경우 실제 건물 데이터 반환
        if (entry.ref) {
            return placedBuildings.get(entry.ref);
        }
        return entry;
    }

    // 건물 삭제
    // 철거 애니메이션 진행 중인 건물 추적
    const demolishingBuildings = new Set();

    // 먼지 이펙트 생성 (철거용)
    function createDemolishDustEffect(x, y, width, depth, buildingHeight) {
        // 건물이 차지하는 영역의 정확한 중심 계산
        const firstTile = tileToWorldCenter(x, y);
        const lastTile = tileToWorldCenter(x + width - 1, y + depth - 1);
        const worldPos = {
            x: (firstTile.x + lastTile.x) / 2,
            z: (firstTile.z + lastTile.z) / 2
        };
        const dustGroup = new THREE.Group();

        // 건물 크기 기반 범위
        const baseRadius = Math.max(width, depth) * 0.6;

        // 먼지 파티클 (작고 많이)
        const dustCount = 60 + Math.floor(buildingHeight * 20);

        for (let i = 0; i < dustCount; i++) {
            // 다양한 크기의 먼지
            const size = 0.02 + Math.random() * 0.04;
            const dustGeometry = new THREE.PlaneGeometry(size, size);
            const dustMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.08, 0.2, 0.6 + Math.random() * 0.2),
                transparent: true,
                opacity: 0.4 + Math.random() * 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const dust = new THREE.Mesh(dustGeometry, dustMaterial);

            // 건물 중심에서 시작
            const angle = Math.random() * Math.PI * 2;
            const startRadius = Math.random() * baseRadius * 0.3;
            dust.position.set(
                worldPos.x + Math.cos(angle) * startRadius,
                0.1 + Math.random() * buildingHeight * 0.3,
                worldPos.z + Math.sin(angle) * startRadius
            );

            // 바깥으로 퍼지는 속도 (수평으로 더 강하게)
            const outwardSpeed = 0.3 + Math.random() * 0.5;
            dust.userData.velocity = {
                x: Math.cos(angle) * outwardSpeed + (Math.random() - 0.5) * 0.2,
                y: Math.random() * 0.8 + 0.2,  // 위로 천천히
                z: Math.sin(angle) * outwardSpeed + (Math.random() - 0.5) * 0.2
            };

            // 빌보드 회전
            dust.userData.billboardOffset = Math.random() * Math.PI * 2;

            // 부유 특성 (작은 파티클은 더 오래 떠있음)
            dust.userData.floatFactor = 1 - size / 0.06;
            dust.userData.initialOpacity = dust.material.opacity;

            dustGroup.add(dust);
        }

        // 큰 먼지 덩어리 (잔해 느낌)
        const debrisCount = 8 + Math.floor(buildingHeight * 3);
        for (let i = 0; i < debrisCount; i++) {
            const size = 0.06 + Math.random() * 0.08;
            const debrisGeometry = new THREE.BoxGeometry(size, size * 0.5, size);
            const debrisMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.08, 0.15, 0.5 + Math.random() * 0.1),
                transparent: true,
                opacity: 0.6
            });

            const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
            const angle = Math.random() * Math.PI * 2;
            debris.position.set(
                worldPos.x + Math.cos(angle) * baseRadius * 0.2,
                0.2,
                worldPos.z + Math.sin(angle) * baseRadius * 0.2
            );

            debris.userData.velocity = {
                x: Math.cos(angle) * (0.5 + Math.random() * 0.8),
                y: 0.8 + Math.random() * 1.2,
                z: Math.sin(angle) * (0.5 + Math.random() * 0.8)
            };
            debris.userData.rotSpeed = {
                x: (Math.random() - 0.5) * 8,
                z: (Math.random() - 0.5) * 8
            };
            debris.userData.isDebris = true;
            debris.userData.initialOpacity = 0.6;

            dustGroup.add(debris);
        }

        scene.add(dustGroup);

        // 먼지 애니메이션
        const startTime = Date.now();
        const duration = 2500;  // 2.5초 (먼지는 천천히 사라짐)

        function animateDust() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);

            dustGroup.children.forEach(dust => {
                const vel = dust.userData.velocity;

                if (dust.userData.isDebris) {
                    // 잔해: 중력 + 바닥 충돌
                    vel.y -= 0.08;
                    dust.position.x += vel.x * 0.016;
                    dust.position.y += vel.y * 0.016;
                    dust.position.z += vel.z * 0.016;
                    dust.rotation.x += dust.userData.rotSpeed.x * 0.016;
                    dust.rotation.z += dust.userData.rotSpeed.z * 0.016;

                    if (dust.position.y < 0.02) {
                        dust.position.y = 0.02;
                        vel.y = 0;
                        vel.x *= 0.9;
                        vel.z *= 0.9;
                    }
                } else {
                    // 먼지: 공기 저항 + 부유
                    const floatFactor = dust.userData.floatFactor;

                    // 공기 저항 (속도 감소)
                    vel.x *= 0.98;
                    vel.z *= 0.98;

                    // 부유 효과 (작은 파티클은 위로 떠오름)
                    vel.y += (floatFactor * 0.01 - 0.005);
                    vel.y *= 0.97;

                    dust.position.x += vel.x * 0.016;
                    dust.position.y += vel.y * 0.016;
                    dust.position.z += vel.z * 0.016;

                    // 빌보드 (항상 카메라를 향함)
                    dust.lookAt(camera.position);

                    // 최소 높이
                    if (dust.position.y < 0.05) {
                        dust.position.y = 0.05;
                        vel.y = Math.abs(vel.y) * 0.3;
                    }
                }

                // 페이드아웃 (후반에 더 빠르게)
                const fadeStart = dust.userData.isDebris ? 0.5 : 0.3;
                if (progress > fadeStart) {
                    const fadeProgress = (progress - fadeStart) / (1 - fadeStart);
                    dust.material.opacity = dust.userData.initialOpacity * (1 - fadeProgress);
                }
            });

            if (progress < 1) {
                requestAnimationFrame(animateDust);
            } else {
                // 정리
                dustGroup.children.forEach(dust => {
                    dust.geometry.dispose();
                    dust.material.dispose();
                });
                scene.remove(dustGroup);
            }
        }

        animateDust();
    }

    // 도로 타일 낙하 애니메이션
    function animateRoadTileDrop(tileX, tileY) {
        const worldPos = tileToWorldCenter(tileX, tileY);
        const dropHeight = 1.5;  // 낙하 시작 높이
        const duration = 250;    // 애니메이션 시간 (ms)

        // 해당 위치의 도로 메시 찾기
        const tolerance = TILE_SIZE * 0.6;
        const meshesToAnimate = [];

        roadGroup.children.forEach(child => {
            if (child.isMesh || child.isGroup) {
                const dx = Math.abs(child.position.x - worldPos.x);
                const dz = Math.abs(child.position.z - worldPos.z);
                if (dx < tolerance && dz < tolerance) {
                    meshesToAnimate.push({
                        mesh: child,
                        targetY: child.position.y
                    });
                }
            }
        });

        // 메시들을 위로 올리고 애니메이션
        meshesToAnimate.forEach(item => {
            item.mesh.position.y += dropHeight;
        });

        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            const eased = 1 - Math.pow(1 - progress, 3);  // easeOutCubic

            meshesToAnimate.forEach(item => {
                item.mesh.position.y = item.targetY + dropHeight * (1 - eased);
            });

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        }

        if (meshesToAnimate.length > 0) {
            animate();
        }
    }

    // 순차적 도로 설치 (시작점 → 끝점, 낙하 + 먼지 이펙트 포함)
    function placeRoadsSequentially(tiles) {
        if (!tiles || tiles.length === 0) return;

        const delayPerTile = 50;  // 타일당 딜레이 (ms)

        tiles.forEach((tile, index) => {
            setTimeout(() => {
                // 해당 위치에 건물이 있으면 먼저 파괴
                removeBuildingAt(tile.x, tile.y, true);
                // 해당 위치에 나무가 있으면 제거
                removeTreeAt(tile.x, tile.y);

                // 기존 구역 지정 확인 (도로로 덮어씌워지므로 시각적 업데이트 필요)
                const wasZone = grid[tile.x][tile.y] === CELL.ZONE_RESIDENTIAL ||
                               grid[tile.x][tile.y] === CELL.ZONE_COMMERCIAL ||
                               grid[tile.x][tile.y] === CELL.ZONE_INDUSTRIAL;

                // 그리드에 도로/다리 설치
                if (tile.type === 'bridge') {
                    grid[tile.x][tile.y] = CELL.BRIDGE;
                } else {
                    grid[tile.x][tile.y] = CELL.ROAD;
                }

                // 해당 타일만 시각적으로 업데이트
                rebuildRoadInstances();
                rebuildRoadModels();
                rebuildAllTiles();

                // 구역이 도로로 대체되었으면 구역 시각 업데이트
                if (wasZone) {
                    rebuildZoneInstances(false);
                }

                // 낙하 애니메이션
                animateRoadTileDrop(tile.x, tile.y);

                // 먼지 이펙트 (낙하 후)
                setTimeout(() => {
                    createSingleTileDustEffect(tile.x, tile.y);
                }, 200);

            }, index * delayPerTile);
        });
    }

    // 순차적 수로 설치 (시작점 → 끝점, 낙하 + 먼지 이펙트 포함)
    function placeWaterSequentially(tiles) {
        if (!tiles || tiles.length === 0) return;

        const delayPerTile = 50;  // 타일당 딜레이 (ms)

        tiles.forEach((tile, index) => {
            setTimeout(() => {
                // 해당 위치에 건물이 있으면 먼저 파괴
                removeBuildingAt(tile.x, tile.y, true);
                // 해당 위치에 나무가 있으면 제거
                removeTreeAt(tile.x, tile.y);

                // 기존 구역 지정 확인
                const wasZone = grid[tile.x][tile.y] === CELL.ZONE_RESIDENTIAL ||
                               grid[tile.x][tile.y] === CELL.ZONE_COMMERCIAL ||
                               grid[tile.x][tile.y] === CELL.ZONE_INDUSTRIAL;

                // 그리드에 수로/다리 설치
                if (tile.type === 'bridge') {
                    grid[tile.x][tile.y] = CELL.BRIDGE;
                } else {
                    grid[tile.x][tile.y] = CELL.WATER;
                }

                // 해당 타일만 시각적으로 업데이트
                rebuildAllTiles();

                // 구역이 수로로 대체되었으면 구역 시각 업데이트
                if (wasZone) {
                    rebuildZoneInstances(false);
                }

                // 낙하 애니메이션 (수로/다리용)
                animateWaterTileDrop(tile.x, tile.y);

                // 먼지 이펙트 (낙하 후)
                setTimeout(() => {
                    createSingleTileDustEffect(tile.x, tile.y);
                }, 200);

            }, index * delayPerTile);
        });
    }

    // 수로 타일 낙하 애니메이션
    function animateWaterTileDrop(tileX, tileY) {
        const worldPos = tileToWorldCenter(tileX, tileY);
        const dropHeight = 1.5;  // 낙하 시작 높이
        const duration = 250;    // 애니메이션 시간 (ms)

        // 해당 위치의 수로/다리 메시 찾기
        const tolerance = TILE_SIZE * 0.6;
        const meshesToAnimate = [];

        // waterGroup과 bridgeGroup에서 찾기
        [waterGroup, bridgeGroup].forEach(group => {
            group.children.forEach(child => {
                if (child.isMesh || child.isGroup) {
                    const dx = Math.abs(child.position.x - worldPos.x);
                    const dz = Math.abs(child.position.z - worldPos.z);
                    if (dx < tolerance && dz < tolerance) {
                        meshesToAnimate.push({
                            mesh: child,
                            targetY: child.position.y
                        });
                    }
                }
            });
        });

        // 메시들을 위로 올리고 애니메이션
        meshesToAnimate.forEach(item => {
            item.mesh.position.y += dropHeight;
        });

        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            const eased = 1 - Math.pow(1 - progress, 3);  // easeOutCubic

            meshesToAnimate.forEach(item => {
                item.mesh.position.y = item.targetY + dropHeight * (1 - eased);
            });

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        }

        if (meshesToAnimate.length > 0) {
            animate();
        }
    }

    // 도로 건설 먼지 이펙트 (순차적으로 퍼지는 효과)
    function createRoadConstructionDustEffect(tiles) {
        if (!tiles || tiles.length === 0) return;

        const delayPerTile = 80;  // 타일당 딜레이 (ms)
        const dustPerTile = 15;   // 타일당 먼지 파티클 수

        tiles.forEach((tile, index) => {
            setTimeout(() => {
                createSingleTileDustEffect(tile.x, tile.y);
            }, index * delayPerTile);
        });
    }

    // 단일 타일 먼지 이펙트
    function createSingleTileDustEffect(tileX, tileY) {
        const worldPos = tileToWorldCenter(tileX, tileY);
        const dustGroup = new THREE.Group();
        const dustCount = 12;

        for (let i = 0; i < dustCount; i++) {
            // 먼지 파티클 크기
            const size = 0.03 + Math.random() * 0.05;
            const dustGeometry = new THREE.PlaneGeometry(size, size);
            const dustMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.08, 0.15, 0.55 + Math.random() * 0.15),  // 황토색
                transparent: true,
                opacity: 0.5 + Math.random() * 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const dust = new THREE.Mesh(dustGeometry, dustMaterial);

            // 타일 중심 근처에서 시작
            const angle = Math.random() * Math.PI * 2;
            const startRadius = Math.random() * 0.2;
            dust.position.set(
                worldPos.x + Math.cos(angle) * startRadius,
                0.02 + Math.random() * 0.05,
                worldPos.z + Math.sin(angle) * startRadius
            );

            // 바깥으로 퍼지며 위로 올라가는 속도
            const outwardSpeed = 0.15 + Math.random() * 0.25;
            dust.userData.velocity = {
                x: Math.cos(angle) * outwardSpeed + (Math.random() - 0.5) * 0.1,
                y: 0.4 + Math.random() * 0.6,  // 위로 솟구침
                z: Math.sin(angle) * outwardSpeed + (Math.random() - 0.5) * 0.1
            };

            dust.userData.initialOpacity = dust.material.opacity;
            dust.userData.rotSpeed = (Math.random() - 0.5) * 3;

            dustGroup.add(dust);
        }

        scene.add(dustGroup);

        // 애니메이션
        const startTime = Date.now();
        const duration = 800;  // 0.8초

        function animateDust() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);

            dustGroup.children.forEach(dust => {
                const vel = dust.userData.velocity;

                // 중력 효과
                vel.y -= 0.04;

                // 공기 저항
                vel.x *= 0.96;
                vel.z *= 0.96;
                vel.y *= 0.96;

                dust.position.x += vel.x * 0.016;
                dust.position.y += vel.y * 0.016;
                dust.position.z += vel.z * 0.016;

                // 최소 높이
                if (dust.position.y < 0.02) {
                    dust.position.y = 0.02;
                    vel.y = 0;
                }

                // 빌보드 효과
                dust.lookAt(camera.position);

                // 페이드아웃
                if (progress > 0.3) {
                    const fadeProgress = (progress - 0.3) / 0.7;
                    dust.material.opacity = dust.userData.initialOpacity * (1 - fadeProgress);
                }
            });

            if (progress < 1) {
                requestAnimationFrame(animateDust);
            } else {
                // 정리
                dustGroup.children.forEach(dust => {
                    dust.geometry.dispose();
                    dust.material.dispose();
                });
                scene.remove(dustGroup);
            }
        }

        animateDust();
    }

    // 4차선 도로 건설 먼지 이펙트 (2x2 영역)
    function create4LaneConstructionDustEffect(origins) {
        if (!origins || origins.length === 0) return;

        const delayPerOrigin = 120;  // 원점당 딜레이 (ms)

        origins.forEach((origin, index) => {
            setTimeout(() => {
                // 2x2 영역의 중심에서 먼지 생성
                create4LaneSingleDustEffect(origin.x, origin.y);
            }, index * delayPerOrigin);
        });
    }

    // 4차선 도로 단일 원점 먼지 이펙트
    function create4LaneSingleDustEffect(originX, originY) {
        // 2x2 영역의 중심 계산
        const tile1 = tileToWorldCenter(originX, originY);
        const tile2 = tileToWorldCenter(originX + 1, originY + 1);
        const centerX = (tile1.x + tile2.x) / 2;
        const centerZ = (tile1.z + tile2.z) / 2;

        const dustGroup = new THREE.Group();
        const dustCount = 25;  // 4차선은 더 많은 먼지

        for (let i = 0; i < dustCount; i++) {
            const size = 0.04 + Math.random() * 0.06;
            const dustGeometry = new THREE.PlaneGeometry(size, size);
            const dustMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.08, 0.15, 0.55 + Math.random() * 0.15),
                transparent: true,
                opacity: 0.5 + Math.random() * 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const dust = new THREE.Mesh(dustGeometry, dustMaterial);

            // 2x2 영역 전체에서 랜덤 시작
            const angle = Math.random() * Math.PI * 2;
            const startRadius = Math.random() * 0.5;
            dust.position.set(
                centerX + Math.cos(angle) * startRadius,
                0.02 + Math.random() * 0.08,
                centerZ + Math.sin(angle) * startRadius
            );

            const outwardSpeed = 0.2 + Math.random() * 0.35;
            dust.userData.velocity = {
                x: Math.cos(angle) * outwardSpeed + (Math.random() - 0.5) * 0.15,
                y: 0.5 + Math.random() * 0.8,
                z: Math.sin(angle) * outwardSpeed + (Math.random() - 0.5) * 0.15
            };

            dust.userData.initialOpacity = dust.material.opacity;

            dustGroup.add(dust);
        }

        scene.add(dustGroup);

        const startTime = Date.now();
        const duration = 1000;  // 1초

        function animateDust() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);

            dustGroup.children.forEach(dust => {
                const vel = dust.userData.velocity;

                vel.y -= 0.035;
                vel.x *= 0.95;
                vel.z *= 0.95;
                vel.y *= 0.95;

                dust.position.x += vel.x * 0.016;
                dust.position.y += vel.y * 0.016;
                dust.position.z += vel.z * 0.016;

                if (dust.position.y < 0.02) {
                    dust.position.y = 0.02;
                    vel.y = 0;
                }

                dust.lookAt(camera.position);

                if (progress > 0.4) {
                    const fadeProgress = (progress - 0.4) / 0.6;
                    dust.material.opacity = dust.userData.initialOpacity * (1 - fadeProgress);
                }
            });

            if (progress < 1) {
                requestAnimationFrame(animateDust);
            } else {
                dustGroup.children.forEach(dust => {
                    dust.geometry.dispose();
                    dust.material.dispose();
                });
                scene.remove(dustGroup);
            }
        }

        animateDust();
    }

    // 철거 애니메이션 (건물이 아래로 꺼지며 무너짐)
    function animateDemolish(building, onComplete) {
        const instance = building.instance;
        if (!instance) {
            onComplete();
            return;
        }

        // 건물 높이 계산
        const bbox = new THREE.Box3().setFromObject(instance);
        const buildingHeight = bbox.max.y - bbox.min.y;

        // 먼지 이펙트 시작
        createDemolishDustEffect(building.x, building.y, building.width || 1, building.depth || 1, buildingHeight);

        // 카메라 흔들림
        if (typeof triggerCameraShake === 'function') {
            triggerCameraShake(0.1, 400);
        }

        const startY = instance.position.y;
        const targetY = startY - buildingHeight - 0.5;  // 지면 아래로
        const startTime = Date.now();
        const duration = 1500;  // 1.5초 (천천히 무너짐)

        // 초기 스케일 저장
        const startScaleX = instance.scale.x;
        const startScaleZ = instance.scale.z;

        // 기울어지는 방향 고정 (랜덤으로 한 번만 결정)
        const tiltDirX = Math.random() > 0.5 ? 1 : -1;
        const tiltDirZ = Math.random() > 0.5 ? 1 : -1;

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);

            // easeInQuad (가속)
            const eased = progress * progress;

            // 아래로 꺼짐
            instance.position.y = startY + (targetY - startY) * eased;

            // 약간 찌그러짐 (무너지는 느낌)
            instance.scale.x = startScaleX * (1 + eased * 0.1);
            instance.scale.z = startScaleZ * (1 + eased * 0.1);

            // 약간 기울어짐 (고정된 방향으로)
            instance.rotation.x = eased * 0.1 * tiltDirX;
            instance.rotation.z = eased * 0.1 * tiltDirZ;

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                onComplete();
            }
        }

        animate();
    }

    function removeBuildingAt(gx, gy, skipRebuild = false) {
        const building = findBuildingAt(gx, gy);
        if (!building || !building.instance) return false;

        // 이미 철거 중이면 무시
        const buildingKey = `${building.x},${building.y}`;
        if (demolishingBuildings.has(buildingKey)) return false;
        demolishingBuildings.add(buildingKey);

        // 업그레이드 대기 중이면 취소
        cancelUpgradeTimer(buildingKey);

        // 선택된 건물이면 팝업과 아웃라인 제거
        if (selectedBuilding === building.instance) {
            hideBuildingPopup();
        }

        // 건물이 차지하던 모든 타일 정보 저장 (재건축용)
        const { x, y, width, depth, instance } = building;
        const zoneTiles = [];

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const tx = x + dx;
                const ty = y + dy;
                // 구역인 경우 재건축 대기 목록에 추가
                if (isZone(tx, ty)) {
                    zoneTiles.push({ x: tx, y: ty, zoneType: grid[tx][ty] });
                }
            }
        }

        // 모든 상태 아이콘 제거 (통합 시스템)
        clearAllBuildingStatuses(x, y);

        // 화재 제거 (있는 경우)
        if (burningBuildings.has(buildingKey)) {
            extinguishFire(buildingKey);
        }

        // 폐건물 목록에서 제거
        abandonedBuildings.delete(buildingKey);

        // 도로 끊김 목록 및 타이머 제거
        disconnectedBuildings.delete(buildingKey);
        buildingRoadDisconnectTime.delete(buildingKey);
        buildingRoadAbandonTime.delete(buildingKey);

        // 위치 추적에서 제거
        const primaryKey = `${building.x},${building.y}`;
        for (const tileKey of building.tiles) {
            placedBuildings.delete(tileKey);
        }
        placedBuildings.delete(primaryKey);
        invalidateBuildingsCache();  // 건물 배열 캐시 무효화

        // 철거 애니메이션 시작
        animateDemolish(building, () => {
            // 애니메이션 완료 후 씬에서 제거 및 메모리 해제
            buildingGroup.remove(instance);
            disposeObject3D(instance);

            // 잔디 타일 복구 (시각적)
            for (let dx = 0; dx < width; dx++) {
                for (let dy = 0; dy < depth; dy++) {
                    addGrassTileAt(x + dx, y + dy);
                }
            }

            // 철거 완료
            demolishingBuildings.delete(buildingKey);

            // 교통 시스템에 건물 변경 알림
            if (trafficManager.initialized) {
                trafficManager.onBuildingChange();
            }

            // 구역인 경우 새 건물 입주 예약 (1.5초 후)
            if (!skipRebuild && zoneTiles.length > 0) {
                setTimeout(() => {
                    scheduleZoneRebuild(zoneTiles);
                }, 1500);
            }
        });

        return true;
    }

    // 기존 removeBuildingAt 즉시 제거 버전 (내부용)
    function removeBuildingAtInstant(gx, gy, skipRebuild = false) {
        const building = findBuildingAt(gx, gy);
        if (!building || !building.instance) return false;

        // 업그레이드 대기 중이면 취소
        const buildingKey = `${building.x},${building.y}`;
        cancelUpgradeTimer(buildingKey);

        // 씬에서 즉시 제거 및 메모리 해제
        buildingGroup.remove(building.instance);
        disposeObject3D(building.instance);

        // 건물이 차지하던 모든 타일 정보 저장 (재건축용)
        const { x, y, width, depth } = building;
        const zoneTiles = [];

        for (let dx = 0; dx < width; dx++) {
            for (let dy = 0; dy < depth; dy++) {
                const tx = x + dx;
                const ty = y + dy;
                // 잔디 타일 복구 (시각적)
                addGrassTileAt(tx, ty);
                // 구역인 경우 재건축 대기 목록에 추가
                if (isZone(tx, ty)) {
                    zoneTiles.push({ x: tx, y: ty, zoneType: grid[tx][ty] });
                }
            }
        }

        // 모든 상태 아이콘 제거 (통합 시스템)
        clearAllBuildingStatuses(x, y);

        // 화재 제거 (있는 경우)
        if (burningBuildings.has(buildingKey)) {
            extinguishFire(buildingKey);
        }

        // 폐건물 목록에서 제거
        abandonedBuildings.delete(buildingKey);

        // 도로 끊김 목록 및 타이머 제거
        disconnectedBuildings.delete(buildingKey);
        buildingRoadDisconnectTime.delete(buildingKey);
        buildingRoadAbandonTime.delete(buildingKey);

        // 위치 추적에서 제거
        const primaryKey = `${building.x},${building.y}`;
        for (const tileKey of building.tiles) {
            placedBuildings.delete(tileKey);
        }
        placedBuildings.delete(primaryKey);
        invalidateBuildingsCache();  // 건물 배열 캐시 무효화

        // 교통 시스템에 건물 변경 알림
        if (trafficManager.initialized) {
            trafficManager.onBuildingChange();
        }

        // 구역인 경우 새 건물 입주 예약 (1.5초 후)
        if (!skipRebuild && zoneTiles.length > 0) {
            setTimeout(() => {
                scheduleZoneRebuild(zoneTiles);
            }, 1500);
        }

        return true;
    }

    // 빈 구역 타일에 새 건물 건설 예약
    function scheduleZoneRebuild(zoneTiles) {
        for (const tile of zoneTiles) {
            const { x, y, zoneType } = tile;

            // 타일이 여전히 해당 구역인지 확인 (도로나 수로로 바뀌었을 수 있음)
            if (grid[x][y] !== zoneType) continue;

            // 이미 건물이 있으면 스킵 (민간 건물)
            if (hasBuildingAt(x, y)) continue;

            // 공공시설이 있으면 스킵
            if (placedPublicBuildings.has(`${x},${y}`)) continue;

            // 이미 공사 중이면 스킵
            if (constructionSites.has(`${x},${y}`)) continue;
            const tier = getTierByLandValue(x, y);
            let buildingNames = getBuildingsForZone(zoneType, tier, "1x1");

            // 건물이 없으면 다른 티어 시도
            if (buildingNames.length === 0) {
                const otherTier = tier === TIER.MIDDLE ? TIER.HIGH : TIER.MIDDLE;
                buildingNames = getBuildingsForZone(zoneType, otherTier, "1x1");
            }

            // 여전히 없으면 Filler 사용
            if (buildingNames.length === 0) {
                let fillerName = null;
                if (zoneType === CELL.ZONE_RESIDENTIAL) fillerName = 'Filler_Residential';
                else if (zoneType === CELL.ZONE_COMMERCIAL) fillerName = 'Filler_Commercial';
                else if (zoneType === CELL.ZONE_INDUSTRIAL) fillerName = 'Filler_Industrial';
                if (fillerName && buildingPrefabs[fillerName]) {
                    buildingNames = [fillerName];
                }
            }

            if (buildingNames.length === 0) continue;

            // 랜덤 건물 선택
            const idx = (x * 7 + y * 13) % buildingNames.length;
            const buildingName = buildingNames[idx];
            const building = buildingPrefabs[buildingName];
            if (!building) continue;

            // 잔디 타일 제거 (공사 시작 전)
            removeGrassTileAt(x, y);

            // 공사 예약 (정착 차량 + 건설 애니메이션)
            queueConstruction(x, y, zoneType, 1, 1, building, buildingName);
        }
    }

    // 특정 위치에 건물이 있는지 확인
    function hasBuildingAt(gx, gy) {
        return findBuildingAt(gx, gy) !== null;
    }

    // 모든 건물 재구성
    // restoreOnlyFromSaved = true: 저장된 건물만 복원 (로드 시)
    // restoreOnlyFromSaved = false: 모든 구역에 건물 자동 생성 (게임 중 구역 변경 시)
    function rebuildAllBuildings(restoreOnlyFromSaved = false) {
        // 기존 건물 제거
        while (buildingGroup.children.length > 0) {
            buildingGroup.remove(buildingGroup.children[0]);
        }
        // 위치 추적 초기화
        placedBuildings.clear();
        invalidateBuildingsCache();  // 건물 배열 캐시 무효화
        // 기존 인구 데이터 초기화 (건물이 삭제될 수 있으므로)
        buildingPopulations.clear();

        // 건물 모델이 로드되지 않았으면 스킵
        if (Object.keys(buildingPrefabs).length === 0) {
            console.warn('Building prefabs not loaded yet');
            return;
        }

        // === 저장된 건물만 복원 모드 ===
        if (restoreOnlyFromSaved && savedBuildingsData && savedBuildingsData.length > 0) {
            console.log(`Restoring ${savedBuildingsData.length} saved buildings...`);

            for (const savedBuilding of savedBuildingsData) {
                const { x, y, width, depth, zoneType, level, tier, isAbandoned, population, prefabName: savedPrefabName, displayName: savedDisplayName } = savedBuilding;

                // 해당 위치가 구역 타일인지 확인
                if (x >= 0 && x < GRID_W && y >= 0 && y < GRID_H) {
                    const cellType = grid[x][y];
                    if (cellType !== CELL.ZONE_RESIDENTIAL &&
                        cellType !== CELL.ZONE_COMMERCIAL &&
                        cellType !== CELL.ZONE_INDUSTRIAL) {
                        console.log(`Skipping building at (${x},${y}) - not a zone cell`);
                        continue;
                    }

                    // 구역 타입 결정
                    const zoneStr = getZoneTypeString(cellType);
                    const buildingTier = tier || (width === 2 ? TIER.HIGH : TIER.MIDDLE);
                    const size = width === 2 ? "2x2" : "1x1";

                    let buildingName = savedPrefabName;
                    let building = savedPrefabName ? buildingPrefabs[savedPrefabName] : null;

                    // 저장된 prefabName이 없거나 해당 건물이 없으면 폴백
                    if (!building) {
                        // 해당 티어와 사이즈의 건물 목록 가져오기
                        let buildingNames = getBuildingsForZone(cellType, buildingTier, size);
                        if (buildingNames.length === 0) {
                            // 다른 티어 시도
                            const otherTier = buildingTier === TIER.HIGH ? TIER.MIDDLE : TIER.HIGH;
                            buildingNames = getBuildingsForZone(cellType, otherTier, size);
                        }

                        if (buildingNames.length === 0) {
                            console.warn(`No building found for zone at (${x},${y})`);
                            continue;
                        }

                        // 위치 기반 선택 (일관된 결과를 위해)
                        const idx = (x * 11 + y * 17) % buildingNames.length;
                        buildingName = buildingNames[idx];
                        building = buildingPrefabs[buildingName];
                    }

                    if (!building) {
                        console.warn(`Building prefab not found: ${buildingName}`);
                        continue;
                    }

                    // placement 객체 생성
                    const placement = {
                        building,
                        prefabName: buildingName,  // 건물 모델 이름 저장
                        displayName: savedDisplayName || getBuildingDisplayName(buildingName),  // 건물 표시 이름
                        x,
                        y,
                        width: width || 1,
                        depth: depth || 1,
                        zoneStr,
                        size
                    };

                    addBuildingInstance(placement);

                    // 저장된 인구 복원 (주거 건물만)
                    if (zoneStr && zoneStr.includes('residential') && population > 0) {
                        const key = getBuildingKey(x, y, size);
                        buildingPopulations.set(key, population);
                    }
                }
            }

            console.log(`Buildings restored: ${buildingGroup.children.length} buildings placed`);
        } else if (!restoreOnlyFromSaved) {
            // === 기존 동작: 모든 구역에 건물 자동 생성 ===
            // 구역 블록 찾기
            const blocks = findZoneBlocks();

            // 각 블록에 건물 배치
            for (const block of blocks) {
                const placements = placeBuildingsInBlock(block);

                for (const placement of placements) {
                    addBuildingInstance(placement);

                    // 주거 건물에 인구 배정
                    if (placement.zoneStr && placement.zoneStr.includes('residential')) {
                        const key = getBuildingKey(placement.x, placement.y, placement.size);
                        assignBuildingPopulation(key, placement.size);
                    }
                }
            }

            console.log(`Buildings rebuilt: ${buildingGroup.children.length} buildings placed`);
        }

        // 총 인구 계산 및 업데이트
        cityStats.population = calculateTotalPopulation();
        updateStatsDisplay();

        // 교통 시스템에 건물 변경 알림
        if (trafficManager.initialized) {
            trafficManager.onBuildingChange();
        }
    }

    /* =========================================================
     * CONSTRUCTION SYSTEM
     * ========================================================= */

    // 시외 스폰 지점 (고정 - 오른쪽 면 꼭짓점)
    let cityEntryPoint = null;

    // 시외 진입 지점 - 오른쪽 면의 위쪽 꼭짓점 고정
    function findCityEntryPoint() {
        // 이미 찾았으면 캐시된 값 반환
        if (cityEntryPoint) return cityEntryPoint;

        // 오른쪽 면의 위쪽 꼭짓점 (GRID_W - 1, 0)
        cityEntryPoint = { x: GRID_W - 1, y: 0 };
        console.log(`City entry point set at (${cityEntryPoint.x},${cityEntryPoint.y})`);
        return cityEntryPoint;
    }

    // 시외 스폰 지점 초기화 (도로 변경 시 호출)
    function resetCityEntryPoint() {
        cityEntryPoint = null;
    }

    // 외곽 도로(LOCKED_ROAD) - 고정된 시외 진입 지점 반환
    function findRandomLockedRoad() {
        return findCityEntryPoint();
    }

    // 건설 트럭 스폰 대기열 (동시 스폰 방지)
    const constructionTruckQueue = [];
    let isProcessingTruckQueue = false;
    const TRUCK_SPAWN_INTERVAL = 2000;  // 트럭 간 스폰 간격 (2초)

    // 공사 현장 대기열에 추가
    function queueConstruction(x, y, zoneType, width, depth, building, prefabName = null) {
        const key = `${x},${y}`;

        // 이미 공사 중인지 확인
        if (constructionSites.has(key)) {
            console.log(`Construction already queued at (${x},${y})`);
            return;
        }

        // 건설 시작까지 랜덤 대기 시간 (3초 ~ 10초)
        const randomDelay = 3000 + Math.random() * 7000;

        const constructionData = {
            x, y, width, depth,
            zoneType,
            state: CONSTRUCTION_STATE.WAITING_VEHICLE,
            vehicleId: null,
            startTime: null,
            duration: CONSTRUCTION_DURATION,
            building,  // 완성될 건물 prefab 정보
            prefabName,  // 건물 모델 이름 (저장용)
            constructionInstance: null,  // 공사 오브젝트 (3D)
            zoneStr: getZoneTypeString(zoneType),
            size: width === 2 ? "2x2" : "1x1",
            scheduledSpawnTime: Date.now() + randomDelay
        };

        constructionSites.set(key, constructionData);
        console.log(`Construction queued at (${x},${y}) - ${constructionData.zoneStr}, truck arrives in ${Math.round(randomDelay/1000)}s`);

        // 트럭 스폰 대기열에 추가 (랜덤 딜레이 후)
        setTimeout(() => {
            constructionTruckQueue.push(constructionData);
            processConstructionTruckQueue();
        }, randomDelay);
    }

    // 건설 트럭 스폰 대기열 처리 (순차적으로 스폰)
    function processConstructionTruckQueue() {
        if (isProcessingTruckQueue || constructionTruckQueue.length === 0) return;

        isProcessingTruckQueue = true;
        const constructionData = constructionTruckQueue.shift();

        // 공사 현장이 여전히 존재하는지 확인
        const key = `${constructionData.x},${constructionData.y}`;
        if (!constructionSites.has(key)) {
            isProcessingTruckQueue = false;
            processConstructionTruckQueue();
            return;
        }

        spawnConstructionTruck(constructionData);

        // 다음 트럭 스폰까지 대기
        setTimeout(() => {
            isProcessingTruckQueue = false;
            processConstructionTruckQueue();
        }, TRUCK_SPAWN_INTERVAL);
    }

    // 공사 자재 트럭 스폰 (시외 → 공사 현장)
    function spawnConstructionTruck(constructionData) {
        // 교통 시스템 초기화 대기
        if (!trafficManager.initialized) {
            console.log('Traffic not initialized, retrying truck spawn...');
            setTimeout(() => spawnConstructionTruck(constructionData), 1000);
            return;
        }

        // 1. 시외(외곽 도로)에서 스폰 위치 선택
        const spawnRoad = findRandomLockedRoad();
        if (!spawnRoad) {
            console.warn('No locked road found for truck spawn');
            startConstruction(constructionData);
            return;
        }

        // 스폰 위치에 다른 차량이 있으면 재시도 (큐에 다시 추가)
        if (trafficManager.isSpawnBlocked(spawnRoad.x, spawnRoad.y)) {
            setTimeout(() => spawnConstructionTruck(constructionData), 500);
            return;
        }

        // 2. 공사 현장 인접 도로 찾기
        const destRoad = trafficManager.findNearestRoad(constructionData.x, constructionData.y);
        if (!destRoad) {
            console.warn('No road near construction site');
            startConstruction(constructionData);
            return;
        }

        // 3. 경로 찾기
        const path = trafficManager.findPath(spawnRoad.x, spawnRoad.y, destRoad.x, destRoad.y);
        if (!path || path.length < 2) {
            console.warn('No path to construction site');
            startConstruction(constructionData);
            return;
        }

        // 4. 트럭 스폰
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) {
            console.warn('No vehicle available for construction truck');
            startConstruction(constructionData);
            return;
        }

        // 이전 사용에서 남은 속성 초기화
        vehicle.isFiretruck = false;
        vehicle.isMoveInVehicle = false;
        vehicle.fireTarget = null;
        vehicle.isReturning = false;
        vehicle.originStation = null;
        vehicle.stationKey = null;
        vehicle.workStartTime = null;
        vehicle.isParked = false;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 트럭 타입으로 설정
        vehicle.vehicleTypeKey = 'truck';
        vehicle.type = 'truck';
        const vehicleTypeConfig = VEHICLE_TYPES['truck'];

        // 트럭 메쉬로 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh('truck');
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 공사 트럭 특수 속성
        vehicle.isConstructionTruck = true;
        vehicle.constructionSite = constructionData;
        vehicle.originBuilding = null;
        vehicle.destBuilding = null;
        vehicle.activity = '🚚 공사 자재를 운반 중...';
        vehicle.originTypeName = '시외';
        vehicle.destTypeName = '건설현장';

        // 속도 설정
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * (vehicleTypeConfig?.speedMultiplier || 0.8);
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        // 공사 데이터에 차량 ID 연결
        constructionData.vehicleId = vehicle.id;

        console.log(`Construction truck ${vehicle.id} spawned for site at (${constructionData.x},${constructionData.y})`);
    }

    // 입주 차량 스폰 대기열 (동시 스폰 방지)
    const moveInVehicleQueue = [];
    let isProcessingMoveInQueue = false;
    const MOVE_IN_SPAWN_INTERVAL = 1500;  // 입주 차량 간 스폰 간격 (1.5초)

    // 입주 차량 대기열에 추가
    function queueMoveInVehicle(buildingX, buildingY, buildingSize) {
        // 랜덤 딜레이 추가 (1초 ~ 5초)
        const randomDelay = 1000 + Math.random() * 4000;
        setTimeout(() => {
            moveInVehicleQueue.push({ buildingX, buildingY, buildingSize });
            processMoveInVehicleQueue();
        }, randomDelay);
    }

    // 입주 차량 대기열 처리
    function processMoveInVehicleQueue() {
        if (isProcessingMoveInQueue || moveInVehicleQueue.length === 0) return;

        isProcessingMoveInQueue = true;
        const data = moveInVehicleQueue.shift();

        spawnMoveInVehicleImmediate(data.buildingX, data.buildingY, data.buildingSize);

        // 다음 차량 스폰까지 대기
        setTimeout(() => {
            isProcessingMoveInQueue = false;
            processMoveInVehicleQueue();
        }, MOVE_IN_SPAWN_INTERVAL);
    }

    // 입주 차량 스폰 (시외 → 완공된 주거지) - 대기열용
    function spawnMoveInVehicle(buildingX, buildingY, buildingSize) {
        queueMoveInVehicle(buildingX, buildingY, buildingSize);
    }

    // 입주 차량 즉시 스폰 (내부 함수)
    function spawnMoveInVehicleImmediate(buildingX, buildingY, buildingSize) {
        if (!trafficManager.initialized) {
            console.log('Traffic not initialized, retrying move-in vehicle spawn...');
            setTimeout(() => spawnMoveInVehicleImmediate(buildingX, buildingY, buildingSize), 1000);
            return;
        }

        // 1. 시외(외곽 도로)에서 스폰
        const spawnRoad = findRandomLockedRoad();
        if (!spawnRoad) return;

        // 스폰 위치에 다른 차량이 있으면 재시도
        if (trafficManager.isSpawnBlocked(spawnRoad.x, spawnRoad.y)) {
            setTimeout(() => spawnMoveInVehicleImmediate(buildingX, buildingY, buildingSize), 500);
            return;
        }

        // 2. 건물 인접 도로 찾기
        const destRoad = trafficManager.findNearestRoad(buildingX, buildingY);
        if (!destRoad) return;

        // 3. 경로 찾기
        const path = trafficManager.findPath(spawnRoad.x, spawnRoad.y, destRoad.x, destRoad.y);
        if (!path || path.length < 2) return;

        // 4. 승용차 스폰 (패밀리카 또는 SUV)
        const vehicle = trafficManager.getFromPool();
        if (!vehicle) return;

        // 이전 사용에서 남은 속성 초기화
        vehicle.isFiretruck = false;
        vehicle.isConstructionTruck = false;
        vehicle.constructionSite = null;
        vehicle.fireTarget = null;
        vehicle.isReturning = false;
        vehicle.originStation = null;
        vehicle.stationKey = null;
        vehicle.workStartTime = null;
        vehicle.isParked = false;

        // 경로 설정
        vehicle.path = path;
        vehicle.pathIndex = 0;
        vehicle.progress = 0;
        vehicle.currentTile = { x: path[0].x, y: path[0].y };
        vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

        // 승용차 타입 랜덤 선택 (패밀리카, SUV, 캠핑카 중)
        const passengerTypes = ['old', 'jeep', 'camper'];
        const vehicleTypeKey = passengerTypes[Math.floor(Math.random() * passengerTypes.length)];
        vehicle.vehicleTypeKey = vehicleTypeKey;
        vehicle.type = vehicleTypeKey;
        const vehicleTypeConfig = VEHICLE_TYPES[vehicleTypeKey];

        // 메쉬 교체
        const oldMesh = vehicle.mesh;
        if (oldMesh) {
            trafficManager.vehicleGroup.remove(oldMesh);
        }
        const newMesh = trafficManager.createVehicleMesh(vehicleTypeKey);
        newMesh.visible = true;
        vehicle.mesh = newMesh;

        // 원본 머티리얼 저장
        vehicle.originalMaterials = new Map();
        newMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                vehicle.originalMaterials.set(child.uuid, child.material);
            }
        });
        trafficManager.vehicleGroup.add(newMesh);

        // 헤드라이트 재연결 (있으면)
        if (vehicle.headlight) {
            newMesh.add(vehicle.headlight);
            const hour = (timeState.gameTime / 3600) % 24;
            vehicle.headlight.visible = (hour >= 19 || hour < 6);
        }

        // 입주 차량 속성
        vehicle.isMoveInVehicle = true;
        vehicle.originBuilding = null;
        vehicle.destBuilding = { x: buildingX, y: buildingY };
        vehicle.activity = '🏠 새 집으로 이사 가는 중!';
        vehicle.originTypeName = '시외';
        vehicle.destTypeName = '새 집';

        // 속도 설정
        vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * (vehicleTypeConfig?.speedMultiplier || 1.0);
        vehicle.targetSpeed = vehicle.speed;

        // 위치 설정
        const worldPos = trafficManager.getTileWorldPos(vehicle.currentTile, vehicle.targetTile);
        vehicle.position.set(worldPos.x, 0.05, worldPos.z);
        vehicle.rotation = trafficManager.calcRotation(vehicle.currentTile, vehicle.targetTile);

        vehicle.mesh.position.copy(vehicle.position);
        vehicle.mesh.position.y = 0.02;
        vehicle.mesh.rotation.y = vehicle.rotation;
        vehicle.mesh.scale.setScalar(1.0);

        vehicle.currentSpeed = vehicle.speed * 0.5;
        vehicle.state = 'moving';
        vehicle.isActive = true;
        trafficManager.activeCount++;
        trafficManager.addToSpatialGrid(vehicle);  // 공간 분할 그리드 등록

        console.log(`Move-in vehicle (${vehicleTypeKey}) spawned for new home at (${buildingX},${buildingY})`);
    }

    // 입주 프로세스 시작 (건물 완성 후 호출)
    function startMoveInProcess(buildingX, buildingY, buildingSize, buildingTier) {
        const key = `${buildingX},${buildingY}`;

        // 건물 레벨 키 생성 (예: "2x2_mid")
        const tierStr = buildingTier || 'low';
        const capacityKey = `${buildingSize}_${tierStr}`;
        const capacity = BUILDING_CAPACITY[capacityKey] || 2;

        pendingMoveIns.set(key, {
            capacity: capacity,
            movedIn: 0,
            buildingX: buildingX,
            buildingY: buildingY,
            size: buildingSize,
            tier: tierStr
        });

        console.log(`Move-in process started at (${buildingX},${buildingY}) - capacity: ${capacity} families`);
    }

    // 입주 차량 도착 시 호출
    function onMoveInArrival(buildingX, buildingY) {
        const key = `${buildingX},${buildingY}`;
        const moveInData = pendingMoveIns.get(key);

        if (!moveInData) return;

        moveInData.movedIn++;
        console.log(`Family moved in at (${buildingX},${buildingY}) - ${moveInData.movedIn}/${moveInData.capacity}`);

        // 모든 가구 입주 완료
        if (moveInData.movedIn >= moveInData.capacity) {
            pendingMoveIns.delete(key);
            console.log(`Building at (${buildingX},${buildingY}) fully occupied!`);

            // 인구 통계 업데이트
            cityStats.population = calculateTotalPopulation();
            updateStatsDisplay();
        }
    }

    // 입주 시스템 업데이트 (행복도에 따른 스폰 속도)
    function updateMoveInSystem() {
        if (pendingMoveIns.size === 0) return;

        const now = Date.now();

        // 행복도에 따른 스폰 간격 계산 (행복도 높을수록 빠름)
        // 행복도 0 = 5초, 행복도 100 = 0.5초
        const happiness = cityStats.happiness || 50;
        const minInterval = 500;   // 최소 0.5초
        const maxInterval = 5000;  // 최대 5초
        const spawnInterval = maxInterval - (happiness / 100) * (maxInterval - minInterval);

        if (now - lastMoveInSpawnTime < spawnInterval) return;

        // 입주 대기 중인 건물에서 랜덤 선택하여 차량 스폰
        const pendingList = Array.from(pendingMoveIns.values());
        if (pendingList.length === 0) return;

        // 랜덤으로 하나 선택
        const target = pendingList[Math.floor(Math.random() * pendingList.length)];

        // 아직 입주 여유가 있으면 차량 스폰
        if (target.movedIn < target.capacity) {
            spawnMoveInVehicle(target.buildingX, target.buildingY, target.size);
        }

        lastMoveInSpawnTime = now;
    }

    // 공사 시작
    function startConstruction(constructionData) {
        const key = `${constructionData.x},${constructionData.y}`;

        constructionData.state = CONSTRUCTION_STATE.UNDER_CONSTRUCTION;
        constructionData.startTime = Date.now();
        constructionData.vehicleId = null;

        // 해당 위치의 잔디 제거
        for (let dx = 0; dx < constructionData.width; dx++) {
            for (let dy = 0; dy < constructionData.depth; dy++) {
                removeGrassTileAt(constructionData.x + dx, constructionData.y + dy);
            }
        }

        // 공사 오브젝트 배치 (공원 모델 사용)
        const parkPrefab = buildingPrefabs['park'];
        if (parkPrefab && parkPrefab.prefab) {
            const instance = parkPrefab.prefab.clone(true);
            const worldPos = tileToWorldCenter(constructionData.x, constructionData.y);

            // 2x2인 경우 중앙 위치 조정
            const offsetX = (constructionData.width - 1) * TILE_SIZE / 2;
            const offsetZ = (constructionData.depth - 1) * TILE_SIZE / 2;

            instance.position.set(worldPos.x + offsetX, 0, worldPos.z + offsetZ);

            // 공사 중 느낌을 위해 약간 투명하게
            instance.traverse((child) => {
                if (child.isMesh && child.material) {
                    const mat = child.material.clone();
                    mat.transparent = true;
                    mat.opacity = 0.7;
                    child.material = mat;
                }
            });

            buildingGroup.add(instance);
            constructionData.constructionInstance = instance;
        }

        console.log(`Construction started at (${constructionData.x},${constructionData.y})`);
    }

    // 공사 완료
    function completeConstruction(constructionData, key) {
        constructionData.state = CONSTRUCTION_STATE.COMPLETED;

        // 공사 오브젝트 제거
        if (constructionData.constructionInstance) {
            buildingGroup.remove(constructionData.constructionInstance);
            constructionData.constructionInstance = null;
        }

        // 실제 건물 배치
        const placement = {
            building: constructionData.building,
            prefabName: constructionData.prefabName,  // 건물 모델 이름 저장
            x: constructionData.x,
            y: constructionData.y,
            width: constructionData.width,
            depth: constructionData.depth,
            zoneStr: constructionData.zoneStr,
            size: constructionData.size
        };

        addBuildingInstance(placement);

        // 주거 건물: 입주 프로세스 시작 (행복도에 따라 점진적 입주)
        if (placement.zoneStr && placement.zoneStr.includes('residential')) {
            const popKey = getBuildingKey(placement.x, placement.y, placement.size);
            assignBuildingPopulation(popKey, placement.size);

            // 건물 등급 추출 (low/mid/high)
            let tier = 'low';
            if (placement.zoneStr.includes('mid') || placement.zoneStr.includes('middle')) {
                tier = 'mid';
            } else if (placement.zoneStr.includes('high')) {
                tier = 'high';
            }

            // 입주 프로세스 시작 (행복도에 따라 차량이 점진적으로 스폰)
            startMoveInProcess(placement.x, placement.y, placement.size, tier);
        }

        // 공사 현장 맵에서 제거
        constructionSites.delete(key);

        // 통계 업데이트
        cityStats.population = calculateTotalPopulation();
        updateStatsDisplay();

        // 교통 시스템에 건물 변경 알림
        if (trafficManager.initialized) {
            trafficManager.onBuildingChange();
        }

        // 도로 연결 상태 체크
        updateRoadConnectivity();

        console.log(`Construction completed at (${constructionData.x},${constructionData.y})`);
    }

    // 공사 진행 체크 (animate 루프에서 호출)
    function updateConstructions() {
        const now = Date.now();

        constructionSites.forEach((site, key) => {
            if (site.state !== CONSTRUCTION_STATE.UNDER_CONSTRUCTION) return;

            const elapsed = now - site.startTime;
            const progress = Math.min(elapsed / site.duration, 1);

            if (progress >= 1) {
                completeConstruction(site, key);
            }
        });
    }

    // 현재 선택된 공사 현장
    let selectedConstruction = null;

    // 공사 현장 팝업 표시
    function showConstructionPopup(constructionData) {
        selectedConstruction = constructionData;
        updateConstructionPopupContent();
        constructionPopup.style.display = 'block';
        updateConstructionPopupPosition();
    }

    // 공사 팝업 내용 업데이트
    function updateConstructionPopupContent() {
        if (!selectedConstruction) return;

        const zoneName = ZONE_NAMES[selectedConstruction.zoneType] || '건설';
        constructionTitle.textContent = `${zoneName} 공사`;

        // 총 소요시간 표시
        const totalMinutes = Math.floor(selectedConstruction.duration / 60000);
        const totalSeconds = Math.floor((selectedConstruction.duration % 60000) / 1000);
        constructionTotalTime.textContent = `${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;

        if (selectedConstruction.state === CONSTRUCTION_STATE.WAITING_VEHICLE) {
            constructionStatus.textContent = '🚗 입주민 대기 중...';
            constructionTimeLeft.textContent = '--:--';
            constructionProgress.style.width = '0%';
        } else if (selectedConstruction.state === CONSTRUCTION_STATE.UNDER_CONSTRUCTION) {
            constructionStatus.textContent = '🏗️ 공사 진행 중';

            const elapsed = Date.now() - selectedConstruction.startTime;
            const remaining = Math.max(0, selectedConstruction.duration - elapsed);
            const progress = Math.min(elapsed / selectedConstruction.duration, 1);

            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            constructionTimeLeft.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            constructionProgress.style.width = (progress * 100) + '%';
        }
    }

    // 공사 팝업 위치 업데이트
    function updateConstructionPopupPosition() {
        if (!selectedConstruction || constructionPopup.style.display === 'none') return;

        const worldPos = tileToWorldCenter(
            selectedConstruction.x + (selectedConstruction.width - 1) / 2,
            selectedConstruction.y + (selectedConstruction.depth - 1) / 2
        );
        const screenPos = new THREE.Vector3(worldPos.x, 1.5, worldPos.z);
        screenPos.project(camera);

        const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

        const popupWidth = constructionPopup.offsetWidth || 260;
        const popupHeight = constructionPopup.offsetHeight || 150;

        let posX = x - popupWidth / 2;
        let posY = y - popupHeight - 30;

        posX = Math.max(10, Math.min(window.innerWidth - popupWidth - 10, posX));
        posY = Math.max(50, Math.min(window.innerHeight - popupHeight - 50, posY));

        constructionPopup.style.left = posX + 'px';
        constructionPopup.style.top = posY + 'px';
    }

    // 공사 팝업 닫기
    function closeConstructionPopup() {
        constructionPopup.style.display = 'none';
        selectedConstruction = null;
    }

    // 공사 팝업 닫기 버튼 이벤트
    if (constructionPopupClose) {
        constructionPopupClose.addEventListener('click', closeConstructionPopup);
    }

    // 공사 현장인지 확인
    function getConstructionAt(x, y) {
        // 해당 좌표가 공사 현장에 포함되어 있는지 확인
        for (const [key, site] of constructionSites) {
            const sx = site.x, sy = site.y;
            const sw = site.width, sd = site.depth;
            if (x >= sx && x < sx + sw && y >= sy && y < sy + sd) {
                return site;
            }
        }
        return null;
    }

    // 새로 배치된 구역 타일 처리 - 건물 배치 결정 후 공사 대기열에 추가
    function processNewZoneTiles(tilesSet, zoneType) {
        // 타일 목록을 배열로 변환
        const tiles = [];
        for (const key of tilesSet) {
            const [x, y] = key.split(',').map(Number);
            tiles.push({ x, y });
        }

        if (tiles.length === 0) return;

        // 이 타일들로 블록 구성
        const block = {
            zoneType,
            tiles,
            minX: Math.min(...tiles.map(t => t.x)),
            maxX: Math.max(...tiles.map(t => t.x)),
            minY: Math.min(...tiles.map(t => t.y)),
            maxY: Math.max(...tiles.map(t => t.y)),
        };

        // placeBuildingsInBlock 로직을 사용하여 건물 배치 결정
        const placements = placeBuildingsInBlock(block);

        // 각 건물에 대해 공사 대기열 추가
        for (const placement of placements) {
            queueConstruction(
                placement.x,
                placement.y,
                zoneType,
                placement.width,
                placement.depth,
                placement.building,
                placement.prefabName
            );
        }

        console.log(`Queued ${placements.length} constructions for ${tiles.length} tiles`);
    }

    function setZone(x, y, zoneType) {
        if (isLocked(x, y)) return false;
        if (isRoad(x, y)) return false;
        if (isWaterOrBridge(x, y)) return false;  // 수로/다리 위 구역지정 금지
        if (placedPublicBuildings.has(`${x},${y}`)) return false;  // 공공시설 위 구역지정 금지
        if (!isAdjacentToRoad(x, y) && zoneType !== CELL.EMPTY) return false;

        grid[x][y] = zoneType;
        // 구역 지정 시 나무 제거
        if (zoneType !== CELL.EMPTY) {
            checkAndRemoveTreeAtTile(x, y);
        }
        return true;
    }

    function setRoad(x, y, place) {
        if (isLocked(x, y)) return;
        if (isBlocked(x, y)) return;
        // 공공시설 위에는 도로 설치 불가
        if (place && placedPublicBuildings.has(`${x},${y}`)) return;
        grid[x][y] = place ? CELL.ROAD : CELL.EMPTY;
        // 도로 설치 시 나무 제거
        if (place) {
            checkAndRemoveTreeAtTile(x, y);
        }
    }

    // 프리뷰 그룹 클리어
    function clearPreviewGroup() {
        while (previewGroup.children.length > 0) {
            previewGroup.remove(previewGroup.children[0]);
        }
    }

    // 프리뷰용 단색 반투명 머티리얼 (텍스쳐 없음)
    const previewMaterialOk = new THREE.MeshBasicMaterial({
        color: 0x44ff66,
        transparent: true,
        opacity: 0.5,
        depthWrite: false,
    });
    const previewMaterialFail = new THREE.MeshBasicMaterial({
        color: 0xff4444,
        transparent: true,
        opacity: 0.5,
        depthWrite: false,
    });

    // 모델에 프리뷰 머티리얼 적용 (텍스쳐 제거, 단색)
    function applyPreviewMaterial(model, ok = true) {
        const mat = ok ? previewMaterialOk : previewMaterialFail;
        model.traverse((child) => {
            if (child.isMesh) {
                child.material = mat;
            }
        });
    }

    function setPreviewPath(path, ok = true) {
        clearPreviewGroup();

        if (!path || path.length === 0) {
            return;
        }

        const isWaterMode = currentMode === MODE.WATER;
        const is4LaneMode = currentMode === MODE.BUILD_4LANE;
        let prefabs, minYRef;
        if (isWaterMode) {
            prefabs = tilePrefabs.water;
            minYRef = tileMinY.water;
        } else if (is4LaneMode) {
            prefabs = tilePrefabs.road4lane;
            minYRef = tileMinY.road4lane;
        } else {
            prefabs = tilePrefabs.road;
            minYRef = tileMinY.road;
        }
        const pickVariant = isWaterMode ? pickWaterVariant : pickRoadVariant;
        const heightOffset = isWaterMode ? WATER_HEIGHT_OFFSET : 0;

        // 임시로 경로에 타일을 설정해서 마스크 계산
        const tempGrid = {};
        for (const t of path) {
            tempGrid[`${t.x},${t.y}`] = true;
        }

        for (const t of path) {
            // 마스크 계산 (임시 그리드 포함)
            let mask = 0;
            for (const [, d] of Object.entries(DIR)) {
                const nx = t.x + d.dx;
                const ny = t.y + d.dy;
                const key = `${nx},${ny}`;
                // 기존 도로/수로 또는 임시 경로에 있으면 연결
                const existingTile = isWaterMode ? isWater(nx, ny) : isRoad(nx, ny);
                if (existingTile || tempGrid[key]) {
                    mask |= d.bit;
                }
            }

            const { key, rotY } = pickVariant(mask);
            const prefab = prefabs[key];
            if (!prefab) continue;

            const tile = prefab.clone(true);
            const c = tileToWorldCenter(t.x, t.y);

            // 단색 반투명 머티리얼 적용 (텍스쳐 없음)
            applyPreviewMaterial(tile, ok);

            tile.position.set(c.x, -(minYRef[key] || 0) + heightOffset + 0.02, c.z);
            tile.rotation.y = rotY;
            previewGroup.add(tile);
        }
    }

    // 4차선 도로 2x2 프리뷰 표시
    function set4LanePreview(originX, originY, canPlace = true) {
        clearPreviewGroup();

        // 2x2 타일 중앙 위치 계산
        const worldX = (ORIGIN_X + originX + 1) * TILE_SIZE;
        const worldZ = (ORIGIN_Z + originY + 1) * TILE_SIZE;

        const prefab = road4lanePrefabs['straight'];  // 기본 직선 모델 사용
        if (!prefab) {
            // 모델이 없으면 단순 박스로 프리뷰
            const geometry = new THREE.BoxGeometry(2, 0.1, 2);
            const material = canPlace ? previewMaterialOk.clone() : previewMaterialFail.clone();
            const box = new THREE.Mesh(geometry, material);
            box.position.set(worldX, 0.1, worldZ);
            previewGroup.add(box);
            return;
        }

        const tile = prefab.clone(true);

        applyPreviewMaterial(tile, canPlace);

        // 센터 오프셋 적용
        const offset = road4laneCenterOffset['straight'].clone();
        const posX = worldX - offset.x;
        const posZ = worldZ - offset.z;

        // minY 적용
        tile.position.set(posX, -(tileMinY.road4lane['straight'] || 0) + 0.02, posZ);
        previewGroup.add(tile);
    }

    /* =========================================================
     * L-PATH BUILDING
     * ========================================================= */
    function buildLPath(a, b, xThenY = true) {
        const path = [];
        const ax = a.x, ay = a.y, bx = b.x, by = b.y;

        if (xThenY) {
            const sx = bx >= ax ? 1 : -1;
            for (let x = ax; x !== bx + sx; x += sx) path.push({ x, y: ay });
            const sy = by >= ay ? 1 : -1;
            for (let y = ay + sy; y !== by + sy; y += sy) path.push({ x: bx, y });
        } else {
            const sy = by >= ay ? 1 : -1;
            for (let y = ay; y !== by + sy; y += sy) path.push({ x: ax, y });
            const sx = bx >= ax ? 1 : -1;
            for (let x = ax + sx; x !== bx + sx; x += sx) path.push({ x, y: by });
        }
        return path;
    }

    function isPathBuildable(path) {
        for (const t of path) {
            if (t.x < 0 || t.y < 0 || t.x >= GRID_W || t.y >= GRID_H) return false;
            if (isBlocked(t.x, t.y)) return false;
        }
        return true;
    }

    function pickBestLPath(a, b) {
        const p1 = buildLPath(a, b, true);
        if (isPathBuildable(p1)) return p1;
        const p2 = buildLPath(a, b, false);
        if (isPathBuildable(p2)) return p2;
        return null;
    }

    /* =========================================================
     * 4-LANE ROAD PATH BUILDING (2x2 타일 경로)
     * ========================================================= */

    // 4차선 L자 경로 생성 (2타일 단위로 이동)
    function build4LaneLPath(a, b, xThenY = true) {
        const path = [];
        // 시작점을 2타일 그리드에 맞춤
        const ax = Math.floor(a.x / 2) * 2;
        const ay = Math.floor(a.y / 2) * 2;
        const bx = Math.floor(b.x / 2) * 2;
        const by = Math.floor(b.y / 2) * 2;

        if (xThenY) {
            const sx = bx >= ax ? 2 : -2;
            for (let x = ax; sx > 0 ? x <= bx : x >= bx; x += sx) {
                path.push({ x, y: ay });
            }
            const sy = by >= ay ? 2 : -2;
            for (let y = ay + sy; sy > 0 ? y <= by : y >= by; y += sy) {
                path.push({ x: bx, y });
            }
        } else {
            const sy = by >= ay ? 2 : -2;
            for (let y = ay; sy > 0 ? y <= by : y >= by; y += sy) {
                path.push({ x: ax, y });
            }
            const sx = bx >= ax ? 2 : -2;
            for (let x = ax + sx; sx > 0 ? x <= bx : x >= bx; x += sx) {
                path.push({ x, y: by });
            }
        }

        // 중복 제거
        const unique = [];
        const seen = new Set();
        for (const p of path) {
            const key = `${p.x},${p.y}`;
            if (!seen.has(key)) {
                seen.add(key);
                unique.push(p);
            }
        }
        return unique;
    }

    // 4차선 경로 배치 가능 여부 확인
    function is4LanePathBuildable(path) {
        for (const origin of path) {
            if (!canPlace4LaneRoad(origin.x, origin.y)) return false;
        }
        return true;
    }

    // 최적의 4차선 L자 경로 선택
    function pickBest4LaneLPath(a, b) {
        const p1 = build4LaneLPath(a, b, true);
        if (is4LanePathBuildable(p1)) return p1;
        const p2 = build4LaneLPath(a, b, false);
        if (is4LanePathBuildable(p2)) return p2;
        return null;
    }

    // 4차선 경로 프리뷰 표시
    function set4LanePathPreview(path, canBuild = true) {
        clearPreviewGroup();
        if (!path || path.length === 0) return;

        for (const origin of path) {
            const canPlace = canPlace4LaneRoad(origin.x, origin.y);
            const worldX = (ORIGIN_X + origin.x + 1) * TILE_SIZE;
            const worldZ = (ORIGIN_Z + origin.y + 1) * TILE_SIZE;

            const prefab = road4lanePrefabs['straight'];
            if (!prefab) {
                // 모델이 없으면 박스로 표시
                const geometry = new THREE.BoxGeometry(2, 0.1, 2);
                const material = (canBuild && canPlace) ? previewMaterialOk.clone() : previewMaterialFail.clone();
                const box = new THREE.Mesh(geometry, material);
                box.position.set(worldX, 0.1, worldZ);
                previewGroup.add(box);
            } else {
                const tile = prefab.clone(true);
                applyPreviewMaterial(tile, canBuild && canPlace);
                const offset = road4laneCenterOffset['straight'].clone();
                tile.position.set(worldX - offset.x, -(tileMinY.road4lane['straight'] || 0) + 0.02, worldZ - offset.z);
                previewGroup.add(tile);
            }
        }
    }

    /* =========================================================
     * INPUT HANDLING
     * ========================================================= */
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    let hovered = null;
    let buildStart = null;
    let currentPath = null;
    let current4LanePath = null;  // 4차선 도로 경로
    let isBuildDragging = false;  // 도로/수로 드래그 중인지 여부

    function updateMouseFromEvent(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function updateHovered(e) {
        updateMouseFromEvent(e);
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(ground, false);
        if (!hits.length) return null;
        const p = hits[0].point;
        return worldToTile(p.x, p.z);
    }

    // 월드 좌표를 직접 반환하는 함수
    function getWorldPositionFromEvent(e) {
        updateMouseFromEvent(e);
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(ground, false);
        if (!hits.length) return null;
        return hits[0].point;
    }

    // 구역 지정 모드 확인
    function isZoneMode() {
        return currentMode === MODE.ZONE_RESIDENTIAL ||
               currentMode === MODE.ZONE_COMMERCIAL ||
               currentMode === MODE.ZONE_INDUSTRIAL;
    }

    /**
     * Ctrl+클릭 시 BFS로 같은 구역 타입의 연결된 타일 모두 선택 (삭제용)
     * @param {number} startX - 시작 X 좌표
     * @param {number} startY - 시작 Y 좌표
     * @returns {Array} 선택된 타일 좌표 배열 [{x, y}, ...]
     */
    function findSameZoneTiles(startX, startY) {
        const tiles = [];
        const visited = new Set();
        const queue = [];

        // 시작 타일의 구역 타입 확인
        const startZoneType = grid[startX]?.[startY];
        if (!isZone(startX, startY)) return tiles;

        // BFS 시작
        const startKey = `${startX},${startY}`;
        queue.push({ x: startX, y: startY });
        visited.add(startKey);

        const directions = [
            { dx: 1, dy: 0 },   // 오른쪽
            { dx: -1, dy: 0 },  // 왼쪽
            { dx: 0, dy: 1 },   // 아래
            { dx: 0, dy: -1 }   // 위
        ];

        // BFS 탐색
        while (queue.length > 0) {
            const current = queue.shift();
            tiles.push(current);

            // 4방향 탐색
            for (const dir of directions) {
                const nx = current.x + dir.dx;
                const ny = current.y + dir.dy;
                const key = `${nx},${ny}`;

                // 이미 방문했거나 범위 밖이면 스킵
                if (visited.has(key) || !inBounds(nx, ny)) continue;

                // 같은 구역 타입인지 확인
                if (grid[nx]?.[ny] === startZoneType) {
                    visited.add(key);
                    queue.push({ x: nx, y: ny });
                }
            }
        }

        return tiles;
    }

    /**
     * Ctrl+클릭 시 BFS로 배치 가능한 모든 인접 타일 선택
     * @param {number} startX - 시작 X 좌표
     * @param {number} startY - 시작 Y 좌표
     * @returns {Array} 선택된 타일 좌표 배열 [{x, y}, ...]
     */
    function findLineTilesAlongRoad(startX, startY) {
        const tiles = [];
        const visited = new Set();
        const queue = [];

        // 시작 타일이 구역 배치 가능한지 확인
        if (!canPlaceZone(startX, startY)) return tiles;

        // BFS 시작
        const startKey = `${startX},${startY}`;
        queue.push({ x: startX, y: startY });
        visited.add(startKey);

        const directions = [
            { dx: 1, dy: 0 },   // 오른쪽
            { dx: -1, dy: 0 },  // 왼쪽
            { dx: 0, dy: 1 },   // 아래
            { dx: 0, dy: -1 }   // 위
        ];

        // BFS 탐색
        while (queue.length > 0) {
            const current = queue.shift();
            tiles.push(current);

            // 4방향 탐색
            for (const dir of directions) {
                const nx = current.x + dir.dx;
                const ny = current.y + dir.dy;
                const key = `${nx},${ny}`;

                // 이미 방문했거나 범위 밖이면 스킵
                if (visited.has(key) || !inBounds(nx, ny)) continue;

                // 배치 가능한 타일인지 확인
                if (canPlaceZone(nx, ny)) {
                    visited.add(key);
                    queue.push({ x: nx, y: ny });
                }
            }
        }

        return tiles;
    }

    // 구역 드래그 상태
    let isZoneDragging = false;
    let zonePlacedTiles = new Set();

    // 철거 드래그 상태
    let isDemolishDragging = false;
    let demolishedTiles = new Set();

    // Ctrl 키 직선 프리뷰 상태
    let linePreviewMeshes = [];
    let linePreviewGroup = new THREE.Group();
    linePreviewGroup.name = 'linePreviewGroup';
    scene.add(linePreviewGroup);

    // 직선 프리뷰 표시 함수
    function showLinePreview(tiles, zoneType) {
        clearLinePreview();
        if (!tiles || tiles.length === 0) return;

        const color = ZONE_COLORS[zoneType] || 0x00ff00;
        const geometry = new THREE.BoxGeometry(TILE_SIZE, 0.15, TILE_SIZE);

        tiles.forEach(tile => {
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            const pos = tileToWorldCenter(tile.x, tile.y);
            mesh.position.set(pos.x, 0.075, pos.z);
            linePreviewGroup.add(mesh);
            linePreviewMeshes.push(mesh);
        });
    }

    // 삭제 프리뷰 표시 함수 (빨간색)
    function showDeletePreview(tiles) {
        clearLinePreview();
        if (!tiles || tiles.length === 0) return;

        const deleteColor = 0xff4444;
        const geometry = new THREE.BoxGeometry(TILE_SIZE, 0.15, TILE_SIZE);

        tiles.forEach(tile => {
            const material = new THREE.MeshStandardMaterial({
                color: deleteColor,
                emissive: deleteColor,
                emissiveIntensity: 0.5,
                transparent: false,
                opacity: 1.0,
                depthWrite: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            const pos = tileToWorldCenter(tile.x, tile.y);
            mesh.position.set(pos.x, 0.075, pos.z);
            linePreviewGroup.add(mesh);
            linePreviewMeshes.push(mesh);
        });
    }

    // 직선 프리뷰 제거 함수
    function clearLinePreview() {
        linePreviewMeshes.forEach(mesh => {
            linePreviewGroup.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        });
        linePreviewMeshes = [];
    }

    // 연결된 직선 도로 찾기 (Ctrl+철거용)
    // 해당 타일에서 상하좌우 4방향으로 연결된 직선 도로 타일 목록 반환
    function findConnectedStraightRoads(startX, startY) {
        const cellType = grid[startX][startY];
        // 도로 타입만 처리
        if (cellType !== CELL.ROAD && cellType !== CELL.BRIDGE) return [];

        const result = [{ x: startX, y: startY }];
        const directions = [
            { dx: 1, dy: 0 },   // 오른쪽
            { dx: -1, dy: 0 },  // 왼쪽
            { dx: 0, dy: 1 },   // 아래
            { dx: 0, dy: -1 }   // 위
        ];

        // 각 방향으로 직선 탐색
        for (const dir of directions) {
            let x = startX + dir.dx;
            let y = startY + dir.dy;

            // 해당 방향으로 계속 탐색
            while (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                const type = grid[x][y];
                // 도로 또는 다리만 연결
                if (type === CELL.ROAD || type === CELL.BRIDGE) {
                    result.push({ x, y });
                    x += dir.dx;
                    y += dir.dy;
                } else {
                    break;
                }
            }
        }

        return result;
    }

    // Ctrl+철거 선택된 도로 타일 저장
    let ctrlDemolishSelectedRoads = [];

    renderer.domElement.addEventListener("pointermove", (e) => {
        // 인구/땅값 뷰 모드일 때 그래프 호버 감지
        if (currentMode === MODE.POPULATION_VIEW || currentMode === MODE.LAND_VALUE_VIEW) {
            handleGraphHover(e);
            return;
        }

        // 그래프 툴팁 숨기기 (다른 모드)
        if (graphTooltip) graphTooltip.style.display = 'none';

        // 카메라 모드면 무시 (단, 철거 모드는 독립 토글이므로 예외)
        if ((currentMode === MODE.CAMERA && !isDemolishModeActive) || !MAP_CONFIG.isOwner) {
            hovered = null;
            ghost.visible = false;
            hideBuildingPreview();
            clearServiceEffects();
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            clearLinePreview();
            clearDemolishHighlight();
            return;
        }

        const t = updateHovered(e);
        if (!t) {
            hovered = null;
            ghost.visible = false;
            hideBuildingPreview();
            clearServiceEffects();
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            clearLinePreview();
            clearDemolishHighlight();
            return;
        }

        hovered = t;

        const c = tileToWorldCenter(t.x, t.y);
        ghost.position.set(c.x, 0.04, c.z);
        ghost.visible = true;

        // 철거 모드일 때 (독립 토글 - 다른 모드보다 우선 처리)
        if (isDemolishModeActive) {
            const cellType = grid[t.x][t.y];
            const hasBuilding = hasBuildingAt(t.x, t.y);
            const hasPublicBuilding = findPublicBuildingAt(t.x, t.y);

            // Ctrl 키 + 도로 위: 연결된 직선 도로 프리뷰
            if ((e.ctrlKey || e.metaKey) && !isDemolishDragging &&
                (cellType === CELL.ROAD || cellType === CELL.BRIDGE)) {
                const straightRoads = findConnectedStraightRoads(t.x, t.y);
                if (straightRoads.length > 0) {
                    ctrlDemolishSelectedRoads = straightRoads;
                    showDeletePreview(straightRoads);
                    ghost.visible = false;
                    clearDemolishHighlight();
                    return;
                }
            } else if (!isDemolishDragging) {
                // Ctrl 키 떼면 프리뷰 제거
                if (ctrlDemolishSelectedRoads.length > 0) {
                    ctrlDemolishSelectedRoads = [];
                    clearLinePreview();
                }
            }

            // 철거 가능한 오브젝트 빨간색 하이라이트
            const canDemolish = cellType === CELL.ROAD || cellType === CELL.WATER ||
                               cellType === CELL.BRIDGE || cellType === CELL.ROAD_4LANE ||
                               hasPublicBuilding || hasBuilding;

            if (canDemolish) {
                const objectToHighlight = findObjectAtTile(t.x, t.y);
                if (objectToHighlight) {
                    highlightForDemolish(objectToHighlight);
                } else {
                    clearDemolishHighlight();
                }
            } else {
                clearDemolishHighlight();
            }

            if (cellType === CELL.ROAD || cellType === CELL.WATER || cellType === CELL.BRIDGE || cellType === CELL.ROAD_4LANE) {
                ghost.material.color.set(0xff4444);  // 빨간색 - 철거 가능
                ghost.material.opacity = 0.6;
            } else if (cellType === CELL.LOCKED_ROAD) {
                ghost.material.color.set(0xffcc00);  // 노란색 - 잠긴 도로
                ghost.material.opacity = 0.4;
            } else if (hasPublicBuilding || hasBuilding) {
                ghost.material.color.set(0xff6600);  // 주황색 - 건물 철거 가능
                ghost.material.opacity = 0.6;
            } else {
                ghost.material.color.set(0x666666);  // 회색 - 철거 불가
                ghost.material.opacity = 0.2;
            }

            // 드래그 중이면 철거 실행
            if (isDemolishDragging) {
                const key = `${t.x},${t.y}`;
                if (!demolishedTiles.has(key)) {
                    // 철거 전 하이라이트 제거 (오브젝트가 제거되므로)
                    clearDemolishHighlight();

                    // 도로/수로/다리 철거
                    if (cellType === CELL.ROAD || cellType === CELL.WATER || cellType === CELL.BRIDGE) {
                        grid[t.x][t.y] = CELL.EMPTY;
                        demolishedTiles.add(key);
                        rebuildRoadInstances();
                        rebuildRoadModels();
                        rebuildAllTiles();
                        markDirty();
                    }
                    // 4차선 도로 철거
                    else if (cellType === CELL.ROAD_4LANE) {
                        if (remove4LaneRoad(t.x, t.y)) {
                            demolishedTiles.add(key);
                            rebuildRoadInstances();
                            rebuildRoadModels();
                            rebuildAllTiles();
                            markDirty();
                        }
                    }
                    // 공공시설 철거
                    else if (hasPublicBuilding) {
                        if (removePublicBuilding(t.x, t.y)) {
                            demolishedTiles.add(key);
                        }
                    }
                    // 일반 건물 철거
                    else if (hasBuilding) {
                        if (removeBuildingAt(t.x, t.y)) {
                            demolishedTiles.add(key);
                            markDirty();
                        }
                    }
                }
            }
            return;  // 철거 모드는 다른 모드와 공존하지만, 처리 후 바로 리턴
        }

        // 구역 삭제 모드일 때
        if (currentMode === MODE.ZONE_DELETE) {
            // Ctrl 키 눌림 상태에서 같은 구역 타입 모두 선택 프리뷰
            if ((e.ctrlKey || e.metaKey) && !isZoneDragging && isZone(t.x, t.y)) {
                const sameZoneTiles = findSameZoneTiles(t.x, t.y);
                if (sameZoneTiles.length > 0) {
                    showDeletePreview(sameZoneTiles);
                    ghost.visible = false;
                } else {
                    clearLinePreview();
                }
            } else {
                clearLinePreview();
                ghost.visible = true;
            }

            if (isZone(t.x, t.y)) {
                ghost.material.color.set(0xff4444);
                ghost.material.emissive.set(0x000000);
                ghost.material.emissiveIntensity = 0;
                ghost.material.opacity = 0.5;
            } else {
                ghost.material.color.set(0x666666);
                ghost.material.emissive.set(0x000000);
                ghost.material.emissiveIntensity = 0;
                ghost.material.opacity = 0.2;
            }

            // 드래그 중이면 구역 삭제 (건물은 유지)
            if (isZoneDragging) {
                const key = `${t.x},${t.y}`;
                if (!zonePlacedTiles.has(key) && isZone(t.x, t.y)) {
                    setZone(t.x, t.y, CELL.EMPTY);
                    zonePlacedTiles.add(key);
                    rebuildZoneInstances(false);  // 건물 유지
                    markDirty();
                }
            }
        }
        // 구역 배치 모드일 때
        else if (isZoneMode()) {
            // 드래그 중이 아닐 때만 가장 가까운 설치 가능 타일 찾기
            // 드래그 중에는 실제 커서 위치만 사용 (반대편 칠해지는 버그 방지)
            let targetTile = t;  // 기본값은 커서 아래 타일

            if (!isZoneDragging) {
                const worldPos = getWorldPositionFromEvent(e);
                if (worldPos) {
                    const nearestPlaceable = findNearestPlaceableZoneTile(worldPos.x, worldPos.z, 5);
                    if (nearestPlaceable) {
                        targetTile = { x: nearestPlaceable.x, y: nearestPlaceable.y };
                        // 프리뷰 위치를 가장 가까운 설치 가능 타일로 이동
                        const nearestWorldPos = tileToWorldCenter(targetTile.x, targetTile.y);
                        ghost.position.set(nearestWorldPos.x, 0.04, nearestWorldPos.z);
                    }
                }
            }

            // Ctrl 키 눌림 상태에서 직선 프리뷰 표시
            if ((e.ctrlKey || e.metaKey) && !isZoneDragging) {
                const lineTiles = findLineTilesAlongRoad(targetTile.x, targetTile.y);
                if (lineTiles.length > 0) {
                    showLinePreview(lineTiles, currentZoneType);
                    ghost.visible = false; // 단일 ghost 숨김
                } else {
                    clearLinePreview();
                }
            } else {
                clearLinePreview();
            }

            if (canPlaceZone(targetTile.x, targetTile.y)) {
                ghost.material.color.set(ZONE_COLORS[currentZoneType]);
                ghost.material.emissive.set(ZONE_COLORS[currentZoneType]);
                ghost.material.emissiveIntensity = 0.5;
                ghost.material.transparent = false;  // 투명도 완전 제거
                ghost.material.opacity = 1.0;
            } else if (isZone(targetTile.x, targetTile.y)) {
                // 이미 구역이 있으면 배치 불가 표시 (회색)
                ghost.material.transparent = true;
                ghost.material.color.set(0x888888);
                ghost.material.emissive.set(0x000000);
                ghost.material.emissiveIntensity = 0;
                ghost.material.opacity = 0.3;
            } else {
                ghost.material.transparent = true;
                ghost.material.color.set(0xff3366);
                ghost.material.emissive.set(0x000000);
                ghost.material.emissiveIntensity = 0;
                ghost.material.opacity = 0.3;
            }

            // Ctrl 키가 눌려있지 않으면 ghost 표시
            if (!(e.ctrlKey || e.metaKey) || isZoneDragging) {
                ghost.visible = true;
            }

            // 드래그 중이면 구역 배치 (이미 있는 구역은 덮어쓰지 않음)
            if (isZoneDragging) {
                const key = `${targetTile.x},${targetTile.y}`;
                if (!zonePlacedTiles.has(key) && canPlaceZone(targetTile.x, targetTile.y)) {
                    setZone(targetTile.x, targetTile.y, currentZoneType);
                    zonePlacedTiles.add(key);
                    rebuildZoneInstances(false);  // 드래그 중에는 건물 생성 안함
                    markDirty();
                }
            }

            // hovered도 targetTile로 업데이트 (클릭 시 사용)
            hovered = targetTile;
        }
        // 도로 모드일 때 (2차선)
        else if (currentMode === MODE.BUILD) {
            // 2차선 도로 배치 규칙 검사
            const lane4Validation = validate2LaneNear4Lane(t.x, t.y);
            const block2x2Validation = validate2LaneNo2x2Block(t.x, t.y);

            if (isLocked(t.x, t.y)) ghost.material.color.set(0xffcc00);
            else if (isBlocked(t.x, t.y)) ghost.material.color.set(0xff3366);
            else if (!lane4Validation.valid) ghost.material.color.set(0xff6600);  // 4차선 규칙 위반 - 주황색
            else if (!block2x2Validation.valid) ghost.material.color.set(0xff6600);  // 2x2 블록 규칙 위반 - 주황색
            else if (isRoad(t.x, t.y)) ghost.material.color.set(0xcc3333);
            else if (isWater(t.x, t.y)) ghost.material.color.set(0x00aaff);  // 수로 위 (다리 가능)
            else ghost.material.color.set(0x00aa88);

            if (isBuildDragging && buildStart) {
                currentPath = pickBestLPath(buildStart, hovered);

                // 경로 내 2차선 규칙 위반 체크 (4차선 연결 규칙 + 2x2 블록 규칙 + 경로 내 연속 배치 + 평행 배치)
                let pathHasRuleError = false;
                let errorReason = '';
                if (currentPath) {
                    // 경로 내에서 4차선 한 면에 연속 배치 체크
                    const v3 = validatePathNo4LaneConsecutive(currentPath);
                    if (!v3.valid) {
                        pathHasRuleError = true;
                        errorReason = v3.reason;
                    }

                    // 기존 도로 옆에 2칸 이상 연속 배치 체크
                    if (!pathHasRuleError) {
                        const v4 = validatePathNoParallelToRoad(currentPath);
                        if (!v4.valid) {
                            pathHasRuleError = true;
                            errorReason = v4.reason;
                        }
                    }

                    // 개별 셀 검증
                    if (!pathHasRuleError) {
                        for (const pt of currentPath) {
                            const v1 = validate2LaneNear4Lane(pt.x, pt.y);
                            if (!v1.valid) {
                                pathHasRuleError = true;
                                errorReason = v1.reason;
                                break;
                            }
                            const v2 = validate2LaneNo2x2Block(pt.x, pt.y);
                            if (!v2.valid) {
                                pathHasRuleError = true;
                                errorReason = v2.reason;
                                break;
                            }
                        }
                    }
                }

                setPreviewPath(currentPath, !!currentPath && !pathHasRuleError);

                // 비용 표시 또는 오류 메시지
                if (currentPath && currentPath.length > 0) {
                    if (pathHasRuleError) {
                        costTooltip.textContent = errorReason;
                        costTooltip.className = 'insufficient';
                    } else {
                        const cost = calcPathCost(currentPath);
                        const canAfford = TEST_MODE || economy.money >= cost;
                        costTooltip.textContent = canAfford ? `₩${cost.toLocaleString()}` : '자금 부족';
                        costTooltip.className = canAfford ? '' : 'insufficient';
                    }
                    costTooltip.style.display = 'block';
                    costTooltip.style.left = (e.clientX + 15) + 'px';
                    costTooltip.style.top = (e.clientY + 15) + 'px';
                } else {
                    costTooltip.style.display = 'none';
                }
            } else {
                setPreviewPath(null);
                costTooltip.style.display = 'none';
            }
        }
        // 4차선 도로 모드일 때 (2x2 드래그 배치)
        else if (currentMode === MODE.BUILD_4LANE) {
            // 2타일 그리드에 맞춘 원점 계산
            const originX = Math.floor(t.x / 2) * 2;
            const originY = Math.floor(t.y / 2) * 2;
            const canPlace = canPlace4LaneRoad(originX, originY);

            if (canPlace) {
                ghost.material.color.set(0x00aa88);  // 설치 가능 - 초록색
            } else {
                ghost.material.color.set(0xff3366);  // 설치 불가 - 빨간색
            }

            // 드래그 중이면 경로 프리뷰 표시
            if (isBuildDragging && buildStart) {
                current4LanePath = pickBest4LaneLPath(buildStart, hovered);
                set4LanePathPreview(current4LanePath, !!current4LanePath);

                // 비용 표시
                if (current4LanePath && current4LanePath.length > 0) {
                    const cost = current4LanePath.length * 500;  // 4차선 도로 비용
                    const canAfford = TEST_MODE || economy.money >= cost;
                    costTooltip.textContent = canAfford ? `₩${cost.toLocaleString()}` : '자금 부족';
                    costTooltip.className = canAfford ? '' : 'insufficient';
                    costTooltip.style.display = 'block';
                    costTooltip.style.left = (e.clientX + 15) + 'px';
                    costTooltip.style.top = (e.clientY + 15) + 'px';
                } else {
                    costTooltip.style.display = 'none';
                }
            } else {
                // 드래그 전에는 단일 2x2 프리뷰
                set4LanePreview(originX, originY, canPlace);
                costTooltip.style.display = 'none';
            }
        }
        // 수로 모드일 때
        else if (currentMode === MODE.WATER) {
            if (isLocked(t.x, t.y)) ghost.material.color.set(0xffcc00);
            else if (isBridge(t.x, t.y)) ghost.material.color.set(0xff3366);  // 다리 위는 설치 불가
            else if (isRoad(t.x, t.y)) ghost.material.color.set(0x00aaff);  // 도로 위 → 다리 가능
            else if (isWater(t.x, t.y)) ghost.material.color.set(0x2266ff);  // 이미 수로
            else ghost.material.color.set(0x4488ff);  // 설치 가능

            if (isBuildDragging && buildStart) {
                currentPath = pickBestLPath(buildStart, hovered);
                setPreviewPath(currentPath, !!currentPath);

                // 비용 표시
                if (currentPath && currentPath.length > 0) {
                    const cost = calcPathCost(currentPath);
                    const canAfford = TEST_MODE || economy.money >= cost;
                    costTooltip.textContent = canAfford ? `₩${cost.toLocaleString()}` : '자금 부족';
                    costTooltip.className = canAfford ? '' : 'insufficient';
                    costTooltip.style.display = 'block';
                    costTooltip.style.left = (e.clientX + 15) + 'px';
                    costTooltip.style.top = (e.clientY + 15) + 'px';
                } else {
                    costTooltip.style.display = 'none';
                }
            } else {
                setPreviewPath(null);
                costTooltip.style.display = 'none';
            }
        }
        // 건물 설치 모드일 때 - 미리보기 표시 + 서비스 효과 범위 표시
        else if (isPlacementMode(currentMode)) {
            const placementType = getCurrentPlacementType();
            if (placementType) {
                // 고스트 타일 숨기고 건물 미리보기 표시
                ghost.visible = false;
                updateBuildingPreview(placementType, t.x, t.y);

                // 서비스 효과 범위 시각화 (발전소/수도시설은 제외 - 전력/수도 뷰 사용)
                const isPowerPlacement = currentMode === MODE.PLACE_POWER_COAL || currentMode === MODE.PLACE_POWER_WIND;
                const isWaterPlacement = currentMode === MODE.PLACE_WATER_TOWER || currentMode === MODE.PLACE_WATER_PUMP;
                if (!isPowerPlacement && !isWaterPlacement) {
                    updateServiceEffectVisualization(placementType, t.x, t.y);
                }

                // 비용 툴팁 표시
                const cost = PUBLIC_BUILDING_MODELS[placementType]?.cost || 1000;
                const canAfford = TEST_MODE || economy.money >= cost;
                const canPlace = canPlacePublicBuilding(t.x, t.y, placementType);
                if (canPlace) {
                    costTooltip.textContent = canAfford ? `₩${cost.toLocaleString()}` : '자금 부족';
                    costTooltip.className = canAfford ? '' : 'insufficient';
                } else {
                    costTooltip.textContent = '배치 불가';
                    costTooltip.className = 'insufficient';
                }
                costTooltip.style.display = 'block';
                costTooltip.style.left = (e.clientX + 15) + 'px';
                costTooltip.style.top = (e.clientY + 15) + 'px';
            }
        }
        // 다른 모드일 때 미리보기 및 서비스 효과 숨기기
        else {
            hideBuildingPreview();
            clearServiceEffects();
        }
    });

    renderer.domElement.addEventListener("pointerdown", (e) => {
        if (!MAP_CONFIG.isOwner) return;
        if (e.button !== 0) return;
        if (!hovered) return;

        // 철거 모드 (클릭 & 드래그로 삭제 - 도로/수로/건물/공공시설) - 독립 토글
        if (isDemolishModeActive) {
            const cellType = grid[hovered.x][hovered.y];

            // Ctrl+클릭: 연결된 직선 도로 일괄 철거
            if ((e.ctrlKey || e.metaKey) && ctrlDemolishSelectedRoads.length > 0) {
                let demolishedCount = 0;
                for (const tile of ctrlDemolishSelectedRoads) {
                    const type = grid[tile.x][tile.y];
                    if (type === CELL.ROAD || type === CELL.BRIDGE) {
                        grid[tile.x][tile.y] = CELL.EMPTY;
                        demolishedCount++;
                    }
                }
                if (demolishedCount > 0) {
                    rebuildRoadInstances();
                    rebuildRoadModels();
                    rebuildAllTiles();
                    markDirty();
                    toast({
                        title: '도로 철거',
                        desc: `${demolishedCount}개의 도로 타일이 철거되었습니다.`,
                        success: true
                    });
                }
                ctrlDemolishSelectedRoads = [];
                clearLinePreview();
                return;
            }

            isDemolishDragging = true;
            demolishedTiles.clear();

            // 철거 전 하이라이트 제거 (오브젝트가 제거되므로)
            clearDemolishHighlight();

            const key = `${hovered.x},${hovered.y}`;
            const hasBuilding = hasBuildingAt(hovered.x, hovered.y);
            const hasPublicBuilding = findPublicBuildingAt(hovered.x, hovered.y);

            // 4차선 도로 철거 (2x2 전체 철거)
            if (cellType === CELL.ROAD_4LANE || cellType === CELL.LOCKED_ROAD_4LANE) {
                if (remove4LaneRoad(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                    rebuildRoadInstances();
                    rebuildRoadModels();
                    rebuildAllTiles();
                    markDirty();
                }
            }
            // 도로/수로/다리 철거
            else if (cellType === CELL.ROAD || cellType === CELL.WATER || cellType === CELL.BRIDGE) {
                grid[hovered.x][hovered.y] = CELL.EMPTY;
                demolishedTiles.add(key);
                rebuildRoadInstances();
                rebuildRoadModels();
                rebuildAllTiles();
                markDirty();
            }
            // 공공시설 철거
            else if (hasPublicBuilding) {
                if (removePublicBuilding(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                }
            }
            // 일반 건물 철거
            else if (hasBuilding) {
                if (removeBuildingAt(hovered.x, hovered.y)) {
                    demolishedTiles.add(key);
                    markDirty();
                }
            }
            return;
        }

        // 공공시설 설치 모드
        if (isPlacementMode(currentMode)) {
            const placementType = getCurrentPlacementType();
            if (placementType) {
                placePublicBuilding(hovered.x, hovered.y, placementType, e.clientX, e.clientY);
            }
            return;
        }

        // 구역 삭제 모드 (건물은 유지, 구역 마스크만 삭제)
        if (currentMode === MODE.ZONE_DELETE) {
            // Ctrl+클릭: 같은 구역 타입 전체 삭제
            if ((e.ctrlKey || e.metaKey) && isZone(hovered.x, hovered.y)) {
                const sameZoneTiles = findSameZoneTiles(hovered.x, hovered.y);
                if (sameZoneTiles.length > 0) {
                    const zoneTypeName = ZONE_NAMES[grid[hovered.x][hovered.y]] || '구역';
                    for (const tile of sameZoneTiles) {
                        setZone(tile.x, tile.y, CELL.EMPTY);
                    }
                    rebuildZoneInstances(false);
                    markDirty();
                    clearLinePreview();
                    toast({
                        title: '구역 삭제',
                        desc: `${sameZoneTiles.length}개의 ${zoneTypeName} 타일이 삭제되었습니다.`,
                        success: true
                    });
                }
                return;
            }

            isZoneDragging = true;
            zonePlacedTiles.clear();

            const key = `${hovered.x},${hovered.y}`;
            if (isZone(hovered.x, hovered.y)) {
                setZone(hovered.x, hovered.y, CELL.EMPTY);
                zonePlacedTiles.add(key);
                rebuildZoneInstances(false);  // 건물 유지
                markDirty();
            }
            return;
        }

        // 구역 배치 모드 (드래그 칠하기)
        if (isZoneMode()) {
            // Ctrl+클릭: 도로를 따라 BFS 범위 선택
            if (e.ctrlKey || e.metaKey) {
                zonePlacedTiles.clear();
                const lineTiles = findLineTilesAlongRoad(hovered.x, hovered.y);
                if (lineTiles.length > 0) {
                    for (const tile of lineTiles) {
                        setZone(tile.x, tile.y, currentZoneType);
                        zonePlacedTiles.add(`${tile.x},${tile.y}`);
                    }
                    rebuildZoneInstances(false);
                    markDirty();

                    processNewZoneTiles(zonePlacedTiles, currentZoneType);
                    const zoneTypeName = ZONE_NAMES[currentZoneType] || '구역';
                    toast({
                        title: '구역 지정 완료',
                        desc: `${zonePlacedTiles.size}개 ${zoneTypeName} 타일이 지정되었습니다.`,
                        success: true
                    });
                    zonePlacedTiles.clear();
                }
                return;
            }

            // 일반 클릭: 드래그 칠하기 시작
            isZoneDragging = true;
            zonePlacedTiles.clear();

            if (canPlaceZone(hovered.x, hovered.y)) {
                const key = `${hovered.x},${hovered.y}`;
                setZone(hovered.x, hovered.y, currentZoneType);
                zonePlacedTiles.add(key);
                rebuildZoneInstances(false);
                markDirty();
            }
            return;
        }

        // 수로 모드 (도로 모드와 동일하게 드래그)
        if (currentMode === MODE.WATER) {
            isBuildDragging = true;
            buildStart = { x: hovered.x, y: hovered.y };
            currentPath = pickBestLPath(buildStart, hovered);
            setPreviewPath(currentPath, !!currentPath);
            return;
        }

        // 도로 모드 (2차선)
        if (currentMode === MODE.BUILD) {
            isBuildDragging = true;
            buildStart = { x: hovered.x, y: hovered.y };
            currentPath = pickBestLPath(buildStart, hovered);
            setPreviewPath(currentPath, !!currentPath);
            return;
        }

        // 4차선 도로 모드 (2x2 드래그 배치)
        if (currentMode === MODE.BUILD_4LANE) {
            isBuildDragging = true;
            buildStart = { x: hovered.x, y: hovered.y };
            current4LanePath = pickBest4LaneLPath(buildStart, hovered);
            set4LanePathPreview(current4LanePath, !!current4LanePath);
            return;
        }
    });

    renderer.domElement.addEventListener("pointerup", (e) => {
        if (!MAP_CONFIG.isOwner) return;

        // 철거 모드 드래그 종료 (독립 토글)
        if (isDemolishModeActive) {
            if (isDemolishDragging && demolishedTiles.size > 0) {
                toast({
                    title: '철거 완료',
                    desc: `${demolishedTiles.size}개 타일이 철거되었습니다.`,
                    success: true
                });
            }
            isDemolishDragging = false;
            demolishedTiles.clear();
            return;
        }

        // 구역 삭제 모드 드래그 종료
        if (currentMode === MODE.ZONE_DELETE) {
            if (isZoneDragging && zonePlacedTiles.size > 0) {
                toast({
                    title: '구역 삭제 완료',
                    desc: `${zonePlacedTiles.size}개 타일이 삭제되었습니다.`,
                    success: true
                });
            }
            isZoneDragging = false;
            zonePlacedTiles.clear();
            return;
        }

        // 구역 배치 모드 드래그 종료
        if (isZoneMode()) {
            if (isZoneDragging && zonePlacedTiles.size > 0) {
                // 새로 배치된 타일들에 대해 공사 대기열 추가
                processNewZoneTiles(zonePlacedTiles, currentZoneType);

                const zoneTypeName = ZONE_NAMES[currentZoneType] || '구역';
                toast({
                    title: `${zoneTypeName} 지정 완료`,
                    desc: `${zonePlacedTiles.size}개 타일이 지정되었습니다. 입주민 대기 중...`,
                    success: true
                });
            }
            isZoneDragging = false;
            zonePlacedTiles.clear();
            return;
        }

        // 수로 모드
        if (currentMode === MODE.WATER) {
            if (!buildStart) {
                isBuildDragging = false;
                costTooltip.style.display = 'none';
                return;
            }

            if (!hovered) {
                isBuildDragging = false;
                buildStart = null;
                currentPath = null;
                setPreviewPath(null);
                costTooltip.style.display = 'none';
                return;
            }

            currentPath = pickBestLPath(buildStart, hovered);

            if (!currentPath) {
                isBuildDragging = false;
                buildStart = null;
                currentPath = null;
                setPreviewPath(null);
                costTooltip.style.display = 'none';
                return;
            }

            // 설치할 타일 목록 수집 (아직 실제로 설치하지 않음)
            const tilesToPlace = [];
            for (const t of currentPath) {
                if (isRoad(t.x, t.y)) {
                    tilesToPlace.push({ x: t.x, y: t.y, type: 'bridge' });
                } else if (!isBridge(t.x, t.y)) {
                    tilesToPlace.push({ x: t.x, y: t.y, type: 'water' });
                }
            }

            // 순차적으로 수로 설치 + 먼지 이펙트
            if (tilesToPlace.length > 0) {
                placeWaterSequentially(tilesToPlace);
            }
            markDirty();

            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 4차선 도로 모드 (2x2 타일, 드래그 배치)
        if (currentMode === MODE.BUILD_4LANE) {
            if (!buildStart) {
                isBuildDragging = false;
                costTooltip.style.display = 'none';
                return;
            }

            if (!hovered) {
                isBuildDragging = false;
                buildStart = null;
                current4LanePath = null;
                set4LanePathPreview(null);
                costTooltip.style.display = 'none';
                return;
            }

            current4LanePath = pickBest4LaneLPath(buildStart, hovered);

            if (!current4LanePath || current4LanePath.length === 0) {
                isBuildDragging = false;
                buildStart = null;
                current4LanePath = null;
                set4LanePathPreview(null);
                costTooltip.style.display = 'none';
                return;
            }

            // 4차선 도로 경로 배치
            let placedCount = 0;
            const placedOrigins = [];
            for (const origin of current4LanePath) {
                if (place4LaneRoad(origin.x, origin.y)) {
                    placedCount++;
                    placedOrigins.push({ x: origin.x, y: origin.y });
                }
            }

            if (placedCount > 0) {
                rebuildRoadInstances();
                rebuildRoadModels();
                rebuildAllTiles();
                markDirty();

                // 4차선 도로 건설 먼지 이펙트 (순차적으로 퍼짐)
                create4LaneConstructionDustEffect(placedOrigins);

                toast({
                    title: '4차선 도로 설치',
                    desc: `${placedCount}개의 2x2 도로가 설치되었습니다.`,
                    success: true
                });
            }

            isBuildDragging = false;
            buildStart = null;
            current4LanePath = null;
            set4LanePathPreview(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 2차선 도로 모드
        if (currentMode !== MODE.BUILD) {
            isBuildDragging = false;
            costTooltip.style.display = 'none';
            return;
        }
        if (!buildStart) {
            isBuildDragging = false;
            costTooltip.style.display = 'none';
            return;
        }

        if (!hovered) {
            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        currentPath = pickBestLPath(buildStart, hovered);

        if (!currentPath) {
            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 2차선 도로 설치 (테스트 모드: 비용 무시)
        // 수로 위에 도로를 놓으면 다리가 됨

        // 2차선 도로 배치 규칙 검사 (4차선 연결 규칙 + 2x2 블록 규칙 + 경로 내 연속 배치 + 평행 배치)
        // 경로 전체에서 4차선 한 면에 연속 배치 체크
        const v3 = validatePathNo4LaneConsecutive(currentPath);
        if (!v3.valid) {
            toast({
                title: '도로 설치 불가',
                desc: v3.reason,
                success: false
            });
            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 기존 도로 옆에 2칸 이상 연속 배치 체크
        const v4 = validatePathNoParallelToRoad(currentPath);
        if (!v4.valid) {
            toast({
                title: '도로 설치 불가',
                desc: v4.reason,
                success: false
            });
            isBuildDragging = false;
            buildStart = null;
            currentPath = null;
            setPreviewPath(null);
            costTooltip.style.display = 'none';
            return;
        }

        // 설치할 타일 목록 수집 (개별 셀 검증 후 유효한 타일만)
        const tilesToPlace = [];
        let skippedCount = 0;

        for (const t of currentPath) {
            // 개별 셀 검증 - 실패 시 해당 타일만 스킵
            const v1 = validate2LaneNear4Lane(t.x, t.y);
            if (!v1.valid) {
                skippedCount++;
                continue;
            }
            const v2 = validate2LaneNo2x2Block(t.x, t.y);
            if (!v2.valid) {
                skippedCount++;
                continue;
            }

            // 기본 조건 체크
            if (isWater(t.x, t.y)) {
                tilesToPlace.push({ x: t.x, y: t.y, type: 'bridge' });
            } else if (!isLocked(t.x, t.y) && !isBlocked(t.x, t.y)) {
                if (is4LaneRoad(t.x, t.y)) continue;
                if (!placedPublicBuildings.has(`${t.x},${t.y}`)) {
                    tilesToPlace.push({ x: t.x, y: t.y, type: 'road' });
                }
            } else {
                skippedCount++;
            }
        }

        // 순차적으로 도로 설치 + 먼지 이펙트
        if (tilesToPlace.length > 0) {
            placeRoadsSequentially(tilesToPlace);
        }

        // 변경사항 표시
        markDirty();

        isBuildDragging = false;
        buildStart = null;
        currentPath = null;
        setPreviewPath(null);
        costTooltip.style.display = 'none';
    });

    renderer.domElement.addEventListener("contextmenu", (e) => {
        if (currentMode === MODE.BUILD || currentMode === MODE.BUILD_4LANE || currentMode === MODE.WATER || isDemolishModeActive || isZoneMode() || currentMode === MODE.ZONE_DELETE) e.preventDefault();
    });

    /* =========================================================
     * BUILDING INFO POPUP SYSTEM
     * ========================================================= */

    // 선택된 건물 참조 (팝업 위치 추적용)
    let selectedBuilding = null;
    let selectedBuildingWorldPos = new THREE.Vector3();

    // 팝업 닫기 버튼
    if (popupClose) {
        popupClose.addEventListener('click', (e) => {
            e.stopPropagation();
            hideBuildingPopup();
        });
    }

    // 팝업 표시 함수
    function showBuildingPopup(building) {
        if (!buildingPopup) return;

        selectedBuilding = building;

        const userData = building.userData || {};
        const zoneType = userData.zoneType || 'residential';
        const size = userData.size || '1x1';
        const x = userData.tileX;
        const y = userData.tileY;

        // 건물 키 생성
        const key = getBuildingKey(x, y, size);

        // 건물 이름 가져오기 (displayName 우선, 없으면 생성)
        const placedBuilding = placedBuildings.get(`${x},${y}`);
        const displayName = placedBuilding?.displayName;
        const buildingName = displayName || assignBuildingName(key, zoneType);

        // 타입 정보
        const isResidential = zoneType.includes('residential');
        const isCommercial = zoneType.includes('commercial');
        const isIndustrial = zoneType.includes('industrial');

        let typeClass, typeIcon, typeText;
        if (isResidential) {
            typeClass = 'residential';
            typeIcon = '🏠';
            typeText = '주거';
        } else if (isCommercial) {
            typeClass = 'commercial';
            typeIcon = '🏪';
            typeText = '상업';
        } else {
            typeClass = 'industrial';
            typeIcon = '🏭';
            typeText = '공업';
        }

        // 땅값 계산
        const rawLandValue = typeof getLandValue === 'function' ? getLandValue(x, y) : 100;
        const serviceBonus = typeof getServiceBonus === 'function' ? getServiceBonus(x, y) : 0;

        // 인구 (주거 건물만)
        let population = 0;
        if (isResidential) {
            population = assignBuildingPopulation(key, size);
        }

        // 총 땅값 계산 (레벨 진행도용)
        const totalRawLandValue = rawLandValue + serviceBonus;

        // 행복도 계산 (땅값 기반 + 세금 패널티)
        const happiness = calculateBuildingHappiness(x, y);
        const happinessColor = getHappinessColor(happiness);

        // 팝업 내용 업데이트
        popupIcon.textContent = typeIcon;
        popupTitle.textContent = buildingName;

        popupType.className = 'popup-type ' + typeClass;
        popupTypeIcon.textContent = typeIcon;
        popupTypeText.textContent = typeText;

        // 인구 행 (주거만 표시)
        if (isResidential) {
            popupPopulationRow.style.display = 'flex';
            popupPopulation.textContent = population + '명';
        } else {
            popupPopulationRow.style.display = 'none';
        }

        // 행복도 바 업데이트 (정확한 수치 표시)
        if (happinessBarFill) {
            happinessBarFill.style.width = happiness + '%';
            happinessBarFill.style.background = happinessColor;
            happinessBarFill.style.boxShadow = `0 0 8px ${happinessColor}`;
        }

        // 행복도 수치 표시
        if (happinessValue) {
            happinessValue.textContent = happiness;
            happinessValue.style.color = happinessColor;
        }

        // 행복도 이모지 업데이트 (수치 기반)
        if (happinessEmoji) {
            if (happiness < 30) {
                happinessEmoji.textContent = '😢';
            } else if (happiness < 60) {
                happinessEmoji.textContent = '😐';
            } else {
                happinessEmoji.textContent = '😊';
            }
        }

        // 시민 한마디 업데이트 (이벤트 우선, 그 다음 효과 원인 기반)
        if (citizenQuote && citizenQuoteText) {
            // 이벤트 상태 확인 (화재 등)
            const buildingKey = `${x},${y}`;
            const isBurning = typeof burningBuildings !== 'undefined' && burningBuildings.has(buildingKey);

            // 업그레이드 공간 부족 확인 (1x1 건물이 땅값 충족했지만 공간 부족)
            const currentBuildingData = placedBuildings.get(buildingKey);
            const buildingWidth = currentBuildingData?.width || 1;
            const currentLevel = userData.level || 1;
            const currentTotalLandValue = getTotalLandValue(x, y);
            const cannotUpgradeDueToSpace = buildingWidth === 1 && currentLevel === 1 &&
                currentTotalLandValue >= LAND_VALUE_THRESHOLD &&
                !check2x2MergeEligibility(x, y, zoneType).canMerge;

            if (isBurning) {
                // 화재 이벤트 문구 표시
                const fireQuotes = [
                    '🔥 불이야! 소방차가 필요해요!',
                    '🔥 도와주세요! 집에 불이 났어요!',
                    '🔥 빨리 대피해야 해요!',
                    '🔥 소방서에 연락해주세요!',
                ];
                citizenQuoteText.textContent = fireQuotes[Math.floor(Math.random() * fireQuotes.length)];
                citizenQuote.className = 'citizen-quote mid';  // 이벤트는 mid 스타일
            } else if (cannotUpgradeDueToSpace) {
                // 업그레이드 공간 부족 문구 표시
                const spaceQuotes = isResidential ? [
                    '📦 이 동네 땅값 올랐는데... 집이 너무 좁아요!',
                    '🏗️ 확장하고 싶은데 옆에 자리가 없네요...',
                    '😤 돈은 모았는데 확장할 공간이 없어요!',
                    '🏠 더 큰 집으로 이사가고 싶어요...',
                ] : isCommercial ? [
                    '📦 가게 확장하고 싶은데 자리가 없어요!',
                    '🏗️ 장사 잘 되는데 매장이 너무 좁네요...',
                    '😤 옆 가게가 비켜주면 확장할 텐데!',
                    '🏪 더 큰 매장이 필요해요...',
                ] : [
                    '📦 공장 확장이 필요한데 부지가 부족해요!',
                    '🏗️ 생산량 늘리고 싶은데 공간이 없네요...',
                    '😤 옆 부지를 사고 싶어요!',
                    '🏭 더 넓은 공장이 필요합니다...',
                ];
                citizenQuoteText.textContent = spaceQuotes[Math.floor(Math.random() * spaceQuotes.length)];
                citizenQuote.className = 'citizen-quote mid';
            } else {
                // 일반 시민 한마디 (행복도 기반)
                const happinessLevelForQuote = happiness < 30 ? 'low' : happiness < 60 ? 'mid' : 'high';
                const quote = getCitizenQuote(zoneType, happinessLevelForQuote, x, y);
                citizenQuoteText.textContent = quote;

                // 효과에 따른 스타일 변경
                const effect = analyzeBuildingEffect(x, y);
                if (effect) {
                    if (effect.isPositive) {
                        citizenQuote.className = 'citizen-quote positive';
                    } else {
                        citizenQuote.className = 'citizen-quote negative';
                    }
                } else {
                    citizenQuote.className = 'citizen-quote ' + happinessLevelForQuote;
                }
            }
        }

        // ===== 레벨 진행도 UI (땅값 통합) =====
        const levelProgressContainer = document.getElementById('levelProgressContainer');
        const levelProgressValue = document.getElementById('levelProgressValue');
        const levelProgressMarker = document.getElementById('levelProgressMarker');
        const levelSection2 = document.getElementById('levelSection2');
        const levelBadgeCurrent = document.getElementById('levelBadgeCurrent');
        const levelBadgeNext = document.getElementById('levelBadgeNext');
        const demolishInfoContainer = document.getElementById('demolishInfoContainer');

        const level = userData.level || 1;
        const currentLandVal = userData.currentLandValue || totalRawLandValue;
        const maxDisplayValue = LAND_VALUE_THRESHOLD * 2;  // 최대 표시 값 (100)

        // 마커 위치 계산 (0% ~ 100%)
        const markerPercent = Math.min((currentLandVal / maxDisplayValue) * 100, 100);

        // 폐건물인 경우
        if (userData.isAbandoned) {
            // 팝업 스타일 변경
            popupIcon.textContent = '🏚️';
            popupTitle.textContent = '폐건물';
            popupType.className = 'popup-type abandoned';
            popupTypeIcon.textContent = '⚠️';
            popupTypeText.textContent = '방치됨';

            // 레벨 진행도 숨김
            if (levelProgressContainer) {
                levelProgressContainer.style.display = 'none';
            }

            // 철거 안내 표시
            if (demolishInfoContainer) {
                demolishInfoContainer.style.display = 'block';
            }

            // 인구 숨김
            popupPopulationRow.style.display = 'none';

            // 행복도 전체 숨김
            if (happinessBarContainer) {
                happinessBarContainer.parentElement.parentElement.style.display = 'none';
            }
            const happinessRow = document.querySelector('.building-popup .popup-row.happiness');
            if (happinessRow) {
                happinessRow.style.display = 'none';
            }

            // 시민 한마디에 철거 이유 표시
            if (citizenQuote && citizenQuoteText) {
                const reason = userData.abandonedReason || '알 수 없는 이유로 방치되었습니다.';
                citizenQuoteText.textContent = reason;
                citizenQuote.className = 'citizen-quote abandoned';
            }
        } else {
            // 철거 안내 숨김
            if (demolishInfoContainer) {
                demolishInfoContainer.style.display = 'none';
            }
            if (levelProgressContainer) {
                levelProgressContainer.style.display = 'block';
                levelProgressContainer.classList.remove('abandoned');
            }
            if (happinessBarContainer) {
                happinessBarContainer.parentElement.parentElement.style.display = 'flex';
            }
            // 행복도 행 다시 표시
            const happinessRow = document.querySelector('.building-popup .popup-row.happiness');
            if (happinessRow) {
                happinessRow.style.display = 'flex';
            }
        }

        // 레벨 진행도 바 업데이트
        if (levelProgressValue) {
            levelProgressValue.textContent = `${Math.round(currentLandVal)} / ${LAND_VALUE_THRESHOLD}`;
        }

        // 마커 위치 업데이트
        if (levelProgressMarker) {
            levelProgressMarker.style.left = markerPercent + '%';

            // 마커 아이콘 업데이트
            const markerIcon = levelProgressMarker.querySelector('.marker-icon');
            if (markerIcon) {
                if (level === 2 || currentLandVal >= LAND_VALUE_THRESHOLD) {
                    markerIcon.textContent = '🏢';
                } else {
                    markerIcon.textContent = typeIcon;
                }
            }

            // eligible 클래스 토글
            if (currentLandVal >= LAND_VALUE_THRESHOLD) {
                levelProgressMarker.classList.add('eligible');
            } else {
                levelProgressMarker.classList.remove('eligible');
            }
        }

        // 레벨 2 섹션 활성화
        if (levelSection2) {
            if (currentLandVal >= LAND_VALUE_THRESHOLD) {
                levelSection2.classList.add('active');
            } else {
                levelSection2.classList.remove('active');
            }
        }

        // 레벨 뱃지 업데이트
        if (levelBadgeCurrent) {
            const currentBadgeIcon = levelBadgeCurrent.querySelector('.badge-icon');
            if (currentBadgeIcon) {
                currentBadgeIcon.textContent = level === 2 ? '🏢' : '🏠';
            }
            levelBadgeCurrent.querySelector('span:last-child').textContent = level === 2 ? 'LV.2' : 'LV.1';
        }

        if (levelBadgeNext) {
            if (level === 2) {
                levelBadgeNext.style.display = 'none';  // 이미 최고 레벨
            } else {
                levelBadgeNext.style.display = 'flex';
            }
        }

        buildingPopup.style.display = 'block';
        updatePopupPosition();
    }

    // 건물 월드 좌표를 화면 좌표로 변환하여 팝업 위치 업데이트
    function updatePopupPosition() {
        if (!selectedBuilding || !buildingPopup || buildingPopup.style.display === 'none') return;

        // 건물의 바운딩 박스 중심점 계산
        const box = new THREE.Box3().setFromObject(selectedBuilding);
        const center = box.getCenter(new THREE.Vector3());
        const top = center.clone();
        top.y = box.max.y + 0.5;  // 건물 상단 위로 약간 띄움

        // 3D 좌표를 화면 좌표로 변환
        const screenPos = top.clone().project(camera);

        // NDC를 화면 픽셀 좌표로 변환
        const rect = renderer.domElement.getBoundingClientRect();
        const screenX = (screenPos.x * 0.5 + 0.5) * rect.width + rect.left;
        const screenY = (-screenPos.y * 0.5 + 0.5) * rect.height + rect.top;

        // 화면 밖으로 나갔는지 체크 (카메라 뒤쪽 또는 화면 경계 밖)
        const margin = 50;
        if (screenPos.z > 1 ||
            screenX < -margin || screenX > window.innerWidth + margin ||
            screenY < -margin || screenY > window.innerHeight + margin) {
            hideBuildingPopup();
            return;
        }

        // 팝업 위치 설정 (건물 위, 중앙 정렬)
        const popupWidth = 280;
        const popupHeight = buildingPopup.offsetHeight || 220;

        let posX = screenX - popupWidth / 2;
        let posY = screenY - popupHeight - 10;

        // 화면 경계 체크
        if (posX < 10) posX = 10;
        if (posX + popupWidth > window.innerWidth - 10) posX = window.innerWidth - popupWidth - 10;
        if (posY < 50) posY = screenY + 10;  // 위에 공간 없으면 아래로
        if (posY + popupHeight > window.innerHeight - 10) posY = window.innerHeight - popupHeight - 10;

        buildingPopup.style.left = posX + 'px';
        buildingPopup.style.top = posY + 'px';
    }

    // 팝업 숨기기
    function hideBuildingPopup() {
        if (buildingPopup) {
            buildingPopup.style.display = 'none';
        }
        selectedBuilding = null;
        // 선택 아웃라인도 제거
        clearBuildingOutline();
    }

    // ===== 공공시설 팝업 시스템 =====
    let selectedPublicBuilding = null;

    function showPublicBuildingPopup(building) {
        if (!publicBuildingPopup) return;

        selectedPublicBuilding = building;
        const userData = building.userData || {};
        const type = userData.publicBuildingType;
        const config = PUBLIC_BUILDING_MODELS[type];

        if (!config) return;

        // 아이콘과 타이틀
        publicPopupIcon.textContent = config.icon || '🏛️';
        publicPopupTitle.textContent = userData.name || config.name || '공공시설';

        // 타입 정보
        publicPopupTypeIcon.textContent = config.icon || '🏛️';
        publicPopupTypeText.textContent = config.name || type;

        // 소방서인 경우 소방차 현황 표시
        if (type === 'fire') {
            firetruckStatusSection.style.display = 'block';
            updateFiretruckStatus(userData.tileX, userData.tileY);
        } else {
            firetruckStatusSection.style.display = 'none';
        }

        // 경찰서인 경우 경찰차/감옥 현황 표시
        if (type === 'police') {
            policeStatusSection.style.display = 'block';
            updatePoliceStatus(userData.tileX, userData.tileY);
        } else {
            policeStatusSection.style.display = 'none';
        }

        // 병원인 경우 구급차/환자 현황 표시
        if (type === 'hospital') {
            hospitalStatusSection.style.display = 'block';
            updateHospitalStatus(userData.tileX, userData.tileY);
        } else {
            hospitalStatusSection.style.display = 'none';
        }

        publicBuildingPopup.style.display = 'block';
        updatePublicBuildingPopupPosition();
    }

    function updateFiretruckStatus(stationX, stationY) {
        const stationKey = `${stationX},${stationY}`;
        const maxTrucks = MAX_FIRETRUCKS_PER_STATION;

        // 해당 소방서에서 출동한 소방차 수 계산
        let dispatchedCount = 0;
        if (trafficManager && trafficManager.vehicles) {
            dispatchedCount = trafficManager.vehicles.filter(v =>
                v.isActive &&
                v.type === 'firetruck' &&
                v.stationKey === stationKey
            ).length;
        }

        const availableCount = Math.max(0, maxTrucks - dispatchedCount);
        const totalCount = maxTrucks;

        // 숫자 업데이트
        firetruckDispatched.textContent = dispatchedCount;
        firetruckAvailable.textContent = availableCount;
        firetruckTotal.textContent = totalCount;
        firetruckMax.textContent = maxTrucks;

        // 막대 그래프 업데이트
        const dispatchedPercent = (dispatchedCount / maxTrucks) * 100;
        const availablePercent = (availableCount / maxTrucks) * 100;

        firetruckBarDispatched.style.width = dispatchedPercent + '%';
        firetruckBarAvailable.style.width = availablePercent + '%';
    }

    function updatePoliceStatus(stationX, stationY) {
        const stationKey = `${stationX},${stationY}`;
        const maxCars = MAX_POLICE_PER_STATION;
        const maxPrisoners = MAX_PRISONERS_PER_STATION;

        // 해당 경찰서에서 출동한 경찰차 수 계산
        let dispatchedCount = 0;
        if (trafficManager && trafficManager.vehicles) {
            dispatchedCount = trafficManager.vehicles.filter(v =>
                v.isActive &&
                v.type === 'police' &&
                v.stationKey === stationKey
            ).length;
        }

        const availableCount = Math.max(0, maxCars - dispatchedCount);

        // 경찰차 숫자 업데이트
        policeDispatched.textContent = dispatchedCount;
        policeAvailable.textContent = availableCount;
        policeTotal.textContent = maxCars;
        policeMax.textContent = maxCars;

        // 경찰차 막대 그래프 업데이트
        const dispatchedPercent = (dispatchedCount / maxCars) * 100;
        const availablePercent = (availableCount / maxCars) * 100;
        policeBarDispatched.style.width = dispatchedPercent + '%';
        policeBarAvailable.style.width = availablePercent + '%';

        // 감옥 현황 업데이트
        const prisoners = stationPrisoners.get(stationKey) || [];
        const occupiedCount = prisoners.length;
        const emptyCount = maxPrisoners - occupiedCount;

        prisonOccupied.textContent = occupiedCount;
        prisonEmpty.textContent = emptyCount;
        prisonTotal.textContent = maxPrisoners;
        prisonMax.textContent = maxPrisoners;

        // 감옥 막대 그래프 업데이트
        const occupiedPercent = (occupiedCount / maxPrisoners) * 100;
        const emptyPercent = (emptyCount / maxPrisoners) * 100;
        prisonBarOccupied.style.width = occupiedPercent + '%';
        prisonBarEmpty.style.width = emptyPercent + '%';
    }

    function updateHospitalStatus(hospitalX, hospitalY) {
        const hospitalKey = `${hospitalX},${hospitalY}`;
        const maxAmbulances = MAX_AMBULANCES_PER_HOSPITAL;
        const maxPatients = MAX_PATIENTS_PER_HOSPITAL;

        // 해당 병원에서 출동한 구급차 수 계산
        let dispatchedCount = 0;
        if (trafficManager && trafficManager.vehicles) {
            dispatchedCount = trafficManager.vehicles.filter(v =>
                v.isActive &&
                v.type === 'ambulance' &&
                v.hospitalKey === hospitalKey
            ).length;
        }

        const availableCount = Math.max(0, maxAmbulances - dispatchedCount);

        // 구급차 숫자 업데이트
        ambulanceDispatched.textContent = dispatchedCount;
        ambulanceAvailable.textContent = availableCount;
        ambulanceTotal.textContent = maxAmbulances;
        ambulanceMax.textContent = maxAmbulances;

        // 구급차 막대 그래프 업데이트
        const dispatchedPercent = (dispatchedCount / maxAmbulances) * 100;
        const availablePercent = (availableCount / maxAmbulances) * 100;
        ambulanceBarDispatched.style.width = dispatchedPercent + '%';
        ambulanceBarAvailable.style.width = availablePercent + '%';

        // 환자 현황 업데이트
        const patients = hospitalPatients.get(hospitalKey) || [];
        const occupiedCount = patients.length;
        const emptyCount = maxPatients - occupiedCount;

        patientOccupied.textContent = occupiedCount;
        patientEmpty.textContent = emptyCount;
        patientTotal.textContent = maxPatients;
        patientMax.textContent = maxPatients;

        // 환자 막대 그래프 업데이트
        const occupiedPercent = (occupiedCount / maxPatients) * 100;
        const emptyPercent = (emptyCount / maxPatients) * 100;
        patientBarOccupied.style.width = occupiedPercent + '%';
        patientBarEmpty.style.width = emptyPercent + '%';
    }

    let lastFiretruckUpdate = 0;
    const FIRETRUCK_UPDATE_INTERVAL = 500;  // 0.5초마다 업데이트

    function updatePublicBuildingPopupPosition() {
        if (!selectedPublicBuilding || !publicBuildingPopup || publicBuildingPopup.style.display === 'none') return;

        const box = new THREE.Box3().setFromObject(selectedPublicBuilding);
        const center = box.getCenter(new THREE.Vector3());
        const top = center.clone();
        top.y = box.max.y + 0.5;

        const screenPos = top.clone().project(camera);
        const rect = renderer.domElement.getBoundingClientRect();
        const screenX = (screenPos.x * 0.5 + 0.5) * rect.width + rect.left;
        const screenY = (-screenPos.y * 0.5 + 0.5) * rect.height + rect.top;

        const margin = 50;
        if (screenPos.z > 1 ||
            screenX < -margin || screenX > window.innerWidth + margin ||
            screenY < -margin || screenY > window.innerHeight + margin) {
            hidePublicBuildingPopup();
            return;
        }

        const popupWidth = 280;
        const popupHeight = publicBuildingPopup.offsetHeight || 220;

        let posX = screenX - popupWidth / 2;
        let posY = screenY - popupHeight - 10;

        if (posX < 10) posX = 10;
        if (posX + popupWidth > window.innerWidth - 10) posX = window.innerWidth - popupWidth - 10;
        if (posY < 50) posY = screenY + 10;
        if (posY + popupHeight > window.innerHeight - 10) posY = window.innerHeight - popupHeight - 10;

        publicBuildingPopup.style.left = posX + 'px';
        publicBuildingPopup.style.top = posY + 'px';

        // 소방서인 경우 소방차 현황 주기적 업데이트
        const userData = selectedPublicBuilding.userData;
        if (userData && userData.publicBuildingType === 'fire') {
            const now = Date.now();
            if (now - lastFiretruckUpdate > FIRETRUCK_UPDATE_INTERVAL) {
                updateFiretruckStatus(userData.tileX, userData.tileY);
                lastFiretruckUpdate = now;
            }
        }

        // 경찰서인 경우 주기적으로 상태 업데이트
        if (userData && userData.publicBuildingType === 'police') {
            const now = Date.now();
            if (now - lastFiretruckUpdate > FIRETRUCK_UPDATE_INTERVAL) {
                updatePoliceStatus(userData.tileX, userData.tileY);
                lastFiretruckUpdate = now;
            }
        }
    }

    function hidePublicBuildingPopup() {
        if (publicBuildingPopup) {
            publicBuildingPopup.style.display = 'none';
        }
        selectedPublicBuilding = null;
        clearBuildingOutline();
    }

    // 공공시설 팝업 닫기 버튼
    if (publicPopupClose) {
        publicPopupClose.addEventListener('click', hidePublicBuildingPopup);
    }

    /* =========================================================
     * BUILDING OUTLINE SYSTEM (호버/선택 시 아웃라인)
     * ========================================================= */

    // 아웃라인용 메쉬들
    let outlineMeshes = [];
    let hoveredBuilding = null;

    // 아웃라인 머티리얼 (뒷면만 렌더링하여 외곽선 효과)
    const outlineMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        side: THREE.BackSide
    });

    const selectedOutlineMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        side: THREE.BackSide
    });

    // 건물에 아웃라인 생성
    function createBuildingOutline(building, isSelected = false) {
        clearBuildingOutline();
        if (!building) return;

        const material = isSelected ? selectedOutlineMaterial : outlineMaterial;

        building.traverse((child) => {
            if (child.isMesh && child.geometry) {
                const outlineMesh = new THREE.Mesh(child.geometry.clone(), material.clone());

                // 월드 매트릭스를 직접 복사하여 정확한 위치/회전/스케일 적용
                child.updateWorldMatrix(true, false);
                outlineMesh.applyMatrix4(child.matrixWorld);

                // 약간 확대하여 아웃라인 효과
                const scaleUp = 1.03;
                outlineMesh.scale.multiplyScalar(scaleUp);

                outlineMesh.renderOrder = -1;
                scene.add(outlineMesh);
                outlineMeshes.push(outlineMesh);
            }
        });
    }

    // 아웃라인 제거
    function clearBuildingOutline() {
        outlineMeshes.forEach(mesh => {
            scene.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        });
        outlineMeshes = [];
    }

    /* =========================================================
     * DEMOLISH MODE HIGHLIGHT SYSTEM (철거 모드 빨간색 하이라이트)
     * ========================================================= */

    let demolishHighlightedObject = null;  // 현재 하이라이트된 오브젝트
    const demolishOriginalMaterials = new Map();  // 원본 머티리얼 저장

    // 철거 모드용 빨간색 머티리얼
    const demolishHighlightMaterial = new THREE.MeshStandardMaterial({
        color: 0xff3333,
        emissive: 0xff0000,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.9
    });

    // 오브젝트를 빨간색으로 하이라이트
    function highlightForDemolish(object) {
        if (!object || object === demolishHighlightedObject) return;

        // 이전 하이라이트 해제
        clearDemolishHighlight();

        demolishHighlightedObject = object;

        // 모든 메쉬의 원본 머티리얼 저장 후 빨간색으로 변경
        object.traverse((child) => {
            if (child.isMesh && child.material) {
                // 원본 머티리얼 저장 (배열인 경우 복사)
                const originalMat = Array.isArray(child.material)
                    ? child.material.map(m => m)
                    : child.material;
                demolishOriginalMaterials.set(child, originalMat);

                // 빨간색 머티리얼로 교체
                if (Array.isArray(child.material)) {
                    child.material = child.material.map(() => demolishHighlightMaterial.clone());
                } else {
                    child.material = demolishHighlightMaterial.clone();
                }
            }
        });
    }

    // 철거 하이라이트 해제
    function clearDemolishHighlight() {
        if (!demolishHighlightedObject) return;

        // 원본 머티리얼 복원
        demolishOriginalMaterials.forEach((originalMat, mesh) => {
            if (mesh && mesh.material) {
                mesh.material = originalMat;
            }
        });

        demolishOriginalMaterials.clear();
        demolishHighlightedObject = null;
    }

    // 좌표로 오브젝트 찾기 (건물, 공공시설, 도로, 수로, 다리)
    function findObjectAtTile(gx, gy) {
        // 1. 공공시설 확인
        const publicBuilding = findPublicBuildingAt(gx, gy);
        if (publicBuilding && publicBuilding.instance) {
            return publicBuilding.instance;
        }

        // 2. 일반 건물 확인
        const building = findBuildingAt(gx, gy);
        if (building && building.instance) {
            return building.instance;
        }

        // 3. 도로/수로/다리 - roadGroup, waterGroup, bridgeGroup에서 찾기
        const cellType = grid[gx][gy];
        const worldCenter = tileToWorldCenter(gx, gy);
        const searchRadius = TILE_SIZE * 0.6;

        // 4차선 도로인 경우 - userData로 검색
        if (cellType === CELL.ROAD_4LANE) {
            for (const child of roadGroup.children) {
                if (child.userData.is4Lane && child.userData.tiles) {
                    // 4차선 도로가 차지하는 타일 중에 현재 타일이 있는지 확인
                    const found = child.userData.tiles.some(t => t.x === gx && t.y === gy);
                    if (found) {
                        return child;
                    }
                }
            }
        }

        // 일반 도로 (2차선) - userData로 검색
        if (cellType === CELL.ROAD || cellType === CELL.LOCKED_ROAD) {
            for (const child of roadGroup.children) {
                if (child.userData.isRoad && !child.userData.is4Lane) {
                    if (child.userData.tileX === gx && child.userData.tileY === gy) {
                        return child;
                    }
                }
            }
            // userData가 없는 경우 위치 기반 검색 (폴백)
            for (const child of roadGroup.children) {
                if (!child.userData.isRoad) {
                    const dist = Math.sqrt(
                        Math.pow(child.position.x - worldCenter.x, 2) +
                        Math.pow(child.position.z - worldCenter.z, 2)
                    );
                    if (dist < searchRadius) {
                        return child;
                    }
                }
            }
        }

        // 수로
        if (cellType === CELL.WATER) {
            for (const child of waterGroup.children) {
                const dist = Math.sqrt(
                    Math.pow(child.position.x - worldCenter.x, 2) +
                    Math.pow(child.position.z - worldCenter.z, 2)
                );
                if (dist < searchRadius) {
                    return child;
                }
            }
        }

        // 다리
        if (cellType === CELL.BRIDGE) {
            for (const child of bridgeGroup.children) {
                const dist = Math.sqrt(
                    Math.pow(child.position.x - worldCenter.x, 2) +
                    Math.pow(child.position.z - worldCenter.z, 2)
                );
                if (dist < searchRadius) {
                    return child;
                }
            }
        }

        return null;
    }

    // 카메라 모드에서 건물 클릭/호버 감지
    const buildingRaycaster = new THREE.Raycaster();
    const buildingMouse = new THREE.Vector2();

    // 마우스 이동 시 건물 호버 감지
    renderer.domElement.addEventListener('mousemove', (e) => {
        // 카메라 모드일 때만 호버 감지 (철거 모드일 때는 제외)
        if (currentMode !== MODE.CAMERA || isDemolishModeActive) {
            if (hoveredBuilding) {
                hoveredBuilding = null;
                if (!selectedBuilding) clearBuildingOutline();
            }
            return;
        }

        const rect = renderer.domElement.getBoundingClientRect();
        buildingMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        buildingMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        buildingRaycaster.setFromCamera(buildingMouse, camera);
        const intersects = buildingRaycaster.intersectObjects(buildingGroup.children, true);

        if (intersects.length > 0) {
            let buildingObj = intersects[0].object;

            // 부모를 따라 올라가서 userData가 있는 건물 그룹 찾기 (민간건물 또는 공공시설)
            while (buildingObj && (!buildingObj.userData || (!buildingObj.userData.zoneType && !buildingObj.userData.isPublicBuilding))) {
                buildingObj = buildingObj.parent;
            }

            if (buildingObj && buildingObj.userData && (buildingObj.userData.zoneType || buildingObj.userData.isPublicBuilding)) {
                if (hoveredBuilding !== buildingObj) {
                    hoveredBuilding = buildingObj;
                    // 선택된 건물이 있으면 선택 아웃라인 유지, 아니면 호버 아웃라인
                    if (!selectedBuilding && !selectedPublicBuilding) {
                        createBuildingOutline(buildingObj, false);
                    }
                }
                renderer.domElement.style.cursor = 'pointer';
            } else {
                if (hoveredBuilding) {
                    hoveredBuilding = null;
                    if (!selectedBuilding && !selectedPublicBuilding) clearBuildingOutline();
                }
                renderer.domElement.style.cursor = 'default';
            }
        } else {
            if (hoveredBuilding) {
                hoveredBuilding = null;
                if (!selectedBuilding && !selectedPublicBuilding) clearBuildingOutline();
            }
            renderer.domElement.style.cursor = 'default';
        }
    });

    // 건물 클릭 시 팝업 표시
    renderer.domElement.addEventListener('click', (e) => {
        // 카메라 모드일 때만 건물 클릭 감지 (철거 모드일 때는 제외)
        if (currentMode !== MODE.CAMERA || isDemolishModeActive) return;

        const rect = renderer.domElement.getBoundingClientRect();
        buildingMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        buildingMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        buildingRaycaster.setFromCamera(buildingMouse, camera);

        // 먼저 그라운드 평면과의 교차로 타일 좌표 확인
        const groundIntersects = buildingRaycaster.intersectObject(ground, false);
        if (groundIntersects.length > 0) {
            const point = groundIntersects[0].point;
            const tile = worldToTile(point.x, point.z);

            if (tile) {
                // 공사 현장인지 확인
                const construction = getConstructionAt(tile.x, tile.y);
                if (construction) {
                    hideBuildingPopup();
                    showConstructionPopup(construction);
                    return;
                }
            }
        }

        // 공사 현장이 아니면 일반 건물 확인
        const intersects = buildingRaycaster.intersectObjects(buildingGroup.children, true);

        if (intersects.length > 0) {
            let buildingObj = intersects[0].object;

            // 부모를 따라 올라가서 userData가 있는 건물 그룹 찾기
            while (buildingObj && (!buildingObj.userData || (!buildingObj.userData.zoneType && !buildingObj.userData.isPublicBuilding))) {
                buildingObj = buildingObj.parent;
            }

            if (buildingObj && buildingObj.userData) {
                closeConstructionPopup();  // 공사 팝업 닫기

                // 공공시설인 경우
                if (buildingObj.userData.isPublicBuilding) {
                    hideBuildingPopup();  // 일반 건물 팝업 닫기
                    showPublicBuildingPopup(buildingObj);
                    createBuildingOutline(buildingObj, true);
                }
                // 민간 건물인 경우
                else if (buildingObj.userData.zoneType) {
                    hidePublicBuildingPopup();  // 공공시설 팝업 닫기
                    showBuildingPopup(buildingObj);
                    createBuildingOutline(buildingObj, true);  // 선택 아웃라인 (노란색)
                }
            }
        } else {
            // 건물이 아닌 곳 클릭시 팝업 닫기
            hideBuildingPopup();
            hidePublicBuildingPopup();
            closeConstructionPopup();
        }
    });

    // 땅 더블클릭 시 카메라 중심 이동
    renderer.domElement.addEventListener('dblclick', (e) => {
        // 카메라 모드일 때만 작동
        if (currentMode !== MODE.CAMERA) return;

        const rect = renderer.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((e.clientX - rect.left) / rect.width) * 2 - 1,
            -((e.clientY - rect.top) / rect.height) * 2 + 1
        );

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        // 그라운드 평면과 교차점 찾기
        const groundIntersects = raycaster.intersectObject(ground, false);
        if (groundIntersects.length > 0) {
            const point = groundIntersects[0].point;

            // 맵 범위 내인지 확인
            const halfW = (GRID_W * TILE_SIZE) / 2;
            const halfH = (GRID_H * TILE_SIZE) / 2;
            const clampedX = Math.max(-halfW, Math.min(halfW, point.x));
            const clampedZ = Math.max(-halfH, Math.min(halfH, point.z));

            // 부드러운 카메라 이동을 위한 애니메이션 (회전 고정)
            const startTarget = controls.target.clone();
            const startPosition = camera.position.clone();
            const endTarget = new THREE.Vector3(clampedX, 0, clampedZ);

            // 카메라-타겟 오프셋 유지 (회전 고정을 위해)
            const cameraOffset = new THREE.Vector3().subVectors(startPosition, startTarget);
            const endPosition = new THREE.Vector3().addVectors(endTarget, cameraOffset);

            const startTime = performance.now();
            const duration = 500; // 0.5초

            function animateCameraMove() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                // easeOutCubic
                const eased = 1 - Math.pow(1 - progress, 3);

                controls.target.lerpVectors(startTarget, endTarget, eased);
                camera.position.lerpVectors(startPosition, endPosition, eased);

                if (progress < 1) {
                    requestAnimationFrame(animateCameraMove);
                }
            }
            animateCameraMove();
        }
    });

    /* =========================================================
     * TRAFFIC SYSTEM - 교통 시뮬레이션
     * ========================================================= */

    // ===== 교통 시스템 설정 =====
    const TRAFFIC_CONFIG = {
        maxVehiclesBase: 30,       // 기본 차량 수 (최적화: 100→30)
        maxVehiclesCap: 300,       // 최대 차량 수 상한 (최적화: 2500→300)
        vehiclesPerPopulation: 25, // 인구 N명당 차량 1대 (최적화: 10→25)
        spawnInterval: 2.0,        // 초 (최적화: 1.5→2.0)
        vehicleSpeed: 0.8,         // 타일/초
        laneOffset: 0.1,           // 2차선 도로 차선 오프셋
        laneOffset4Lane: 0.35,     // 4차선 도로 차선 오프셋 (더 넓음)
        speed4LaneMultiplier: 1.3, // 4차선 도로 속도 배율 (30% 빠름)
        stopDistance: 0.7,         // 정차 거리 (더 증가)
        minVehicleGap: 0.35,       // 최소 차간 거리 (증가)
    };

    // ===== 차량 종류 설정 =====
    const VEHICLE_TYPES = {
        // 트럭 - 공업지구 전용 (공장↔공장, 시외↔공장)
        truck: {
            name: '수송 트럭',
            icon: '🚚',
            models: [
                '/models/transport_truck.glb',
                '/models/transport_truck.001.glb',
                '/models/transport_truck.002.glb',
                '/models/transport_truck.003.glb',
                '/models/transport_truck.004.glb',
                '/models/transport_truck.005.glb',
                '/models/transport_truck.006.glb',
                '/models/transport_truck.007.glb',
                '/models/transport_truck.008.glb',
                '/models/transport_truck.009.glb',
            ],
            activities: [
                '공장으로 자재를 운송 중 🏭',
                '공장 간 물자 이동 중 📦',
                '시외에서 원자재 운반 중 🚚',
                '완제품을 출하하는 중 📮',
                '산업단지로 배송 중 🔧',
            ],
            routes: ['industrial_only'],  // 공업지구 전용
            weight: 1.5,
            speedMultiplier: 0.8,
            hasHeadlight: false,
            length: 0.4,  // 차량 길이 (타일 단위)
        },
        // 버스 - 대중교통
        bus: {
            name: '시내버스',
            icon: '🚌',
            models: [
                '/models/transport_bus.006.glb',
            ],
            activities: [
                '승객을 태우고 가요 🚌',
                '다음 정류장으로 이동 중 🚏',
                '시내 순환 노선 운행 중 🛤️',
                '출퇴근 승객을 태우는 중 👥',
            ],
            routes: ['any'],
            weight: 0,  // 상시 스폰 비활성화
            speedMultiplier: 0.7,
            hasHeadlight: false,
            length: 0.5,  // 차량 길이 (타일 단위)
        },
        // 스쿨버스
        schoolbus: {
            name: '스쿨버스',
            icon: '🚐',
            models: [
                '/models/transport_bus.001.glb',
            ],
            activities: [
                '등교하는 학생들을 태우고 가요 📚',
                '하교하는 학생들을 데려다줘요 🎒',
                '학교로 가는 중이에요 🏫',
            ],
            routes: ['residential'],
            weight: 0,  // 상시 스폰 비활성화
            speedMultiplier: 0.6,
            hasHeadlight: false,
            length: 0.45,  // 차량 길이 (타일 단위)
        },
        // 캠핑카 - 승용차 계열
        camper: {
            name: '캠핑카',
            icon: '🚐',
            models: [
                '/models/transport_bus.glb',
                '/models/transport_bus.002.glb',
                '/models/transport_bus.003.glb',
                '/models/transport_bus.004.glb',
                '/models/transport_bus.005.glb',
            ],
            activities: [
                '가족과 캠핑 여행 중! ⛺',
                '주말 여행 가는 길 🏕️',
                '자연 속으로 떠나요 🌲',
                '캠핑장으로 가는 중 🔥',
            ],
            routes: ['residential'],
            weight: 0.15,
            speedMultiplier: 0.75,
            hasHeadlight: true,
            length: 0.4,  // 차량 길이 (타일 단위)
        },
        // 고급 세단 - 승용차
        cool: {
            name: '고급 세단',
            icon: '🚗',
            models: [
                '/models/transport_cool.glb',
                '/models/transport_cool.001.glb',
                '/models/transport_cool.002.glb',
                '/models/transport_cool.003.glb',
                '/models/transport_cool.004.glb',
                '/models/transport_cool.005.glb',
                '/models/transport_cool.006.glb',
                '/models/transport_cool.007.glb',
                '/models/transport_cool.008.glb',
                '/models/transport_cool.009.glb',
            ],
            activities: [
                '비즈니스 미팅에 가요 💼',
                'VIP 고객 방문 중 👔',
                '중요한 약속이 있어요 📋',
                '골프장으로 가는 길 ⛳',
            ],
            routes: ['commercial'],
            weight: 0.4,
            speedMultiplier: 1.0,
            hasHeadlight: true,
            length: 0.25,  // 차량 길이 (타일 단위)
        },
        // SUV - 승용차
        jeep: {
            name: 'SUV',
            icon: '🚙',
            models: [
                '/models/transport_jeep.glb',
                '/models/transport_jeep.001.glb',
                '/models/transport_jeep.002.glb',
                '/models/transport_jeep.003.glb',
                '/models/transport_jeep.004.glb',
                '/models/transport_jeep.005.glb',
                '/models/transport_jeep.006.glb',
                '/models/transport_jeep.007.glb',
                '/models/transport_jeep.008.glb',
                '/models/transport_jeep.009.glb',
            ],
            activities: [
                '드라이브 중이에요 🛣️',
                '아이들을 학교에 데려다줘요 🏫',
                '대형마트에 장보러 가요 🛒',
                '주말 나들이 가는 중 🌳',
            ],
            routes: ['any'],
            weight: 0.8,
            speedMultiplier: 0.9,
            hasHeadlight: true,
            length: 0.3,  // 차량 길이 (타일 단위)
        },
        // 패밀리카 - 승용차
        old: {
            name: '패밀리카',
            icon: '🚗',
            models: [
                '/models/transport_old.glb',
                '/models/transport_old.001.glb',
                '/models/transport_old.002.glb',
                '/models/transport_old.003.glb',
                '/models/transport_old.004.glb',
                '/models/transport_old.005.glb',
                '/models/transport_old.006.glb',
                '/models/transport_old.007.glb',
                '/models/transport_old.008.glb',
                '/models/transport_old.009.glb',
            ],
            activities: [
                '가족과 외출 중 👨‍👩‍👧‍👦',
                '아이들 학원 데려다주는 중 📖',
                '마트에 장보러 가요 🥬',
                '친척집 방문 가는 길 🏠',
                '주말 가족 나들이 🌸',
            ],
            routes: ['residential'],
            weight: 1.0,
            speedMultiplier: 0.85,
            hasHeadlight: true,
            length: 0.25,  // 차량 길이 (타일 단위)
        },
        // 스포츠카 - 승용차
        sport: {
            name: '스포츠카',
            icon: '🏎️',
            models: [
                '/models/transport_sport.glb',
                '/models/transport_sport.001.glb',
                '/models/transport_sport.002.glb',
                '/models/transport_sport.003.glb',
                '/models/transport_sport.004.glb',
                '/models/transport_sport.005.glb',
                '/models/transport_sport.006.glb',
                '/models/transport_sport.007.glb',
                '/models/transport_sport.008.glb',
                '/models/transport_sport.009.glb',
            ],
            activities: [
                '드라이브 즐기는 중 🏎️',
                '달리기 좋은 날이에요! 🌤️',
                '클럽 미팅 가는 길 🎵',
                '차 좀 굴리러 나왔어요 😎',
            ],
            routes: ['any'],
            weight: 0.25,
            speedMultiplier: 1.2,
            hasHeadlight: true,
            length: 0.22,  // 차량 길이 (타일 단위)
        },
        // 택시 - 승용차
        taxi: {
            name: '택시',
            icon: '🚕',
            models: [
                '/models/transport_purpose.003.glb',
                '/models/transport_purpose.004.glb',
            ],
            activities: [
                '승객을 목적지로 모시는 중 🚕',
                '콜을 받고 이동 중 📱',
                '손님을 기다리며 이동 중 🚖',
            ],
            routes: ['any'],
            weight: 0.5,
            speedMultiplier: 1.0,
            hasHeadlight: true,
            length: 0.25,  // 차량 길이 (타일 단위)
        },
        // 경찰차
        police: {
            name: '경찰차',
            icon: '🚓',
            models: [
                '/models/transport_purpose.002.glb',
            ],
            activities: [
                '순찰 중이에요 🚔',
                '시내를 순찰하고 있어요 👮',
                '출동 중입니다 🚨',
            ],
            routes: ['any'],
            weight: 0,  // 상시 스폰 비활성화 (출동 시에만 스폰)
            speedMultiplier: 1.1,
            hasHeadlight: false,
            length: 0.28,  // 차량 길이 (타일 단위)
        },
        // 소방차
        firetruck: {
            name: '소방차',
            icon: '🚒',
            models: [
                '/models/transport_purpose.005.glb',
            ],
            activities: [
                '출동 중입니다! 🚒',
                '화재 현장으로 가는 중 🔥',
                '안전 점검 순찰 중 🧯',
            ],
            routes: ['any'],
            weight: 0,  // 상시 스폰 비활성화 (화재 출동 시에만 스폰)
            speedMultiplier: 1.15,
            hasHeadlight: false,
            length: 0.45,  // 차량 길이 (타일 단위)
        },
        // 구급차
        ambulance: {
            name: '구급차',
            icon: '🚑',
            models: [
                '/models/transport_purpose.006.glb',
            ],
            activities: [
                '환자를 이송 중입니다 🚑',
                '응급 출동 중! 🏥',
                '병원으로 가는 중 💉',
            ],
            routes: ['any'],
            weight: 0,  // 상시 스폰 비활성화 (응급 출동 시에만 스폰)
            speedMultiplier: 1.15,
            hasHeadlight: false,
            length: 0.35,  // 차량 길이 (타일 단위)
        },
        // 견인차
        wrecker: {
            name: '견인차',
            icon: '🚗',
            models: [
                '/models/transport_purpose.007.glb',
            ],
            activities: [
                '고장 차량 견인 중 🔧',
                '사고 현장으로 출동 중 🚨',
                '차량 이송 중이에요 🚛',
            ],
            routes: ['any'],
            weight: 0.08,
            speedMultiplier: 0.8,
            hasHeadlight: false,
            length: 0.38,  // 차량 길이 (타일 단위)
        },
    };

    // 시간대별 교통량 배수 계산
    function getTrafficMultiplier() {
        const hour = (timeState.gameTime / 3600) % 24;

        // 시간대별 교통량 (0.0 ~ 1.0)
        // 출근시간(7-9): 100%, 점심(12-13): 80%, 퇴근시간(17-19): 100%
        // 밤(22-5): 20%, 새벽(5-7): 40%
        if (hour >= 7 && hour < 9) return 1.0;      // 출근 러시아워
        if (hour >= 9 && hour < 12) return 0.7;     // 오전
        if (hour >= 12 && hour < 13) return 0.8;    // 점심
        if (hour >= 13 && hour < 17) return 0.7;    // 오후
        if (hour >= 17 && hour < 19) return 1.0;    // 퇴근 러시아워
        if (hour >= 19 && hour < 22) return 0.5;    // 저녁
        if (hour >= 22 || hour < 5) return 0.2;     // 심야
        if (hour >= 5 && hour < 7) return 0.4;      // 새벽
        return 0.6;
    }

    // 인구 기반 최대 차량 수 계산 (시간대별 변동 적용)
    function getMaxVehicles() {
        const pop = cityStats.population || 0;
        const calculated = TRAFFIC_CONFIG.maxVehiclesBase + Math.floor(pop / TRAFFIC_CONFIG.vehiclesPerPopulation);
        const base = Math.min(TRAFFIC_CONFIG.maxVehiclesCap, calculated);
        // 시간대별 배수 적용
        return Math.max(5, Math.floor(base * getTrafficMultiplier()));
    }

    // ===== 차량 클래스 =====
    class Vehicle {
        constructor(type = 'car') {
            this.id = Math.random().toString(36).substr(2, 9);
            this.type = type;
            this.mesh = null;
            this.headlight = null;  // 헤드라이트 그룹
            this.spotLight = null;  // 헤드라이트 SpotLight
            this.position = new THREE.Vector3();
            this.visualPosition = new THREE.Vector3();  // 시각적 위치 (부드러운 보간용)
            this.visualRotation = 0;  // 시각적 회전 (부드러운 보간용)
            this.rotation = 0;
            this.currentTile = { x: 0, y: 0 };
            this.targetTile = { x: 0, y: 0 };
            this.progress = 0;
            this.path = [];
            this.pathIndex = 0;
            this.speed = TRAFFIC_CONFIG.vehicleSpeed;
            this.currentSpeed = 0;  // 현재 속도 (부드러운 가감속용)
            this.targetSpeed = TRAFFIC_CONFIG.vehicleSpeed;  // 목표 속도
            this.length = 0.25;  // 차량 길이 (기본값, 타일 단위)
            this.state = 'idle';  // idle, moving, waiting, despawning
            this.stopReason = '';  // 정차 이유: '', 'signal', 'vehicle'
            this.waitTimer = 0;
            this.isActive = false;
            this.visualInitialized = false;  // 시각적 위치 초기화 여부
        }

        reset() {
            this.path = [];
            this.pathIndex = 0;
            this.progress = 0;
            this.currentSpeed = 0;
            this.targetSpeed = TRAFFIC_CONFIG.vehicleSpeed;
            this.state = 'idle';
            this.stopReason = '';
            this.waitTimer = 0;
            this.isActive = false;
            this.visualInitialized = false;
            this.enterProgress = 0;
            this.enterTarget = null;
            this.enterStart = null;
            this.enterStartScale = null;

            // 사이렌 라이트 제거 (긴급차량용)
            if (this.sirenLights && this.mesh) {
                this.mesh.remove(this.sirenLights);
                // 사이렌 라이트 머티리얼 정리
                this.sirenLights.traverse((child) => {
                    if (child.isLight) {
                        // PointLight는 dispose 불필요
                    } else if (child.isMesh && child.material) {
                        // MeshBasicMaterial/MeshStandardMaterial은 dispose
                        child.material.dispose();
                    }
                    if (child.geometry) {
                        child.geometry.dispose();
                    }
                });
                this.sirenLights = null;
            }

            if (this.mesh) {
                this.mesh.visible = false;
                this.mesh.scale.setScalar(1.0);  // 스케일 복구
            }
            if (this.headlight) this.headlight.visible = false;
        }
    }

    // ===== 도로 노드 클래스 =====
    class RoadNode {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.key = `${x},${y}`;
            this.neighbors = [];
            this.intersectionType = 'none';  // none, t, cross
            this.hasSignal = false;
            this.congestion = 0;
        }
    }

    // ===== 신호등 클래스 =====
    class TrafficSignal {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.phases = [];
            this.currentPhase = 0;
            this.timer = 0;
            this.greenDirections = [];
            this.mesh = null;
            this.setupPhases(type);
        }

        setupPhases(type) {
            const greenTime = TRAFFIC_CONFIG.signalGreenTime;
            const yellowTime = TRAFFIC_CONFIG.signalYellowTime;
            if (type === 'cross') {
                this.phases = [
                    { directions: ['N', 'S'], duration: greenTime, yellow: yellowTime },
                    { directions: ['E', 'W'], duration: greenTime, yellow: yellowTime }
                ];
            } else {
                this.phases = [
                    { directions: ['N', 'S'], duration: greenTime, yellow: yellowTime },
                    { directions: ['E', 'W'], duration: greenTime / 2, yellow: yellowTime }
                ];
            }
            this.greenDirections = this.phases[0].directions;
        }

        update(dt) {
            this.timer += dt;
            const phase = this.phases[this.currentPhase];
            if (this.timer >= phase.duration + phase.yellow) {
                this.timer = 0;
                this.currentPhase = (this.currentPhase + 1) % this.phases.length;
                this.greenDirections = this.phases[this.currentPhase].directions;
            }
        }

        isGreen(direction) {
            return this.greenDirections.includes(direction);
        }
    }

    // ===== 우선순위 큐 (A* 용) =====
    class PriorityQueue {
        constructor() {
            this.heap = [];
        }
        push(item) {
            this.heap.push(item);
            this._bubbleUp(this.heap.length - 1);
        }
        pop() {
            if (this.heap.length === 0) return null;
            const result = this.heap[0];
            const end = this.heap.pop();
            if (this.heap.length > 0) {
                this.heap[0] = end;
                this._sinkDown(0);
            }
            return result;
        }
        isEmpty() { return this.heap.length === 0; }
        _bubbleUp(idx) {
            while (idx > 0) {
                const parent = Math.floor((idx - 1) / 2);
                if (this.heap[idx].f >= this.heap[parent].f) break;
                [this.heap[idx], this.heap[parent]] = [this.heap[parent], this.heap[idx]];
                idx = parent;
            }
        }
        _sinkDown(idx) {
            const len = this.heap.length;
            while (true) {
                const left = 2 * idx + 1, right = 2 * idx + 2;
                let smallest = idx;
                if (left < len && this.heap[left].f < this.heap[smallest].f) smallest = left;
                if (right < len && this.heap[right].f < this.heap[smallest].f) smallest = right;
                if (smallest === idx) break;
                [this.heap[idx], this.heap[smallest]] = [this.heap[smallest], this.heap[idx]];
                idx = smallest;
            }
        }
    }

    // ===== 교통 관리자 =====
    const trafficManager = {
        // 상태
        initialized: false,
        roadNetwork: new Map(),
        vehicles: [],
        vehiclePool: [],
        activeCount: 0,
        signals: new Map(),
        congestionMap: new Map(),
        pathCache: new Map(),

        // 공간 분할 시스템 (충돌 검사 최적화)
        spatialGrid: new Map(),  // "cellX,cellY" -> Set of vehicles
        SPATIAL_CELL_SIZE: 2.0,  // 셀 크기 (타일 단위)

        // Three.js 그룹
        vehicleGroup: new THREE.Group(),
        signalGroup: new THREE.Group(),

        // 차량 프리팹
        vehiclePrefabs: [],

        // 건물 분류
        residentialBuildings: [],
        commercialBuildings: [],
        industrialBuildings: [],

        // 타이머
        spawnTimer: 0,
        lastUpdate: 0,

        // 스폰 대기열 시스템 (외곽 진입점 차량 겹침 방지)
        spawnQueue: [],
        isProcessingSpawnQueue: false,
        SPAWN_QUEUE_INTERVAL: 800,  // 차량 간 스폰 간격 (0.8초)

        // 초기화
        async init() {
            if (this.initialized) return;

            try {
                scene.add(this.vehicleGroup);

                await this.loadVehicleModels();
                this.buildRoadNetwork();
                this.categorizeBuildings();
                this.initVehiclePool();

                // lastUpdate 초기화 (첫 프레임 dt 정상화)
                this.lastUpdate = performance.now();

                this.initialized = true;
                console.log('Traffic system initialized');
                console.log(`Buildings - Residential: ${this.residentialBuildings.length}, Commercial: ${this.commercialBuildings.length}, Industrial: ${this.industrialBuildings.length}`);

                // 초기 차량 스폰 (즉시 몇 대 배치)
                this.spawnInitialVehicles();
            } catch (e) {
                console.error('Traffic system init failed:', e);
            }
        },

        // 차량 모델 로드 (타임아웃 포함) - 종류별로 로드
        async loadVehicleModels() {
            // 차량 종류별 프리팹 저장소
            this.vehiclePrefabsByType = {};

            const loadWithTimeout = (path, timeout = 5000) => {
                return new Promise((resolve, reject) => {
                    const timer = setTimeout(() => reject(new Error('Timeout')), timeout);
                    loader.load(path,
                        (gltf) => { clearTimeout(timer); resolve(gltf); },
                        undefined,
                        (err) => { clearTimeout(timer); reject(err); }
                    );
                });
            };

            const createVehiclePrefab = (gltf, scale = 0.12) => {
                const wrapper = new THREE.Group();
                const inner = gltf.scene.clone();
                inner.scale.setScalar(scale);
                inner.rotation.set(0, Math.PI, 0);
                inner.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        const convertMaterial = (mat) => {
                            return new THREE.MeshLambertMaterial({
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
                                map: mat.map || null,
                                transparent: mat.transparent || false,
                                opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                side: mat.side !== undefined ? mat.side : THREE.FrontSide,
                            });
                        };
                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(m => convertMaterial(m));
                        } else {
                            child.material = convertMaterial(child.material);
                        }
                    }
                });
                wrapper.add(inner);
                return wrapper;
            };

            // 각 차량 종류별로 모델 로드
            for (const [typeKey, typeConfig] of Object.entries(VEHICLE_TYPES)) {
                this.vehiclePrefabsByType[typeKey] = [];

                // 차량 크기 설정 (모든 차량 승용차 크기로 통일)
                const scale = 0.12;

                for (const path of typeConfig.models) {
                    try {
                        const gltf = await loadWithTimeout(path);
                        const prefab = createVehiclePrefab(gltf, scale);
                        this.vehiclePrefabsByType[typeKey].push(prefab);
                        // 하위 호환을 위해 기존 배열에도 추가
                        this.vehiclePrefabs.push(prefab);
                    } catch (e) {
                        console.warn(`Failed to load vehicle ${typeKey}:`, path);
                    }
                }

                if (this.vehiclePrefabsByType[typeKey].length > 0) {
                    console.log(`Loaded ${this.vehiclePrefabsByType[typeKey].length} models for ${typeKey}`);
                }
            }

            // 폴백 박스 모델
            if (this.vehiclePrefabs.length === 0) {
                const geo = new THREE.BoxGeometry(0.3, 0.15, 0.5);
                const mat = new THREE.MeshStandardMaterial({ color: 0x3366cc });
                const box = new THREE.Mesh(geo, mat);
                box.position.y = 0.075;
                const group = new THREE.Group();
                group.add(box);
                this.vehiclePrefabs.push(group);
                this.vehiclePrefabsByType['fallback'] = [group];
            }

            console.log(`Loaded ${this.vehiclePrefabs.length} vehicle models`);
        },

        // 도로 네트워크 구축
        buildRoadNetwork() {
            this.roadNetwork.clear();

            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    if (!isRoad(x, y)) continue;

                    const node = new RoadNode(x, y);
                    const directions = [
                        { dir: 'N', dx: 0, dy: -1 },
                        { dir: 'E', dx: 1, dy: 0 },
                        { dir: 'S', dx: 0, dy: 1 },
                        { dir: 'W', dx: -1, dy: 0 }
                    ];

                    for (const { dir, dx, dy } of directions) {
                        const nx = x + dx, ny = y + dy;
                        if (inBounds(nx, ny) && isRoad(nx, ny)) {
                            node.neighbors.push({ x: nx, y: ny, dir });
                        }
                    }

                    // 교차로 타입 결정
                    const count = node.neighbors.length;
                    if (count === 4) node.intersectionType = 'cross';
                    else if (count === 3) node.intersectionType = 't';

                    this.roadNetwork.set(node.key, node);
                }
            }

            console.log(`Road network built: ${this.roadNetwork.size} nodes`);
        },

        // === 공간 분할 시스템 (충돌 검사 최적화) ===
        // 월드 좌표를 공간 분할 셀 키로 변환
        getSpatialCellKey(x, z) {
            const cellX = Math.floor(x / this.SPATIAL_CELL_SIZE);
            const cellZ = Math.floor(z / this.SPATIAL_CELL_SIZE);
            return `${cellX},${cellZ}`;
        },

        // 차량을 공간 분할 그리드에 등록
        addToSpatialGrid(vehicle) {
            const key = this.getSpatialCellKey(vehicle.position.x, vehicle.position.z);
            if (!this.spatialGrid.has(key)) {
                this.spatialGrid.set(key, new Set());
            }
            this.spatialGrid.get(key).add(vehicle);
            vehicle._spatialKey = key;
        },

        // 차량을 공간 분할 그리드에서 제거
        removeFromSpatialGrid(vehicle) {
            if (vehicle._spatialKey && this.spatialGrid.has(vehicle._spatialKey)) {
                this.spatialGrid.get(vehicle._spatialKey).delete(vehicle);
            }
            vehicle._spatialKey = null;
        },

        // 차량 위치 업데이트 시 공간 분할 그리드 갱신
        updateSpatialGrid(vehicle) {
            const newKey = this.getSpatialCellKey(vehicle.position.x, vehicle.position.z);
            if (vehicle._spatialKey !== newKey) {
                this.removeFromSpatialGrid(vehicle);
                this.addToSpatialGrid(vehicle);
            }
        },

        // 주변 셀의 차량들 가져오기 (9개 셀: 현재 + 8방향 인접)
        getNearbyVehicles(x, z) {
            const cellX = Math.floor(x / this.SPATIAL_CELL_SIZE);
            const cellZ = Math.floor(z / this.SPATIAL_CELL_SIZE);
            const nearby = [];

            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const key = `${cellX + dx},${cellZ + dz}`;
                    if (this.spatialGrid.has(key)) {
                        for (const v of this.spatialGrid.get(key)) {
                            nearby.push(v);
                        }
                    }
                }
            }
            return nearby;
        },

        // 신호등 설치
        setupSignals() {
            this.signals.clear();
            while (this.signalGroup.children.length > 0) {
                this.signalGroup.remove(this.signalGroup.children[0]);
            }

            for (const [key, node] of this.roadNetwork) {
                if (node.intersectionType !== 'none') {
                    node.hasSignal = true;
                    const signal = new TrafficSignal(node.x, node.y, node.intersectionType);
                    // 신호등 메쉬는 설정에 따라 표시
                    if (TRAFFIC_CONFIG.showSignals) {
                        signal.mesh = this.createSignalMesh(node.x, node.y);
                        this.signalGroup.add(signal.mesh);
                    }
                    this.signals.set(key, signal);
                }
            }

            console.log(`Traffic signals: ${this.signals.size}`);
        },

        // 신호등 메쉬 생성 (교차로 4방향에 신호등 배치)
        createSignalMesh(x, y) {
            const group = new THREE.Group();
            const worldPos = tileToWorldCenter(x, y);

            // 신호등 하나 생성 함수
            const createSingleSignal = (offsetX, offsetZ, rotation, dirName) => {
                const signalGroup = new THREE.Group();

                // 기둥
                const postGeo = new THREE.CylinderGeometry(0.015, 0.02, 0.5, 6);
                const postMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5 });
                const post = new THREE.Mesh(postGeo, postMat);
                post.position.y = 0.25;
                post.castShadow = true;
                signalGroup.add(post);

                // 신호등 박스
                const boxGeo = new THREE.BoxGeometry(0.05, 0.1, 0.03);
                const boxMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.3 });
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.y = 0.55;
                box.castShadow = true;
                signalGroup.add(box);

                // 빨간불
                const lightGeo = new THREE.SphereGeometry(0.015, 8, 8);
                const redMat = new THREE.MeshStandardMaterial({
                    color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3
                });
                const redLight = new THREE.Mesh(lightGeo, redMat);
                redLight.position.set(0, 0.58, 0.018);
                redLight.name = 'red_' + dirName;
                signalGroup.add(redLight);

                // 초록불
                const greenMat = new THREE.MeshStandardMaterial({
                    color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.8
                });
                const greenLight = new THREE.Mesh(lightGeo, greenMat);
                greenLight.position.set(0, 0.52, 0.018);
                greenLight.name = 'green_' + dirName;
                signalGroup.add(greenLight);

                signalGroup.position.set(offsetX, 0, offsetZ);
                signalGroup.rotation.y = rotation;
                return signalGroup;
            };

            // 교차로 각 코너에 신호등 배치 (도로 진행 방향을 바라보도록)
            // 북쪽에서 오는 차량용 (남쪽 코너에 배치, 북쪽을 바라봄)
            group.add(createSingleSignal(0.35, 0.35, 0, 'S'));
            // 남쪽에서 오는 차량용 (북쪽 코너에 배치, 남쪽을 바라봄)
            group.add(createSingleSignal(-0.35, -0.35, Math.PI, 'N'));
            // 동쪽에서 오는 차량용 (서쪽 코너에 배치, 동쪽을 바라봄)
            group.add(createSingleSignal(-0.35, 0.35, Math.PI / 2, 'W'));
            // 서쪽에서 오는 차량용 (동쪽 코너에 배치, 서쪽을 바라봄)
            group.add(createSingleSignal(0.35, -0.35, -Math.PI / 2, 'E'));

            group.position.set(worldPos.x, 0, worldPos.z);

            // 방향별 신호등 참조 저장
            group.userData.signalLights = {
                N: { red: group.getObjectByName('red_N'), green: group.getObjectByName('green_N') },
                S: { red: group.getObjectByName('red_S'), green: group.getObjectByName('green_S') },
                E: { red: group.getObjectByName('red_E'), green: group.getObjectByName('green_E') },
                W: { red: group.getObjectByName('red_W'), green: group.getObjectByName('green_W') }
            };

            return group;
        },

        // 건물 분류
        categorizeBuildings() {
            this.residentialBuildings = [];
            this.commercialBuildings = [];
            this.industrialBuildings = [];

            buildingGroup.children.forEach(building => {
                if (!building.userData?.zoneType) return;
                const data = {
                    x: building.userData.tileX,
                    y: building.userData.tileY,
                    obj: building,
                    type: building.userData.zoneType
                };
                if (building.userData.zoneType.includes('residential')) {
                    this.residentialBuildings.push(data);
                } else if (building.userData.zoneType.includes('commercial')) {
                    this.commercialBuildings.push(data);
                } else if (building.userData.zoneType.includes('industrial')) {
                    this.industrialBuildings.push(data);
                }
            });
        },

        // 시민 활동 메시지 생성 (출발지/목적지 기반)
        generateActivity(originType, destType) {
            const activities = {
                // 주거 → 상업
                'residential_commercial': [
                    '쇼핑하러 가요! 🛒',
                    '마트에 장보러 가는 중 🥬',
                    '카페에서 친구 만나요 ☕',
                    '맛집 탐방 중! 🍽️',
                    '영화 보러 가요 🎬',
                    '백화점 구경 가요 🏬',
                ],
                // 주거 → 공업
                'residential_industrial': [
                    '출근 중이에요 💼',
                    '회사 가는 길이에요 🏢',
                    '열심히 일하러! 💪',
                    '오늘도 화이팅! 🔧',
                    '야근하러 가요... 😅',
                ],
                // 주거 → 주거
                'residential_residential': [
                    '친구 집에 놀러가요! 🏠',
                    '가족 방문 중 👨‍👩‍👧',
                    '이웃집에 심부름 📦',
                    '집들이 가는 길 🎁',
                    '반려동물 산책 중 🐕',
                ],
                // 상업 → 주거
                'commercial_residential': [
                    '쇼핑 끝! 집에 가요 🏡',
                    '퇴근하고 집으로~ 🚗',
                    '장 봤어요, 귀가 중 🛍️',
                ],
                // 공업 → 주거
                'industrial_residential': [
                    '퇴근이다! 🎉',
                    '오늘 하루도 수고! 🌙',
                    '집에 가서 쉬어야지 😴',
                    '야근 끝! 빨리 집에... 🏃',
                ],
                // 상업 → 상업
                'commercial_commercial': [
                    '다른 가게 구경 가요 🏪',
                    '배달 중이에요 📦',
                    '비즈니스 미팅 중 💼',
                ],
                // 공업 → 공업
                'industrial_industrial': [
                    '다른 공장으로 출장 🏭',
                    '자재 운반 중 🚚',
                    '현장 점검 가요 🔍',
                ],
                // 상업 → 공업
                'commercial_industrial': [
                    '납품하러 가는 중 📦',
                    '거래처 방문 중 🤝',
                ],
                // 공업 → 상업
                'industrial_commercial': [
                    '점심 먹으러! 🍱',
                    '잠깐 휴식~ ☕',
                    '업무용품 사러 가요 📎',
                ],
            };

            const key = `${originType}_${destType}`;
            const messages = activities[key] || ['드라이브 중 🚗'];
            return messages[Math.floor(Math.random() * messages.length)];
        },

        // 건물 타입 문자열 반환
        getBuildingTypeName(type) {
            if (!type) return '도로';
            if (type.includes('residential')) return '주거지';
            if (type.includes('commercial')) return '상업지구';
            if (type.includes('industrial')) return '공업지구';
            return '건물';
        },

        // 경로 유형에 맞는 차량 종류 선택
        selectVehicleType(originType, destType) {
            const candidates = [];

            // 경로 유형에 맞는 차량 종류 추가
            for (const [typeKey, typeConfig] of Object.entries(VEHICLE_TYPES)) {
                const routes = typeConfig.routes;
                let weight = typeConfig.weight;

                // industrial_only: 출발/도착 모두 공업지구일 때만
                if (routes.includes('industrial_only')) {
                    if (originType === 'industrial' && destType === 'industrial') {
                        candidates.push({ type: typeKey, weight: weight * 3.0 });  // 높은 가중치
                    }
                    continue;  // 다른 조건은 체크하지 않음
                }

                // 일반 경로 적합성 체크
                if (routes.includes('any')) {
                    candidates.push({ type: typeKey, weight });
                } else if (routes.includes(originType) || routes.includes(destType)) {
                    candidates.push({ type: typeKey, weight: weight * 1.5 });
                }
            }

            // 기본 폴백
            if (candidates.length === 0) {
                candidates.push({ type: 'old', weight: 1.0 });
            }

            // 가중치 기반 랜덤 선택
            const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
            let random = Math.random() * totalWeight;

            for (const candidate of candidates) {
                random -= candidate.weight;
                if (random <= 0) {
                    return candidate.type;
                }
            }

            return candidates[0].type;
        },

        // 차량 종류에 맞는 메쉬 생성
        createVehicleMesh(vehicleType) {
            const prefabs = this.vehiclePrefabsByType[vehicleType];
            if (!prefabs || prefabs.length === 0) {
                // 폴백: 기존 프리팹 사용
                const idx = Math.floor(Math.random() * this.vehiclePrefabs.length);
                return this.vehiclePrefabs[idx].clone();
            }

            const idx = Math.floor(Math.random() * prefabs.length);
            return prefabs[idx].clone();
        },

        // 헤드라이트용 공유 지오메트리/머티리얼 (성능 최적화 - 메모리 절약)
        // SpotLight 추가 - 실제 조명 효과
        headlightSharedResources: null,
        getHeadlightResources() {
            if (!this.headlightSharedResources) {
                this.headlightSharedResources = {
                    bulbGeo: new THREE.SphereGeometry(0.025, 6, 6),
                    // emissive 머티리얼로 발광 효과 구현
                    bulbMat: new THREE.MeshStandardMaterial({
                        color: 0xffffcc,
                        emissive: 0xffffaa,
                        emissiveIntensity: 3.0
                    })
                };
            }
            return this.headlightSharedResources;
        },

        // 차량 풀 초기화
        initVehiclePool() {
            // 공유 리소스 미리 생성
            const hlRes = this.getHeadlightResources();

            for (let i = 0; i < TRAFFIC_CONFIG.maxVehiclesCap; i++) {
                const vehicle = new Vehicle('car');

                // 초기 메쉬는 기본 차량으로 (스폰 시 교체됨)
                const prefabIdx = Math.floor(Math.random() * this.vehiclePrefabs.length);
                vehicle.mesh = this.vehiclePrefabs[prefabIdx].clone();
                vehicle.mesh.visible = false;
                vehicle.vehicleTypeKey = 'old';  // 기본 타입

                // 헤드라이트 추가 (SpotLight + emissive 구체)
                const headlightGroup = new THREE.Group();

                // 헤드라이트 발광 구체 (공유 리소스 - emissive 머티리얼)
                const leftBulb = new THREE.Mesh(hlRes.bulbGeo, hlRes.bulbMat);
                leftBulb.position.set(-0.03, 0.03, 0.08);
                const rightBulb = new THREE.Mesh(hlRes.bulbGeo, hlRes.bulbMat);
                rightBulb.position.set(0.03, 0.03, 0.08);
                headlightGroup.add(leftBulb);
                headlightGroup.add(rightBulb);

                // SpotLight 추가 (중앙 하나만 - 성능 최적화)
                const spotLight = new THREE.SpotLight(0xffffcc, 0.6, 2.5, Math.PI / 6, 0.3, 1);
                spotLight.position.set(0, 0.04, 0.1);
                spotLight.target.position.set(0, 0, 1);  // 전방 조준
                spotLight.castShadow = false;  // 그림자 비활성화 (성능)
                headlightGroup.add(spotLight);
                headlightGroup.add(spotLight.target);
                vehicle.spotLight = spotLight;  // 참조 저장

                headlightGroup.visible = false;  // 낮에는 끔
                vehicle.mesh.add(headlightGroup);
                vehicle.headlight = headlightGroup;

                // 원본 머티리얼 저장 (zone 모드 복구용)
                vehicle.originalMaterials = new Map();
                vehicle.mesh.traverse((child) => {
                    if (child.isMesh && child.material) {
                        vehicle.originalMaterials.set(child.uuid, child.material);
                    }
                });

                this.vehicleGroup.add(vehicle.mesh);
                this.vehiclePool.push(vehicle);
                this.vehicles.push(vehicle);
            }
            console.log(`Vehicle pool initialized: ${this.vehiclePool.length}`);
        },

        // 풀에서 차량 가져오기
        getFromPool() {
            for (const v of this.vehiclePool) {
                if (!v.isActive) return v;
            }
            return null;
        },

        // A* 경로탐색 (최적화)
        findPath(startX, startY, endX, endY) {
            const cacheKey = `${startX},${startY}-${endX},${endY}`;
            // 캐시 사용 안 함 (다양한 경로 위해)
            // 대신 간단한 5초 캐시
            const cached = this.pathCache.get(cacheKey);
            if (cached && Date.now() - cached.time < 5000) {
                return [...cached.path];
            }

            const startKey = `${startX},${startY}`;
            const endKey = `${endX},${endY}`;
            if (!this.roadNetwork.has(startKey) || !this.roadNetwork.has(endKey)) {
                return null;
            }

            const openSet = new PriorityQueue();
            const closedSet = new Set();  // 방문 완료 노드
            const gScore = new Map();
            const cameFrom = new Map();

            // 랜덤 시드 (같은 출발/도착이어도 다른 경로)
            const randomSeed = Math.random() * 0.5;

            gScore.set(startKey, 0);
            openSet.push({ key: startKey, x: startX, y: startY, f: this.heuristic(startX, startY, endX, endY) });

            let iterations = 0;
            const maxIterations = 1000;  // 무한루프 방지

            while (!openSet.isEmpty() && iterations < maxIterations) {
                iterations++;
                const current = openSet.pop();

                // 이미 방문한 노드면 스킵
                if (closedSet.has(current.key)) continue;
                closedSet.add(current.key);

                if (current.key === endKey) {
                    const path = this.reconstructPath(cameFrom, current);
                    this.pathCache.set(cacheKey, { path: [...path], time: Date.now() });
                    return path;
                }

                const node = this.roadNetwork.get(current.key);
                if (!node) continue;

                for (const neighbor of node.neighbors) {
                    const nKey = `${neighbor.x},${neighbor.y}`;
                    if (closedSet.has(nKey)) continue;  // 이미 방문한 노드 스킵

                    // 혼잡도 기반 비용 + 약간의 랜덤
                    const congestion = this.congestionMap.get(nKey) || 0;
                    const moveCost = 1 + congestion * 2 + Math.random() * randomSeed;
                    const tentativeG = gScore.get(current.key) + moveCost;

                    if (tentativeG < (gScore.get(nKey) || Infinity)) {
                        cameFrom.set(nKey, current.key);
                        gScore.set(nKey, tentativeG);
                        const f = tentativeG + this.heuristic(neighbor.x, neighbor.y, endX, endY);
                        openSet.push({ key: nKey, x: neighbor.x, y: neighbor.y, f });
                    }
                }
            }
            return null;
        },

        heuristic(x1, y1, x2, y2) {
            return Math.abs(x2 - x1) + Math.abs(y2 - y1);
        },

        reconstructPath(cameFrom, current) {
            const path = [];
            let key = current.key;
            while (key) {
                const [x, y] = key.split(',').map(Number);
                path.unshift({ x, y });
                key = cameFrom.get(key);
            }
            return path;
        },

        // 가장 가까운 도로 찾기
        findNearestRoad(tileX, tileY) {
            const queue = [{ x: tileX, y: tileY }];
            const visited = new Set([`${tileX},${tileY}`]);

            while (queue.length > 0) {
                const curr = queue.shift();
                if (isRoad(curr.x, curr.y)) {
                    return curr;
                }
                const neighbors = [
                    { x: curr.x - 1, y: curr.y },
                    { x: curr.x + 1, y: curr.y },
                    { x: curr.x, y: curr.y - 1 },
                    { x: curr.x, y: curr.y + 1 }
                ];
                for (const n of neighbors) {
                    const key = `${n.x},${n.y}`;
                    if (!visited.has(key) && inBounds(n.x, n.y)) {
                        visited.add(key);
                        queue.push(n);
                    }
                }
            }
            return null;
        },

        // 스폰 위치에 차량이 있는지 체크
        isSpawnBlocked(x, y) {
            for (const v of this.vehicles) {
                if (!v.isActive) continue;
                if (v.currentTile.x === x && v.currentTile.y === y) return true;
                if (v.targetTile.x === x && v.targetTile.y === y && v.progress < 0.3) return true;
            }
            return false;
        },

        // 차량 스폰 시도
        trySpawnVehicle() {
            // 스폰 비활성화 체크
            if (typeof vehicleSpawnEnabled !== 'undefined' && !vehicleSpawnEnabled) {
                return;
            }
            if (this.activeCount >= getMaxVehicles()) {
                return;
            }

            // 50% 확률로 랜덤 스폰 (다양성 증가)
            if (Math.random() < 0.5 || this.residentialBuildings.length === 0) {
                if (this.roadNetwork.size > 5) {
                    this.tryRandomSpawn();
                }
                return;
            }

            // 여러 번 시도
            for (let attempt = 0; attempt < 5; attempt++) {
                // 모든 건물 중에서 출발지 선택
                const allBuildings = [
                    ...this.residentialBuildings,
                    ...this.commercialBuildings,
                    ...this.industrialBuildings
                ];
                if (allBuildings.length < 2) continue;

                const originIdx = Math.floor(Math.random() * allBuildings.length);
                const origin = allBuildings[originIdx];

                // 목적지 선택 (다른 건물)
                let destination;
                const roll = Math.random();

                // 출발지 타입에 따른 목적지 선택 확률 조정
                const isOriginResidential = origin.type?.includes('residential');
                const isOriginCommercial = origin.type?.includes('commercial');
                const isOriginIndustrial = origin.type?.includes('industrial');

                if (isOriginResidential) {
                    // 주거 → 상업(40%) / 공업(40%) / 다른 주거(20%)
                    if (roll < 0.4 && this.commercialBuildings.length > 0) {
                        destination = this.commercialBuildings[
                            Math.floor(Math.random() * this.commercialBuildings.length)
                        ];
                    } else if (roll < 0.8 && this.industrialBuildings.length > 0) {
                        destination = this.industrialBuildings[
                            Math.floor(Math.random() * this.industrialBuildings.length)
                        ];
                    } else if (this.residentialBuildings.length > 1) {
                        let destIdx = Math.floor(Math.random() * this.residentialBuildings.length);
                        if (this.residentialBuildings[destIdx] === origin) {
                            destIdx = (destIdx + 1) % this.residentialBuildings.length;
                        }
                        destination = this.residentialBuildings[destIdx];
                    }
                } else if (isOriginCommercial || isOriginIndustrial) {
                    // 상업/공업 → 주거(70%) / 같은 타입(30%)
                    if (roll < 0.7 && this.residentialBuildings.length > 0) {
                        destination = this.residentialBuildings[
                            Math.floor(Math.random() * this.residentialBuildings.length)
                        ];
                    } else if (isOriginCommercial && this.commercialBuildings.length > 1) {
                        let destIdx = Math.floor(Math.random() * this.commercialBuildings.length);
                        if (this.commercialBuildings[destIdx] === origin) {
                            destIdx = (destIdx + 1) % this.commercialBuildings.length;
                        }
                        destination = this.commercialBuildings[destIdx];
                    } else if (isOriginIndustrial && this.industrialBuildings.length > 1) {
                        let destIdx = Math.floor(Math.random() * this.industrialBuildings.length);
                        if (this.industrialBuildings[destIdx] === origin) {
                            destIdx = (destIdx + 1) % this.industrialBuildings.length;
                        }
                        destination = this.industrialBuildings[destIdx];
                    }
                }

                // 목적지를 못 찾으면 아무 건물이나 선택
                if (!destination) {
                    let destIdx = Math.floor(Math.random() * allBuildings.length);
                    if (destIdx === originIdx) destIdx = (destIdx + 1) % allBuildings.length;
                    destination = allBuildings[destIdx];
                }
                if (!destination || destination === origin) continue;

                const originRoad = this.findNearestRoad(origin.x, origin.y);
                const destRoad = this.findNearestRoad(destination.x, destination.y);
                if (!originRoad || !destRoad) continue;
                if (originRoad.x === destRoad.x && originRoad.y === destRoad.y) continue;

                // 스폰 위치 혼잡도 및 차량 체크
                if (this.isSpawnBlocked(originRoad.x, originRoad.y)) continue;
                const spawnCongestion = this.congestionMap.get(`${originRoad.x},${originRoad.y}`) || 0;
                if (spawnCongestion > 0.6) continue;

                const path = this.findPath(originRoad.x, originRoad.y, destRoad.x, destRoad.y);
                if (!path || path.length < 3) continue;

                // 출발/도착 건물 정보와 함께 스폰
                this.spawnVehicle(path, origin, destination);
                return;
            }
        },

        // 초기 차량 스폰 (게임 시작 시 즉시 배치) - 건물 기반
        spawnInitialVehicles() {
            const maxVehicles = getMaxVehicles();
            const initialCount = Math.max(5, Math.floor(maxVehicles * 0.3));

            const allBuildings = [
                ...this.residentialBuildings,
                ...this.commercialBuildings,
                ...this.industrialBuildings
            ];

            if (allBuildings.length < 2) {
                console.log('Not enough buildings for initial spawn');
                return;
            }

            console.log(`Spawning ${initialCount} initial vehicles (building-based, staggered)...`);

            // 유효한 스폰 데이터 미리 수집
            const validSpawns = [];
            let attempts = 0;
            const maxAttempts = initialCount * 20;

            while (validSpawns.length < initialCount && attempts < maxAttempts) {
                attempts++;

                // 랜덤 출발/도착 건물 선택
                const originIdx = Math.floor(Math.random() * allBuildings.length);
                let destIdx = originIdx;

                for (let i = 0; i < 10; i++) {
                    destIdx = Math.floor(Math.random() * allBuildings.length);
                    if (destIdx !== originIdx) break;
                }

                if (originIdx === destIdx) continue;

                const origin = allBuildings[originIdx];
                const destination = allBuildings[destIdx];

                const originRoad = this.findNearestRoad(origin.x, origin.y);
                const destRoad = this.findNearestRoad(destination.x, destination.y);
                if (!originRoad || !destRoad) continue;
                if (originRoad.x === destRoad.x && originRoad.y === destRoad.y) continue;

                const path = this.findPath(originRoad.x, originRoad.y, destRoad.x, destRoad.y);
                if (!path || path.length < 2) continue;

                validSpawns.push({ path, origin, destination, originRoad });
            }

            // 스폰 데이터를 스태거드 방식으로 처리
            validSpawns.forEach((spawnData, index) => {
                const delay = index * 300;  // 각 차량 0.3초 간격
                setTimeout(() => {
                    // 스폰 비활성화 체크
                    if (typeof vehicleSpawnEnabled !== 'undefined' && !vehicleSpawnEnabled) return;
                    // 스폰 전 다시 블록 체크
                    if (!this.isSpawnBlocked(spawnData.originRoad.x, spawnData.originRoad.y)) {
                        this.spawnVehicle(spawnData.path, spawnData.origin, spawnData.destination);
                    }
                }, delay);
            });

            console.log(`Initial spawn queued: ${validSpawns.length} vehicles (staggered over ${validSpawns.length * 0.3}s)`);
        },

        // 랜덤 건물 간 스폰 (다양한 위치에서)
        tryRandomSpawn() {
            const allBuildings = [
                ...this.residentialBuildings,
                ...this.commercialBuildings,
                ...this.industrialBuildings
            ];
            if (allBuildings.length < 2) return;

            // 여러 번 시도
            for (let attempt = 0; attempt < 5; attempt++) {
                // 랜덤 출발/도착 건물 선택
                const originIdx = Math.floor(Math.random() * allBuildings.length);
                let destIdx = originIdx;

                for (let i = 0; i < 10; i++) {
                    destIdx = Math.floor(Math.random() * allBuildings.length);
                    if (destIdx !== originIdx) break;
                }

                if (originIdx === destIdx) continue;

                const origin = allBuildings[originIdx];
                const destination = allBuildings[destIdx];

                const originRoad = this.findNearestRoad(origin.x, origin.y);
                const destRoad = this.findNearestRoad(destination.x, destination.y);
                if (!originRoad || !destRoad) continue;
                if (originRoad.x === destRoad.x && originRoad.y === destRoad.y) continue;

                // 스폰 위치에 차량이 있는지 체크
                if (this.isSpawnBlocked(originRoad.x, originRoad.y)) continue;

                const path = this.findPath(originRoad.x, originRoad.y, destRoad.x, destRoad.y);
                if (!path || path.length < 3) continue;

                // 스폰 위치 혼잡도 체크
                const spawnCongestion = this.congestionMap.get(`${originRoad.x},${originRoad.y}`) || 0;
                if (spawnCongestion > 0.5) continue;

                this.spawnVehicle(path, origin, destination);
                return;
            }
        },

        // 차량 스폰 (출발/도착 건물 정보 포함)
        spawnVehicle(path, originBuilding = null, destBuilding = null) {
            const vehicle = this.getFromPool();
            if (!vehicle) {
                console.warn('No vehicle available in pool');
                return;
            }
            if (!vehicle.mesh) {
                console.warn('Vehicle has no mesh');
                return;
            }

            // 이전 사용에서 남은 특수 차량 속성 초기화
            vehicle.isFiretruck = false;
            vehicle.isPoliceCar = false;
            vehicle.isAmbulance = false;
            vehicle.isConstructionTruck = false;
            vehicle.isMoveInVehicle = false;
            vehicle.constructionSite = null;
            vehicle.fireTarget = null;
            vehicle.crimeTarget = null;
            vehicle.emergencyTarget = null;
            vehicle.isReturning = false;
            vehicle.originStation = null;
            vehicle.originHospital = null;
            vehicle.stationKey = null;
            vehicle.hospitalKey = null;
            vehicle.workStartTime = null;
            vehicle.isParked = false;

            vehicle.path = path;
            vehicle.pathIndex = 0;
            vehicle.progress = 0;
            vehicle.currentTile = { x: path[0].x, y: path[0].y };
            vehicle.targetTile = path.length > 1 ? { x: path[1].x, y: path[1].y } : vehicle.currentTile;

            // 출발/도착 건물 정보 저장
            vehicle.originBuilding = originBuilding;
            vehicle.destBuilding = destBuilding;

            // 출발지/목적지 타입 판별
            const originType = originBuilding?.type?.includes('residential') ? 'residential' :
                               originBuilding?.type?.includes('commercial') ? 'commercial' :
                               originBuilding?.type?.includes('industrial') ? 'industrial' : 'residential';
            const destType = destBuilding?.type?.includes('residential') ? 'residential' :
                             destBuilding?.type?.includes('commercial') ? 'commercial' :
                             destBuilding?.type?.includes('industrial') ? 'industrial' : 'residential';

            // 차량 종류 선택 (경로 유형 기반)
            const vehicleTypeKey = this.selectVehicleType(originType, destType);
            const vehicleTypeConfig = VEHICLE_TYPES[vehicleTypeKey];
            vehicle.vehicleTypeKey = vehicleTypeKey;
            vehicle.type = vehicleTypeKey;
            vehicle.length = vehicleTypeConfig?.length || 0.25;  // 차량 길이 저장

            // 차량 메쉬 교체 (종류에 맞게)
            const oldMesh = vehicle.mesh;
            const oldPosition = oldMesh.position.clone();
            const oldRotation = oldMesh.rotation.y;
            const headlight = vehicle.headlight;

            // 기존 메쉬 제거
            this.vehicleGroup.remove(oldMesh);

            // 새 메쉬 생성
            const newMesh = this.createVehicleMesh(vehicleTypeKey);
            newMesh.visible = false;
            newMesh.position.copy(oldPosition);
            newMesh.rotation.y = oldRotation;

            // 헤드라이트 재부착
            if (headlight) {
                newMesh.add(headlight);
            }

            vehicle.mesh = newMesh;

            // 새 원본 머티리얼 저장
            vehicle.originalMaterials = new Map();
            newMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    vehicle.originalMaterials.set(child.uuid, child.material);
                }
            });

            this.vehicleGroup.add(newMesh);

            // 차량 종류에 따른 활동 메시지 설정
            if (vehicleTypeConfig && vehicleTypeConfig.activities) {
                const activities = vehicleTypeConfig.activities;
                vehicle.activity = activities[Math.floor(Math.random() * activities.length)];
            } else {
                vehicle.activity = this.generateActivity(originType, destType);
            }

            // 출발지/목적지 이름 설정
            vehicle.originTypeName = this.getBuildingTypeName(originBuilding?.type);
            vehicle.destTypeName = this.getBuildingTypeName(destBuilding?.type);

            // 속도 배율 적용
            const speedMultiplier = vehicleTypeConfig?.speedMultiplier || 1.0;
            vehicle.speed = TRAFFIC_CONFIG.vehicleSpeed * speedMultiplier;
            vehicle.targetSpeed = vehicle.speed;

            // 4차선 도로 차선 번호 할당 (0 = 외부, 1 = 내부)
            // 랜덤하게 차선 배정하여 도로 활용도 증가
            vehicle.laneNumber = Math.random() < 0.6 ? 0 : 1;  // 60% 외부 차선, 40% 내부 차선

            // 초기 위치 설정 (차선 오프셋 적용)
            const worldPos = this.getTileWorldPos(vehicle.currentTile, vehicle.targetTile, vehicle);
            vehicle.position.set(worldPos.x, 0.05, worldPos.z);
            vehicle.rotation = this.calcRotation(vehicle.currentTile, vehicle.targetTile);

            vehicle.mesh.position.copy(vehicle.position);
            vehicle.mesh.position.y = 0.02;  // 도로 위 높이
            vehicle.mesh.rotation.y = vehicle.rotation;
            vehicle.mesh.scale.setScalar(1.0);  // 스케일 초기화 (진입 애니메이션 후 복구)
            vehicle.mesh.visible = true;

            // 초기 속도 설정
            vehicle.currentSpeed = vehicle.speed * 0.5;  // 절반 속도로 시작

            vehicle.state = 'moving';
            vehicle.isActive = true;
            this.activeCount++;

            // 공간 분할 그리드에 등록 (충돌 검사 최적화)
            this.addToSpatialGrid(vehicle);

            // 밤이면 헤드라이트 켜기 (승용차만)
            if (vehicle.headlight) {
                const hasHeadlight = vehicleTypeConfig?.hasHeadlight === true;
                if (hasHeadlight) {
                    const hour = (timeState.gameTime / 3600) % 24;
                    vehicle.headlight.visible = (hour >= 19 || hour < 6);
                } else {
                    vehicle.headlight.visible = false;  // 비승용차는 헤드라이트 끔
                }
            }

            // 수치 모드 중이면 회색 머티리얼 적용
            if (isZoneModeActive) {
                vehicle.mesh.traverse((child) => {
                    if (child.isMesh && child.material) {
                        originalMaterials.set(child.uuid, child.material);
                        child.material = grayMaterialBuilding.clone();
                    }
                });
            } else {
                // 수치 모드가 아니면 원본 머티리얼로 복구 (이전 zone 모드에서 흰색으로 남은 경우)
                if (vehicle.originalMaterials && vehicle.originalMaterials.size > 0) {
                    vehicle.mesh.traverse((child) => {
                        if (child.isMesh && vehicle.originalMaterials.has(child.uuid)) {
                            const originalMat = vehicle.originalMaterials.get(child.uuid);
                            safeAssignMaterial(child, originalMat);
                        }
                    });
                }
            }
        },

        // 차선 적용된 월드 좌표 (4차선: 좌좌우우 배치)
        getTileWorldPos(current, next, vehicle = null) {
            const center = tileToWorldCenter(current.x, current.y);
            const dx = next.x - current.x;
            const dy = next.y - current.y;

            // 4차선 도로 여부 확인
            const is4Lane = is4LaneRoad(current.x, current.y);

            let ox = 0, oz = 0;

            if (is4Lane) {
                // 4차선 도로: 앞앞뒤뒤 배치 (같은 방향 2개 차선이 한 쪽에)
                // 외부 차선: 0.35, 내부 차선: 0.19 (중앙선에서 확실히 떨어진 위치)
                const outerOffset = TRAFFIC_CONFIG.laneOffset4Lane;  // 0.35
                const innerOffset = outerOffset * 0.55;  // 0.19 (내부 차선은 외부와 중앙 사이)

                const laneOffset = (vehicle && vehicle.laneNumber === 1) ? innerOffset : outerOffset;

                if (dy !== 0) {  // N/S 방향
                    ox = -dy * laneOffset;  // N(-1)이면 오른쪽, S(+1)이면 왼쪽 (우측통행)
                } else if (dx !== 0) {  // E/W 방향
                    oz = dx * laneOffset;  // E(+1)이면 아래쪽, W(-1)이면 위쪽 (우측통행)
                }
            } else {
                // 2차선 도로: 기존 로직
                const offset = TRAFFIC_CONFIG.laneOffset;
                if (dy !== 0) {
                    ox = dy * offset;
                } else if (dx !== 0) {
                    oz = -dx * offset;
                }
            }

            return { x: center.x + ox, z: center.z + oz };
        },

        // 회전 계산
        calcRotation(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            return Math.atan2(dx, dy);
        },

        // 이동 방향
        getDirection(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            if (dy < 0) return 'N';
            if (dx > 0) return 'E';
            if (dy > 0) return 'S';
            if (dx < 0) return 'W';
            return 'N';
        },

        // 메인 업데이트
        update(currentTime) {
            if (!this.initialized) return;

            try {
                const dt = Math.min((currentTime - this.lastUpdate) / 1000, 0.1);
                this.lastUpdate = currentTime;

                // 밤/낮 체크 (헤드라이트용)
                const hour = (timeState.gameTime / 3600) % 24;
                const isNight = hour >= 19 || hour < 6;
                this.updateHeadlights(isNight);

                // 차량 업데이트
                this.updateVehicles(dt);

                // 스폰 타이머
                this.spawnTimer += dt;
                if (this.spawnTimer >= TRAFFIC_CONFIG.spawnInterval) {
                    this.spawnTimer = 0;
                    this.trySpawnVehicle();
                }

                // 혼잡도 업데이트 (매 10프레임마다)
                if (Math.random() < 0.1) {
                    this.updateCongestion();
                }
            } catch (e) {
                console.error('Traffic update error:', e);
            }
        },

        // 헤드라이트 업데이트 (자연스러운 깜빡임 효과 포함)
        headlightPhase: 0,  // 헤드라이트 애니메이션 페이즈

        updateHeadlights(isNight) {
            // 상태 변경 시 차량 헤드라이트 켜기/끄기 처리
            if (this._lastNightState !== isNight) {
                this._lastNightState = isNight;

                let headlightCount = 0;
                for (const vehicle of this.vehicles) {
                    if (vehicle.headlight) {
                        headlightCount++;
                        // 승용차만 헤드라이트 활성화
                        const vehicleTypeConfig = VEHICLE_TYPES[vehicle.vehicleTypeKey];
                        const hasHeadlight = vehicleTypeConfig?.hasHeadlight === true;

                        if (isNight && vehicle.isActive && hasHeadlight) {
                            // 밤: 랜덤 딜레이 후 켜기 (0~2초)
                            const delay = Math.random() * 2000;
                            setTimeout(() => {
                                if (vehicle.headlight && vehicle.isActive) {
                                    vehicle.headlight.visible = true;
                                }
                            }, delay);
                        } else {
                            // 낮: 즉시 끄기
                            vehicle.headlight.visible = false;
                        }
                    }
                }
                console.log(`[Headlights] isNight: ${isNight}, vehiclesWithHeadlight: ${headlightCount}`);
            }

            // 밤이면 자연스러운 헤드라이트 깜빡임 효과 (공유 머티리얼 업데이트)
            if (isNight && this.headlightSharedResources) {
                this.updateNaturalHeadlightGlow();
            }
        },

        // 자연스러운 헤드라이트 불빛 효과 (사이렌처럼 부드러운 변화)
        updateNaturalHeadlightGlow() {
            this.headlightPhase += 0.05;  // 느린 변화 속도

            const hlRes = this.headlightSharedResources;
            if (!hlRes) return;

            // 여러 주파수의 사인파 조합으로 자연스러운 깜빡임 생성
            const flicker1 = Math.sin(this.headlightPhase * 2.3) * 0.03;    // 느린 호흡
            const flicker2 = Math.sin(this.headlightPhase * 5.7) * 0.02;    // 중간 속도
            const flicker3 = Math.sin(this.headlightPhase * 13.1) * 0.01;   // 빠른 미세 떨림

            // 총 변화량 (0.94 ~ 1.06 범위)
            const totalFlicker = 1 + flicker1 + flicker2 + flicker3;

            // 전구 색상 및 emissive 밝기 업데이트 (공유 머티리얼)
            if (hlRes.bulbMat) {
                // 기본색 0xffffdd에서 약간 변화 (노란빛 ~ 흰빛)
                const warmth = 0.86 + Math.sin(this.headlightPhase * 1.5) * 0.02;
                hlRes.bulbMat.color.setRGB(1.0, 1.0, warmth);
                hlRes.bulbMat.emissive.setRGB(1.0, 1.0, warmth);
                hlRes.bulbMat.emissiveIntensity = 3.0 * totalFlicker;
            }

            // SpotLight 강도 업데이트 (활성 차량만)
            const baseIntensity = 0.6;
            for (const vehicle of this.vehicles) {
                if (vehicle.spotLight && vehicle.headlight && vehicle.headlight.visible) {
                    vehicle.spotLight.intensity = baseIntensity * totalFlicker;
                }
            }
        },

        // 신호등 업데이트
        updateSignals(dt) {
            for (const [, signal] of this.signals) {
                signal.update(dt);

                // 시각적 업데이트 (각 방향별 신호등)
                if (signal.mesh && signal.mesh.userData.signalLights) {
                    const lights = signal.mesh.userData.signalLights;

                    // 각 방향별로 신호등 색상 업데이트
                    for (const dir of ['N', 'S', 'E', 'W']) {
                        const light = lights[dir];
                        if (!light) continue;

                        const isGreen = signal.isGreen(dir);
                        if (light.red && light.red.material) {
                            light.red.material.emissiveIntensity = isGreen ? 0.1 : 1.0;
                        }
                        if (light.green && light.green.material) {
                            light.green.material.emissiveIntensity = isGreen ? 1.0 : 0.1;
                        }
                    }
                }
            }
        },

        // 차량 업데이트
        updateVehicles(dt) {
            const maxVehicles = getMaxVehicles();

            for (const vehicle of this.vehicles) {
                if (!vehicle.isActive) continue;

                // 긴급차량 사이렌 라이트 업데이트
                if (vehicle.sirenLights && (vehicle.isFiretruck || vehicle.isPoliceCar || vehicle.isAmbulance)) {
                    // 구급차는 복귀 중에도 사이렌 유지 (환자 이송 완료 후 다음 출동 대비)
                    if (vehicle.isReturning && !vehicle.isAmbulance) {
                        // 복귀 중: 사이렌 끄기 (구급차 제외)
                        vehicle.sirenLights.visible = false;
                    } else {
                        // 임무 중 또는 구급차 복귀 중: 사이렌 켜기 및 애니메이션
                        vehicle.sirenLights.visible = true;
                        updateSirenLights(vehicle.sirenLights, dt);
                    }
                }

                if (vehicle.state === 'moving') {
                    this.updateMovingVehicle(vehicle, dt);
                } else if (vehicle.state === 'waiting') {
                    this.updateWaitingVehicle(vehicle, dt);
                } else if (vehicle.state === 'entering') {
                    this.updateEnteringVehicle(vehicle, dt);
                } else if (vehicle.state === 'despawning') {
                    this.despawnVehicle(vehicle);
                } else if (vehicle.state === 'working') {
                    // 소방차 잔화 작업 중
                    this.updateWorkingVehicle(vehicle, dt);
                }
            }

            // 인구 감소 시 초과 차량 제거 (소방차, 공사트럭 등 특수 차량 제외)
            if (this.activeCount > maxVehicles) {
                let toRemove = this.activeCount - maxVehicles;
                for (const vehicle of this.vehicles) {
                    if (toRemove <= 0) break;
                    // 특수 차량은 제거하지 않음
                    if (vehicle.isActive && !vehicle.isFiretruck && !vehicle.isPoliceCar && !vehicle.isConstructionTruck && !vehicle.isMoveInVehicle) {
                        this.despawnVehicle(vehicle);
                        toRemove--;
                    }
                }
            }
        },

        // 이동 중인 차량 업데이트
        updateMovingVehicle(vehicle, dt) {
            // 목표 속도 계산 (4차선 도로에서는 더 빠르게)
            const is4Lane = is4LaneRoad(vehicle.currentTile.x, vehicle.currentTile.y);
            const speedMultiplier = is4Lane ? TRAFFIC_CONFIG.speed4LaneMultiplier : 1.0;
            vehicle.targetSpeed = vehicle.speed * speedMultiplier;
            vehicle.stopReason = '';  // 초기화

            // 전방 차량 체크 - 부드러운 감속
            const aheadDist = this.getDistanceToVehicleAhead(vehicle);
            const stopDist = TRAFFIC_CONFIG.stopDistance;
            const minGap = TRAFFIC_CONFIG.minVehicleGap;

            if (aheadDist < stopDist) {
                // 최소 간격 이하면 완전 정지
                if (aheadDist < minGap) {
                    vehicle.targetSpeed = 0;
                    vehicle.stopReason = 'vehicle';
                } else {
                    // 거리에 비례해서 감속
                    const ratio = (aheadDist - minGap) / (stopDist - minGap);
                    vehicle.targetSpeed = Math.min(vehicle.targetSpeed, vehicle.speed * ratio);
                    if (vehicle.targetSpeed < vehicle.speed * 0.3) {
                        vehicle.stopReason = 'vehicle';  // 감속 중
                    }
                }
            }

            // 부드러운 가감속 (현재 속도를 목표 속도로 보간)
            const accel = vehicle.targetSpeed > vehicle.currentSpeed ? 3.0 : 4.0;  // 더 부드러운 가감속
            vehicle.currentSpeed += (vehicle.targetSpeed - vehicle.currentSpeed) * Math.min(1, accel * dt);

            // 아주 느리면 0으로 처리
            if (vehicle.currentSpeed < 0.005) vehicle.currentSpeed = 0;

            // 진행
            if (vehicle.currentSpeed > 0) {
                vehicle.progress += vehicle.currentSpeed * dt;
            }

            if (vehicle.progress >= 1.0) {
                vehicle.progress = 0;
                vehicle.pathIndex++;

                if (vehicle.pathIndex >= vehicle.path.length - 1) {
                    // 공사 트럭인 경우 - 도착 시 공사 시작 후 디스폰
                    if (vehicle.isConstructionTruck && vehicle.constructionSite) {
                        const site = vehicle.constructionSite;
                        const siteX = site.x;
                        const siteY = site.y;
                        const siteKey = `${siteX},${siteY}`;

                        // 건설 가능 여부 체크 (도로로 변경됨, 서비스 건물 설치됨 등)
                        let canBuild = true;

                        for (let dx = 0; dx < site.width && canBuild; dx++) {
                            for (let dy = 0; dy < site.depth && canBuild; dy++) {
                                const checkX = siteX + dx;
                                const checkY = siteY + dy;

                                // 도로인지 체크
                                if (isRoad(checkX, checkY) || isBridge(checkX, checkY)) {
                                    canBuild = false;
                                    console.log(`[Construction] Cancelled - road at (${checkX},${checkY})`);
                                }

                                // 서비스 건물인지 체크
                                if (placedPublicBuildings.has(`${checkX},${checkY}`)) {
                                    canBuild = false;
                                    console.log(`[Construction] Cancelled - public building at (${checkX},${checkY})`);
                                }

                                // 이미 다른 건물이 있는지 체크
                                const existingBuilding = placedBuildings.get(`${checkX},${checkY}`);
                                if (existingBuilding && !existingBuilding.ref) {
                                    canBuild = false;
                                    console.log(`[Construction] Cancelled - building exists at (${checkX},${checkY})`);
                                }
                            }
                        }

                        if (canBuild) {
                            startConstruction(site);
                        } else {
                            // 공사 취소 - constructionSites에서 제거
                            constructionSites.delete(siteKey);
                            toast({ title: '공사 취소', desc: '건설 현장이 변경되어 공사가 취소되었습니다.' });
                        }

                        this.despawnVehicle(vehicle);
                        return;
                    }

                    // 입주 차량인 경우 - 빠르게 디스폰
                    if (vehicle.isMoveInVehicle) {
                        // 입주 완료 처리
                        if (vehicle.destBuilding) {
                            onMoveInArrival(vehicle.destBuilding.x, vehicle.destBuilding.y);
                        }
                        this.despawnVehicle(vehicle);
                        return;
                    }

                    // 소방차인 경우 - 화재 현장 도착 또는 소방서 복귀
                    if (vehicle.isFiretruck) {
                        // 소방서로 복귀 완료
                        if (vehicle.isReturning) {
                            console.log(`[Fire] Firetruck returned to station`);
                            this.despawnVehicle(vehicle);
                            return;
                        }

                        // 화재 현장 도착 - 잔화 작업 시작
                        if (vehicle.fireTarget) {
                            console.log(`[Fire] Firetruck arrived at fire location (${vehicle.fireTarget.x}, ${vehicle.fireTarget.y})`);
                            onFiretruckArrival(vehicle.fireTarget.x, vehicle.fireTarget.y, vehicle);
                            return;
                        }

                        // fireTarget이 없는 경우 (비정상) - 소방서로 복귀
                        console.warn(`[Fire] Firetruck has no fireTarget, returning to station`);
                        startFiretruckReturn(vehicle);
                        return;
                    }

                    // 경찰차인 경우 - 범죄 현장 도착 또는 경찰서 복귀
                    if (vehicle.isPoliceCar) {
                        // 경찰서로 복귀 완료
                        if (vehicle.isReturning) {
                            console.log(`[Crime] Police car returned to station`);
                            this.despawnVehicle(vehicle);
                            return;
                        }

                        // 범죄 현장 도착 - 현장 조사 시작
                        if (vehicle.crimeTarget) {
                            console.log(`[Crime] Police car arrived at crime location (${vehicle.crimeTarget.x}, ${vehicle.crimeTarget.y})`);
                            onPoliceCarArrival(vehicle.crimeTarget.x, vehicle.crimeTarget.y, vehicle);
                            return;
                        }

                        // crimeTarget이 없는 경우 (비정상) - 경찰서로 복귀
                        console.warn(`[Crime] Police car has no crimeTarget, returning to station`);
                        startPoliceCarReturn(vehicle);
                        return;
                    }

                    // 구급차인 경우 - 응급 현장 도착 또는 병원 복귀
                    if (vehicle.isAmbulance) {
                        // 병원으로 복귀 완료
                        if (vehicle.isReturning) {
                            console.log(`[Medical] Ambulance returned to hospital`);
                            this.despawnVehicle(vehicle);
                            return;
                        }

                        // 응급 현장 도착 - 환자 이송 준비 시작
                        if (vehicle.emergencyTarget) {
                            console.log(`[Medical] Ambulance arrived at emergency location (${vehicle.emergencyTarget.x}, ${vehicle.emergencyTarget.y})`);
                            onAmbulanceArrival(vehicle.emergencyTarget.x, vehicle.emergencyTarget.y, vehicle);
                            return;
                        }

                        // emergencyTarget이 없는 경우 (비정상) - 병원으로 복귀
                        console.warn(`[Medical] Ambulance has no emergencyTarget, returning to hospital`);
                        startAmbulanceReturn(vehicle);
                        return;
                    }

                    // 목적지 건물로 진입 시작
                    vehicle.state = 'entering';
                    vehicle.enterProgress = 0;
                    // 목적지 건물 위치 저장
                    if (vehicle.destBuilding) {
                        const bldg = vehicle.destBuilding;
                        const centerX = bldg.x + (bldg.width || 1) / 2;
                        const centerY = bldg.y + (bldg.depth || 1) / 2;
                        const worldPos = tileToWorldCenter(centerX, centerY);
                        vehicle.enterTarget = { x: worldPos.x, z: worldPos.z };
                    } else {
                        // 건물 정보 없으면 현재 위치 유지
                        vehicle.enterTarget = { x: vehicle.position.x, z: vehicle.position.z };
                    }
                    vehicle.enterStart = { x: vehicle.position.x, z: vehicle.position.z };
                    vehicle.enterStartScale = vehicle.mesh.scale.x;
                    // 시작 회전값 저장 및 목표 회전값 계산 (건물 방향)
                    vehicle.enterStartRotation = vehicle.mesh.rotation.y;
                    const dx = vehicle.enterTarget.x - vehicle.enterStart.x;
                    const dz = vehicle.enterTarget.z - vehicle.enterStart.z;
                    vehicle.enterTargetRotation = Math.atan2(dx, dz);
                    return;
                }

                vehicle.currentTile = { ...vehicle.targetTile };
                vehicle.targetTile = {
                    x: vehicle.path[vehicle.pathIndex + 1].x,
                    y: vehicle.path[vehicle.pathIndex + 1].y
                };
                vehicle.rotation = this.calcRotation(vehicle.currentTile, vehicle.targetTile);
            }

            // 교착상태 체크 및 해제
            this.checkAndResolveStuck(vehicle);

            this.updateVehiclePosition(vehicle);
        },

        // 대기 중인 차량 업데이트 (사용 안 함 - 부드러운 감속 방식으로 변경)
        updateWaitingVehicle(vehicle, dt) {
            // 이제 moving 상태에서 speedMultiplier로 처리하므로 사용 안 함
            vehicle.state = 'moving';
        },

        // 소방차 잔화 작업 중 업데이트
        updateWorkingVehicle(vehicle, dt) {
            if (!vehicle.workStartTime) {
                vehicle.workStartTime = Date.now();
            }

            const elapsed = Date.now() - vehicle.workStartTime;

            // 작업 시간 완료 체크 (소방차, 경찰차, 또는 구급차)
            let workTime;
            if (vehicle.isPoliceCar) {
                workTime = CRIME_POLICE_WORK_TIME;
            } else if (vehicle.isAmbulance) {
                workTime = MEDICAL_AMBULANCE_WORK_TIME;
            } else {
                workTime = FIRETRUCK_WORK_TIME;
            }

            if (elapsed >= workTime) {
                // 복귀 시작
                if (vehicle.isPoliceCar) {
                    startPoliceCarReturn(vehicle);
                    toast({
                        title: '🏠 복귀 시작',
                        desc: '현장 조사 완료! 경찰차가 경찰서로 복귀합니다.',
                        ms: 3000
                    });
                } else if (vehicle.isAmbulance) {
                    startAmbulanceReturn(vehicle);
                    toast({
                        title: '🏠 복귀 시작',
                        desc: '환자 이송 완료! 구급차가 병원으로 복귀합니다.',
                        ms: 3000
                    });
                } else {
                    startFiretruckReturn(vehicle);
                    toast({
                        title: '🏠 복귀 시작',
                        desc: '잔화 작업 완료! 소방차가 소방서로 복귀합니다.',
                        ms: 3000
                    });
                }
            }
        },

        // 교차로인지 확인
        isIntersection(x, y) {
            const node = this.roadNetwork.get(`${x},${y}`);
            return node && (node.intersectionType === 't' || node.intersectionType === 'cross');
        },

        // 전방 차량까지 거리 계산 (공간 분할 최적화, 교차로 우선권 적용, 차량 길이 고려)
        getDistanceToVehicleAhead(vehicle) {
            let minDist = Infinity;

            // 내 진행 방향 벡터
            const myForwardX = Math.sin(vehicle.rotation);
            const myForwardZ = Math.cos(vehicle.rotation);

            // 내 차량 길이
            const myLength = vehicle.length || 0.25;

            // 현재 교차로에 있는지 확인
            const atIntersection = this.isIntersection(vehicle.currentTile.x, vehicle.currentTile.y) ||
                                   this.isIntersection(vehicle.targetTile.x, vehicle.targetTile.y);

            // 공간 분할을 이용해 주변 차량만 검사 (O(n²) → O(n*k) 최적화)
            const nearbyVehicles = this.getNearbyVehicles(vehicle.position.x, vehicle.position.z);

            for (const other of nearbyVehicles) {
                if (!other.isActive || other === vehicle) continue;

                const dx = other.position.x - vehicle.position.x;
                const dz = other.position.z - vehicle.position.z;
                const centerDist = Math.sqrt(dx * dx + dz * dz);

                if (centerDist > 1.5) continue;  // 검색 범위 확장 (긴 차량 고려)

                // 1. 전방인지 확인
                const dotAhead = dx * myForwardX + dz * myForwardZ;
                if (dotAhead <= 0.08) continue;  // 전방 아님

                // 2. 방향 체크
                const otherForwardX = Math.sin(other.rotation);
                const otherForwardZ = Math.cos(other.rotation);
                const dotDirection = myForwardX * otherForwardX + myForwardZ * otherForwardZ;

                // 반대 방향은 무시
                if (dotDirection < -0.3) continue;

                // 3. 앞차 길이를 고려한 실제 간격 계산
                // 중심간 거리에서 내 앞부분과 상대 뒷부분까지의 거리를 계산
                const otherLength = other.length || 0.25;
                const actualGap = centerDist - (myLength / 2) - (otherLength / 2);

                // 4. 교차로에서 수직 방향 차량 처리 (우선권)
                if (atIntersection && Math.abs(dotDirection) < 0.5) {
                    // 수직 방향 차량 (교차로에서 교차)
                    // ID가 작은 차량이 우선권 (간단한 우선권 규칙)
                    if (vehicle.id > other.id) {
                        // 내가 양보해야 함
                        if (actualGap < minDist) minDist = actualGap;
                    }
                    // 내가 우선권이면 무시하고 통과
                    continue;
                }

                // 5. 같은 방향/비슷한 방향 차량
                const lateralDist = Math.abs(-dx * myForwardZ + dz * myForwardX);
                if (lateralDist > 0.4) continue;  // 다른 차선

                if (actualGap < minDist) {
                    minDist = actualGap;
                }
            }
            return minDist;
        },

        // 교착상태 감지 및 해제
        stuckTimers: new Map(),

        checkAndResolveStuck(vehicle) {
            const key = vehicle.id;
            const atIntersection = this.isIntersection(vehicle.currentTile.x, vehicle.currentTile.y);

            if (vehicle.currentSpeed < 0.02 && vehicle.targetSpeed === 0) {
                const timer = this.stuckTimers.get(key) || 0;
                this.stuckTimers.set(key, timer + 1);

                // 교차로에서는 더 빨리 해제 (2초), 일반 도로는 4초
                const threshold = atIntersection ? 60 : 120;

                if (timer > threshold) {
                    vehicle.progress += 0.15;  // 강제 전진
                    this.stuckTimers.set(key, 0);
                    vehicle.stopReason = '';
                }
            } else {
                this.stuckTimers.set(key, 0);
            }
        },


        // 좌회전 감지 (cross product로 회전 방향 판별)
        isLeftTurn(from, current, to) {
            const dx1 = current.x - from.x;
            const dy1 = current.y - from.y;
            const dx2 = to.x - current.x;
            const dy2 = to.y - current.y;
            // cross product: 음수면 좌회전 (반시계방향)
            return (dx1 * dy2 - dy1 * dx2) < 0;
        },

        // U-턴 감지 (180도 회전 - 반대 방향으로 진행)
        isUTurn(from, current, to) {
            const dx1 = current.x - from.x;
            const dy1 = current.y - from.y;
            const dx2 = to.x - current.x;
            const dy2 = to.y - current.y;
            // dot product: 음수면 반대 방향 (U-턴)
            // 정확히 -1이면 완전 U-턴, 0보다 작으면 90도 이상 회전
            const dot = dx1 * dx2 + dy1 * dy2;
            return dot < 0;
        },

        // 차량 위치 업데이트 (자연스러운 곡선 이동 + 시각적 보간)
        updateVehiclePosition(vehicle) {
            // 현재, 다음, 그 다음 타일 위치 (vehicle 전달로 4차선 차선 정보 사용)
            const p0 = vehicle.pathIndex > 0
                ? this.getTileWorldPos(vehicle.path[vehicle.pathIndex - 1], vehicle.currentTile, vehicle)
                : this.getTileWorldPos(vehicle.currentTile, vehicle.targetTile, vehicle);
            const p1 = this.getTileWorldPos(vehicle.currentTile, vehicle.targetTile, vehicle);
            const p2 = this.getTileWorldPos(vehicle.targetTile,
                vehicle.pathIndex + 2 < vehicle.path.length
                    ? vehicle.path[vehicle.pathIndex + 2]
                    : vehicle.targetTile,
                vehicle
            );
            const p3 = vehicle.pathIndex + 3 < vehicle.path.length
                ? this.getTileWorldPos(vehicle.path[vehicle.pathIndex + 2], vehicle.path[vehicle.pathIndex + 3], vehicle)
                : p2;

            // Catmull-Rom 스플라인으로 목표 위치 계산
            const t = vehicle.progress;
            let posX = this.catmullRom(p0.x, p1.x, p2.x, p3.x, t);
            let posZ = this.catmullRom(p0.z, p1.z, p2.z, p3.z, t);

            // 좌회전 시 안쪽(왼쪽)으로 오프셋 적용
            if (vehicle.pathIndex + 2 < vehicle.path.length) {
                const prevTile = vehicle.pathIndex > 0 ? vehicle.path[vehicle.pathIndex - 1] : vehicle.currentTile;
                const nextTile = vehicle.path[vehicle.pathIndex + 2];

                if (this.isLeftTurn(prevTile, vehicle.targetTile, nextTile)) {
                    // 좌회전 중 - 진행 방향의 왼쪽(안쪽)으로 오프셋
                    const dirX = p2.x - p1.x;
                    const dirZ = p2.z - p1.z;
                    const dirLen = Math.sqrt(dirX * dirX + dirZ * dirZ);

                    if (dirLen > 0.01) {
                        // 왼쪽 수직 벡터 (90도 반시계방향)
                        const perpX = -dirZ / dirLen;
                        const perpZ = dirX / dirLen;

                        // sin 곡선으로 부드러운 오프셋 (0 → max → 0)
                        const inwardOffset = 0.12 * Math.sin(t * Math.PI);
                        posX += perpX * inwardOffset;
                        posZ += perpZ * inwardOffset;
                    }
                }
                // U-턴 시 중앙선 통과 처리 (교차로에서만)
                else if (this.isUTurn(prevTile, vehicle.targetTile, nextTile) &&
                         this.isIntersection(vehicle.targetTile.x, vehicle.targetTile.y)) {
                    // U-턴 중 - 현재 차선에서 반대 차선으로 중앙선을 통해 이동
                    const dirX = p2.x - p1.x;
                    const dirZ = p2.z - p1.z;
                    const dirLen = Math.sqrt(dirX * dirX + dirZ * dirZ);

                    if (dirLen > 0.01) {
                        // 왼쪽 수직 벡터 (U-턴은 항상 왼쪽으로 회전)
                        const perpX = -dirZ / dirLen;
                        const perpZ = dirX / dirLen;

                        // 차선 오프셋 (현재 도로 타입에 따라)
                        const is4Lane = is4LaneRoad(vehicle.targetTile.x, vehicle.targetTile.y);
                        const laneOffset = is4Lane ? TRAFFIC_CONFIG.laneOffset4Lane : TRAFFIC_CONFIG.laneOffset;

                        // sin 곡선으로 중앙선까지 이동 후 반대 차선으로
                        // t=0: 원래 차선 (+laneOffset)
                        // t=0.5: 중앙선 (0)
                        // t=1: 반대 차선 (-laneOffset 방향, 하지만 회전 후이므로 실제로는 올바른 위치)
                        // U-턴이므로 더 넓게 회전 (차선 2개 폭만큼)
                        const uTurnOffset = laneOffset * 2 * Math.sin(t * Math.PI);
                        posX += perpX * uTurnOffset;
                        posZ += perpZ * uTurnOffset;
                    }
                }
            }

            vehicle.position.x = posX;
            vehicle.position.z = posZ;

            // 공간 분할 그리드 업데이트 (셀 변경 시에만)
            this.updateSpatialGrid(vehicle);

            // 시각적 위치 보간 (부드러운 이동)
            if (!vehicle.visualInitialized) {
                vehicle.visualPosition.copy(vehicle.position);
                vehicle.visualInitialized = true;
            } else {
                // 부드러운 보간 (0.4 = 빠르지만 부드럽게)
                vehicle.visualPosition.lerp(vehicle.position, 0.4);
            }

            vehicle.mesh.position.copy(vehicle.visualPosition);
            vehicle.mesh.position.y = 0.02;  // 도로 위 높이

            // 진행 방향 계산 (미분)
            const dx = this.catmullRomDerivative(p0.x, p1.x, p2.x, p3.x, t);
            const dz = this.catmullRomDerivative(p0.z, p1.z, p2.z, p3.z, t);
            if (Math.abs(dx) > 0.001 || Math.abs(dz) > 0.001) {
                vehicle.rotation = Math.atan2(dx, dz);
            }

            // 시각적 회전 보간 (부드러운 회전)
            if (vehicle.visualRotation === undefined) {
                vehicle.visualRotation = vehicle.rotation;
            }
            vehicle.visualRotation = this.lerpAngle(vehicle.visualRotation, vehicle.rotation, 0.3);
            vehicle.mesh.rotation.set(0, vehicle.visualRotation, 0);
        },

        // Catmull-Rom 스플라인 보간
        catmullRom(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return 0.5 * (
                (2 * p1) +
                (-p0 + p2) * t +
                (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
                (-p0 + 3 * p1 - 3 * p2 + p3) * t3
            );
        },

        // Catmull-Rom 미분 (방향 계산용)
        catmullRomDerivative(p0, p1, p2, p3, t) {
            const t2 = t * t;
            return 0.5 * (
                (-p0 + p2) +
                2 * (2 * p0 - 5 * p1 + 4 * p2 - p3) * t +
                3 * (-p0 + 3 * p1 - 3 * p2 + p3) * t2
            );
        },

        smoothstep(t) {
            return t * t * (3 - 2 * t);
        },

        lerpAngle(from, to, t) {
            let diff = to - from;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return from + diff * t;
        },

        // 건물 진입 중인 차량 업데이트
        updateEnteringVehicle(vehicle, dt) {
            const enterDuration = 0.15;  // 진입 애니메이션 시간 (초) - 거의 즉시
            vehicle.enterProgress += dt / enterDuration;

            if (vehicle.enterProgress >= 1.0) {
                // 애니메이션 완료 - 차량 제거
                this.despawnVehicle(vehicle);
                return;
            }

            // easeInOutQuad로 부드럽게 가감속
            const t = vehicle.enterProgress;
            const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

            // 위치 보간 (시작점 → 건물 중심)
            const x = vehicle.enterStart.x + (vehicle.enterTarget.x - vehicle.enterStart.x) * eased;
            const z = vehicle.enterStart.z + (vehicle.enterTarget.z - vehicle.enterStart.z) * eased;

            vehicle.mesh.position.x = x;
            vehicle.mesh.position.z = z;
            // 높이를 약간 낮춰서 건물 안으로 들어가는 느낌
            vehicle.mesh.position.y = 0.02 * (1 - eased * 0.5);

            // 회전 보간 (건물 방향으로 회전)
            if (vehicle.enterStartRotation !== undefined && vehicle.enterTargetRotation !== undefined) {
                const rotationT = Math.min(t * 2, 1);  // 전반부에서 회전 완료
                const rotEased = rotationT < 0.5 ? 2 * rotationT * rotationT : 1 - Math.pow(-2 * rotationT + 2, 2) / 2;
                vehicle.mesh.rotation.y = this.lerpAngle(vehicle.enterStartRotation, vehicle.enterTargetRotation, rotEased);
            }

            // 스케일 축소 (점점 작아짐)
            const scale = (vehicle.enterStartScale || 1.0) * (1 - eased * 0.7);
            vehicle.mesh.scale.setScalar(scale);
        },

        // 차량 제거
        despawnVehicle(vehicle) {
            // 소방차인 경우 소방서 카운트 감소
            if (vehicle.isFiretruck && vehicle.stationKey) {
                const currentCount = stationFiretruckCount.get(vehicle.stationKey) || 0;
                if (currentCount > 0) {
                    stationFiretruckCount.set(vehicle.stationKey, currentCount - 1);
                }
                // 소방차 관련 속성 초기화
                vehicle.isFiretruck = false;
                vehicle.stationKey = null;
                vehicle.fireTarget = null;
                vehicle.isReturning = false;
            }
            // 경찰차인 경우 경찰서 카운트 감소
            if (vehicle.isPoliceCar && vehicle.stationKey) {
                const currentCount = stationPoliceCount.get(vehicle.stationKey) || 0;
                if (currentCount > 0) {
                    stationPoliceCount.set(vehicle.stationKey, currentCount - 1);
                }
                // 경찰차 관련 속성 초기화
                vehicle.isPoliceCar = false;
                vehicle.stationKey = null;
                vehicle.crimeTarget = null;
                vehicle.isReturning = false;
            }
            // 구급차인 경우 병원 카운트 감소
            if (vehicle.isAmbulance && vehicle.hospitalKey) {
                const currentCount = hospitalAmbulanceCount.get(vehicle.hospitalKey) || 0;
                if (currentCount > 0) {
                    hospitalAmbulanceCount.set(vehicle.hospitalKey, currentCount - 1);
                }
                // 구급차 관련 속성 초기화
                vehicle.isAmbulance = false;
                vehicle.hospitalKey = null;
                vehicle.emergencyTarget = null;
                vehicle.isReturning = false;
            }
            // 공간 분할 그리드에서 제거
            this.removeFromSpatialGrid(vehicle);
            vehicle.reset();
            this.activeCount--;
        },

        // 모든 차량 제거
        removeAllVehicles() {
            // 활성 차량 모두 despawn
            const toRemove = this.vehicles.filter(v => v.isActive);
            for (const vehicle of toRemove) {
                this.despawnVehicle(vehicle);
            }
            // 스폰 대기열 초기화
            this.spawnQueue = [];
            // 공간 분할 그리드 초기화
            this.spatialGrid.clear();
            // 혼잡도 맵 초기화
            this.congestionMap.clear();
            console.log('All vehicles removed');
        },

        // 혼잡도 업데이트 (지수 이동 평균 - EMA)
        // RAM 추가 없이 시간 평균 계산
        updateCongestion() {
            const alpha = 0.15;  // 평활 계수 (낮을수록 과거 데이터 더 반영)
            const decayThreshold = 0.01;  // 이 값 이하면 삭제 (메모리 절약)

            // 현재 프레임의 차량 수 집계
            const counts = new Map();
            for (const v of this.vehicles) {
                if (!v.isActive) continue;
                const key = `${v.currentTile.x},${v.currentTile.y}`;
                counts.set(key, (counts.get(key) || 0) + 1);
            }

            // 기존 타일들 EMA 업데이트 + 감쇠
            for (const [key, oldValue] of this.congestionMap) {
                const currentCount = counts.get(key) || 0;
                const instantaneous = Math.min(currentCount / 3, 1);
                const smoothed = alpha * instantaneous + (1 - alpha) * oldValue;

                if (smoothed < decayThreshold) {
                    this.congestionMap.delete(key);  // 메모리 정리
                } else {
                    this.congestionMap.set(key, smoothed);
                }
                counts.delete(key);  // 처리 완료 표시
            }

            // 새로운 타일 추가 (기존 맵에 없던 타일)
            for (const [key, count] of counts) {
                const instantaneous = Math.min(count / 3, 1);
                if (instantaneous >= decayThreshold) {
                    this.congestionMap.set(key, instantaneous * alpha);
                }
            }
        },

        // 도로 변경 시 재구축
        onRoadChange() {
            // 도로가 없어진 곳의 차량 제거
            this.removeVehiclesOnInvalidRoads();
            this.buildRoadNetwork();
            this.pathCache.clear();
        },

        // 유효하지 않은 도로 위 차량 제거
        removeVehiclesOnInvalidRoads() {
            for (const vehicle of this.vehicles) {
                if (!vehicle.isActive) continue;

                // 현재 타일이나 목표 타일이 도로가 아니면 제거
                const currIsRoad = isRoad(vehicle.currentTile.x, vehicle.currentTile.y);
                const targetIsRoad = isRoad(vehicle.targetTile.x, vehicle.targetTile.y);

                if (!currIsRoad || !targetIsRoad) {
                    this.despawnVehicle(vehicle);
                    continue;
                }

                // 남은 경로에 유효하지 않은 도로가 있으면 제거
                if (vehicle.path && vehicle.pathIndex < vehicle.path.length) {
                    let pathInvalid = false;
                    for (let i = vehicle.pathIndex; i < vehicle.path.length; i++) {
                        const tile = vehicle.path[i];
                        if (!isRoad(tile.x, tile.y)) {
                            pathInvalid = true;
                            break;
                        }
                    }
                    if (pathInvalid) {
                        this.despawnVehicle(vehicle);
                    }
                }
            }
        },

        // 건물 변경 시 재분류
        onBuildingChange() {
            // 철거된 건물로 향하는 차량 제거
            this.removeVehiclesWithInvalidDestination();
            // 건물 목록 재분류
            this.categorizeBuildings();
        },

        // 유효하지 않은 목적지로 향하는 차량 제거
        removeVehiclesWithInvalidDestination() {
            for (const vehicle of this.vehicles) {
                if (!vehicle.isActive) continue;

                // 목적지 건물이 존재하는지 확인
                if (vehicle.destBuilding) {
                    const { x, y } = vehicle.destBuilding;
                    // 해당 위치에 건물이 더 이상 없으면 차량 제거
                    if (!findBuildingAt(x, y)) {
                        this.despawnVehicle(vehicle);
                    }
                }
            }
        },

        // 통계 정보
        getStats() {
            return {
                activeVehicles: this.activeCount,
                maxVehicles: getMaxVehicles(),
                roadNodes: this.roadNetwork.size,
                signals: this.signals.size,
                pathCacheSize: this.pathCache.size,
                residential: this.residentialBuildings.length,
                commercial: this.commercialBuildings.length,
                industrial: this.industrialBuildings.length
            };
        },

        // === 차량 선택 시스템 ===
        selectedVehicle: null,
        followingVehicle: null,
        vehicleOutlineMeshes: [],

        // 차량 선택
        selectVehicle(vehicle) {
            this.clearVehicleOutline();
            this.selectedVehicle = vehicle;
            if (vehicle && vehicle.mesh) {
                this.createVehicleOutline(vehicle);
                this.showVehiclePopup(vehicle);
            }
        },

        // 차량 선택 해제
        deselectVehicle() {
            this.clearVehicleOutline();
            this.selectedVehicle = null;
            this.stopFollowing();
            this.hideVehiclePopup();
        },

        // 차량 아웃라인 생성
        createVehicleOutline(vehicle) {
            this.clearVehicleOutline();
            if (!vehicle || !vehicle.mesh) return;

            const outlineMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                side: THREE.BackSide
            });

            vehicle.mesh.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const outline = new THREE.Mesh(child.geometry.clone(), outlineMat.clone());
                    child.updateWorldMatrix(true, false);
                    outline.applyMatrix4(child.matrixWorld);
                    outline.scale.multiplyScalar(1.06);
                    outline.renderOrder = -1;
                    scene.add(outline);
                    this.vehicleOutlineMeshes.push(outline);
                }
            });
        },

        // 차량 아웃라인 업데이트 (따라다니는 중일 때)
        updateVehicleOutline() {
            if (!this.selectedVehicle || !this.selectedVehicle.isActive) {
                this.deselectVehicle();
                return;
            }

            // 아웃라인 위치 업데이트
            if (this.vehicleOutlineMeshes.length > 0 && this.selectedVehicle.mesh) {
                this.clearVehicleOutline();
                this.createVehicleOutline(this.selectedVehicle);
            }
        },

        // 차량 아웃라인 제거
        clearVehicleOutline() {
            this.vehicleOutlineMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            this.vehicleOutlineMeshes = [];
        },

        // 카메라 따라가기 시작
        startFollowing(vehicle) {
            this.followingVehicle = vehicle;
        },

        // 카메라 따라가기 중지
        stopFollowing() {
            this.followingVehicle = null;
        },

        // 카메라 따라가기 업데이트 (animate에서 호출)
        updateCameraFollow() {
            if (!this.followingVehicle || !this.followingVehicle.isActive) {
                if (this.followingVehicle) this.stopFollowing();
                return;
            }

            const v = this.followingVehicle;
            const targetPos = v.position.clone();

            // 카메라 회전은 차량 회전과 독립적
            // 현재 카메라 오프셋 유지하면서 차량 위치만 따라감
            const currentOffset = camera.position.clone().sub(controls.target);

            // 타겟(차량 위치)을 부드럽게 따라감
            controls.target.lerp(targetPos, 0.08);

            // 카메라 위치 = 타겟 + 현재 오프셋 (회전 유지)
            const newCamPos = controls.target.clone().add(currentOffset);
            camera.position.copy(newCamPos);
        },

        // 차량 정보 팝업 표시
        showVehiclePopup(vehicle) {
            const popup = document.getElementById('vehiclePopup');
            if (!popup || !vehicle) return;

            // 차량 타입에 따른 정보 (VEHICLE_TYPES에서 가져옴)
            const vehicleTypeKey = vehicle.vehicleTypeKey || vehicle.type || 'old';
            const vehicleTypeConfig = VEHICLE_TYPES[vehicleTypeKey];

            let typeName = '차량';
            let typeIcon = '🚗';

            if (vehicleTypeConfig) {
                typeName = vehicleTypeConfig.name;
                typeIcon = vehicleTypeConfig.icon;
            } else {
                // 폴백: 기존 방식
                const typeNames = {
                    'car': '승용차',
                    'truck': '트럭',
                    'bus': '버스',
                    'taxi': '택시'
                };
                typeName = typeNames[vehicle.type] || '차량';
            }

            // 경로 정보
            const pathLength = vehicle.path ? vehicle.path.length : 0;
            const progress = vehicle.pathIndex ? Math.round((vehicle.pathIndex / pathLength) * 100) : 0;

            // 속도 정보
            const speedKmh = Math.round(vehicle.currentSpeed * 50);  // 임의 변환

            document.getElementById('vehiclePopupTitle').textContent = `${typeIcon} ${typeName}`;
            document.getElementById('vehiclePopupSpeed').textContent = speedKmh + ' km/h';
            document.getElementById('vehiclePopupProgress').style.width = progress + '%';
            document.getElementById('vehiclePopupProgressText').textContent = progress + '%';

            // 활동 정보 표시
            const activityEl = document.getElementById('vehiclePopupActivity');
            if (activityEl) {
                activityEl.textContent = vehicle.activity || '드라이브 중 🚗';
            }

            // 출발지/목적지 정보 표시
            const originEl = document.getElementById('vehiclePopupOrigin');
            const destEl = document.getElementById('vehiclePopupDest');

            if (originEl) {
                originEl.textContent = vehicle.originTypeName || '알 수 없음';
            }
            if (destEl) {
                destEl.textContent = vehicle.destTypeName || '알 수 없음';
            }

            popup.style.display = 'block';
        },

        // 차량 상태 표시 업데이트 (테스트용 상세)
        updateVehicleStatusDisplay(vehicle, statusEl) {
            if (!statusEl) return;

            let statusText = '';
            let statusClass = 'moving';

            const speed = vehicle.currentSpeed.toFixed(2);
            const targetSpeed = vehicle.targetSpeed.toFixed(2);
            const progress = (vehicle.progress * 100).toFixed(0);

            if (vehicle.stopReason === 'signal') {
                const signalKey = `${vehicle.targetTile.x},${vehicle.targetTile.y}`;
                const dir = this.getDirection(vehicle.currentTile, vehicle.targetTile);
                statusText = `신호대기 | 타일(${vehicle.targetTile.x},${vehicle.targetTile.y}) | 방향:${dir} | prog:${progress}%`;
                statusClass = 'signal';
            } else if (vehicle.stopReason === 'vehicle') {
                const dist = this.getDistanceToVehicleAhead(vehicle);
                statusText = `전방차량 | 거리:${dist.toFixed(2)} | 속도:${speed}/${targetSpeed}`;
                statusClass = 'vehicle';
            } else if (vehicle.currentSpeed < 0.05) {
                statusText = `정차 | 속도:${speed} | target:${targetSpeed}`;
                statusClass = 'vehicle';
            } else {
                statusText = `주행 | 속도:${speed}/${targetSpeed} | prog:${progress}%`;
                statusClass = 'moving';
            }

            statusEl.textContent = statusText;
            statusEl.className = 'vehicle-popup-value vehicle-status ' + statusClass;
        },

        // 차량 정보 팝업 숨기기
        hideVehiclePopup() {
            const popup = document.getElementById('vehiclePopup');
            if (popup) popup.style.display = 'none';
        },

        // 차량 팝업 위치 업데이트
        updateVehiclePopupPosition() {
            if (!this.selectedVehicle || !this.selectedVehicle.isActive) return;

            const popup = document.getElementById('vehiclePopup');
            if (!popup || popup.style.display === 'none') return;

            const pos = this.selectedVehicle.position.clone();
            pos.y += 0.3;

            const screenPos = pos.project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

            popup.style.left = (x + 20) + 'px';
            popup.style.top = (y - 50) + 'px';

            // 속도 실시간 업데이트
            const speedKmh = Math.round(this.selectedVehicle.currentSpeed * 50);
            const speedEl = document.getElementById('vehiclePopupSpeed');
            if (speedEl) speedEl.textContent = speedKmh + ' km/h';

            // 진행률 실시간 업데이트
            const vehicle = this.selectedVehicle;
            const pathLength = vehicle.path ? vehicle.path.length : 0;
            const progress = vehicle.pathIndex ? Math.round((vehicle.pathIndex / pathLength) * 100) : 0;
            const progressEl = document.getElementById('vehiclePopupProgress');
            const progressTextEl = document.getElementById('vehiclePopupProgressText');
            if (progressEl) progressEl.style.width = progress + '%';
            if (progressTextEl) progressTextEl.textContent = progress + '%';
        }
    };

    // ===== 개발자 테스트 패널 (통합) =====
    const devPanelEl = document.createElement('div');
    devPanelEl.id = 'devPanel';
    devPanelEl.style.cssText = `
        position: fixed;
        top: 50px;
        right: 10px;
        background: rgba(15, 15, 20, 0.95);
        color: #fff;
        font-family: 'Segoe UI', sans-serif;
        font-size: 12px;
        padding: 0;
        border-radius: 8px;
        z-index: 1001;
        min-width: 280px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        border: 1px solid rgba(255,255,255,0.1);
        display: flex;
        flex-direction: column;
        max-height: calc(100vh - 160px);
        overflow: hidden;
    `;
    devPanelEl.innerHTML = `
        <div id="devPanelHeader" style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: linear-gradient(180deg, #2a2a35, #1a1a25);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            cursor: move;
            user-select: none;
        ">
            <span style="font-weight: 600; color: #4ade80;">🛠️ Developer Panel</span>
            <button id="devPanelToggle" style="
                background: none;
                border: none;
                color: #888;
                font-size: 16px;
                cursor: pointer;
                padding: 0 4px;
            ">+</button>
        </div>
        <div id="devPanelContent" style="
            padding: 10px;
            display: none;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        ">
            <!-- Traffic System Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #60a5fa; margin-bottom: 6px; font-size: 11px;">🚗 TRAFFIC SYSTEM</div>
                <div id="trafficDebugContent" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #4ade80;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                    margin-bottom: 6px;
                ">Initializing...</div>
                <div style="display: flex; gap: 4px; flex-wrap: wrap; align-items: center;">
                    <button id="devBtnDeleteAllVehicles" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #ef4444, #b91c1c);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🗑️ 모든 차량 삭제</button>
                    <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; color: #aaa;">
                        <input type="checkbox" id="devChkVehicleSpawn" checked style="
                            width: 14px;
                            height: 14px;
                            cursor: pointer;
                        ">
                        <span>스폰 ON</span>
                    </label>
                </div>
            </div>

            <!-- Fire System Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #f97316; margin-bottom: 6px; font-size: 11px;">🔥 FIRE SYSTEM</div>
                <div id="fireDebugContent" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #fbbf24;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                    margin-bottom: 6px;
                ">Active Fires: 0</div>
                <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                    <button id="devBtnStartFire" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #ef4444, #b91c1c);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🔥 선택 건물 화재</button>
                    <button id="devBtnExtinguishAll" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #3b82f6, #1d4ed8);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">💧 전체 진압</button>
                </div>
            </div>

            <!-- Crime System Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #3b82f6; margin-bottom: 6px; font-size: 11px;">🚔 CRIME SYSTEM</div>
                <div id="crimeDebugContent" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #60a5fa;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                    margin-bottom: 6px;
                ">Active Crimes: 0</div>
                <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                    <button id="devBtnStartCrime" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #3b82f6, #1d4ed8);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🚨 선택 건물 강도</button>
                    <button id="devBtnResolveAll" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #22c55e, #16a34a);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">✅ 전체 해결</button>
                </div>
            </div>

            <!-- Medical System Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #ec4899; margin-bottom: 6px; font-size: 11px;">🏥 MEDICAL SYSTEM</div>
                <div id="medicalDebugContent" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #f472b6;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                    margin-bottom: 6px;
                ">Active Emergencies: 0</div>
                <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                    <button id="devBtnStartMedical" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #ec4899, #be185d);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">💔 선택 건물 환자</button>
                    <button id="devBtnResolveAllMedical" style="
                        padding: 5px 10px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #22c55e, #16a34a);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">✅ 전체 해결</button>
                </div>
            </div>

            <!-- Time Control Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #fbbf24; margin-bottom: 6px; font-size: 11px;">⏰ TIME CONTROL</div>
                <div style="display: flex; gap: 4px; margin-bottom: 6px;">
                    <button id="devBtnDay" style="
                        flex: 1;
                        padding: 5px 8px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #fbbf24, #d97706);
                        color: #000;
                        font-size: 11px;
                        font-weight: 500;
                    ">☀️ 낮</button>
                    <button id="devBtnNight" style="
                        flex: 1;
                        padding: 5px 8px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #3b4a6a, #1e293b);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🌙 밤</button>
                </div>
                <div style="display: flex; gap: 4px; margin-bottom: 8px;">
                    <button id="devBtnSunrise" style="
                        flex: 1;
                        padding: 5px 8px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #fb923c, #ea580c);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🌅 일출</button>
                    <button id="devBtnSunset" style="
                        flex: 1;
                        padding: 5px 8px;
                        cursor: pointer;
                        border: none;
                        border-radius: 4px;
                        background: linear-gradient(180deg, #f87171, #dc2626);
                        color: #fff;
                        font-size: 11px;
                        font-weight: 500;
                    ">🌇 일몰</button>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input id="devTimeSlider" type="range" min="0" max="24" step="0.5" value="12" style="
                        flex: 1;
                        height: 4px;
                        -webkit-appearance: none;
                        background: linear-gradient(90deg, #1e293b 0%, #fbbf24 50%, #1e293b 100%);
                        border-radius: 2px;
                        cursor: pointer;
                    ">
                    <span id="devTimeDisplay" style="
                        min-width: 45px;
                        font-family: monospace;
                        font-size: 11px;
                        color: #fbbf24;
                    ">12:00</span>
                </div>
            </div>

            <!-- Selected Building Info -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #a78bfa; margin-bottom: 6px; font-size: 11px;">🏠 SELECTED BUILDING</div>
                <div id="devSelectedBuilding" style="
                    font-family: monospace;
                    font-size: 10px;
                    color: #c4b5fd;
                    background: rgba(0,0,0,0.3);
                    padding: 6px 8px;
                    border-radius: 4px;
                    line-height: 1.5;
                ">None selected</div>
            </div>

            <!-- Mountain Background Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #a78bfa; margin-bottom: 6px; font-size: 11px;">⛰️ MOUNTAIN BACKGROUND</div>
                <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px;">
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>Scale</span>
                            <span id="mountainScaleValue" style="font-family: monospace; color: #a78bfa;">1.0</span>
                        </label>
                        <input type="range" id="mountainScaleSlider" min="0.1" max="100" step="0.1" value="1" style="width: 100%; cursor: pointer;">
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>Height (Y)</span>
                            <span id="mountainHeightValue" style="font-family: monospace; color: #a78bfa;">0</span>
                        </label>
                        <input type="range" id="mountainHeightSlider" min="-50" max="50" step="0.5" value="0" style="width: 100%; cursor: pointer;">
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>Position X</span>
                            <span id="mountainPosXValue" style="font-family: monospace; color: #a78bfa;">0</span>
                        </label>
                        <input type="range" id="mountainPosXSlider" min="-100" max="100" step="1" value="0" style="width: 100%; cursor: pointer;">
                    </div>
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #aaa; margin-bottom: 4px;">
                            <span>Position Z</span>
                            <span id="mountainPosZValue" style="font-family: monospace; color: #a78bfa;">0</span>
                        </label>
                        <input type="range" id="mountainPosZSlider" min="-100" max="100" step="1" value="0" style="width: 100%; cursor: pointer;">
                    </div>
                    <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                        <button id="devBtnMountainReset" style="
                            padding: 5px 10px;
                            cursor: pointer;
                            border: none;
                            border-radius: 4px;
                            background: linear-gradient(180deg, #6366f1, #4f46e5);
                            color: #fff;
                            font-size: 11px;
                            font-weight: 500;
                        ">🔄 Reset</button>
                        <button id="devBtnMountainLog" style="
                            padding: 5px 10px;
                            cursor: pointer;
                            border: none;
                            border-radius: 4px;
                            background: linear-gradient(180deg, #22c55e, #16a34a);
                            color: #fff;
                            font-size: 11px;
                            font-weight: 500;
                        ">📋 Log Values</button>
                    </div>
                </div>
            </div>

            <!-- Performance Monitor Section -->
            <div class="dev-section">
                <div style="font-weight: 600; color: #10b981; margin-bottom: 6px; font-size: 11px;">📊 PERFORMANCE</div>
                <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px;">
                    <!-- FPS Graph -->
                    <div style="margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 10px; color: #4ade80;">🖥️ CPU (FPS)</span>
                            <span id="perfFpsValue" style="font-family: monospace; font-size: 10px; color: #4ade80;">-- fps</span>
                        </div>
                        <canvas id="perfFpsGraph" width="240" height="40" style="width: 100%; height: 40px; background: rgba(0,0,0,0.4); border-radius: 3px;"></canvas>
                    </div>
                    <!-- Memory Graph -->
                    <div style="margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 10px; color: #60a5fa;">💾 RAM (MB)</span>
                            <span id="perfMemValue" style="font-family: monospace; font-size: 10px; color: #60a5fa;">-- MB</span>
                        </div>
                        <canvas id="perfMemGraph" width="240" height="40" style="width: 100%; height: 40px; background: rgba(0,0,0,0.4); border-radius: 3px;"></canvas>
                    </div>
                    <!-- GPU Graph -->
                    <div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 10px; color: #f472b6;">🎮 GPU (Draws)</span>
                            <span id="perfGpuValue" style="font-family: monospace; font-size: 10px; color: #f472b6;">-- calls</span>
                        </div>
                        <canvas id="perfGpuGraph" width="240" height="40" style="width: 100%; height: 40px; background: rgba(0,0,0,0.4); border-radius: 3px;"></canvas>
                    </div>
                    <!-- GPU Details -->
                    <div id="perfGpuDetails" style="
                        margin-top: 8px;
                        font-family: monospace;
                        font-size: 9px;
                        color: #888;
                        line-height: 1.4;
                    ">Triangles: -- | Textures: --</div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(devPanelEl);

    // Performance Monitor 초기화
    const perfMonitor = {
        // 데이터 히스토리 (최근 60개 샘플)
        fpsHistory: [],
        memHistory: [],
        gpuHistory: [],
        maxSamples: 60,

        // FPS 계산용
        lastTime: performance.now(),
        frameCount: 0,
        currentFps: 0,

        // GPU 통계 캐시 (렌더링 직후 저장됨)
        cachedDrawCalls: 0,
        cachedTriangles: 0,
        cachedTextures: 0,

        // 그래프 캔버스
        fpsCanvas: null,
        memCanvas: null,
        gpuCanvas: null,
        fpsCtx: null,
        memCtx: null,
        gpuCtx: null,

        init() {
            this.fpsCanvas = document.getElementById('perfFpsGraph');
            this.memCanvas = document.getElementById('perfMemGraph');
            this.gpuCanvas = document.getElementById('perfGpuGraph');

            if (this.fpsCanvas) this.fpsCtx = this.fpsCanvas.getContext('2d');
            if (this.memCanvas) this.memCtx = this.memCanvas.getContext('2d');
            if (this.gpuCanvas) this.gpuCtx = this.gpuCanvas.getContext('2d');

            // 히스토리 초기화
            for (let i = 0; i < this.maxSamples; i++) {
                this.fpsHistory.push(0);
                this.memHistory.push(0);
                this.gpuHistory.push(0);
            }
        },

        // 프레임마다 호출 (FPS 계산)
        tick() {
            this.frameCount++;
            const now = performance.now();
            const elapsed = now - this.lastTime;

            if (elapsed >= 1000) {
                this.currentFps = Math.round((this.frameCount * 1000) / elapsed);
                this.frameCount = 0;
                this.lastTime = now;

                // 히스토리 업데이트
                this.fpsHistory.push(this.currentFps);
                if (this.fpsHistory.length > this.maxSamples) {
                    this.fpsHistory.shift();
                }
            }
        },

        // 렌더링 직후 GPU 통계 캡처 (renderer.info는 렌더 후 리셋됨)
        captureGpuStats() {
            if (renderer && renderer.info) {
                this.cachedDrawCalls = renderer.info.render.calls || 0;
                this.cachedTriangles = renderer.info.render.triangles || 0;
                this.cachedTextures = renderer.info.memory.textures || 0;
            }
        },

        // 1초마다 호출 (메모리, GPU 업데이트)
        update() {
            // Memory (Chrome only)
            let memMB = 0;
            if (performance.memory) {
                memMB = Math.round(performance.memory.usedJSHeapSize / (1024 * 1024));
            }
            this.memHistory.push(memMB);
            if (this.memHistory.length > this.maxSamples) {
                this.memHistory.shift();
            }

            // GPU (캐시된 값 사용 - 렌더링 직후 captureGpuStats()에서 저장됨)
            const drawCalls = this.cachedDrawCalls;
            const triangles = this.cachedTriangles;
            const textures = this.cachedTextures;
            this.gpuHistory.push(drawCalls);
            if (this.gpuHistory.length > this.maxSamples) {
                this.gpuHistory.shift();
            }

            // UI 업데이트
            const fpsVal = document.getElementById('perfFpsValue');
            const memVal = document.getElementById('perfMemValue');
            const gpuVal = document.getElementById('perfGpuValue');
            const gpuDetails = document.getElementById('perfGpuDetails');

            if (fpsVal) fpsVal.textContent = `${this.currentFps} fps`;
            if (memVal) memVal.textContent = `${memMB} MB`;
            if (gpuVal) gpuVal.textContent = `${drawCalls} calls`;
            if (gpuDetails) {
                gpuDetails.textContent = `Triangles: ${(triangles/1000).toFixed(1)}K | Textures: ${textures}`;
            }

            // 그래프 그리기
            this.drawGraph(this.fpsCtx, this.fpsHistory, '#4ade80', 120);  // max 120 fps
            this.drawGraph(this.memCtx, this.memHistory, '#60a5fa', 500);  // max 500 MB
            this.drawGraph(this.gpuCtx, this.gpuHistory, '#f472b6', 1000); // max 1000 calls
        },

        drawGraph(ctx, data, color, maxValue) {
            if (!ctx) return;

            const canvas = ctx.canvas;
            const w = canvas.width;
            const h = canvas.height;

            // 클리어
            ctx.clearRect(0, 0, w, h);

            // 그리드 라인
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 4; i++) {
                const y = (h / 4) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // 데이터 라인
            if (data.length < 2) return;

            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();

            const step = w / (this.maxSamples - 1);
            for (let i = 0; i < data.length; i++) {
                const x = i * step;
                const normalizedValue = Math.min(data[i] / maxValue, 1);
                const y = h - (normalizedValue * (h - 4)) - 2;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // 영역 채우기
            ctx.lineTo((data.length - 1) * step, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fillStyle = color.replace(')', ', 0.2)').replace('rgb', 'rgba');
            ctx.fill();
        }
    };

    // 초기화
    perfMonitor.init();

    // 패널 접기/펼치기
    let devPanelCollapsed = true;
    document.getElementById('devPanelToggle').addEventListener('click', () => {
        devPanelCollapsed = !devPanelCollapsed;
        document.getElementById('devPanelContent').style.display = devPanelCollapsed ? 'none' : 'flex';
        document.getElementById('devPanelToggle').textContent = devPanelCollapsed ? '+' : '−';
    });

    // 패널 드래그 이동
    let isDraggingPanel = false;
    let panelDragOffset = { x: 0, y: 0 };
    const devPanelHeader = document.getElementById('devPanelHeader');

    devPanelHeader.addEventListener('mousedown', (e) => {
        isDraggingPanel = true;
        const rect = devPanelEl.getBoundingClientRect();
        panelDragOffset.x = e.clientX - rect.left;
        panelDragOffset.y = e.clientY - rect.top;
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDraggingPanel) return;
        devPanelEl.style.left = (e.clientX - panelDragOffset.x) + 'px';
        devPanelEl.style.top = (e.clientY - panelDragOffset.y) + 'px';
        devPanelEl.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
        isDraggingPanel = false;
    });

    // 시간 조절 버튼 이벤트
    document.getElementById('devBtnDay').addEventListener('click', () => {
        timeState.gameTime = 12 * 3600;
        updateEnvironment();
    });
    document.getElementById('devBtnNight').addEventListener('click', () => {
        timeState.gameTime = 22 * 3600;
        updateEnvironment();
    });
    document.getElementById('devBtnSunrise').addEventListener('click', () => {
        timeState.gameTime = 6 * 3600;
        updateEnvironment();
    });
    document.getElementById('devBtnSunset').addEventListener('click', () => {
        timeState.gameTime = 18.5 * 3600;
        updateEnvironment();
    });

    // 시간 슬라이더
    const devTimeSlider = document.getElementById('devTimeSlider');
    const devTimeDisplay = document.getElementById('devTimeDisplay');
    devTimeSlider.addEventListener('input', () => {
        const hour = parseFloat(devTimeSlider.value);
        timeState.gameTime = hour * 3600;
        const h = Math.floor(hour);
        const m = Math.floor((hour - h) * 60);
        devTimeDisplay.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
        updateEnvironment();
    });

    // 차량 스폰 온오프 상태
    let vehicleSpawnEnabled = true;

    // 모든 차량 삭제 버튼 이벤트
    document.getElementById('devBtnDeleteAllVehicles').addEventListener('click', () => {
        if (trafficManager.initialized) {
            const count = trafficManager.vehicles.length;
            trafficManager.removeAllVehicles();
            toast({ title: '차량 삭제', desc: `${count}대의 차량을 삭제했습니다.`, success: true });
        } else {
            toast({ title: '트래픽 미초기화', desc: '트래픽 시스템이 아직 초기화되지 않았습니다.' });
        }
    });

    // 차량 스폰 온오프 체크박스 이벤트
    document.getElementById('devChkVehicleSpawn').addEventListener('change', (e) => {
        vehicleSpawnEnabled = e.target.checked;
        const label = e.target.nextElementSibling;
        label.textContent = vehicleSpawnEnabled ? '스폰 ON' : '스폰 OFF';
        label.style.color = vehicleSpawnEnabled ? '#4ade80' : '#ef4444';
        toast({ title: vehicleSpawnEnabled ? '스폰 활성화' : '스폰 비활성화', desc: vehicleSpawnEnabled ? '차량이 자동으로 생성됩니다.' : '차량이 더 이상 생성되지 않습니다.', success: vehicleSpawnEnabled });
    });

    // 화재 버튼 이벤트
    document.getElementById('devBtnStartFire').addEventListener('click', () => {
        if (selectedBuilding && selectedBuilding.userData) {
            const x = selectedBuilding.userData.tileX;
            const y = selectedBuilding.userData.tileY;
            const key = `${x},${y}`;
            if (!burningBuildings.has(key)) {
                startFire(x, y);
                toast({ title: '화재 발생', desc: `(${x}, ${y}) 건물에 화재가 발생했습니다.`, success: true });
            } else {
                toast({ title: '이미 화재 중', desc: '해당 건물은 이미 화재 중입니다.' });
            }
        } else {
            toast({ title: '건물 선택 필요', desc: '먼저 건물을 클릭하여 선택하세요.' });
        }
    });

    document.getElementById('devBtnExtinguishAll').addEventListener('click', () => {
        const keys = [...burningBuildings.keys()];
        keys.forEach(key => extinguishFire(key, true));
        toast({ title: '전체 진압', desc: `${keys.length}건의 화재를 진압했습니다.`, success: true });
    });

    // 강도 사건 버튼 이벤트
    document.getElementById('devBtnStartCrime').addEventListener('click', () => {
        if (selectedBuilding && selectedBuilding.userData) {
            const x = selectedBuilding.userData.tileX;
            const y = selectedBuilding.userData.tileY;
            const key = `${x},${y}`;
            const zoneType = selectedBuilding.userData.zoneType || '';
            const isCommercial = zoneType.includes('commercial');
            if (!activeCrimes.has(key)) {
                startCrime(x, y, isCommercial);
                toast({ title: '강도 사건 발생', desc: `(${x}, ${y}) 건물에서 강도 사건이 발생했습니다.`, success: true });
            } else {
                toast({ title: '이미 사건 진행 중', desc: '해당 건물에서 이미 사건이 진행 중입니다.' });
            }
        } else {
            toast({ title: '건물 선택 필요', desc: '먼저 건물을 클릭하여 선택하세요.' });
        }
    });

    document.getElementById('devBtnResolveAll').addEventListener('click', () => {
        const keys = [...activeCrimes.keys()];
        keys.forEach(key => resolveCrime(key, true));
        toast({ title: '전체 해결', desc: `${keys.length}건의 사건을 해결했습니다.`, success: true });
    });

    // 의료 응급 버튼 이벤트
    document.getElementById('devBtnStartMedical').addEventListener('click', () => {
        if (selectedBuilding && selectedBuilding.userData) {
            const x = selectedBuilding.userData.tileX;
            const y = selectedBuilding.userData.tileY;
            const key = `${x},${y}`;
            if (!activeMedicalEmergencies.has(key)) {
                startMedicalEmergency(x, y);
                toast({ title: '환자 발생', desc: `(${x}, ${y}) 건물에서 환자가 발생했습니다.`, success: true });
            } else {
                toast({ title: '이미 응급 상황', desc: '해당 건물에서 이미 응급 상황이 진행 중입니다.' });
            }
        } else {
            toast({ title: '건물 선택 필요', desc: '먼저 건물을 클릭하여 선택하세요.' });
        }
    });

    document.getElementById('devBtnResolveAllMedical').addEventListener('click', () => {
        const keys = [...activeMedicalEmergencies.keys()];
        keys.forEach(key => resolveMedicalEmergency(key, true));
        toast({ title: '전체 해결', desc: `${keys.length}건의 응급 상황을 해결했습니다.`, success: true });
    });

    // ========== Mountain Background 컨트롤 ==========
    document.getElementById('mountainScaleSlider').addEventListener('input', (e) => {
        if (mountainModel) {
            const scale = parseFloat(e.target.value);
            mountainModel.scale.setScalar(scale);
            updateMountainSliderLabels();
        }
    });

    document.getElementById('mountainHeightSlider').addEventListener('input', (e) => {
        if (mountainModel) {
            mountainModel.position.y = parseFloat(e.target.value);
            updateMountainSliderLabels();
        }
    });

    document.getElementById('mountainPosXSlider').addEventListener('input', (e) => {
        if (mountainModel) {
            mountainModel.position.x = parseFloat(e.target.value);
            updateMountainSliderLabels();
        }
    });

    document.getElementById('mountainPosZSlider').addEventListener('input', (e) => {
        if (mountainModel) {
            mountainModel.position.z = parseFloat(e.target.value);
            updateMountainSliderLabels();
        }
    });

    document.getElementById('devBtnMountainReset').addEventListener('click', () => {
        if (mountainModel) {
            mountainModel.scale.setScalar(mountainDefaults.scale);
            mountainModel.position.set(mountainDefaults.x, mountainDefaults.y, mountainDefaults.z);
            document.getElementById('mountainScaleSlider').value = mountainDefaults.scale;
            document.getElementById('mountainHeightSlider').value = mountainDefaults.y;
            document.getElementById('mountainPosXSlider').value = mountainDefaults.x;
            document.getElementById('mountainPosZSlider').value = mountainDefaults.z;
            updateMountainSliderLabels();
            toast({ title: '⛰️ Mountain Reset', desc: '기본값으로 초기화되었습니다.', success: true });
        }
    });

    document.getElementById('devBtnMountainLog').addEventListener('click', () => {
        if (mountainModel) {
            const scale = mountainModel.scale.x;
            const pos = mountainModel.position;
            console.log(`[Mountain] Scale: ${scale.toFixed(2)}, Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
            toast({
                title: '⛰️ Mountain Values',
                desc: `Scale: ${scale.toFixed(2)}, X: ${pos.x.toFixed(1)}, Y: ${pos.y.toFixed(1)}, Z: ${pos.z.toFixed(1)}`,
                success: true,
                ms: 5000
            });
        }
    });

    // 개발자 패널 업데이트 함수
    function updateDevPanel() {
        // Traffic System 정보
        const trafficContent = document.getElementById('trafficDebugContent');
        if (trafficManager.initialized) {
            const s = trafficManager.getStats();
            trafficContent.innerHTML = `
                Vehicles: ${s.activeVehicles}/${s.maxVehicles}<br>
                Roads: ${s.roadNodes} | Signals: ${s.signals}<br>
                Buildings: R${s.residential} C${s.commercial} I${s.industrial}<br>
                PathCache: ${s.pathCacheSize}
            `;
        } else {
            trafficContent.textContent = 'Initializing...';
        }

        // Fire System 정보
        const fireContent = document.getElementById('fireDebugContent');
        const fireCount = burningBuildings.size;
        const firetruckCount = dispatchedFiretrucks.size;
        fireContent.innerHTML = `
            Active Fires: ${fireCount}<br>
            Dispatched Trucks: ${firetruckCount}
        `;

        // Crime System 정보
        const crimeContent = document.getElementById('crimeDebugContent');
        const crimeCount = activeCrimes.size;
        const policeCarCount = dispatchedPoliceCars.size;
        const totalPrisoners = getTotalPrisoners();
        const totalCapacity = getTotalPrisonCapacity();
        crimeContent.innerHTML = `
            Active Crimes: ${crimeCount}<br>
            Dispatched Police: ${policeCarCount}<br>
            Prisoners: ${totalPrisoners}/${totalCapacity}
        `;

        // Medical System 정보
        const medicalContent = document.getElementById('medicalDebugContent');
        const medicalCount = activeMedicalEmergencies ? activeMedicalEmergencies.size : 0;
        const ambulanceCount = dispatchedAmbulances ? dispatchedAmbulances.size : 0;
        const totalPatients = getTotalPatients ? getTotalPatients() : 0;
        const totalBeds = getTotalHospitalCapacity ? getTotalHospitalCapacity() : 0;
        medicalContent.innerHTML = `
            Active Emergencies: ${medicalCount}<br>
            Dispatched Ambulances: ${ambulanceCount}<br>
            Patients: ${totalPatients}/${totalBeds}
        `;

        // 선택된 건물 정보
        const selectedContent = document.getElementById('devSelectedBuilding');
        if (selectedBuilding && selectedBuilding.userData) {
            const x = selectedBuilding.userData.tileX;
            const y = selectedBuilding.userData.tileY;
            const key = `${x},${y}`;
            const isBurning = burningBuildings.has(key);
            const hasCrime = activeCrimes.has(key);
            const hasMedical = activeMedicalEmergencies && activeMedicalEmergencies.has(key);
            const zoneType = selectedBuilding.userData.zoneType || 'Unknown';
            const isAbandoned = selectedBuilding.userData.isAbandoned || false;

            let statusText = '✅ 정상';
            if (isAbandoned) statusText = '🏚️ 폐건물';
            else if (isBurning) statusText = '🔥 화재 중';
            else if (hasCrime) statusText = '🚨 강도 중';
            else if (hasMedical) statusText = '💔 환자 발생';

            selectedContent.innerHTML = `
                Position: (${x}, ${y})<br>
                Type: ${zoneType}<br>
                Status: ${statusText}
            `;
        } else {
            selectedContent.textContent = 'None selected';
        }

        // 시간 슬라이더 동기화
        const currentHour = (timeState.gameTime / 3600) % 24;
        devTimeSlider.value = currentHour;
        const h = Math.floor(currentHour);
        const m = Math.floor((currentHour - h) * 60);
        devTimeDisplay.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;

        // 퍼포먼스 모니터 업데이트
        if (perfMonitor) perfMonitor.update();
    }

    // 1초마다 업데이트
    setInterval(updateDevPanel, 1000);

    // 차량 정보 팝업 HTML 생성
    const vehiclePopupEl = document.createElement('div');
    vehiclePopupEl.id = 'vehiclePopup';
    vehiclePopupEl.innerHTML = `
        <div class="vehicle-popup-header">
            <span class="vehicle-popup-icon">🚗</span>
            <span id="vehiclePopupTitle" class="vehicle-popup-title">시민</span>
            <div class="vehicle-popup-actions">
                <button id="vehicleFollowBtn" class="vehicle-follow-btn" title="따라가기">📍</button>
                <button id="vehiclePopupClose" class="vehicle-popup-close">✕</button>
            </div>
        </div>
        <div class="vehicle-popup-body">
            <div class="vehicle-popup-row activity-row">
                <span id="vehiclePopupActivity" class="vehicle-popup-activity">드라이브 중 🚗</span>
            </div>
            <div class="vehicle-popup-row">
                <span class="vehicle-popup-label">출발:</span>
                <span id="vehiclePopupOrigin" class="vehicle-popup-value origin-info">주거지</span>
            </div>
            <div class="vehicle-popup-row">
                <span class="vehicle-popup-label">도착:</span>
                <span id="vehiclePopupDest" class="vehicle-popup-value dest-info">상업지구</span>
            </div>
            <div class="vehicle-popup-row">
                <span class="vehicle-popup-label">속도:</span>
                <span id="vehiclePopupSpeed" class="vehicle-popup-value vehicle-speed">0 km/h</span>
            </div>
            <div class="vehicle-popup-row">
                <span class="vehicle-popup-label">진행:</span>
                <div class="vehicle-progress-bar">
                    <div id="vehiclePopupProgress" class="vehicle-progress-fill"></div>
                </div>
                <span id="vehiclePopupProgressText" class="vehicle-progress-text">0%</span>
            </div>
        </div>
    `;
    vehiclePopupEl.style.cssText = `
        position: fixed;
        display: none;
        background: rgba(30, 40, 60, 0.95);
        border: 1px solid #4a9eff;
        border-radius: 8px;
        padding: 0;
        min-width: 220px;
        z-index: 1001;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        font-family: 'Segoe UI', sans-serif;
        color: #fff;
    `;
    document.body.appendChild(vehiclePopupEl);

    // 차량 팝업 스타일 추가
    const vehiclePopupStyle = document.createElement('style');
    vehiclePopupStyle.textContent = `
        .vehicle-popup-header {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: rgba(74, 158, 255, 0.2);
            border-bottom: 1px solid rgba(74, 158, 255, 0.3);
            border-radius: 8px 8px 0 0;
        }
        .vehicle-popup-icon {
            font-size: 20px;
            margin-right: 8px;
        }
        .vehicle-popup-title {
            flex: 1;
            font-weight: bold;
            font-size: 14px;
        }
        .vehicle-popup-actions {
            display: flex;
            gap: 5px;
        }
        .vehicle-follow-btn {
            background: #4a9eff;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .vehicle-follow-btn:hover {
            background: #3a8eef;
        }
        .vehicle-follow-btn.active {
            background: #ff9500;
        }
        .vehicle-popup-close {
            background: transparent;
            border: none;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            padding: 2px 6px;
        }
        .vehicle-popup-close:hover {
            color: #fff;
        }
        .vehicle-popup-body {
            padding: 10px 12px;
        }
        .vehicle-popup-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 12px;
        }
        .vehicle-popup-label {
            color: #8899aa;
            min-width: 45px;
        }
        .vehicle-popup-value {
            color: #fff;
        }
        .vehicle-speed {
            color: #4aff4a;
            font-weight: bold;
        }
        .vehicle-status {
            font-weight: bold;
        }
        .vehicle-status.moving {
            color: #4aff4a;
        }
        .vehicle-status.signal {
            color: #ff4a4a;
        }
        .vehicle-status.vehicle {
            color: #ffa64a;
        }
        .route-info {
            color: #aabbcc;
            font-size: 11px;
        }
        .vehicle-progress-bar {
            flex: 1;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin: 0 8px;
            overflow: hidden;
        }
        .vehicle-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #4aff9e);
            border-radius: 4px;
            transition: width 0.3s;
        }
        .vehicle-progress-text {
            color: #4a9eff;
            font-size: 11px;
            min-width: 35px;
            text-align: right;
        }
    `;
    document.head.appendChild(vehiclePopupStyle);

    // 차량 팝업 이벤트
    document.getElementById('vehiclePopupClose').addEventListener('click', () => {
        trafficManager.deselectVehicle();
    });

    document.getElementById('vehicleFollowBtn').addEventListener('click', (e) => {
        const btn = e.target;
        if (trafficManager.followingVehicle) {
            trafficManager.stopFollowing();
            btn.classList.remove('active');
            btn.textContent = '📍';
        } else if (trafficManager.selectedVehicle) {
            trafficManager.startFollowing(trafficManager.selectedVehicle);
            btn.classList.add('active');
            btn.textContent = '⏹';
        }
    });

    // 차량 클릭 감지용 레이캐스터
    const vehicleRaycaster = new THREE.Raycaster();
    const vehicleMouse = new THREE.Vector2();

    // 차량 클릭 감지
    renderer.domElement.addEventListener('click', (e) => {
        if (currentMode !== MODE.CAMERA) return;

        vehicleMouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
        vehicleMouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;

        vehicleRaycaster.setFromCamera(vehicleMouse, camera);

        // 활성화된 차량의 메쉬만 체크
        const vehicleMeshes = trafficManager.vehicles
            .filter(v => v.isActive && v.mesh)
            .map(v => v.mesh);

        const intersects = vehicleRaycaster.intersectObjects(vehicleMeshes, true);

        if (intersects.length > 0) {
            // 클릭된 메쉬의 부모(차량 그룹) 찾기
            let clickedMesh = intersects[0].object;
            while (clickedMesh.parent && !trafficManager.vehicleGroup.children.includes(clickedMesh)) {
                clickedMesh = clickedMesh.parent;
            }

            // 해당 메쉬를 가진 차량 찾기
            const clickedVehicle = trafficManager.vehicles.find(v => v.mesh === clickedMesh);
            if (clickedVehicle) {
                trafficManager.selectVehicle(clickedVehicle);
                e.stopPropagation();
                return;
            }
        }
    });

    /* =========================================================
     * MODE SYSTEM
     * ========================================================= */
    const MODE = {
        CAMERA: "camera",
        BUILD: "build",
        BUILD_4LANE: "build_4lane",  // 4차로 도로 설치 모드
        WATER: "water",  // 수로 설치 모드
        DEMOLISH: "demolish",  // 도로/수로 철거 모드
        ZONE_RESIDENTIAL: "zone_residential",
        ZONE_COMMERCIAL: "zone_commercial",
        ZONE_INDUSTRIAL: "zone_industrial",
        ZONE_DELETE: "zone_delete",
        LAND_VALUE_VIEW: "land_value_view",  // 땅값 확인 모드
        POPULATION_VIEW: "population_view",  // 인구 확인 모드
        TRAFFIC_VIEW: "traffic_view",  // 교통량 확인 모드
        // 공공시설 설치 모드
        PLACE_SCHOOL: "place_school",
        PLACE_POLICE: "place_police",
        PLACE_FIRE: "place_fire",
        PLACE_PARK: "place_park",
        PLACE_HOSPITAL: "place_hospital",
        // 발전소 설치 모드
        PLACE_POWER_COAL: "place_power_coal",
        PLACE_POWER_WIND: "place_power_wind",
        // 전력 뷰 모드
        POWER_VIEW: "power_view",
        // 수도 시설 설치 모드
        PLACE_WATER_TOWER: "place_water_tower",
        PLACE_WATER_PUMP: "place_water_pump",
        // 수도 뷰 모드
        WATER_VIEW: "water_view",
    };
    let currentMode = MODE.CAMERA;
    let currentZoneType = null;

    // 철거 모드 독립 토글 (다른 모드와 공존 가능)
    let isDemolishModeActive = false;

    // 철거 모드와 공존 불가능한 모드 (건물 설치 모드)
    function isExclusiveWithDemolish(mode) {
        return mode === MODE.PLACE_SCHOOL ||
               mode === MODE.PLACE_POLICE ||
               mode === MODE.PLACE_FIRE ||
               mode === MODE.PLACE_PARK ||
               mode === MODE.PLACE_HOSPITAL ||
               mode === MODE.PLACE_POWER_COAL ||
               mode === MODE.PLACE_POWER_WIND;
    }

    // 설치 모드의 부모 모드 찾기 (설치 모드 -> 토글 모드)
    function getParentModeForPlacement(mode) {
        if (mode === MODE.PLACE_POWER_COAL || mode === MODE.PLACE_POWER_WIND) {
            return MODE.POWER_VIEW;  // 발전소 설치 -> 전력 뷰
        }
        // 기타 공공시설은 카메라 모드로
        return MODE.CAMERA;
    }

    // 철거 모드 토글
    function toggleDemolishMode() {
        const hint = document.getElementById('hint');
        const ghost = window.ghostMesh;  // ghost 참조

        if (isDemolishModeActive) {
            // 철거 모드 끄기
            isDemolishModeActive = false;
            if (btnDemolish) btnDemolish.classList.remove('active');
            // 현재 모드에 맞는 힌트로 복원
            updateHintForCurrentMode();
            // 회전 다시 활성화 (카메라 모드나 그래프 모드일 때만)
            const allowRotate = currentMode === MODE.CAMERA || currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW;
            controls.enableRotate = allowRotate;
            // 철거 하이라이트 제거
            clearDemolishHighlight();
            // Ctrl+철거 선택 프리뷰 제거
            ctrlDemolishSelectedRoads = [];
            clearLinePreview();
        } else {
            // 철거 모드 켜기 전에 건물 설치 모드면 부모 모드로 이동
            if (isExclusiveWithDemolish(currentMode)) {
                const parentMode = getParentModeForPlacement(currentMode);
                closeSubMenu();
                setMode(parentMode);
            }
            isDemolishModeActive = true;
            if (btnDemolish) btnDemolish.classList.add('active');
            // 철거 모드 힌트 표시
            if (hint) hint.textContent = "클릭/드래그로 도로/수로/건물 철거 (ESC로 취소)";
            if (ghost) ghost.material.color.set(0xff4444);
            // 격자 표시
            if (typeof gridHelper !== 'undefined') gridHelper.visible = true;
            // 회전 비활성화
            controls.enableRotate = false;
        }
    }

    // 현재 모드에 맞는 힌트 업데이트 (철거 모드 OFF 시 호출)
    function updateHintForCurrentMode() {
        const hint = document.getElementById('hint');
        const ghost = window.ghostMesh;
        if (!hint) return;

        if (currentMode === MODE.CAMERA) {
            hint.textContent = i18n.t('hint.camera');
            if (ghost) ghost.visible = false;
        } else if (currentMode === MODE.BUILD) {
            hint.textContent = i18n.t('hint.road');
        } else if (currentMode === MODE.BUILD_4LANE) {
            hint.textContent = "클릭으로 4차선 도로 설치 (2x2)";
            if (ghost) ghost.visible = false;  // 2x2 프리뷰 사용
        } else if (currentMode === MODE.WATER) {
            hint.textContent = "클릭/드래그로 수로 설치";
            if (ghost) ghost.material.color.set(0x4488ff);
        } else if (currentMode === MODE.ZONE_RESIDENTIAL) {
            hint.textContent = i18n.t('hint.residential');
        } else if (currentMode === MODE.ZONE_COMMERCIAL) {
            hint.textContent = i18n.t('hint.commercial');
        } else if (currentMode === MODE.ZONE_INDUSTRIAL) {
            hint.textContent = i18n.t('hint.industrial');
        } else if (currentMode === MODE.ZONE_DELETE) {
            hint.textContent = i18n.t('hint.delete');
        } else if (currentMode === MODE.POWER_VIEW) {
            hint.textContent = '전력 뷰 모드';
        }
        // 격자 가시성 업데이트
        if (typeof gridHelper !== 'undefined') {
            gridHelper.visible = (currentMode === MODE.BUILD || currentMode === MODE.BUILD_4LANE || currentMode === MODE.WATER || isPlacementMode(currentMode));
        }
    }

    // 철거 모드 강제 종료 (건물 설치 모드 진입 시 호출)
    function deactivateDemolishMode() {
        if (isDemolishModeActive) {
            isDemolishModeActive = false;
            if (btnDemolish) btnDemolish.classList.remove('active');
            // 회전 다시 활성화 (카메라 모드나 그래프 모드일 때만)
            const allowRotate = currentMode === MODE.CAMERA || currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW;
            controls.enableRotate = allowRotate;
            // 철거 하이라이트 제거
            clearDemolishHighlight();
            // Ctrl+철거 선택 프리뷰 제거
            ctrlDemolishSelectedRoads = [];
            clearLinePreview();
        }
    }

    // 구역 버튼 참조
    const btnZoneDelete = document.getElementById("btnZoneDelete");
    const btnZoneResidential = document.getElementById("btnZoneResidential");
    const btnZoneCommercial = document.getElementById("btnZoneCommercial");
    const btnZoneIndustrial = document.getElementById("btnZoneIndustrial");
    // btnWater removed - water is now in roads submenu

    function setMode(mode) {
        if (mode !== MODE.CAMERA && !MAP_CONFIG.isOwner) {
            toast({
                title: "편집 권한 없음",
                desc: "자신의 도시만 편집할 수 있습니다.",
            });
            return;
        }

        // 직선 프리뷰 제거
        clearLinePreview();

        // 프리뷰 그룹 제거 (4차선 도로 등)
        if (typeof clearPreviewGroup === 'function') {
            clearPreviewGroup();
        }

        // 이전 모드 저장 (효과 전환용)
        const prevMode = currentMode;

        // 카메라 모드에서 다른 모드로 전환시 팝업/아웃라인 숨기기
        if (prevMode === MODE.CAMERA && mode !== MODE.CAMERA) {
            hideBuildingPopup();
        }

        // === ViewModeManager를 통한 통합 뷰 모드 전환 처리 ===
        // 모드별 관련 뷰 타입 매핑
        const modeToViewType = {
            [MODE.LAND_VALUE_VIEW]: 'landValue',
            [MODE.POPULATION_VIEW]: 'population',
            [MODE.TRAFFIC_VIEW]: 'traffic',
            [MODE.POWER_VIEW]: 'power',
            [MODE.WATER_VIEW]: 'water'
        };

        // 모드 그룹 정의
        const zoneRelatedModes = [MODE.ZONE_RESIDENTIAL, MODE.ZONE_COMMERCIAL, MODE.ZONE_INDUSTRIAL,
                                  MODE.ZONE_DELETE, MODE.LAND_VALUE_VIEW, MODE.POPULATION_VIEW];
        const roadRelatedModes = [MODE.BUILD, MODE.BUILD_4LANE, MODE.WATER, MODE.TRAFFIC_VIEW];
        const waterRelatedModes = [MODE.WATER_VIEW, MODE.PLACE_WATER_TOWER, MODE.PLACE_WATER_PUMP];
        const powerRelatedModes = [MODE.POWER_VIEW, MODE.PLACE_POWER_COAL, MODE.PLACE_POWER_WIND];

        // 이전 뷰 모드에서 나갈 때 종료 처리
        const prevViewType = modeToViewType[prevMode];
        const newViewType = modeToViewType[mode];

        if (prevViewType && prevViewType !== newViewType) {
            ViewModeManager.exitViewMode(prevViewType);
        }

        // 모드 그룹 전환 시 관련 뷰 종료
        const prevIsZoneRelated = zoneRelatedModes.includes(prevMode);
        const newIsZoneRelated = zoneRelatedModes.includes(mode);
        if (prevIsZoneRelated && !newIsZoneRelated) {
            ViewModeManager.exitViewMode('landValue');
            ViewModeManager.exitViewMode('population');
        }

        const prevIsRoadRelated = roadRelatedModes.includes(prevMode);
        const newIsRoadRelated = roadRelatedModes.includes(mode);
        if (prevIsRoadRelated && !newIsRoadRelated) {
            ViewModeManager.exitViewMode('traffic');
        }

        const prevIsWaterRelated = waterRelatedModes.includes(prevMode);
        const newIsWaterRelated = waterRelatedModes.includes(mode);
        if (prevIsWaterRelated && !newIsWaterRelated) {
            ViewModeManager.exitViewMode('water');
            hideUtilityLegend();  // 수도 게이지 패널 숨기기
        }

        const prevIsPowerRelated = powerRelatedModes.includes(prevMode);
        const newIsPowerRelated = powerRelatedModes.includes(mode);
        if (prevIsPowerRelated && !newIsPowerRelated) {
            ViewModeManager.exitViewMode('power');
            hideUtilityLegend();  // 전력 게이지 패널 숨기기
        }

        // 건물 설치 모드에서 나갈 때 효과 복원 및 미리보기/서비스효과 숨김
        if (isPlacementMode(prevMode) && !isPlacementMode(mode)) {
            restorePlacementModeEffect();
            hideBuildingPreview();
            // 서비스 뷰 모드도 종료
            if (isServiceViewActive()) {
                exitServiceBuildingView();
            } else {
                clearServiceEffects();
            }
            costTooltip.style.display = 'none';
        }

        // 서비스 뷰가 활성화된 상태에서 비관련 모드로 전환 시 종료
        const serviceRelatedModes = [MODE.PLACE_FIRE, MODE.PLACE_POLICE, MODE.PLACE_SCHOOL,
                                     MODE.PLACE_HOSPITAL, MODE.PLACE_PARK, MODE.CAMERA];
        if (isServiceViewActive() && !serviceRelatedModes.includes(mode)) {
            exitServiceBuildingView();
        }

        // 건물 설치 모드 진입 시 철거 모드 비활성화 (상호 배제)
        if (isPlacementMode(mode)) {
            deactivateDemolishMode();
        }

        currentMode = mode;

        // 건설 모드일 때 카메라 회전만 비활성화 (좌클릭 드래그 충돌 방지)
        // 우클릭 이동은 활성화 유지
        // 철거 모드는 독립 토글이므로 isDemolishModeActive 사용
        const isConstructionMode = mode === MODE.BUILD || mode === MODE.BUILD_4LANE || mode === MODE.WATER ||
                                   isDemolishModeActive || mode === MODE.ZONE_DELETE ||
                                   isZoneMode() || isPlacementMode(mode);
        controls.enableRotate = !isConstructionMode;

        // Clear all active states first
        clearToolButtonActive();

        // Set active state for current mode (bottom bar buttons)
        btnCam.classList.toggle("active", mode === MODE.CAMERA);
        if (btnBuild) btnBuild.classList.toggle("active", mode === MODE.BUILD || mode === MODE.BUILD_4LANE);
        // 철거 버튼은 독립 토글이므로 isDemolishModeActive로 관리 (setMode에서 건드리지 않음)

        // Zone modes - activate the Zones button
        if (isZoneMode()) {
            if (btnZones) btnZones.classList.add("active");
        }

        // Placement modes - activate individual buttons
        if (mode === MODE.PLACE_POLICE && btnPolice) btnPolice.classList.add("active");
        if (mode === MODE.PLACE_FIRE && btnFire) btnFire.classList.add("active");
        if (mode === MODE.PLACE_SCHOOL && btnSchool) btnSchool.classList.add("active");
        if (mode === MODE.PLACE_HOSPITAL && btnHospital) btnHospital.classList.add("active");
        if (mode === MODE.PLACE_PARK && btnParkBtn) btnParkBtn.classList.add("active");

        // Power modes - activate power button
        const isPowerMode = mode === MODE.PLACE_POWER_COAL || mode === MODE.PLACE_POWER_WIND || mode === MODE.POWER_VIEW;
        if (isPowerMode && btnPower) btnPower.classList.add("active");

        // Legacy buttons (hidden)
        if (btnZoneResidential) btnZoneResidential.classList.toggle("active", mode === MODE.ZONE_RESIDENTIAL);
        if (btnZoneCommercial) btnZoneCommercial.classList.toggle("active", mode === MODE.ZONE_COMMERCIAL);
        if (btnZoneIndustrial) btnZoneIndustrial.classList.toggle("active", mode === MODE.ZONE_INDUSTRIAL);
        if (btnZoneDelete) btnZoneDelete.classList.toggle("active", mode === MODE.ZONE_DELETE);

        // 회전은 카메라/그래프 모드에서만, 이동은 항상 가능 (줌은 커스텀 핸들러 사용)
        // 철거 모드일 때는 회전 비활성화
        controls.enabled = true;  // 컨트롤 항상 활성화
        const allowRotate = (mode === MODE.CAMERA || mode === MODE.LAND_VALUE_VIEW || mode === MODE.POPULATION_VIEW) && !isDemolishModeActive;
        controls.enableRotate = allowRotate;
        controls.enableZoom = false;  // 커스텀 줌 사용
        controls.enablePan = true;

        // 격자 가시성 - 도로/수로/철거/건물 설치 모드에서 표시
        gridHelper.visible = (mode === MODE.BUILD || mode === MODE.BUILD_4LANE || mode === MODE.WATER || isDemolishModeActive || isPlacementMode(mode));

        // 구역 메시 가시성 - 구역 모드에서만 보이게
        const showZones = isZoneMode() || mode === MODE.ZONE_DELETE;
        residentialMesh.visible = showZones;
        commercialMesh.visible = showZones;
        industrialMesh.visible = showZones;

        // 구역/수치 모드 진입/퇴장 시 오브젝트 색상 변경
        // 땅값 뷰는 자체 색상 시스템 사용 (빨강-흰색-초록 그라데이션)
        const showWhiteEffect = showZones || mode === MODE.POPULATION_VIEW;
        if (showWhiteEffect) {
            applyZoneModeEffect();
        } else if (mode !== MODE.LAND_VALUE_VIEW) {
            // 땅값 뷰가 아닐 때만 복원 (땅값 뷰는 자체적으로 복원)
            restoreOriginalMaterials();
        }

        // 좌측 사이드바 - 구역 모드일 때만 표시 (땅값/인구 토글 버튼)
        if (leftSidebar) {
            const showLeftSidebar = isZoneMode() || mode === MODE.ZONE_DELETE ||
                                    mode === MODE.LAND_VALUE_VIEW || mode === MODE.POPULATION_VIEW;
            if (showLeftSidebar) {
                leftSidebar.classList.add('visible');
            } else {
                leftSidebar.classList.remove('visible');
                // 땅값/인구 뷰 종료
                if (isLandValueViewActive) exitLandValueView();
                if (isPopulationViewActive) exitPopulationView();
            }
        }

        // 구역 모드 단축키 힌트 패널 표시/숨김
        const zoneModeHint = document.getElementById('zoneModeHint');
        if (zoneModeHint) {
            if (isZoneMode()) {
                zoneModeHint.classList.add('visible');
            } else {
                zoneModeHint.classList.remove('visible');
            }
        }

        // 구역 모드 범례 표시/숨김
        const isZoneModeNow = isZoneMode() || mode === MODE.ZONE_DELETE;
        const wasZoneMode = prevMode === MODE.ZONE_RESIDENTIAL || prevMode === MODE.ZONE_COMMERCIAL ||
                           prevMode === MODE.ZONE_INDUSTRIAL || prevMode === MODE.ZONE_DELETE;
        if (isZoneModeNow && !wasZoneMode) {
            // 구역 모드 진입 시 범례 표시
            showDataViewLegend('zone');
        } else if (!isZoneModeNow && wasZoneMode) {
            // 구역 모드 퇴장 시 범례 숨김 (다른 뷰 모드가 아닐 때만)
            if (mode !== MODE.LAND_VALUE_VIEW && mode !== MODE.POPULATION_VIEW && mode !== MODE.TRAFFIC_VIEW) {
                hideDataViewLegend();
            }
        }

        // 도로 모드 우측 사이드바 표시/숨김
        if (rightSidebarRoad) {
            if (mode === MODE.BUILD || mode === MODE.BUILD_4LANE || mode === MODE.WATER || mode === MODE.TRAFFIC_VIEW) {
                rightSidebarRoad.classList.add('visible');
            } else {
                rightSidebarRoad.classList.remove('visible');
                if (btnTrafficView) btnTrafficView.classList.remove('active');
                // 교통량 뷰 종료
                if (typeof hideTrafficView === 'function') {
                    hideTrafficView();
                }
            }
        }

        // 전력 모드 시각화 업데이트
        if (powerManager.initialized) {
            powerManager.updatePowerVisualization();
        }

        // 현재 구역 타입 설정
        if (mode === MODE.ZONE_RESIDENTIAL) {
            currentZoneType = CELL.ZONE_RESIDENTIAL;
        } else if (mode === MODE.ZONE_COMMERCIAL) {
            currentZoneType = CELL.ZONE_COMMERCIAL;
        } else if (mode === MODE.ZONE_INDUSTRIAL) {
            currentZoneType = CELL.ZONE_INDUSTRIAL;
        } else if (mode === MODE.ZONE_DELETE) {
            currentZoneType = CELL.EMPTY;
        } else {
            currentZoneType = null;
        }

        // X 버튼 표시/숨김 (카메라 모드 제외 모든 모드에서 표시)
        if (btnExitMode) {
            btnExitMode.style.display = (mode === MODE.CAMERA) ? 'none' : 'block';
        }

        // hintContainer 표시/숨김 (전력 건물 설치 모드에서만 표시)
        const isPowerPlacementMode = mode === MODE.PLACE_POWER_COAL || mode === MODE.PLACE_POWER_WIND;
        const isWaterPlacementMode = mode === MODE.PLACE_WATER_TOWER || mode === MODE.PLACE_WATER_PUMP;
        if (hintContainer) {
            if (isPowerPlacementMode || isWaterPlacementMode) {
                hintContainer.classList.add('visible');
            } else {
                hintContainer.classList.remove('visible');
            }
        }

        // 힌트 텍스트 업데이트
        if (mode === MODE.CAMERA) {
            hint.textContent = MAP_CONFIG.isOwner
                ? i18n.t('hint.camera')
                : i18n.t('hint.viewOnly', { username: MAP_CONFIG.username });
            ghost.visible = false;
            setPreviewPath(null);
            set4LanePathPreview(null);
            isBuildDragging = false;
            isDemolishDragging = false;
            buildStart = null;
            currentPath = null;
            current4LanePath = null;
            costTooltip.style.display = 'none';
            // 구역 모드에서 벗어날 때 투명도 다시 활성화, emissive 리셋
            ghost.material.transparent = true;
            ghost.material.opacity = 0.35;
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
        } else if (mode === MODE.BUILD) {
            hint.textContent = i18n.t('hint.road');
            ghost.material.transparent = true;
            ghost.material.opacity = 0.35;
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
        } else if (mode === MODE.BUILD_4LANE) {
            hint.textContent = "드래그로 4차선 도로 설치 (2x2)";
            ghost.visible = false;  // 2x2 프리뷰 사용
        } else if (mode === MODE.WATER) {
            hint.textContent = "클릭/드래그로 수로 설치";
            ghost.material.color.set(0x4488ff);  // 파란색
            ghost.material.transparent = true;
            ghost.material.opacity = 0.35;
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
        } else if (mode === MODE.ZONE_RESIDENTIAL) {
            hint.textContent = i18n.t('hint.residential');
            ghost.material.color.set(ZONE_COLORS[CELL.ZONE_RESIDENTIAL]);
            ghost.material.emissive.set(ZONE_COLORS[CELL.ZONE_RESIDENTIAL]);
            ghost.material.emissiveIntensity = 0.5;
            ghost.material.transparent = false;  // 구역 프리뷰 투명도 제거
        } else if (mode === MODE.ZONE_COMMERCIAL) {
            hint.textContent = i18n.t('hint.commercial');
            ghost.material.color.set(ZONE_COLORS[CELL.ZONE_COMMERCIAL]);
            ghost.material.emissive.set(ZONE_COLORS[CELL.ZONE_COMMERCIAL]);
            ghost.material.emissiveIntensity = 0.5;
            ghost.material.transparent = false;
        } else if (mode === MODE.ZONE_INDUSTRIAL) {
            hint.textContent = i18n.t('hint.industrial');
            ghost.material.color.set(ZONE_COLORS[CELL.ZONE_INDUSTRIAL]);
            ghost.material.emissive.set(ZONE_COLORS[CELL.ZONE_INDUSTRIAL]);
            ghost.material.emissiveIntensity = 0.5;
            ghost.material.transparent = false;
        } else if (mode === MODE.ZONE_DELETE) {
            hint.textContent = i18n.t('hint.delete');
            ghost.material.color.set(0xff4444);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            ghost.material.transparent = true;  // 삭제 모드는 투명도 유지
        } else if (mode === MODE.LAND_VALUE_VIEW) {
            hint.textContent = '땅값 보기 모드 (ESC로 종료)';
            ghost.visible = false;
        } else if (mode === MODE.POPULATION_VIEW) {
            hint.textContent = '인구 보기 모드 (ESC로 종료)';
            ghost.visible = false;
        } else if (mode === MODE.TRAFFIC_VIEW) {
            hint.textContent = '교통량 보기 모드 (ESC로 종료)';
            ghost.visible = false;
        } else if (mode === MODE.PLACE_SCHOOL) {
            hint.textContent = '클릭으로 학교 설치 (2x2) - ₩4,000';
            ghost.material.color.set(0x4488ff);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('school');
            showServiceEffects('school');
        } else if (mode === MODE.PLACE_POLICE) {
            hint.textContent = '클릭으로 경찰서 설치 (1x1) - ₩3,000';
            ghost.material.color.set(0x4488ff);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('police');
            showServiceEffects('police');
        } else if (mode === MODE.PLACE_FIRE) {
            hint.textContent = '클릭으로 소방서 설치 (1x1) - ₩3,000';
            ghost.material.color.set(0xff6644);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('fire');
            showServiceEffects('fire');
        } else if (mode === MODE.PLACE_PARK) {
            hint.textContent = '클릭으로 공원 설치 (2x2) - ₩1,000';
            ghost.material.color.set(0x44cc66);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('park');
            showServiceEffects('park');
        } else if (mode === MODE.PLACE_HOSPITAL) {
            hint.textContent = '클릭으로 병원 설치 (2x2) - ₩6,000';
            ghost.material.color.set(0xff6688);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            applyPlacementModeEffect('hospital');
            showServiceEffects('hospital');
        } else if (mode === MODE.PLACE_POWER_COAL) {
            hint.textContent = '클릭으로 화력 발전소 설치 (2x2) - ₩5,000';
            ghost.material.color.set(0xffcc00);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            // 전력 뷰가 이미 활성화되어 있으므로 placement effect는 적용하지 않음
            // 서비스 효과 범위 그라데이션 제거
            clearServiceEffects();
            powerManager.recalculatePowerGrid();
        } else if (mode === MODE.PLACE_POWER_WIND) {
            hint.textContent = '클릭으로 풍력 발전기 설치 (1x1) - ₩3,000';
            ghost.material.color.set(0xffcc00);
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            // 전력 뷰가 이미 활성화되어 있으므로 placement effect는 적용하지 않음
            // 서비스 효과 범위 그라데이션 제거
            clearServiceEffects();
            powerManager.recalculatePowerGrid();
        } else if (mode === MODE.POWER_VIEW) {
            hint.textContent = '전력 사용량 뷰 - 발전소를 선택하여 설치하세요 (ESC로 종료)';
            ghost.visible = false;
            powerManager.recalculatePowerGrid();
        } else if (mode === MODE.PLACE_WATER_TOWER) {
            hint.textContent = '클릭으로 급수탑 설치 (2x2) - ₩4,000';
            ghost.material.color.set(0x87CEEB);  // 하늘색
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            // 수도 뷰가 이미 활성화되어 있으므로 placement effect는 적용하지 않음
            clearServiceEffects();
            waterManager.recalculateWaterGrid();
        } else if (mode === MODE.PLACE_WATER_PUMP) {
            hint.textContent = '클릭으로 펌프장 설치 (1x1) - ₩2,000';
            ghost.material.color.set(0x87CEEB);  // 하늘색
            ghost.material.emissive.set(0x000000);
            ghost.material.emissiveIntensity = 0;
            clearServiceEffects();
            waterManager.recalculateWaterGrid();
        } else if (mode === MODE.WATER_VIEW) {
            hint.textContent = '수도 사용량 뷰 - 수도시설을 선택하여 설치하세요 (ESC로 종료)';
            ghost.visible = false;
            waterManager.recalculateWaterGrid();
        }
    }

    // 건물 설치 모드인지 확인
    function isPlacementMode(mode) {
        return mode === MODE.PLACE_SCHOOL ||
               mode === MODE.PLACE_POLICE ||
               mode === MODE.PLACE_FIRE ||
               mode === MODE.PLACE_PARK ||
               mode === MODE.PLACE_HOSPITAL ||
               mode === MODE.PLACE_POWER_COAL ||
               mode === MODE.PLACE_POWER_WIND ||
               mode === MODE.PLACE_WATER_TOWER ||
               mode === MODE.PLACE_WATER_PUMP;
    }

    // 현재 설치 중인 건물 타입 가져오기
    function getCurrentPlacementType() {
        switch(currentMode) {
            case MODE.PLACE_SCHOOL: return 'school';
            case MODE.PLACE_POLICE: return 'police';
            case MODE.PLACE_FIRE: return 'fire';
            case MODE.PLACE_PARK: return 'park';
            case MODE.PLACE_HOSPITAL: return 'hospital';
            case MODE.PLACE_POWER_COAL: return 'powerplant_coal';
            case MODE.PLACE_POWER_WIND: return 'powerplant_wind';
            case MODE.PLACE_WATER_TOWER: return 'water_tower';
            case MODE.PLACE_WATER_PUMP: return 'water_pump';
            default: return null;
        }
    }

    /* =========================================================
     * TRAFFIC VIEW SYSTEM (교통량 뷰)
     * ========================================================= */
    const trafficViewGroup = new THREE.Group();
    scene.add(trafficViewGroup);
    let isTrafficViewActive = false;

    // 둥근 모서리 박스 지오메트리 생성
    function createRoundedBoxGeometry(width, height, depth, radius) {
        const shape = new THREE.Shape();
        const w = width / 2 - radius;
        const d = depth / 2 - radius;

        shape.moveTo(-w, -depth / 2);
        shape.lineTo(w, -depth / 2);
        shape.quadraticCurveTo(width / 2, -depth / 2, width / 2, -d);
        shape.lineTo(width / 2, d);
        shape.quadraticCurveTo(width / 2, depth / 2, w, depth / 2);
        shape.lineTo(-w, depth / 2);
        shape.quadraticCurveTo(-width / 2, depth / 2, -width / 2, d);
        shape.lineTo(-width / 2, -d);
        shape.quadraticCurveTo(-width / 2, -depth / 2, -w, -depth / 2);

        const extrudeSettings = {
            depth: height,
            bevelEnabled: false,
        };

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.rotateX(-Math.PI / 2);
        geometry.translate(0, height / 2, 0);
        return geometry;
    }

    // 도로 직선 구간 탐지 (가로/세로 연속 도로)
    function detectRoadSegments() {
        const segments = [];
        const visitedH = new Set();  // 가로 방향 방문 기록
        const visitedV = new Set();  // 세로 방향 방문 기록

        // 도로인지 확인
        function isRoadTile(x, y) {
            if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return false;
            const cell = grid[y][x];
            return cell === CELL.ROAD || cell === CELL.LOCKED_ROAD;
        }

        // 가로 방향 연속 도로 탐지
        for (let y = 0; y < GRID_H; y++) {
            let segmentStart = -1;
            for (let x = 0; x <= GRID_W; x++) {
                const isRoad = x < GRID_W && isRoadTile(x, y);
                // 가로 연결이 있는 도로 (좌우에 도로가 있거나, 단독 가로 도로)
                const hasHorizontalConnection = isRoad && (isRoadTile(x - 1, y) || isRoadTile(x + 1, y));

                if (hasHorizontalConnection && segmentStart === -1) {
                    segmentStart = x;
                } else if ((!hasHorizontalConnection || !isRoad) && segmentStart !== -1) {
                    const endX = x - 1;
                    if (endX >= segmentStart) {
                        segments.push({
                            type: 'horizontal',
                            startX: segmentStart,
                            endX: endX,
                            y: y
                        });
                    }
                    segmentStart = -1;
                }
            }
        }

        // 세로 방향 연속 도로 탐지
        for (let x = 0; x < GRID_W; x++) {
            let segmentStart = -1;
            for (let y = 0; y <= GRID_H; y++) {
                const isRoad = y < GRID_H && isRoadTile(x, y);
                // 세로 연결이 있는 도로 (상하에 도로가 있거나, 단독 세로 도로)
                const hasVerticalConnection = isRoad && (isRoadTile(x, y - 1) || isRoadTile(x, y + 1));

                if (hasVerticalConnection && segmentStart === -1) {
                    segmentStart = y;
                } else if ((!hasVerticalConnection || !isRoad) && segmentStart !== -1) {
                    const endY = y - 1;
                    if (endY >= segmentStart) {
                        segments.push({
                            type: 'vertical',
                            x: x,
                            startY: segmentStart,
                            endY: endY
                        });
                    }
                    segmentStart = -1;
                }
            }
        }

        return segments;
    }

    // 교통량 히트맵 (DataTexture 기반 그라데이션)
    let trafficTexture = null;
    let trafficTextureData = null;
    let trafficPlane = null;
    let trafficOutline = null;

    // 혼잡도 → RGB 색상 (0~255)
    function getCongestionRGB(congestion) {
        // 녹색(0) → 노란색(0.5) → 빨간색(1)
        if (congestion <= 0.5) {
            const t = congestion * 2;
            return {
                r: Math.floor(t * 255),
                g: 255,
                b: 0
            };
        } else {
            const t = (congestion - 0.5) * 2;
            return {
                r: 255,
                g: Math.floor((1 - t) * 255),
                b: 0
            };
        }
    }

    // 도로인지 체크
    function isRoadCell(gx, gy) {
        if (gx < 0 || gx >= GRID_W || gy < 0 || gy >= GRID_H) return false;
        const cell = grid[gx][gy];
        return cell === CELL.ROAD || cell === CELL.LOCKED_ROAD;
    }

    // 교통량 텍스처 생성
    function createTrafficTexture() {
        trafficTextureData = new Uint8Array(GRID_W * GRID_H * 4);

        // 초기화 (모두 투명)
        for (let i = 0; i < GRID_W * GRID_H * 4; i += 4) {
            trafficTextureData[i] = 0;
            trafficTextureData[i + 1] = 0;
            trafficTextureData[i + 2] = 0;
            trafficTextureData[i + 3] = 0;
        }

        trafficTexture = new THREE.DataTexture(
            trafficTextureData,
            GRID_W,
            GRID_H,
            THREE.RGBAFormat
        );
        trafficTexture.magFilter = THREE.NearestFilter;  // 타일 기반 (픽셀화)
        trafficTexture.minFilter = THREE.NearestFilter;
        trafficTexture.needsUpdate = true;

        return trafficTexture;
    }

    // 교통량 텍스처 업데이트
    function updateTrafficTexture() {
        if (!trafficTexture || !trafficTextureData) return;

        const baseOpacity = 200;

        for (let gy = 0; gy < GRID_H; gy++) {
            for (let gx = 0; gx < GRID_W; gx++) {
                // 텍스처 좌표 (Y축 뒤집기 - Three.js 텍스처 좌표계)
                const idx = ((GRID_H - 1 - gy) * GRID_W + gx) * 4;

                if (isRoadCell(gx, gy)) {
                    const key = `${gx},${gy}`;
                    const congestion = trafficManager.initialized
                        ? (trafficManager.congestionMap.get(key) || 0)
                        : 0;

                    const rgb = getCongestionRGB(congestion);
                    trafficTextureData[idx] = rgb.r;
                    trafficTextureData[idx + 1] = rgb.g;
                    trafficTextureData[idx + 2] = rgb.b;
                    trafficTextureData[idx + 3] = baseOpacity;
                } else {
                    // 도로가 아닌 곳은 투명
                    trafficTextureData[idx] = 0;
                    trafficTextureData[idx + 1] = 0;
                    trafficTextureData[idx + 2] = 0;
                    trafficTextureData[idx + 3] = 0;
                }
            }
        }

        trafficTexture.needsUpdate = true;
    }

    // 도로 아웃라인 생성 (샤프한 경계선)
    function createTrafficOutline() {
        const positions = [];
        const height = 0.12;

        for (let gy = 0; gy < GRID_H; gy++) {
            for (let gx = 0; gx < GRID_W; gx++) {
                if (!isRoadCell(gx, gy)) continue;

                // ORIGIN 오프셋 적용 (그리드 중심이 0,0이 되도록)
                const x0 = (ORIGIN_X + gx) * TILE_SIZE;
                const x1 = (ORIGIN_X + gx + 1) * TILE_SIZE;
                const z0 = (ORIGIN_Z + gy) * TILE_SIZE;
                const z1 = (ORIGIN_Z + gy + 1) * TILE_SIZE;

                // 상단 경계 (gy-1이 도로가 아닐 때)
                if (!isRoadCell(gx, gy - 1)) {
                    positions.push(x0, height, z0, x1, height, z0);
                }
                // 하단 경계 (gy+1이 도로가 아닐 때)
                if (!isRoadCell(gx, gy + 1)) {
                    positions.push(x0, height, z1, x1, height, z1);
                }
                // 좌측 경계 (gx-1이 도로가 아닐 때)
                if (!isRoadCell(gx - 1, gy)) {
                    positions.push(x0, height, z0, x0, height, z1);
                }
                // 우측 경계 (gx+1이 도로가 아닐 때)
                if (!isRoadCell(gx + 1, gy)) {
                    positions.push(x1, height, z0, x1, height, z1);
                }
            }
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        const material = new THREE.LineBasicMaterial({
            color: 0x000000,
            linewidth: 2,
            transparent: true,
            opacity: 0.8
        });

        return new THREE.LineSegments(geometry, material);
    }

    // 교통량 뷰 표시
    function showTrafficView() {
        if (isTrafficViewActive) return;
        isTrafficViewActive = true;

        // Bloom 효과 끄기
        if (typeof bloomPass !== 'undefined') {
            bloomPass.enabled = false;
        }

        // 다른 수치 모드처럼 오브젝트를 흰색으로 변경
        applyZoneModeEffect();

        // 범례 패널 표시
        showDataViewLegend('traffic');

        // 기존 제거
        while (trafficViewGroup.children.length > 0) {
            const child = trafficViewGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (child.material.map) {
                    child.material.map.dispose();
                    child.material.map = null;
                }
                child.material.dispose();
            }
            trafficViewGroup.remove(child);
        }

        // 텍스처 생성
        createTrafficTexture();
        updateTrafficTexture();

        // 평면 생성 (각 타일에 맞게 UV 조정)
        const planeWidth = GRID_W * TILE_SIZE;
        const planeHeight = GRID_H * TILE_SIZE;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

        const material = new THREE.MeshBasicMaterial({
            map: trafficTexture,
            transparent: true,
            opacity: 0,
            depthWrite: false
        });

        trafficPlane = new THREE.Mesh(geometry, material);
        trafficPlane.rotation.x = -Math.PI / 2;  // 수평으로 눕히기
        // 평면 중심이 그리드 중심에 오도록 배치 (ORIGIN이 -GRID/2이므로 중심은 0,0)
        trafficPlane.position.set(0, 0.06, 0);

        trafficViewGroup.add(trafficPlane);

        // 샤프한 아웃라인 추가
        trafficOutline = createTrafficOutline();
        trafficOutline.material.opacity = 0;
        trafficViewGroup.add(trafficOutline);

        trafficViewGroup.visible = true;

        // 페이드인 애니메이션
        const duration = 400;
        const startTime = performance.now();

        function animateFadeIn(time) {
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);

            if (trafficPlane && trafficPlane.material) {
                trafficPlane.material.opacity = eased * 0.85;
            }
            if (trafficOutline && trafficOutline.material) {
                trafficOutline.material.opacity = eased * 0.9;
            }

            if (progress < 1 && isTrafficViewActive) {
                requestAnimationFrame(animateFadeIn);
            }
        }
        requestAnimationFrame(animateFadeIn);
    }

    // 교통량 뷰 실시간 업데이트
    function updateTrafficView() {
        if (!isTrafficViewActive || !trafficManager.initialized) return;
        if (!trafficTexture) return;

        updateTrafficTexture();
    }

    // 교통량 뷰 숨기기
    function hideTrafficView() {
        // ViewModeManager에 위임
        ViewModeManager.exitViewMode('traffic');
    }

    // 교통량 뷰 버튼 이벤트
    if (btnTrafficView) {
        btnTrafficView.addEventListener('click', () => {
            if (isTrafficViewActive) {
                hideTrafficView();
                btnTrafficView.classList.remove('active');
                setMode(MODE.BUILD);
            } else {
                showTrafficView();
                btnTrafficView.classList.add('active');
                setMode(MODE.TRAFFIC_VIEW);
            }
        });
    }

    // 현재 모드가 카메라가 아니면 카메라 모드로 전환 (서브메뉴 열기 전 정리용)
    function exitCurrentModeIfNeeded() {
        if (currentMode !== MODE.CAMERA) {
            closeSubMenu();
            setMode(MODE.CAMERA);
        }
    }

    btnCam.addEventListener("click", () => {
        closeSubMenu();
        setMode(MODE.CAMERA);
    });

    // 카메라 설정 패널 기능
    const cameraSettingsPanel = document.getElementById('cameraSettingsPanel');
    const cameraSettingsClose = document.getElementById('cameraSettingsClose');
    const minZoomSlider = document.getElementById('minZoomSlider');
    const maxZoomSlider = document.getElementById('maxZoomSlider');
    const minAngleSlider = document.getElementById('minAngleSlider');
    const maxAngleSlider = document.getElementById('maxAngleSlider');
    const minZoomValue = document.getElementById('minZoomValue');
    const maxZoomValue = document.getElementById('maxZoomValue');
    const minAngleValue = document.getElementById('minAngleValue');
    const maxAngleValue = document.getElementById('maxAngleValue');
    const cameraResetBtn = document.getElementById('cameraResetBtn');

    // 카메라 기본값 (원근 카메라용)
    const CAMERA_DEFAULTS = {
        minDistance: 0.1,  // 가까이
        maxDistance: 80,  // 멀리
        minAngle: 0,
        maxAngle: 89
    };

    // 카메라 버튼 우클릭으로 설정 패널 열기
    btnCam.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const isVisible = cameraSettingsPanel.style.display === 'block';
        cameraSettingsPanel.style.display = isVisible ? 'none' : 'block';
    });

    // 설정 패널 닫기
    if (cameraSettingsClose) {
        cameraSettingsClose.addEventListener('click', () => {
            cameraSettingsPanel.style.display = 'none';
        });
    }

    // 최소 거리 슬라이더 (원근 카메라용 - 가까이)
    if (minZoomSlider) {
        minZoomSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);  // 슬라이더 값 그대로 사용
            controls.minDistance = value;
            minZoomValue.textContent = value.toFixed(1);
            // 현재 거리가 최소보다 작으면 조정
            if (targetCameraDistance < value) {
                targetCameraDistance = value;
            }
        });
    }

    // 최대 거리 슬라이더 (원근 카메라용 - 멀리)
    if (maxZoomSlider) {
        maxZoomSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);  // 슬라이더 값 그대로 사용
            controls.maxDistance = value;
            maxZoomValue.textContent = value.toFixed(0);
            // 현재 거리가 최대보다 크면 조정
            if (targetCameraDistance > value) {
                targetCameraDistance = value;
            }
        });
    }

    // 최소 각도 슬라이더
    if (minAngleSlider) {
        minAngleSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            controls.minPolarAngle = value * Math.PI / 180;
            minAngleValue.textContent = value + '°';
        });
    }

    // 최대 각도 슬라이더
    if (maxAngleSlider) {
        maxAngleSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            controls.maxPolarAngle = value * Math.PI / 180;
            maxAngleValue.textContent = value + '°';
        });
    }

    // 기본값 초기화 버튼
    if (cameraResetBtn) {
        cameraResetBtn.addEventListener('click', () => {
            // 슬라이더 값 초기화
            minZoomSlider.value = CAMERA_DEFAULTS.minDistance;
            maxZoomSlider.value = CAMERA_DEFAULTS.maxDistance;
            minAngleSlider.value = CAMERA_DEFAULTS.minAngle;
            maxAngleSlider.value = CAMERA_DEFAULTS.maxAngle;

            // 표시값 초기화
            minZoomValue.textContent = CAMERA_DEFAULTS.minDistance.toFixed(1);
            maxZoomValue.textContent = CAMERA_DEFAULTS.maxDistance.toFixed(0);
            minAngleValue.textContent = CAMERA_DEFAULTS.minAngle + '°';
            maxAngleValue.textContent = CAMERA_DEFAULTS.maxAngle + '°';

            // 카메라 컨트롤 초기화 (원근 카메라)
            controls.minDistance = CAMERA_DEFAULTS.minDistance;
            controls.maxDistance = CAMERA_DEFAULTS.maxDistance;
            controls.minPolarAngle = CAMERA_DEFAULTS.minAngle * Math.PI / 180;
            controls.maxPolarAngle = CAMERA_DEFAULTS.maxAngle * Math.PI / 180;
        });
    }

    // 도로 버튼 - 토글 형식
    if (btnBuild) btnBuild.addEventListener("click", () => {
        const isRoadModeActive = currentMode === MODE.BUILD || currentMode === MODE.BUILD_4LANE || currentMode === MODE.WATER || currentMode === MODE.TRAFFIC_VIEW;
        if (isRoadModeActive) {
            // 이미 도로 모드면 토글 OFF → 카메라 모드로
            closeSubMenu();
            clearToolButtonActive();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            openSubMenu('roads');
        }
    });
    // btnWater removed - water is now in roads submenu

    // Legacy zone buttons (hidden, for compatibility)
    if (btnZoneResidential) btnZoneResidential.addEventListener("click", () => setMode(MODE.ZONE_RESIDENTIAL));
    if (btnZoneCommercial) btnZoneCommercial.addEventListener("click", () => setMode(MODE.ZONE_COMMERCIAL));
    if (btnZoneIndustrial) btnZoneIndustrial.addEventListener("click", () => setMode(MODE.ZONE_INDUSTRIAL));
    if (btnZoneDelete) btnZoneDelete.addEventListener("click", () => setMode(MODE.ZONE_DELETE));

    // 구역 버튼 - 토글 형식
    if (btnZones) btnZones.addEventListener("click", () => {
        const isZoneModeActive = isZoneMode() || currentMode === MODE.ZONE_DELETE ||
                                  currentMode === MODE.LAND_VALUE_VIEW || currentMode === MODE.POPULATION_VIEW;
        if (isZoneModeActive) {
            // 이미 구역 모드면 토글 OFF → 카메라 모드로
            closeSubMenu();
            clearToolButtonActive();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            setMode(MODE.ZONE_RESIDENTIAL);
            openSubMenu('zones');
        }
    });
    // 전력 버튼 - 전력 뷰 모드 진입 + 발전소 선택 서브메뉴 열기
    if (btnPower) btnPower.addEventListener("click", () => {
        const isPowerModeActive = currentMode === MODE.POWER_VIEW ||
                                  currentMode === MODE.PLACE_POWER_COAL ||
                                  currentMode === MODE.PLACE_POWER_WIND;
        if (isPowerModeActive) {
            // 전력 모드 활성화 상태면 종료
            closeSubMenu();
            clearToolButtonActive();
            hideUtilityLegend();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            setMode(MODE.POWER_VIEW);
            openSubMenu('power');
            showUtilityLegend('power');
        }
    });

    // 수도 버튼 - 수도 뷰 모드 진입 + 수도시설 선택 서브메뉴 열기
    if (btnWater) btnWater.addEventListener("click", () => {
        const isWaterModeActive = currentMode === MODE.WATER_VIEW ||
                                  currentMode === MODE.PLACE_WATER_TOWER ||
                                  currentMode === MODE.PLACE_WATER_PUMP;
        if (isWaterModeActive) {
            // 수도 모드 활성화 상태면 종료
            closeSubMenu();
            clearToolButtonActive();
            hideUtilityLegend();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            setMode(MODE.WATER_VIEW);
            openSubMenu('waterSupply');
            showUtilityLegend('water');
        }
    });

    // Public facility individual buttons - 토글 형식 (서브메뉴 + 범례 모드)
    if (btnPolice) btnPolice.addEventListener("click", () => {
        const isPoliceModeActive = currentMode === MODE.PLACE_POLICE;
        const isPoliceViewActive = activeServiceViewType === 'police';

        if (isPoliceModeActive || isPoliceViewActive) {
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('police');
            openSubMenu('police');
        }
    });
    if (btnFire) btnFire.addEventListener("click", () => {
        const isFireModeActive = currentMode === MODE.PLACE_FIRE;
        const isFireViewActive = activeServiceViewType === 'fire';

        if (isFireModeActive || isFireViewActive) {
            // 이미 소방서 모드/뷰가 활성화되어 있으면 종료
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('fire');
            openSubMenu('fire');
        }
    });
    if (btnSchool) btnSchool.addEventListener("click", () => {
        const isSchoolModeActive = currentMode === MODE.PLACE_SCHOOL;
        const isSchoolViewActive = activeServiceViewType === 'school';

        if (isSchoolModeActive || isSchoolViewActive) {
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('school');
            openSubMenu('school');
        }
    });
    if (btnHospital) btnHospital.addEventListener("click", () => {
        const isHospitalModeActive = currentMode === MODE.PLACE_HOSPITAL;
        const isHospitalViewActive = activeServiceViewType === 'hospital';

        if (isHospitalModeActive || isHospitalViewActive) {
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('hospital');
            openSubMenu('hospital');
        }
    });
    if (btnParkBtn) btnParkBtn.addEventListener("click", () => {
        const isParkModeActive = currentMode === MODE.PLACE_PARK;
        const isParkViewActive = activeServiceViewType === 'park';

        if (isParkModeActive || isParkViewActive) {
            closeSubMenu();
            clearToolButtonActive();
            exitServiceBuildingView();
            setMode(MODE.CAMERA);
        } else {
            // 다른 모드면 바로 전환 (카메라 모드 거치지 않음)
            deactivateDemolishMode();
            exitServiceBuildingView();
            hideUtilityLegend();
            closeSubMenu();
            clearToolButtonActive();
            enterServiceBuildingView('park');
            openSubMenu('park');
        }
    });

    // 철거 버튼 - 독립 토글 (다른 모드와 공존 가능)
    if (btnDemolish) btnDemolish.addEventListener("click", () => {
        toggleDemolishMode();
    });

    // X 버튼 클릭으로 카메라 모드로 복귀
    if (btnExitMode) btnExitMode.addEventListener("click", () => {
        closeSubMenu();
        setMode(MODE.CAMERA);
    });

    // 좌측 사이드바 버튼 이벤트
    if (btnLandValue) btnLandValue.addEventListener("click", () => {
        toggleLandValueView();
    });

    if (btnPopulation) btnPopulation.addEventListener("click", () => {
        togglePopulationView();
    });

    window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
            // 철거 모드 비활성화
            if (isDemolishModeActive) {
                deactivateDemolishMode();
            }
            // 서비스 건물 뷰 모드면 종료
            if (isServiceViewActive()) {
                exitServiceBuildingView();
            }
            // 땅값 뷰 모드면 종료
            if (isLandValueViewActive) {
                exitLandValueView();
            }
            // 인구 뷰 모드면 종료
            if (isPopulationViewActive) {
                exitPopulationView();
            }
            // 유틸리티 범례 숨기기 (전력/수도 모드)
            hideUtilityLegend();
            closeSubMenu();
            setMode(MODE.CAMERA);
        }
        // 배속 조절
        if (e.key === " ") {  // Space - 일시정지/재생
            e.preventDefault();
            setGameSpeed(timeState.speed === 0 ? 1 : 0);
        }
        if (e.key === "," || e.key === "<") setGameSpeed(Math.max(0, timeState.speed / 2));  // 감속
        if (e.key === "." || e.key === ">") setGameSpeed(Math.min(4, timeState.speed === 0 ? 1 : timeState.speed * 2));  // 가속
        // 모드 전환
        if (e.key === "1") { closeSubMenu(); setMode(MODE.CAMERA); }
        if (e.key === "2" && MAP_CONFIG.isOwner) { closeSubMenu(); setMode(MODE.BUILD); }
        if (e.key === "3" && MAP_CONFIG.isOwner) setMode(MODE.ZONE_RESIDENTIAL);
        if (e.key === "4" && MAP_CONFIG.isOwner) setMode(MODE.ZONE_COMMERCIAL);
        if (e.key === "5" && MAP_CONFIG.isOwner) setMode(MODE.ZONE_INDUSTRIAL);
        if (e.key === "6" && MAP_CONFIG.isOwner) setMode(MODE.ZONE_DELETE);
        // Ctrl+S 저장
        if ((e.ctrlKey || e.metaKey) && e.key === "s" && MAP_CONFIG.isOwner) {
            e.preventDefault();
            saveMapData();
        }
    });

    // Ctrl 키 떼면 직선 프리뷰 제거
    window.addEventListener("keyup", (e) => {
        if (e.key === "Control" || e.key === "Meta") {
            clearLinePreview();
        }
    });

    setMode(MODE.CAMERA);

    /* =========================================================
     * SAVE / LOAD API
     * ========================================================= */
    let isSaving = false;
    let isDirty = false;  // 변경사항 추적
    let lastSaveTime = 0;  // 마지막 저장 시간
    const SAVE_COOLDOWN = 10000;  // 저장 쿨다운 10초

    function markDirty() {
        if (!MAP_CONFIG.isOwner) return;
        isDirty = true;
        updateSaveButton();
    }

    function markClean() {
        isDirty = false;
        updateSaveButton();
    }

    function updateSaveButton() {
        const btnSave = document.getElementById('btnSave');
        if (btnSave) {
            if (isDirty) {
                btnSave.classList.add('dirty');
                btnSave.title = '저장 필요 (Ctrl+S)';
            } else {
                btnSave.classList.remove('dirty');
                btnSave.title = '저장 (Ctrl+S)';
            }
        }
    }

    // 저장 버튼 클릭 이벤트
    const btnSave = document.getElementById('btnSave');
    if (btnSave) {
        // 방문 모드에서는 저장 버튼 숨기기
        if (!MAP_CONFIG.isOwner) {
            btnSave.style.display = 'none';
        } else {
            btnSave.addEventListener('click', () => saveMapData());
        }
    }

    function showSaveIndicator(status) {
        saveIndicator.className = status;
        saveIndicator.textContent = status === 'saving' ? i18n.t('toast.saving') : i18n.t('toast.saved');
        if (status === 'saved') {
            setTimeout(() => {
                saveIndicator.className = '';
            }, 1500);
        }
    }

    async function saveMapData() {
        // 테스트 모드: DB 저장 비활성화
        if (TEST_MODE) {
            toast({ title: '테스트 모드', desc: 'DB 저장이 비활성화되어 있습니다.', success: true });
            markClean();
            return;
        }

        // 방문 모드에서는 저장 불가
        if (!MAP_CONFIG.isOwner) {
            toast({ title: '저장 불가', desc: '다른 사람의 도시는 저장할 수 없습니다.', success: false });
            return;
        }

        if (isSaving) return;

        // 쿨다운 체크 (10초)
        const now = Date.now();
        const timeSinceLastSave = now - lastSaveTime;
        if (lastSaveTime > 0 && timeSinceLastSave < SAVE_COOLDOWN) {
            const remainingSeconds = Math.ceil((SAVE_COOLDOWN - timeSinceLastSave) / 1000);
            toast({
                title: '저장 대기',
                desc: `${remainingSeconds}초 후에 다시 저장할 수 있습니다.`,
                success: false
            });
            return;
        }

        if (!isDirty) {
            toast({ title: i18n.t('toast.saved'), desc: i18n.t('toast.savedDesc'), success: true });
            return;
        }

        isSaving = true;
        showSaveIndicator('saving');

        try {
            // 도시 이름이 있으면 해당 도시에 저장, 없으면 기본 도시
            const saveUrl = MAP_CONFIG.cityName
                ? `/api/map/${MAP_CONFIG.username}/${encodeURIComponent(MAP_CONFIG.cityName)}`
                : `/api/map/${MAP_CONFIG.username}`;
            const response = await fetch(saveUrl, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    grid: grid,
                    money: economy.money,
                    buildings: extractBuildingsData(),  // 건물 레벨/폐건물 상태 저장
                    cameraState: {
                        position: {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        },
                        target: {
                            x: controls.target.x,
                            y: controls.target.y,
                            z: controls.target.z
                        },
                        // 카메라 회전 (OrbitControls 극좌표)
                        azimuthAngle: controls.getAzimuthalAngle(),
                        polarAngle: controls.getPolarAngle()
                    },
                    // 게임 시간/날짜 저장
                    gameState: {
                        gameTime: timeState.gameTime,
                        gameDay: timeState.gameDay
                    }
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || i18n.t('toast.saveError'));
            }

            showSaveIndicator('saved');
            markClean();
            lastSaveTime = Date.now();  // 쿨다운 타이머 시작
            toast({ title: i18n.t('toast.saved'), desc: i18n.t('toast.savedDesc'), success: true });
        } catch (error) {
            console.error('Save failed:', error);
            toast({
                title: i18n.t('toast.saveError'),
                desc: error.message
            });
            showSaveIndicator('');
        } finally {
            isSaving = false;
        }
    }

    // 페이지 이탈 시 저장 안 된 변경사항 경고
    window.addEventListener('beforeunload', (e) => {
        if (isDirty && MAP_CONFIG.isOwner) {
            e.preventDefault();
            e.returnValue = '';
        }
    });

    async function loadMapData() {
        console.log('loadMapData 시작...');
        try {
            // 도시 이름이 있으면 해당 도시 로드, 없으면 기본 도시
            const apiUrl = MAP_CONFIG.cityName
                ? `/api/map/${MAP_CONFIG.username}/${encodeURIComponent(MAP_CONFIG.cityName)}`
                : `/api/map/${MAP_CONFIG.username}`;
            const response = await fetch(apiUrl);
            console.log('API 응답 받음');
            if (!response.ok) throw new Error('맵 로드 실패');

            const data = await response.json();

            // 그리드 데이터 로드
            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    grid[x][y] = data.grid[x][y];
                }
            }

            // 자금 로드 (테스트용 무한 자금 모드면 유지)
            if (!UNLIMITED_MONEY) {
                economy.money = data.money;
            }
            renderMoney();

            // 도시 통계 로드
            cityStats.population = data.population || 0;
            cityStats.happiness = data.happiness || 50;
            cityStats.powerCapacity = data.powerCapacity || 0;
            cityStats.powerUsage = data.powerUsage || 0;
            cityStats.waterCapacity = data.waterCapacity || 0;
            cityStats.waterUsage = data.waterUsage || 0;
            cityStats.crimeRate = data.crimeRate || 0;
            cityStats.fireRisk = data.fireRisk || 0;
            cityStats.trafficLevel = data.trafficLevel || 0;
            cityStats.taxPerHour = data.taxPerHour || 0;
            cityStats.actionPoints = data.actionPoints || 10;
            cityStats.consecutiveLoginDays = data.consecutiveLoginDays || 0;
            cityStats.congestionMap = data.congestionMap || null;

            updateStatsDisplay();

            // 건물 데이터 로드 (새 구조: civilBuildings, publicBuildings)
            const buildingsData = data.buildings || null;
            if (buildingsData && typeof buildingsData === 'object') {
                // 새 구조
                savedBuildingsData = buildingsData.civilBuildings || null;
                console.log('민간 건물 데이터 로드:', savedBuildingsData ? savedBuildingsData.length + '개' : '없음');
                console.log('공공시설 데이터 로드:', buildingsData.publicBuildings ? buildingsData.publicBuildings.length + '개' : '없음');
            } else if (Array.isArray(buildingsData)) {
                // 기존 구조 (하위 호환)
                savedBuildingsData = buildingsData;
                console.log('건물 데이터 로드 (구 구조):', savedBuildingsData.length + '개');
            } else {
                savedBuildingsData = null;
            }

            // 오프라인 수익 표시
            if (data.offlineEarnings && data.offlineEarnings > 0) {
                showOfflineEarnings(data.offlineEarnings);
            }

            // 로그인 보상 표시
            if (data.loginReward && data.loginReward > 0) {
                showLoginReward(data.loginReward);
            }

            // 도로 및 구역 재구성
            console.log('도로 재구성 시작...');
            // 4차선 도로 원점 복원 (저장된 데이터가 있으면 사용, 없으면 그리드에서 재구성)
            if (buildingsData && buildingsData.road4LaneOrigins && buildingsData.road4LaneOrigins.length > 0) {
                restore4LaneOrigins(buildingsData.road4LaneOrigins);
            } else {
                rebuild4LaneOrigins();  // 4차선 도로 원점 그리드에서 재구성
            }
            rebuildRoadInstances();
            rebuildRoadModels();
            console.log('구역 재구성 시작...');
            // 저장된 건물만 복원 (구역만 지정하고 저장한 경우 건물이 자동 생성되지 않도록)
            rebuildZoneInstances(true, true);

            // 공공시설 복원
            if (buildingsData && buildingsData.publicBuildings) {
                console.log('공공시설 복원 시작...');
                restoreAllPublicBuildings(buildingsData.publicBuildings);
                console.log('공공시설 복원 완료');
            }

            // 공사중인 현장 복원
            if (buildingsData && buildingsData.constructionSites && buildingsData.constructionSites.length > 0) {
                console.log('공사 현장 복원 시작:', buildingsData.constructionSites.length + '개');
                restoreConstructionSites(buildingsData.constructionSites);
                console.log('공사 현장 복원 완료');
            }

            // 잔디/수로/다리 타일 재구성
            console.log('타일 재구성 시작...');
            rebuildAllTiles();
            console.log('타일 재구성 완료');

            // 나무 복원 또는 새로 생성
            if (buildingsData && buildingsData.trees && buildingsData.trees.length > 0) {
                // 저장된 나무 데이터가 있으면 복원
                console.log('나무 복원 시작:', buildingsData.trees.length + '개');
                restoreTreesFromData(buildingsData.trees);
                console.log('나무 복원 완료');
            } else {
                // 저장된 나무가 없으면 새로 생성 (새 맵인 경우)
                console.log('새 맵 - 나무 생성 중...');
                const treeSeed = data.treeSeed || Date.now();  // 시드가 저장되어 있으면 사용
                generateTreesWithSeed(treeSeed);
                console.log('나무 생성 완료');
                markDirty();  // 새 나무가 생성되었으므로 저장 필요
            }

            // 혼잡도 시각화
            if (cityStats.congestionMap) {
                updateCongestionVisualization();
            }

            // 카메라 위치/회전 복원
            if (data.cameraState) {
                const { position, target, azimuthAngle, polarAngle } = data.cameraState;
                if (position) {
                    camera.position.set(position.x, position.y, position.z);
                }
                if (target) {
                    controls.target.set(target.x, target.y, target.z);
                }
                controls.update();
                cameraRestoredFromSave = true;  // 인트로 애니메이션 스킵 플래그
                controls.enabled = true;  // 컨트롤 즉시 활성화
                console.log('카메라 위치 복원 완료');
            }

            // 게임 시간/날짜 복원
            if (data.gameState) {
                const { gameTime, gameDay } = data.gameState;
                if (gameTime !== undefined) {
                    timeState.gameTime = gameTime;
                }
                if (gameDay !== undefined) {
                    timeState.gameDay = gameDay;
                }
                // 조명 및 환경 업데이트 (낮/밤 상태 반영)
                updateEnvironment();
                console.log(`게임 시간 복원: Day ${timeState.gameDay}, ${formatGameTime(timeState.gameTime)}`);
            }

            // 도시 이름 업데이트
            if (data.cityName) {
                const cityNameDisplay = document.getElementById('cityNameDisplay');
                if (cityNameDisplay) {
                    cityNameDisplay.innerHTML = `${data.cityName} <span style="opacity: 0.6; font-weight: 400;">- ${data.username}</span>`;
                }
            }

            console.log('맵 로드 완료:', data.username, '도시:', data.cityName, '소유자:', data.isOwner);

        } catch (error) {
            console.error('맵 로드 실패:', error);
            toast({
                title: "로드 실패",
                desc: "맵 데이터를 불러올 수 없습니다."
            });

            // 기본 외곽 도로 생성
            buildOuterRingRoad();
            rebuildRoadInstances();
            rebuildRoadModels();
            rebuildZoneInstances();
            rebuildAllTiles();

            // 기본 나무 생성
            generateTreesWithSeed(Date.now());
        }
    }

    // 도로 혼잡도 시각화 업데이트
    function updateCongestionVisualization() {
        if (!cityStats.congestionMap) return;

        // roadGroup의 각 도로 모델에 색상 적용
        roadGroup.children.forEach((roadModel, index) => {
            // 도로 위치에서 그리드 좌표 계산
            const worldX = roadModel.position.x;
            const worldZ = roadModel.position.z;
            const gx = Math.floor(worldX / TILE_SIZE - ORIGIN_X);
            const gy = Math.floor(worldZ / TILE_SIZE - ORIGIN_Z);

            if (gx >= 0 && gx < GRID_W && gy >= 0 && gy < GRID_H) {
                const congestion = cityStats.congestionMap[gx][gy] || 0;

                roadModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        // 원본 재질 복제
                        if (!child.userData.originalMaterial) {
                            child.userData.originalMaterial = child.material;
                        }

                        // 원본 재질이 유효한지 확인 후 복제
                        const origMat = child.userData.originalMaterial;
                        if (origMat && typeof origMat.clone === 'function') {
                            child.material = origMat.clone();
                        }

                        // 혼잡도 30 이상일 때만 색상 적용 (원활할 때는 원래 색상 유지)
                        if (congestion >= 30) {
                            const color = getCongestionColor(congestion);
                            if (child.material.emissive) {
                                child.material.emissive = new THREE.Color(color);
                                child.material.emissiveIntensity = 0.3;
                            }
                        } else {
                            // 혼잡도 낮으면 emissive 없음
                            if (child.material.emissive) {
                                child.material.emissive = new THREE.Color(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        }
                    }
                });
            }
        });
    }

    function getCongestionColor(level) {
        // 30 미만은 이제 여기 도달하지 않음
        if (level < 60) return 0xffcc00;  // 노랑 - 보통
        if (level < 80) return 0xff9500;  // 주황 - 혼잡
        return 0xff4444;  // 빨강 - 정체
    }

    function buildOuterRingRoad() {
        // 오른쪽 한 면만 외곽 도로로 설정 (2차선 - 4차선은 2x2 필요)
        for (let y = 0; y < GRID_H; y++) {
            grid[GRID_W - 1][y] = CELL.LOCKED_ROAD;
        }
    }

    /* =========================================================
     * RESIZE / LOOP
     * ========================================================= */
    function resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        renderer.setSize(w, h, false);

        // Post-processing composer 크기 조정
        composer.setSize(w, h);
        // Bloom은 절반 해상도 유지 (성능 최적화)
        bloomPass.resolution.set(
            Math.floor(w * GRAPHICS_SETTINGS.bloomResolutionScale),
            Math.floor(h * GRAPHICS_SETTINGS.bloomResolutionScale)
        );

        // 원근 카메라 비율 조정
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        // 캐시된 렌더러 rect 업데이트 (getBoundingClientRect 호출 최소화)
        cachedRendererRect = renderer.domElement.getBoundingClientRect();
    }

    window.addEventListener("resize", resize);
    resize();

    // 프레임 스킵용 카운터 (최적화)
    let frameCount = 0;

    function animate() {
        requestAnimationFrame(animate);
        const currentTime = performance.now();
        frameCount++;

        // 퍼포먼스 모니터 FPS 계산
        if (perfMonitor) perfMonitor.tick();

        // === 매 프레임 실행 (필수) ===
        updateCameraIntro();  // 카메라 인트로 애니메이션
        updateSmoothZoom();   // 부드러운 줌 애니메이션
        updateBuildingPreviewPosition();  // 건물 프리뷰 부드러운 이동
        trafficManager.updateCameraFollow();  // 차량 카메라 따라가기 (부드러움 유지)

        // === 2프레임마다 실행 (교통 + UI 위치 업데이트) ===
        if (frameCount % 2 === 0) {
            trafficManager.update(currentTime);  // 교통 시스템 업데이트 (최적화: 2프레임마다)
            updatePopupPosition();  // 건물 팝업 위치 업데이트
            updatePublicBuildingPopupPosition();  // 공공시설 팝업 위치 업데이트
            updateConstructionPopupPosition();  // 공사 팝업 위치 업데이트
            trafficManager.updateVehiclePopupPosition();  // 차량 팝업 위치 업데이트
            updateAllServiceEmojis();  // 서비스 이모지 위치 업데이트
            updateAllDisconnectIcons();  // 도로 끊김 아이콘 위치 업데이트
            updateAbandonedIcons();  // 폐건물 아이콘 위치 업데이트
        }

        // === 3프레임마다 실행 (게임 로직) ===
        if (frameCount % 3 === 0) {
            updateGameTime();  // 시간 사이클 업데이트
            updateConstructions();  // 공사 진행 상태 업데이트
            updateConstructionPopupContent();  // 공사 팝업 실시간 업데이트
            trafficManager.updateVehicleOutline();  // 차량 아웃라인 업데이트
            updateTrafficView();  // 교통량 뷰 실시간 업데이트
            updateFireSystem();  // 화재 시스템 업데이트
            updateCrimeSystem();  // 강도 사건 시스템 업데이트
            updateMedicalSystem();  // 의료 응급 시스템 업데이트
        }

        // === 6프레임마다 실행 (무거운 로직) ===
        if (frameCount % 6 === 0) {
            updateMoveInSystem();   // 입주 시스템 업데이트 (행복도 기반 스폰)
            updateRCIShortageEffects();  // RCI 부족 영향 건물 업데이트
            updateBuildingHappinessStatus();  // 행복도 상태 체크 (폐건물 전환)
            updateCityHappinessDisplay();     // 도시 전체 행복도 UI 업데이트
        }

        // 건물 업그레이드 시스템 - 주기적 땅값 체크
        if (currentTime - lastUpgradeCheck > UPGRADE_CHECK_INTERVAL) {
            checkBuildingLandValues();
            lastUpgradeCheck = currentTime;
        }

        // 하단 바 업데이트 (예산/인구) - 1초마다
        if (currentTime - lastBottomBarUpdate > 1000) {
            updateBudgetDisplay();
            updatePopulationDisplay();
            // 인구 패널이 열려있으면 패널도 업데이트
            if (populationPanel && populationPanel.classList.contains('open')) {
                updatePopulationPanel();
            }
            lastBottomBarUpdate = currentTime;
        }

        // 카메라 이동 제한 (맵 범위 내, 땅 위)
        clampCameraPosition();

        // three.quarks 파티클 시스템 업데이트
        const particleDelta = particleClock.getDelta();
        batchRenderer.update(particleDelta);

        controls.update();
        // Post-processing으로 렌더링 (Bloom, Tone Mapping 적용)
        composer.render();

        // GPU 통계 캡처 (렌더링 직후, 리셋 전에)
        if (perfMonitor) perfMonitor.captureGpuStats();
    }

    /**
     * 렌더링 전 disposed된 텍스처를 가진 머티리얼 정리
     * Three.js에서 texture.map이 disposed되었지만 참조가 남아있으면 렌더링 에러 발생
     */
    function cleanupDisposedMaterials() {
        // 화재/범죄/의료 이펙트 그룹 정리
        if (fireEffectsGroup) {
            fireEffectsGroup.traverse((child) => {
                if (child.material) {
                    // map이 있지만 disposed된 경우 (source와 image 둘 다 없음)
                    if (child.material.map && !child.material.map.source && !child.material.map.image) {
                        child.material.map = null;
                        child.material.needsUpdate = true;
                    }
                }
            });
        }
    }

    /* =========================================================
     * INIT
     * ========================================================= */
    // 건물 모델 로드
    await loadAllBuildingModels();

    await loadMapData();
    updateCurrencySymbols();
    i18n.applyTranslations();

    // 초기 도로 연결 상태 체크
    updateRoadConnectivity();

    // 초기 환경 설정
    updateEnvironment();

    loadingEl.classList.add('hidden');
    // 저장된 카메라 상태가 복원되지 않은 경우에만 인트로 애니메이션 시작
    if (!cameraRestoredFromSave) {
        startCameraIntro();  // 카메라 줌인 애니메이션 시작
    }
    animate();

    // 교통 시스템 초기화 (비동기 - 게임 시작 후 백그라운드에서)
    setTimeout(() => {
        trafficManager.init().catch(e => console.error('Traffic init error:', e));
    }, 1000);

    // 전력망 시스템 초기화
    setTimeout(() => {
        powerManager.init();
        powerManager.recalculatePowerGrid();
    }, 500);

    // 수도 시스템 초기화
    setTimeout(() => {
        waterManager.init();
        waterManager.recalculateWaterGrid();
    }, 600);

    // 자동저장 (10분마다)
    const AUTO_SAVE_INTERVAL = 10 * 60 * 1000;  // 10분 = 600,000ms
    if (MAP_CONFIG.isOwner) {
        setInterval(() => {
            if (isDirty && !isSaving) {
                console.log('자동저장 실행...');
                toast({
                    title: '자동저장 중',
                    desc: '변경사항을 저장하고 있습니다...',
                    success: true
                });
                saveMapData();
            }
        }, AUTO_SAVE_INTERVAL);
        console.log('자동저장 활성화 (10분 간격)');
    }

    /* =========================================================
     * ANTI-CHEAT (클라이언트 측 - UX용, 실제 보안은 서버)
     * ========================================================= */
    // 참고: Object.freeze()는 정상 게임 동작을 방해하므로 제거
    // 실제 보안은 서버의 GameSecurityService에서 처리

    // 콘솔 경고
    console.log('%c⚠️ 경고!', 'color: red; font-size: 30px; font-weight: bold;');
    console.log('%c이 콘솔을 사용하여 게임 데이터를 조작하면 계정이 제재될 수 있습니다.',
        'color: red; font-size: 14px;');
    console.log('%c모든 게임 데이터는 서버에서 검증됩니다.',
        'color: gray; font-size: 12px;');

</script>
</body>
</html>
