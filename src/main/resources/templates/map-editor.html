<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Editor - Master Mode</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #fff;
            overflow: hidden;
        }
        #canvas-container { width: 100vw; height: 100vh; }

        .top-bar {
            position: fixed;
            top: 0; left: 0; right: 0;
            height: 50px;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 15px;
            z-index: 1000;
        }
        .top-bar h1 { font-size: 1rem; color: #f97316; }
        .top-bar-actions { display: flex; gap: 8px; margin-left: auto; }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
        }
        .btn-primary { background: #3b82f6; color: #fff; }
        .btn-success { background: #22c55e; color: #fff; }
        .btn-secondary { background: #374151; color: #fff; }
        .btn-warning { background: #f59e0b; color: #fff; }

        .left-toolbar {
            position: fixed;
            top: 60px; left: 10px;
            background: rgba(0,0,0,0.9);
            border-radius: 10px;
            padding: 12px;
            z-index: 1000;
        }
        .toolbar-title { font-size: 0.75rem; color: #9ca3af; margin-bottom: 10px; }
        .tool-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; }
        .tool-btn {
            width: 50px; height: 50px;
            border: 2px solid #374151;
            border-radius: 8px;
            background: #1f2937;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .tool-btn:hover { border-color: #6b7280; }
        .tool-btn.active { border-color: #f97316; background: rgba(249,115,22,0.2); }
        .tool-btn .icon { font-size: 1.3rem; }
        .tool-btn .label { font-size: 0.55rem; color: #9ca3af; }

        .info-panel {
            position: fixed;
            top: 60px; right: 10px;
            width: 180px;
            background: rgba(0,0,0,0.9);
            border-radius: 10px;
            padding: 12px;
            z-index: 1000;
        }
        .info-panel h3 { font-size: 0.8rem; color: #f97316; margin-bottom: 8px; }
        .info-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.75rem; }
        .info-label { color: #9ca3af; }
        .info-value { color: #fff; font-weight: 600; }

        .bottom-hint {
            position: fixed;
            bottom: 15px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.75rem;
            color: #9ca3af;
            z-index: 1000;
        }
        .bottom-hint kbd {
            background: #374151;
            padding: 2px 5px;
            border-radius: 3px;
            margin: 0 2px;
            color: #fff;
        }

        .toast {
            position: fixed;
            top: 60px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 10px 20px;
            border-radius: 6px;
            z-index: 2000;
            display: none;
        }
        .toast.success { border: 1px solid #22c55e; color: #22c55e; }
        .toast.error { border: 1px solid #ef4444; color: #ef4444; }
        .toast.show { display: block; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000;
        }
        .modal-content {
            background: #1f2937;
            border-radius: 10px;
            padding: 20px;
            min-width: 320px;
        }
        .modal-content h2 { color: #fff; margin-bottom: 15px; font-size: 1rem; }
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; color: #9ca3af; font-size: 0.8rem; margin-bottom: 4px; }
        .form-group input {
            width: 100%; padding: 8px;
            background: #111827; border: 1px solid #374151;
            border-radius: 6px; color: #fff; font-size: 0.85rem;
        }
        .form-group input:focus { border-color: #f97316; outline: none; }
        .modal-actions { display: flex; gap: 10px; margin-top: 15px; justify-content: flex-end; }

        .template-list { max-height: 200px; overflow-y: auto; margin: 10px 0; }
        .template-item {
            padding: 8px 10px; background: #111827;
            border: 1px solid #374151; border-radius: 6px;
            margin-bottom: 5px; cursor: pointer;
        }
        .template-item:hover { border-color: #f97316; }
        .template-item.selected { border-color: #22c55e; background: rgba(34,197,94,0.1); }
        .template-item-content { flex: 1; }
        .template-name { color: #fff; font-weight: 600; font-size: 0.85rem; }
        .template-desc { color: #9ca3af; font-size: 0.75rem; }
        .template-item { display: flex; align-items: center; gap: 10px; }
        .template-delete-btn {
            background: #ef4444;
            border: none;
            border-radius: 4px;
            color: #fff;
            padding: 4px 8px;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.7;
        }
        .template-delete-btn:hover { opacity: 1; }

        /* ë§µ ëª©ë¡ ê´€ë¦¬ ëª¨ë‹¬ */
        .map-list-modal {
            min-width: 450px;
            max-width: 550px;
        }
        .map-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .map-list-header h2 {
            margin: 0;
        }
        .map-count {
            color: #9ca3af;
            font-size: 0.85rem;
        }
        .map-list-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #374151;
            border-radius: 8px;
            background: #111827;
        }
        .map-list-empty {
            padding: 40px 20px;
            text-align: center;
            color: #6b7280;
        }
        .map-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #374151;
            gap: 12px;
        }
        .map-item:last-child {
            border-bottom: none;
        }
        .map-item:hover {
            background: rgba(249, 115, 22, 0.1);
        }
        .map-item-info {
            flex: 1;
            min-width: 0;
        }
        .map-item-name {
            color: #fff;
            font-weight: 600;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .map-item-desc {
            color: #9ca3af;
            font-size: 0.75rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .map-item-date {
            color: #6b7280;
            font-size: 0.7rem;
            margin-top: 2px;
        }
        .map-item-actions {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }
        .map-action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .map-action-btn:hover {
            opacity: 0.9;
        }
        .btn-load {
            background: #3b82f6;
            color: #fff;
        }
        .btn-delete {
            background: #ef4444;
            color: #fff;
        }

        /* í™˜ê²½ ì„¤ì • íŒ¨ë„ */
        .env-panel {
            position: fixed;
            top: 60px;
            right: 200px;
            width: 200px;
            background: rgba(0,0,0,0.9);
            border-radius: 10px;
            padding: 12px;
            z-index: 1000;
        }
        .env-panel h3 {
            font-size: 0.8rem;
            color: #f97316;
            margin-bottom: 12px;
        }
        .env-section {
            margin-bottom: 15px;
        }
        .env-section-title {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .direction-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .direction-row {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .dir-btn {
            width: 50px;
            height: 32px;
            border: 2px solid #374151;
            border-radius: 6px;
            background: #1f2937;
            color: #fff;
            font-size: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .dir-btn:hover {
            border-color: #6b7280;
            background: #374151;
        }
        .dir-btn.active {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.3);
        }

        /* í˜¸ë²„ í”„ë¦¬ë·° */
        .hover-preview {
            pointer-events: none;
        }

        /* ë¸ŒëŸ¬ì‰¬ í¬ê¸° ì»¨íŠ¸ë¡¤ */
        .brush-size-control {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }
        .brush-btn {
            width: 32px; height: 32px;
            border: 2px solid #374151;
            border-radius: 6px;
            background: #1f2937;
            color: #fff;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
        }
        .brush-btn:hover { border-color: #6b7280; }
        .brush-btn.active { border-color: #10b981; background: rgba(16,185,129,0.2); }
        .brush-hint {
            font-size: 0.65rem;
            color: #6b7280;
            margin-top: 6px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="top-bar">
        <h1>ğŸ—ºï¸ Map Editor</h1>
        <div class="top-bar-actions">
            <button class="btn btn-primary" onclick="openMapListDialog()">ğŸ“‹ ë§µ ëª©ë¡</button>
            <button class="btn btn-secondary" onclick="resetMap()">ğŸ”„ ì´ˆê¸°í™”</button>
            <button class="btn btn-success" onclick="openSaveDialog()">ğŸ’¾ ì €ì¥</button>
            <a href="/" class="btn btn-secondary">ğŸ  í™ˆ</a>
        </div>
    </div>

    <div id="saveDialog" class="modal-overlay" style="display:none;">
        <div class="modal-content">
            <h2>ğŸ’¾ í…œí”Œë¦¿ ì €ì¥</h2>
            <div class="form-group">
                <label>ì´ë¦„ *</label>
                <input type="text" id="templateName" placeholder="ì˜ˆ: í•´ë³€ ë„ì‹œ">
            </div>
            <div class="form-group">
                <label>ì„¤ëª…</label>
                <input type="text" id="templateDesc" placeholder="ì„¤ëª… (ì„ íƒì‚¬í•­)">
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeSaveDialog()">ì·¨ì†Œ</button>
                <button class="btn btn-success" onclick="saveTemplate()">ì €ì¥</button>
            </div>
        </div>
    </div>

    <div id="loadDialog" class="modal-overlay" style="display:none;">
        <div class="modal-content">
            <h2>ğŸ“‚ í…œí”Œë¦¿ ë¶ˆëŸ¬ì˜¤ê¸°</h2>
            <div class="template-list" id="templateList"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeLoadDialog()">ì·¨ì†Œ</button>
                <button class="btn btn-primary" id="loadBtn" onclick="loadSelectedTemplate()" disabled>ë¶ˆëŸ¬ì˜¤ê¸°</button>
            </div>
        </div>
    </div>

    <!-- ë§µ ëª©ë¡ ê´€ë¦¬ ë‹¤ì´ì–¼ë¡œê·¸ -->
    <div id="mapListDialog" class="modal-overlay" style="display:none;">
        <div class="modal-content map-list-modal">
            <div class="map-list-header">
                <h2>ğŸ“‹ ì €ì¥ëœ ë§µ ëª©ë¡</h2>
                <span class="map-count" id="mapCount">0ê°œ</span>
            </div>
            <div class="map-list-container" id="mapListContainer">
                <div class="map-list-empty">ë¡œë”© ì¤‘...</div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeMapListDialog()">ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <div class="left-toolbar">
        <div class="toolbar-title">íƒ€ì¼</div>
        <div class="tool-grid">
            <button class="tool-btn active" data-tool="grass" onclick="selectTool('grass')">
                <span class="icon">ğŸŒ¿</span>
                <span class="label">ì”ë””</span>
            </button>
            <button class="tool-btn" data-tool="road" onclick="selectTool('road')">
                <span class="icon">ğŸ›£ï¸</span>
                <span class="label">4ì°¨ì„ </span>
            </button>
            <button class="tool-btn" data-tool="beach" onclick="selectTool('beach')">
                <span class="icon">ğŸ–ï¸</span>
                <span class="label">í•´ë³€</span>
            </button>
            <button class="tool-btn" data-tool="ocean" onclick="selectTool('ocean')">
                <span class="icon">ğŸŒŠ</span>
                <span class="label">ë°”ë‹¤</span>
            </button>
            <button class="tool-btn" data-tool="eraser" onclick="selectTool('eraser')">
                <span class="icon">ğŸ§¹</span>
                <span class="label">ì§€ìš°ê¸°</span>
            </button>
        </div>
        <div class="toolbar-title" style="margin-top:12px;">ë¸ŒëŸ¬ì‰¬ í¬ê¸°</div>
        <div class="brush-size-control">
            <button class="brush-btn active" data-size="1" onclick="setBrushSize(1)">1</button>
            <button class="brush-btn" data-size="2" onclick="setBrushSize(2)">2</button>
            <button class="brush-btn" data-size="3" onclick="setBrushSize(3)">3</button>
            <button class="brush-btn" data-size="5" onclick="setBrushSize(5)">5</button>
        </div>
        <div class="brush-hint">ë„ë¡œëŠ” í•­ìƒ 2x2</div>
    </div>

    <!-- í™˜ê²½ ì„¤ì • íŒ¨ë„ -->
    <div class="env-panel">
        <h3>ğŸŒ í™˜ê²½ ì„¤ì •</h3>

        <!-- ë°”ëŒ ë°©í–¥ -->
        <div class="env-section">
            <div class="env-section-title">
                <span>ğŸ’¨</span> ë°”ëŒ ë°©í–¥
            </div>
            <div class="direction-control" id="windControl">
                <div class="direction-row">
                    <button class="dir-btn" data-dir="N" onclick="setWindDirection('N')">â†‘ ë¶</button>
                </div>
                <div class="direction-row">
                    <button class="dir-btn" data-dir="W" onclick="setWindDirection('W')">â† ì„œ</button>
                    <button class="dir-btn" data-dir="E" onclick="setWindDirection('E')">ë™ â†’</button>
                </div>
                <div class="direction-row">
                    <button class="dir-btn" data-dir="S" onclick="setWindDirection('S')">â†“ ë‚¨</button>
                </div>
            </div>
        </div>

        <!-- í•´ë¥˜ ë°©í–¥ -->
        <div class="env-section">
            <div class="env-section-title">
                <span>ğŸŒŠ</span> í•´ë¥˜ ë°©í–¥
            </div>
            <div class="direction-control" id="currentControl">
                <div class="direction-row">
                    <button class="dir-btn" data-dir="N" onclick="setCurrentDirection('N')">â†‘ ë¶</button>
                </div>
                <div class="direction-row">
                    <button class="dir-btn" data-dir="W" onclick="setCurrentDirection('W')">â† ì„œ</button>
                    <button class="dir-btn" data-dir="E" onclick="setCurrentDirection('E')">ë™ â†’</button>
                </div>
                <div class="direction-row">
                    <button class="dir-btn" data-dir="S" onclick="setCurrentDirection('S')">â†“ ë‚¨</button>
                </div>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <h3>ğŸ“Š ì •ë³´</h3>
        <div class="info-row">
            <span class="info-label">ë„êµ¬</span>
            <span class="info-value" id="currentTool">ì”ë””</span>
        </div>
        <div class="info-row">
            <span class="info-label">ë¸ŒëŸ¬ì‰¬</span>
            <span class="info-value" id="currentBrushSize">1x1</span>
        </div>
        <div class="info-row">
            <span class="info-label">ìœ„ì¹˜</span>
            <span class="info-value" id="mousePos">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">ì”ë””</span>
            <span class="info-value" id="grassCount">0</span>
        </div>
        <div class="info-row">
            <span class="info-label">4ì°¨ì„ </span>
            <span class="info-value" id="roadCount">0</span>
        </div>
        <div class="info-row">
            <span class="info-label">í•´ë³€</span>
            <span class="info-value" id="beachCount">0</span>
        </div>
        <div class="info-row">
            <span class="info-label">ë°”ë‹¤</span>
            <span class="info-value" id="oceanCount">0</span>
        </div>
    </div>

    <div class="bottom-hint">
        <kbd>ì¢Œí´ë¦­/ë“œë˜ê·¸</kbd> ì„¤ì¹˜ Â· <kbd>ìš°ë“œë˜ê·¸</kbd> ì´ë™ Â· <kbd>íœ </kbd> ì¤Œ Â· <kbd>íœ í´ë¦­</kbd> íšŒì „
    </div>

    <div id="toast" class="toast"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        /* =========================================================
         * CONSTANTS (city.htmlê³¼ ë™ì¼)
         * ========================================================= */
        const GRID_W = 70;
        const GRID_H = 70;
        const TILE_SIZE = 1;
        const ORIGIN_X = -GRID_W / 2;
        const ORIGIN_Z = -GRID_H / 2;

        const CELL = {
            EMPTY: 0,
            ROAD: 1,
            LOCKED_ROAD: 2,
            ROAD_4LANE: 13,
            LOCKED_ROAD_4LANE: 14,
            BEACH: 15,
            OCEAN: 16,
            BREAKWATER: 17
        };

        const TOOL_TO_CELL = {
            grass: CELL.EMPTY,
            road: CELL.LOCKED_ROAD_4LANE,
            beach: CELL.BEACH,
            ocean: CELL.OCEAN,
            eraser: CELL.EMPTY
        };

        const TILE_COLORS = {
            grass: 0x4ade80,
            road: 0x4b5563,
            beach: 0xfcd34d,
            ocean: 0x3b82f6,
            eraser: 0xff6b6b  // ë¹¨ê°„ìƒ‰ í”„ë¦¬ë·°
        };

        /* =========================================================
         * STATE
         * ========================================================= */
        let grid = [];
        let currentTool = 'grass';
        let brushSize = 1;  // ë¸ŒëŸ¬ì‰¬ í¬ê¸° (ë„ë¡œ ì œì™¸)
        let hovered = null;  // city.htmlê³¼ ë™ì¼
        let isPainting = false;
        let selectedTemplateId = null;
        let templatesData = [];

        // í™˜ê²½ ì„¤ì • ìƒíƒœ
        let envSettings = {
            windDirection: 'E',      // ë°”ëŒ ë°©í–¥ (N, E, S, W)
            currentDirection: 'S'    // í•´ë¥˜ ë°©í–¥ (N, E, S, W)
        };

        /* =========================================================
         * THREE.JS (city.html êµ¬ì¡° ë”°ë¼í•˜ê¸°)
         * ========================================================= */
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let ground;  // í´ë¦­ ê°ì§€ìš© íˆ¬ëª… í‰ë©´
        let tileGroup;  // íƒ€ì¼ ë©”ì‹œë“¤ì„ ë‹´ëŠ” ê·¸ë£¹

        // íŒ¬ ê´€ë ¨
        let isRightDragging = false;
        let lastMouseX = 0, lastMouseY = 0;

        /* =========================================================
         * INIT
         * ========================================================= */
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 40, 40);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls (city.htmlê³¼ ìœ ì‚¬í•˜ê²Œ ì„¤ì •)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.minDistance = 10;
            controls.maxDistance = 120;
            controls.maxPolarAngle = Math.PI / 2.1;
            // ì¢Œí´ë¦­: ì—†ìŒ(ì§ì ‘ ì²˜ë¦¬), ì¤‘ê°„: íšŒì „, ìš°í´ë¦­: ì—†ìŒ(ì§ì ‘ ì²˜ë¦¬)
            controls.mouseButtons = {
                LEFT: null,
                MIDDLE: THREE.MOUSE.ROTATE,
                RIGHT: null
            };

            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 100, 50);
            scene.add(sun);

            // Raycaster & Mouse (city.htmlê³¼ ë™ì¼)
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Ground - í´ë¦­ ê°ì§€ìš© íˆ¬ëª… í‰ë©´ (city.htmlê³¼ ë™ì¼)
            ground = new THREE.Mesh(
                new THREE.PlaneGeometry(GRID_W * TILE_SIZE, GRID_H * TILE_SIZE),
                new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            scene.add(ground);

            // Tile Group
            tileGroup = new THREE.Group();
            scene.add(tileGroup);

            // Grid Helper (ì‹œê°ì  ê°€ì´ë“œ)
            const gridHelper = new THREE.GridHelper(GRID_W, GRID_W, 0x444444, 0x333333);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Initialize grid data
            initGrid();
            buildAllTiles();

            // í™˜ê²½ ì„¤ì • UI ì´ˆê¸°í™”
            initEnvSettingsUI();

            // Events (city.html íŒ¨í„´)
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onKeyDown);

            // Animate
            animate();
            console.log('Map Editor initialized');
        }

        /* =========================================================
         * GRID & TILES
         * ========================================================= */
        function initGrid() {
            grid = [];
            for (let x = 0; x < GRID_W; x++) {
                grid[x] = [];
                for (let y = 0; y < GRID_H; y++) {
                    grid[x][y] = CELL.EMPTY;
                }
            }
            // ê¸°ë³¸ í•˜ë‹¨ ì™¸ê³½ ë„ë¡œ (2ì¤„, ì ê¸ˆ)
            for (let x = 0; x < GRID_W; x++) {
                grid[x][GRID_H - 2] = CELL.LOCKED_ROAD_4LANE;
                grid[x][GRID_H - 1] = CELL.LOCKED_ROAD_4LANE;
            }
        }

        // ì ê¸ˆ íƒ€ì¼ì¸ì§€ í™•ì¸ (ì™¸ê³½ ë„ë¡œ)
        function isLockedTile(gx, gy) {
            if (gx < 0 || gx >= GRID_W || gy < 0 || gy >= GRID_H) return true;
            const val = grid[gx][gy];
            return val === CELL.LOCKED_ROAD_4LANE || val === CELL.LOCKED_ROAD;
        }

        function getCellType(val) {
            if (val === CELL.EMPTY) return 'grass';
            if (val === CELL.ROAD || val === CELL.LOCKED_ROAD ||
                val === CELL.ROAD_4LANE || val === CELL.LOCKED_ROAD_4LANE) return 'road';
            if (val === CELL.BEACH) return 'beach';
            if (val === CELL.OCEAN) return 'ocean';
            return 'grass';
        }

        function buildAllTiles() {
            // Clear existing
            while (tileGroup.children.length > 0) {
                tileGroup.remove(tileGroup.children[0]);
            }

            const geo = new THREE.BoxGeometry(TILE_SIZE * 0.98, 0.15, TILE_SIZE * 0.98);

            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    const type = getCellType(grid[x][y]);
                    const mat = new THREE.MeshLambertMaterial({ color: TILE_COLORS[type] });
                    const mesh = new THREE.Mesh(geo, mat);

                    // city.htmlê³¼ ë™ì¼í•œ ì¢Œí‘œ ê³„ì‚°
                    const worldX = (ORIGIN_X + x + 0.5) * TILE_SIZE;
                    const worldZ = (ORIGIN_Z + y + 0.5) * TILE_SIZE;
                    mesh.position.set(worldX, 0.075, worldZ);
                    mesh.userData = { gx: x, gy: y };

                    tileGroup.add(mesh);
                }
            }
            updateCounts();
        }

        function updateTile(gx, gy) {
            // í•´ë‹¹ íƒ€ì¼ ì°¾ê¸°
            const targetX = (ORIGIN_X + gx + 0.5) * TILE_SIZE;
            const targetZ = (ORIGIN_Z + gy + 0.5) * TILE_SIZE;

            for (const mesh of tileGroup.children) {
                if (Math.abs(mesh.position.x - targetX) < 0.01 &&
                    Math.abs(mesh.position.z - targetZ) < 0.01) {
                    const type = getCellType(grid[gx][gy]);
                    mesh.material.color.setHex(TILE_COLORS[type]);
                    return;
                }
            }
        }

        function paint(gx, gy) {
            if (gx < 0 || gx >= GRID_W || gy < 0 || gy >= GRID_H) return;

            // ë„ë¡œëŠ” í•­ìƒ 2x2ë¡œ ì„¤ì¹˜ (ë¸ŒëŸ¬ì‰¬ í¬ê¸° ë¬´ì‹œ)
            if (currentTool === 'road') {
                paintRoad2x2(gx, gy);
                return;
            }

            // ë¸ŒëŸ¬ì‰¬ í¬ê¸° ì ìš© (ë„ë¡œ ì œì™¸)
            const half = Math.floor(brushSize / 2);
            let changed = false;

            for (let dx = -half; dx < brushSize - half; dx++) {
                for (let dy = -half; dy < brushSize - half; dy++) {
                    const nx = gx + dx;
                    const ny = gy + dy;

                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) continue;
                    if (isLockedTile(nx, ny)) continue;

                    const newVal = TOOL_TO_CELL[currentTool];
                    if (grid[nx][ny] !== newVal) {
                        grid[nx][ny] = newVal;
                        updateTile(nx, ny);
                        changed = true;
                    }
                }
            }
            if (changed) updateCounts();
        }

        // 2x2 ë„ë¡œ ì„¤ì¹˜ (4ì°¨ì„ , ì² ê±° ë¶ˆê°€)
        function paintRoad2x2(gx, gy) {
            // 2x2 ì˜ì—­ì˜ ì¢Œìƒë‹¨ ì¢Œí‘œë¡œ ì •ë ¬ (ì§ìˆ˜ ì¢Œí‘œ)
            const startX = Math.floor(gx / 2) * 2;
            const startY = Math.floor(gy / 2) * 2;

            // 2x2 ì˜ì—­ì´ ì ê¸ˆ íƒ€ì¼ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const nx = startX + dx;
                    const ny = startY + dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) return;
                    if (isLockedTile(nx, ny)) return;
                }
            }

            // 2x2 ì˜ì—­ì— ë„ë¡œ ì„¤ì¹˜ (LOCKEDë¡œ ì„¤ì¹˜í•˜ì—¬ ì² ê±° ë¶ˆê°€)
            let changed = false;
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const nx = startX + dx;
                    const ny = startY + dy;
                    if (grid[nx][ny] !== CELL.LOCKED_ROAD_4LANE) {
                        grid[nx][ny] = CELL.LOCKED_ROAD_4LANE;
                        updateTile(nx, ny);
                        changed = true;
                    }
                }
            }
            if (changed) updateCounts();
        }

        /* =========================================================
         * COORDINATE CONVERSION (city.htmlê³¼ ë™ì¼)
         * ========================================================= */
        function updateMouseFromEvent(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function worldToTile(wx, wz) {
            const gx = Math.floor(wx / TILE_SIZE - ORIGIN_X);
            const gy = Math.floor(wz / TILE_SIZE - ORIGIN_Z);
            if (gx < 0 || gy < 0 || gx >= GRID_W || gy >= GRID_H) return null;
            return { x: gx, y: gy };
        }

        function updateHovered(e) {
            updateMouseFromEvent(e);
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObject(ground, false);
            if (!hits.length) return null;
            const p = hits[0].point;
            return worldToTile(p.x, p.z);
        }

        /* =========================================================
         * EVENT HANDLERS (city.html íŒ¨í„´)
         * ========================================================= */
        function onPointerMove(e) {
            // í˜¸ë²„ íƒ€ì¼ ì—…ë°ì´íŠ¸
            const t = updateHovered(e);
            if (!t) {
                hovered = null;
                document.getElementById('mousePos').textContent = '-';
                hidePreview();
                return;
            }

            hovered = t;
            document.getElementById('mousePos').textContent = `(${t.x}, ${t.y})`;

            // í”„ë¦¬ë·° í‘œì‹œ
            showPreview(t.x, t.y);

            // í˜ì¸íŒ… ì¤‘ì´ë©´ íƒ€ì¼ ì„¤ì¹˜
            if (isPainting) {
                paint(t.x, t.y);
            }

            // ìš°í´ë¦­ ë“œë˜ê·¸ (íŒ¬)
            if (isRightDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;

                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                dir.y = 0;
                dir.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(dir, new THREE.Vector3(0, 1, 0));

                const move = new THREE.Vector3();
                move.addScaledVector(right, -dx * 0.05);
                move.addScaledVector(dir, dy * 0.05);

                controls.target.add(move);
                camera.position.add(move);

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        }

        function onPointerDown(e) {
            if (e.button === 0) {
                // ì¢Œí´ë¦­ - í˜ì¸íŒ… ì‹œì‘
                isPainting = true;
                if (hovered) {
                    paint(hovered.x, hovered.y);
                }
            } else if (e.button === 2) {
                // ìš°í´ë¦­ - íŒ¬ ì‹œì‘
                isRightDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        }

        function onPointerUp(e) {
            if (e.button === 0) {
                isPainting = false;
            } else if (e.button === 2) {
                isRightDragging = false;
            }
        }

        function onKeyDown(e) {
            const map = { '1': 'grass', '2': 'road', '3': 'beach', '4': 'ocean', '5': 'eraser' };
            if (map[e.key]) selectTool(map[e.key]);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /* =========================================================
         * PREVIEW
         * ========================================================= */
        let previewMesh = null;
        let previewRoad = null;
        let currentPreviewSize = 1;

        function showPreview(gx, gy) {
            // ë„ë¡œëŠ” í•­ìƒ 2x2 í”„ë¦¬ë·°
            if (currentTool === 'road') {
                showPreviewRoad(gx, gy);
                return;
            }

            // ë¸ŒëŸ¬ì‰¬ í¬ê¸°ì— ë”°ë¥¸ í”„ë¦¬ë·°
            const size = brushSize;

            // í¬ê¸°ê°€ ë°”ë€Œë©´ ë©”ì‹œ ì¬ìƒì„±
            if (!previewMesh || currentPreviewSize !== size) {
                if (previewMesh) scene.remove(previewMesh);
                const geo = new THREE.BoxGeometry(TILE_SIZE * size * 0.98, 0.2, TILE_SIZE * size * 0.98);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5,
                    depthTest: false
                });
                previewMesh = new THREE.Mesh(geo, mat);
                previewMesh.renderOrder = 999;
                scene.add(previewMesh);
                currentPreviewSize = size;
            }

            // ë¸ŒëŸ¬ì‰¬ ì˜ì—­ ì¤‘ ì ê¸ˆ íƒ€ì¼ì´ ìˆëŠ”ì§€ í™•ì¸
            const half = Math.floor(size / 2);
            let hasLocked = false;
            for (let dx = -half; dx < size - half && !hasLocked; dx++) {
                for (let dy = -half; dy < size - half && !hasLocked; dy++) {
                    const nx = gx + dx;
                    const ny = gy + dy;
                    if (isLockedTile(nx, ny)) hasLocked = true;
                }
            }

            previewMesh.material.color.setHex(hasLocked ? 0xff4444 : TILE_COLORS[currentTool]);
            previewMesh.material.opacity = hasLocked ? 0.3 : 0.5;

            // ë¸ŒëŸ¬ì‰¬ ì¤‘ì‹¬ ìœ„ì¹˜
            const worldX = (ORIGIN_X + gx + 0.5) * TILE_SIZE;
            const worldZ = (ORIGIN_Z + gy + 0.5) * TILE_SIZE;
            previewMesh.position.set(worldX, 0.15, worldZ);
            previewMesh.visible = true;

            if (previewRoad) previewRoad.visible = false;
        }

        function showPreviewRoad(gx, gy) {
            // 2x2 ì˜ì—­ì˜ ì¢Œìƒë‹¨ ì¢Œí‘œë¡œ ì •ë ¬ (ì§ìˆ˜ ì¢Œí‘œ)
            const startX = Math.floor(gx / 2) * 2;
            const startY = Math.floor(gy / 2) * 2;

            // 2x2 í”„ë¦¬ë·° ë©”ì‹œ ìƒì„±
            if (!previewRoad) {
                const geo = new THREE.BoxGeometry(TILE_SIZE * 2 * 0.98, 0.2, TILE_SIZE * 2 * 0.98);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5,
                    depthTest: false
                });
                previewRoad = new THREE.Mesh(geo, mat);
                previewRoad.renderOrder = 999;
                scene.add(previewRoad);
            }

            // 2x2 ì˜ì—­ì´ ì ê¸ˆ íƒ€ì¼ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
            let hasLocked = false;
            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const nx = startX + dx;
                    const ny = startY + dy;
                    if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H || isLockedTile(nx, ny)) {
                        hasLocked = true;
                        break;
                    }
                }
                if (hasLocked) break;
            }

            // ì ê¸ˆ ì˜ì—­ì´ë©´ ë¹¨ê°„ìƒ‰
            previewRoad.material.color.setHex(hasLocked ? 0xff4444 : TILE_COLORS['road']);
            previewRoad.material.opacity = hasLocked ? 0.3 : 0.5;

            // 2x2 ì¤‘ì‹¬ ìœ„ì¹˜ ê³„ì‚°
            const worldX = (ORIGIN_X + startX + 1) * TILE_SIZE;
            const worldZ = (ORIGIN_Z + startY + 1) * TILE_SIZE;
            previewRoad.position.set(worldX, 0.15, worldZ);
            previewRoad.visible = true;

            if (previewMesh) previewMesh.visible = false;
        }

        function hidePreview() {
            if (previewMesh) previewMesh.visible = false;
            if (previewRoad) previewRoad.visible = false;
        }

        /* =========================================================
         * UI
         * ========================================================= */
        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            const names = { grass: 'ì”ë””', road: '4ì°¨ì„ ', beach: 'í•´ë³€', ocean: 'ë°”ë‹¤', eraser: 'ì§€ìš°ê¸°' };
            document.getElementById('currentTool').textContent = names[tool];

            // ë„ë¡œëŠ” í•­ìƒ 2x2 í‘œì‹œ
            if (tool === 'road') {
                document.getElementById('currentBrushSize').textContent = '2x2 (ê³ ì •)';
            } else {
                document.getElementById('currentBrushSize').textContent = `${brushSize}x${brushSize}`;
            }
        }

        function setBrushSize(size) {
            brushSize = size;
            document.querySelectorAll('.brush-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.size) === size);
            });
            // ë„ë¡œê°€ ì•„ë‹ ë•Œë§Œ ë¸ŒëŸ¬ì‰¬ í¬ê¸° í‘œì‹œ ì—…ë°ì´íŠ¸
            if (currentTool !== 'road') {
                document.getElementById('currentBrushSize').textContent = `${size}x${size}`;
            }
            // í”„ë¦¬ë·° í¬ê¸° ì¦‰ì‹œ ì—…ë°ì´íŠ¸ (ë‹¤ìŒ í˜¸ë²„ ì‹œ ì ìš©)
            currentPreviewSize = 0;
        }

        /* =========================================================
         * í™˜ê²½ ì„¤ì • ì»¨íŠ¸ë¡¤
         * ========================================================= */
        function setWindDirection(dir) {
            envSettings.windDirection = dir;
            updateDirectionUI('windControl', dir);
        }

        function setCurrentDirection(dir) {
            envSettings.currentDirection = dir;
            updateDirectionUI('currentControl', dir);
        }

        function updateDirectionUI(controlId, activeDir) {
            const control = document.getElementById(controlId);
            control.querySelectorAll('.dir-btn[data-dir]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.dir === activeDir);
            });
        }

        // í™˜ê²½ ì„¤ì • UI ì´ˆê¸°í™”
        function initEnvSettingsUI() {
            updateDirectionUI('windControl', envSettings.windDirection);
            updateDirectionUI('currentControl', envSettings.currentDirection);
        }

        // í™˜ê²½ ì„¤ì • ë¡œë“œ (í…œí”Œë¦¿ì—ì„œ)
        function loadEnvSettings(settings) {
            if (!settings) return;
            if (settings.windDirection) envSettings.windDirection = settings.windDirection;
            if (settings.currentDirection) envSettings.currentDirection = settings.currentDirection;
            initEnvSettingsUI();
        }

        // í™˜ê²½ ì„¤ì • ì´ˆê¸°í™”
        function resetEnvSettings() {
            envSettings = {
                windDirection: 'E',
                currentDirection: 'S'
            };
            initEnvSettingsUI();
        }

        function updateCounts() {
            let c = { grass: 0, road: 0, beach: 0, ocean: 0 };
            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    c[getCellType(grid[x][y])]++;
                }
            }
            document.getElementById('grassCount').textContent = c.grass;
            document.getElementById('roadCount').textContent = c.road;
            document.getElementById('beachCount').textContent = c.beach;
            document.getElementById('oceanCount').textContent = c.ocean;
        }

        function resetMap() {
            if (confirm('ë§µì„ ì´ˆê¸°í™”í• ê¹Œìš”? (í™˜ê²½ ì„¤ì •ë„ ì´ˆê¸°í™”ë©ë‹ˆë‹¤)')) {
                initGrid();
                buildAllTiles();
                resetEnvSettings();
                showToast('ì´ˆê¸°í™” ì™„ë£Œ', 'success');
            }
        }

        /* =========================================================
         * SAVE / LOAD
         * ========================================================= */
        function openSaveDialog() {
            document.getElementById('saveDialog').style.display = 'flex';
        }
        function closeSaveDialog() {
            document.getElementById('saveDialog').style.display = 'none';
            document.getElementById('templateName').value = '';
            document.getElementById('templateDesc').value = '';
        }

        async function saveTemplate() {
            const name = document.getElementById('templateName').value.trim();
            const desc = document.getElementById('templateDesc').value.trim();
            if (!name) { showToast('ì´ë¦„ ì…ë ¥ í•„ìš”', 'error'); return; }

            try {
                // ê·¸ë¦¬ë“œ ë°ì´í„°ì™€ í™˜ê²½ ì„¤ì •ì„ í•¨ê»˜ ì €ì¥
                const saveData = {
                    tiles: grid,
                    env: envSettings
                };

                const res = await fetch('/api/map/templates', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', [csrfHeader]: csrfToken },
                    body: JSON.stringify({ name, description: desc || null, grid: saveData })
                });
                if (res.ok) {
                    showToast('ì €ì¥ ì™„ë£Œ!', 'success');
                    closeSaveDialog();
                } else {
                    throw new Error((await res.json()).error || 'ì €ì¥ ì‹¤íŒ¨');
                }
            } catch (e) {
                showToast(e.message, 'error');
            }
        }

        async function openLoadDialog() {
            document.getElementById('loadDialog').style.display = 'flex';
            selectedTemplateId = null;
            document.getElementById('loadBtn').disabled = true;

            const list = document.getElementById('templateList');
            list.innerHTML = '<p style="color:#9ca3af;text-align:center;padding:10px;">ë¡œë”©...</p>';

            try {
                const res = await fetch('/api/map/templates');
                templatesData = await res.json();
                if (templatesData.length === 0) {
                    list.innerHTML = '<p style="color:#9ca3af;text-align:center;">ì—†ìŒ</p>';
                    return;
                }
                list.innerHTML = '';
                templatesData.forEach(t => {
                    const div = document.createElement('div');
                    div.className = 'template-item';
                    div.dataset.id = t.id;
                    div.innerHTML = `
                        <div class="template-item-content" onclick="selectTemplate(${t.id})">
                            <div class="template-name">${t.name}</div>
                            <div class="template-desc">${t.description || ''}</div>
                        </div>
                        <button class="template-delete-btn" onclick="deleteTemplate(${t.id}, event)">ğŸ—‘ï¸</button>
                    `;
                    list.appendChild(div);
                });
            } catch (e) {
                list.innerHTML = `<p style="color:#ef4444;">${e.message}</p>`;
            }
        }

        function closeLoadDialog() {
            document.getElementById('loadDialog').style.display = 'none';
        }

        async function deleteTemplate(id, event) {
            event.stopPropagation();  // í´ë¦­ ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€

            const template = templatesData.find(t => t.id === id);
            if (!template) return;

            if (!confirm(`"${template.name}" í…œí”Œë¦¿ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;

            try {
                const res = await fetch(`/api/map/templates/${id}`, {
                    method: 'DELETE',
                    headers: { [csrfHeader]: csrfToken }
                });

                if (res.ok) {
                    showToast('ì‚­ì œ ì™„ë£Œ', 'success');
                    // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    openLoadDialog();
                } else {
                    const data = await res.json();
                    throw new Error(data.error || 'ì‚­ì œ ì‹¤íŒ¨');
                }
            } catch (e) {
                showToast(e.message, 'error');
            }
        }

        function selectTemplate(id) {
            selectedTemplateId = id;
            document.querySelectorAll('.template-item').forEach(el => {
                el.classList.toggle('selected', parseInt(el.dataset.id) === id);
            });
            document.getElementById('loadBtn').disabled = false;
        }

        function loadSelectedTemplate() {
            if (!selectedTemplateId) return;
            const t = templatesData.find(x => x.id === selectedTemplateId);
            if (!t) return;
            try {
                let data = t.gridData;

                // ë¬¸ìì—´ì´ë©´ íŒŒì‹± (ì´ì¤‘ ì¸ì½”ë”© ì²˜ë¦¬)
                while (typeof data === 'string') {
                    data = JSON.parse(data);
                }

                console.log('Load template data:', data);

                // ìƒˆ í˜•ì‹ (tiles + env) ë˜ëŠ” ê¸°ì¡´ í˜•ì‹ (ë°°ì—´ë§Œ) ì²˜ë¦¬
                if (data && data.tiles && Array.isArray(data.tiles)) {
                    // ìƒˆ í˜•ì‹
                    grid = data.tiles;
                    loadEnvSettings(data.env);
                } else if (Array.isArray(data)) {
                    // ê¸°ì¡´ í˜•ì‹ (ë°°ì—´ë§Œ)
                    grid = data;
                    resetEnvSettings();
                } else {
                    console.error('Unknown template format:', data);
                    throw new Error('ë°ì´í„° ì˜¤ë¥˜');
                }

                buildAllTiles();
                showToast('ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!', 'success');
                closeLoadDialog();
            } catch (e) {
                console.error('Template load error:', e);
                showToast(e.message, 'error');
            }
        }

        /* =========================================================
         * ë§µ ëª©ë¡ ê´€ë¦¬ (ìƒˆ ë‹¤ì´ì–¼ë¡œê·¸)
         * ========================================================= */
        async function openMapListDialog() {
            document.getElementById('mapListDialog').style.display = 'flex';
            await refreshMapList();
        }

        function closeMapListDialog() {
            document.getElementById('mapListDialog').style.display = 'none';
        }

        async function refreshMapList() {
            const container = document.getElementById('mapListContainer');
            const countEl = document.getElementById('mapCount');
            container.innerHTML = '<div class="map-list-empty">ë¡œë”© ì¤‘...</div>';

            try {
                const res = await fetch('/api/map/templates');
                templatesData = await res.json();

                countEl.textContent = `${templatesData.length}ê°œ`;

                if (templatesData.length === 0) {
                    container.innerHTML = '<div class="map-list-empty">ì €ì¥ëœ ë§µì´ ì—†ìŠµë‹ˆë‹¤.<br>ìƒˆ ë§µì„ ì €ì¥í•´ë³´ì„¸ìš”!</div>';
                    return;
                }

                container.innerHTML = '';
                templatesData.forEach(t => {
                    const item = document.createElement('div');
                    item.className = 'map-item';
                    item.innerHTML = `
                        <div class="map-item-info">
                            <div class="map-item-name">${escapeHtml(t.name)}</div>
                            ${t.description ? `<div class="map-item-desc">${escapeHtml(t.description)}</div>` : ''}
                        </div>
                        <div class="map-item-actions">
                            <button class="map-action-btn btn-load" onclick="loadMapFromList(${t.id})">ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                            <button class="map-action-btn btn-delete" onclick="deleteMapFromList(${t.id})">ğŸ—‘ï¸ ì‚­ì œ</button>
                        </div>
                    `;
                    container.appendChild(item);
                });
            } catch (e) {
                container.innerHTML = `<div class="map-list-empty" style="color:#ef4444;">ì˜¤ë¥˜: ${e.message}</div>`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function loadMapFromList(id) {
            const t = templatesData.find(x => x.id === id);
            if (!t) return;

            try {
                let data = t.gridData;

                // ë¬¸ìì—´ì´ë©´ íŒŒì‹± (ì´ì¤‘ ì¸ì½”ë”© ì²˜ë¦¬)
                while (typeof data === 'string') {
                    data = JSON.parse(data);
                }

                console.log('Load data:', data);

                // ìƒˆ í˜•ì‹ (tiles + env) ì²˜ë¦¬
                if (data && data.tiles && Array.isArray(data.tiles)) {
                    grid = data.tiles;
                    loadEnvSettings(data.env);
                }
                // ê¸°ì¡´ í˜•ì‹ (2D ë°°ì—´ë§Œ) ì²˜ë¦¬
                else if (Array.isArray(data)) {
                    grid = data;
                    resetEnvSettings();
                }
                else {
                    console.error('Unknown data format:', data);
                    throw new Error('ë°ì´í„° í˜•ì‹ ì˜¤ë¥˜');
                }

                buildAllTiles();
                showToast(`"${t.name}" ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!`, 'success');
                closeMapListDialog();
            } catch (e) {
                console.error('Load error:', e);
                showToast(e.message, 'error');
            }
        }

        async function deleteMapFromList(id) {
            const template = templatesData.find(t => t.id === id);
            if (!template) return;

            if (!confirm(`"${template.name}" ë§µì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`)) return;

            try {
                const res = await fetch(`/api/map/templates/${id}`, {
                    method: 'DELETE',
                    headers: { [csrfHeader]: csrfToken }
                });

                if (res.ok) {
                    showToast('ì‚­ì œ ì™„ë£Œ!', 'success');
                    await refreshMapList();  // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                } else {
                    const data = await res.json();
                    throw new Error(data.error || 'ì‚­ì œ ì‹¤íŒ¨');
                }
            } catch (e) {
                showToast(e.message, 'error');
            }
        }

        function showToast(msg, type) {
            const el = document.getElementById('toast');
            el.textContent = msg;
            el.className = `toast ${type} show`;
            setTimeout(() => el.classList.remove('show'), 2500);
        }

        /* =========================================================
         * ANIMATE
         * ========================================================= */
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
